var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
function _mergeNamespaces(n2, m4) {
  m4.forEach(function(e3) {
    e3 && typeof e3 !== "string" && !Array.isArray(e3) && Object.keys(e3).forEach(function(k3) {
      if (k3 !== "default" && !(k3 in n2)) {
        var d4 = Object.getOwnPropertyDescriptor(e3, k3);
        Object.defineProperty(n2, k3, d4.get ? d4 : {
          enumerable: true,
          get: function() {
            return e3[k3];
          }
        });
      }
    });
  });
  return Object.freeze(Object.defineProperty(n2, Symbol.toStringTag, { value: "Module" }));
}
var react = { exports: {} };
var react_production_min = {};
/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var l$7 = Symbol.for("react.element"), n$6 = Symbol.for("react.portal"), p$8 = Symbol.for("react.fragment"), q$2 = Symbol.for("react.strict_mode"), r$6 = Symbol.for("react.profiler"), t$6 = Symbol.for("react.provider"), u$5 = Symbol.for("react.context"), v$6 = Symbol.for("react.forward_ref"), w$5 = Symbol.for("react.suspense"), x$5 = Symbol.for("react.memo"), y$3 = Symbol.for("react.lazy"), z$2 = Symbol.iterator;
function A$4(a4) {
  if (null === a4 || "object" !== typeof a4)
    return null;
  a4 = z$2 && a4[z$2] || a4["@@iterator"];
  return "function" === typeof a4 ? a4 : null;
}
var B$1 = { isMounted: function() {
  return false;
}, enqueueForceUpdate: function() {
}, enqueueReplaceState: function() {
}, enqueueSetState: function() {
} }, C$4 = Object.assign, D$3 = {};
function E$5(a4, b3, e3) {
  this.props = a4;
  this.context = b3;
  this.refs = D$3;
  this.updater = e3 || B$1;
}
E$5.prototype.isReactComponent = {};
E$5.prototype.setState = function(a4, b3) {
  if ("object" !== typeof a4 && "function" !== typeof a4 && null != a4)
    throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
  this.updater.enqueueSetState(this, a4, b3, "setState");
};
E$5.prototype.forceUpdate = function(a4) {
  this.updater.enqueueForceUpdate(this, a4, "forceUpdate");
};
function F$2() {
}
F$2.prototype = E$5.prototype;
function G$1(a4, b3, e3) {
  this.props = a4;
  this.context = b3;
  this.refs = D$3;
  this.updater = e3 || B$1;
}
var H$1 = G$1.prototype = new F$2();
H$1.constructor = G$1;
C$4(H$1, E$5.prototype);
H$1.isPureReactComponent = true;
var I$2 = Array.isArray, J = Object.prototype.hasOwnProperty, K$2 = { current: null }, L$1 = { key: true, ref: true, __self: true, __source: true };
function M$3(a4, b3, e3) {
  var d4, c3 = {}, k3 = null, h4 = null;
  if (null != b3)
    for (d4 in void 0 !== b3.ref && (h4 = b3.ref), void 0 !== b3.key && (k3 = "" + b3.key), b3)
      J.call(b3, d4) && !L$1.hasOwnProperty(d4) && (c3[d4] = b3[d4]);
  var g2 = arguments.length - 2;
  if (1 === g2)
    c3.children = e3;
  else if (1 < g2) {
    for (var f2 = Array(g2), m4 = 0; m4 < g2; m4++)
      f2[m4] = arguments[m4 + 2];
    c3.children = f2;
  }
  if (a4 && a4.defaultProps)
    for (d4 in g2 = a4.defaultProps, g2)
      void 0 === c3[d4] && (c3[d4] = g2[d4]);
  return { $$typeof: l$7, type: a4, key: k3, ref: h4, props: c3, _owner: K$2.current };
}
function N$1(a4, b3) {
  return { $$typeof: l$7, type: a4.type, key: b3, ref: a4.ref, props: a4.props, _owner: a4._owner };
}
function O$4(a4) {
  return "object" === typeof a4 && null !== a4 && a4.$$typeof === l$7;
}
function escape(a4) {
  var b3 = { "=": "=0", ":": "=2" };
  return "$" + a4.replace(/[=:]/g, function(a5) {
    return b3[a5];
  });
}
var P$3 = /\/+/g;
function Q$1(a4, b3) {
  return "object" === typeof a4 && null !== a4 && null != a4.key ? escape("" + a4.key) : b3.toString(36);
}
function R$6(a4, b3, e3, d4, c3) {
  var k3 = typeof a4;
  if ("undefined" === k3 || "boolean" === k3)
    a4 = null;
  var h4 = false;
  if (null === a4)
    h4 = true;
  else
    switch (k3) {
      case "string":
      case "number":
        h4 = true;
        break;
      case "object":
        switch (a4.$$typeof) {
          case l$7:
          case n$6:
            h4 = true;
        }
    }
  if (h4)
    return h4 = a4, c3 = c3(h4), a4 = "" === d4 ? "." + Q$1(h4, 0) : d4, I$2(c3) ? (e3 = "", null != a4 && (e3 = a4.replace(P$3, "$&/") + "/"), R$6(c3, b3, e3, "", function(a5) {
      return a5;
    })) : null != c3 && (O$4(c3) && (c3 = N$1(c3, e3 + (!c3.key || h4 && h4.key === c3.key ? "" : ("" + c3.key).replace(P$3, "$&/") + "/") + a4)), b3.push(c3)), 1;
  h4 = 0;
  d4 = "" === d4 ? "." : d4 + ":";
  if (I$2(a4))
    for (var g2 = 0; g2 < a4.length; g2++) {
      k3 = a4[g2];
      var f2 = d4 + Q$1(k3, g2);
      h4 += R$6(k3, b3, e3, f2, c3);
    }
  else if (f2 = A$4(a4), "function" === typeof f2)
    for (a4 = f2.call(a4), g2 = 0; !(k3 = a4.next()).done; )
      k3 = k3.value, f2 = d4 + Q$1(k3, g2++), h4 += R$6(k3, b3, e3, f2, c3);
  else if ("object" === k3)
    throw b3 = String(a4), Error("Objects are not valid as a React child (found: " + ("[object Object]" === b3 ? "object with keys {" + Object.keys(a4).join(", ") + "}" : b3) + "). If you meant to render a collection of children, use an array instead.");
  return h4;
}
function S$3(a4, b3, e3) {
  if (null == a4)
    return a4;
  var d4 = [], c3 = 0;
  R$6(a4, d4, "", "", function(a5) {
    return b3.call(e3, a5, c3++);
  });
  return d4;
}
function T$3(a4) {
  if (-1 === a4._status) {
    var b3 = a4._result;
    b3 = b3();
    b3.then(function(b4) {
      if (0 === a4._status || -1 === a4._status)
        a4._status = 1, a4._result = b4;
    }, function(b4) {
      if (0 === a4._status || -1 === a4._status)
        a4._status = 2, a4._result = b4;
    });
    -1 === a4._status && (a4._status = 0, a4._result = b3);
  }
  if (1 === a4._status)
    return a4._result.default;
  throw a4._result;
}
var U$2 = { current: null }, V$2 = { transition: null }, W$1 = { ReactCurrentDispatcher: U$2, ReactCurrentBatchConfig: V$2, ReactCurrentOwner: K$2 };
react_production_min.Children = { map: S$3, forEach: function(a4, b3, e3) {
  S$3(a4, function() {
    b3.apply(this, arguments);
  }, e3);
}, count: function(a4) {
  var b3 = 0;
  S$3(a4, function() {
    b3++;
  });
  return b3;
}, toArray: function(a4) {
  return S$3(a4, function(a5) {
    return a5;
  }) || [];
}, only: function(a4) {
  if (!O$4(a4))
    throw Error("React.Children.only expected to receive a single React element child.");
  return a4;
} };
react_production_min.Component = E$5;
react_production_min.Fragment = p$8;
react_production_min.Profiler = r$6;
react_production_min.PureComponent = G$1;
react_production_min.StrictMode = q$2;
react_production_min.Suspense = w$5;
react_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = W$1;
react_production_min.cloneElement = function(a4, b3, e3) {
  if (null === a4 || void 0 === a4)
    throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + a4 + ".");
  var d4 = C$4({}, a4.props), c3 = a4.key, k3 = a4.ref, h4 = a4._owner;
  if (null != b3) {
    void 0 !== b3.ref && (k3 = b3.ref, h4 = K$2.current);
    void 0 !== b3.key && (c3 = "" + b3.key);
    if (a4.type && a4.type.defaultProps)
      var g2 = a4.type.defaultProps;
    for (f2 in b3)
      J.call(b3, f2) && !L$1.hasOwnProperty(f2) && (d4[f2] = void 0 === b3[f2] && void 0 !== g2 ? g2[f2] : b3[f2]);
  }
  var f2 = arguments.length - 2;
  if (1 === f2)
    d4.children = e3;
  else if (1 < f2) {
    g2 = Array(f2);
    for (var m4 = 0; m4 < f2; m4++)
      g2[m4] = arguments[m4 + 2];
    d4.children = g2;
  }
  return { $$typeof: l$7, type: a4.type, key: c3, ref: k3, props: d4, _owner: h4 };
};
react_production_min.createContext = function(a4) {
  a4 = { $$typeof: u$5, _currentValue: a4, _currentValue2: a4, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null };
  a4.Provider = { $$typeof: t$6, _context: a4 };
  return a4.Consumer = a4;
};
react_production_min.createElement = M$3;
react_production_min.createFactory = function(a4) {
  var b3 = M$3.bind(null, a4);
  b3.type = a4;
  return b3;
};
react_production_min.createRef = function() {
  return { current: null };
};
react_production_min.forwardRef = function(a4) {
  return { $$typeof: v$6, render: a4 };
};
react_production_min.isValidElement = O$4;
react_production_min.lazy = function(a4) {
  return { $$typeof: y$3, _payload: { _status: -1, _result: a4 }, _init: T$3 };
};
react_production_min.memo = function(a4, b3) {
  return { $$typeof: x$5, type: a4, compare: void 0 === b3 ? null : b3 };
};
react_production_min.startTransition = function(a4) {
  var b3 = V$2.transition;
  V$2.transition = {};
  try {
    a4();
  } finally {
    V$2.transition = b3;
  }
};
react_production_min.unstable_act = function() {
  throw Error("act(...) is not supported in production builds of React.");
};
react_production_min.useCallback = function(a4, b3) {
  return U$2.current.useCallback(a4, b3);
};
react_production_min.useContext = function(a4) {
  return U$2.current.useContext(a4);
};
react_production_min.useDebugValue = function() {
};
react_production_min.useDeferredValue = function(a4) {
  return U$2.current.useDeferredValue(a4);
};
react_production_min.useEffect = function(a4, b3) {
  return U$2.current.useEffect(a4, b3);
};
react_production_min.useId = function() {
  return U$2.current.useId();
};
react_production_min.useImperativeHandle = function(a4, b3, e3) {
  return U$2.current.useImperativeHandle(a4, b3, e3);
};
react_production_min.useInsertionEffect = function(a4, b3) {
  return U$2.current.useInsertionEffect(a4, b3);
};
react_production_min.useLayoutEffect = function(a4, b3) {
  return U$2.current.useLayoutEffect(a4, b3);
};
react_production_min.useMemo = function(a4, b3) {
  return U$2.current.useMemo(a4, b3);
};
react_production_min.useReducer = function(a4, b3, e3) {
  return U$2.current.useReducer(a4, b3, e3);
};
react_production_min.useRef = function(a4) {
  return U$2.current.useRef(a4);
};
react_production_min.useState = function(a4) {
  return U$2.current.useState(a4);
};
react_production_min.useSyncExternalStore = function(a4, b3, e3) {
  return U$2.current.useSyncExternalStore(a4, b3, e3);
};
react_production_min.useTransition = function() {
  return U$2.current.useTransition();
};
react_production_min.version = "18.2.0";
{
  react.exports = react_production_min;
}
var e$3 = react.exports;
var React = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  "default": e$3
}, [react.exports]);
var reactDom = { exports: {} };
var reactDom_production_min = {};
var scheduler = { exports: {} };
var scheduler_production_min = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
(function(exports) {
  function f2(a4, b3) {
    var c3 = a4.length;
    a4.push(b3);
    a:
      for (; 0 < c3; ) {
        var d4 = c3 - 1 >>> 1, e3 = a4[d4];
        if (0 < g2(e3, b3))
          a4[d4] = b3, a4[c3] = e3, c3 = d4;
        else
          break a;
      }
  }
  function h4(a4) {
    return 0 === a4.length ? null : a4[0];
  }
  function k3(a4) {
    if (0 === a4.length)
      return null;
    var b3 = a4[0], c3 = a4.pop();
    if (c3 !== b3) {
      a4[0] = c3;
      a:
        for (var d4 = 0, e3 = a4.length, w3 = e3 >>> 1; d4 < w3; ) {
          var m4 = 2 * (d4 + 1) - 1, C2 = a4[m4], n2 = m4 + 1, x3 = a4[n2];
          if (0 > g2(C2, c3))
            n2 < e3 && 0 > g2(x3, C2) ? (a4[d4] = x3, a4[n2] = c3, d4 = n2) : (a4[d4] = C2, a4[m4] = c3, d4 = m4);
          else if (n2 < e3 && 0 > g2(x3, c3))
            a4[d4] = x3, a4[n2] = c3, d4 = n2;
          else
            break a;
        }
    }
    return b3;
  }
  function g2(a4, b3) {
    var c3 = a4.sortIndex - b3.sortIndex;
    return 0 !== c3 ? c3 : a4.id - b3.id;
  }
  if ("object" === typeof performance && "function" === typeof performance.now) {
    var l2 = performance;
    exports.unstable_now = function() {
      return l2.now();
    };
  } else {
    var p2 = Date, q3 = p2.now();
    exports.unstable_now = function() {
      return p2.now() - q3;
    };
  }
  var r2 = [], t3 = [], u3 = 1, v2 = null, y4 = 3, z3 = false, A2 = false, B3 = false, D3 = "function" === typeof setTimeout ? setTimeout : null, E3 = "function" === typeof clearTimeout ? clearTimeout : null, F2 = "undefined" !== typeof setImmediate ? setImmediate : null;
  "undefined" !== typeof navigator && void 0 !== navigator.scheduling && void 0 !== navigator.scheduling.isInputPending && navigator.scheduling.isInputPending.bind(navigator.scheduling);
  function G3(a4) {
    for (var b3 = h4(t3); null !== b3; ) {
      if (null === b3.callback)
        k3(t3);
      else if (b3.startTime <= a4)
        k3(t3), b3.sortIndex = b3.expirationTime, f2(r2, b3);
      else
        break;
      b3 = h4(t3);
    }
  }
  function H4(a4) {
    B3 = false;
    G3(a4);
    if (!A2)
      if (null !== h4(r2))
        A2 = true, I3(J2);
      else {
        var b3 = h4(t3);
        null !== b3 && K3(H4, b3.startTime - a4);
      }
  }
  function J2(a4, b3) {
    A2 = false;
    B3 && (B3 = false, E3(L3), L3 = -1);
    z3 = true;
    var c3 = y4;
    try {
      G3(b3);
      for (v2 = h4(r2); null !== v2 && (!(v2.expirationTime > b3) || a4 && !M4()); ) {
        var d4 = v2.callback;
        if ("function" === typeof d4) {
          v2.callback = null;
          y4 = v2.priorityLevel;
          var e3 = d4(v2.expirationTime <= b3);
          b3 = exports.unstable_now();
          "function" === typeof e3 ? v2.callback = e3 : v2 === h4(r2) && k3(r2);
          G3(b3);
        } else
          k3(r2);
        v2 = h4(r2);
      }
      if (null !== v2)
        var w3 = true;
      else {
        var m4 = h4(t3);
        null !== m4 && K3(H4, m4.startTime - b3);
        w3 = false;
      }
      return w3;
    } finally {
      v2 = null, y4 = c3, z3 = false;
    }
  }
  var N2 = false, O3 = null, L3 = -1, P2 = 5, Q3 = -1;
  function M4() {
    return exports.unstable_now() - Q3 < P2 ? false : true;
  }
  function R3() {
    if (null !== O3) {
      var a4 = exports.unstable_now();
      Q3 = a4;
      var b3 = true;
      try {
        b3 = O3(true, a4);
      } finally {
        b3 ? S4() : (N2 = false, O3 = null);
      }
    } else
      N2 = false;
  }
  var S4;
  if ("function" === typeof F2)
    S4 = function() {
      F2(R3);
    };
  else if ("undefined" !== typeof MessageChannel) {
    var T3 = new MessageChannel(), U2 = T3.port2;
    T3.port1.onmessage = R3;
    S4 = function() {
      U2.postMessage(null);
    };
  } else
    S4 = function() {
      D3(R3, 0);
    };
  function I3(a4) {
    O3 = a4;
    N2 || (N2 = true, S4());
  }
  function K3(a4, b3) {
    L3 = D3(function() {
      a4(exports.unstable_now());
    }, b3);
  }
  exports.unstable_IdlePriority = 5;
  exports.unstable_ImmediatePriority = 1;
  exports.unstable_LowPriority = 4;
  exports.unstable_NormalPriority = 3;
  exports.unstable_Profiling = null;
  exports.unstable_UserBlockingPriority = 2;
  exports.unstable_cancelCallback = function(a4) {
    a4.callback = null;
  };
  exports.unstable_continueExecution = function() {
    A2 || z3 || (A2 = true, I3(J2));
  };
  exports.unstable_forceFrameRate = function(a4) {
    0 > a4 || 125 < a4 ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : P2 = 0 < a4 ? Math.floor(1e3 / a4) : 5;
  };
  exports.unstable_getCurrentPriorityLevel = function() {
    return y4;
  };
  exports.unstable_getFirstCallbackNode = function() {
    return h4(r2);
  };
  exports.unstable_next = function(a4) {
    switch (y4) {
      case 1:
      case 2:
      case 3:
        var b3 = 3;
        break;
      default:
        b3 = y4;
    }
    var c3 = y4;
    y4 = b3;
    try {
      return a4();
    } finally {
      y4 = c3;
    }
  };
  exports.unstable_pauseExecution = function() {
  };
  exports.unstable_requestPaint = function() {
  };
  exports.unstable_runWithPriority = function(a4, b3) {
    switch (a4) {
      case 1:
      case 2:
      case 3:
      case 4:
      case 5:
        break;
      default:
        a4 = 3;
    }
    var c3 = y4;
    y4 = a4;
    try {
      return b3();
    } finally {
      y4 = c3;
    }
  };
  exports.unstable_scheduleCallback = function(a4, b3, c3) {
    var d4 = exports.unstable_now();
    "object" === typeof c3 && null !== c3 ? (c3 = c3.delay, c3 = "number" === typeof c3 && 0 < c3 ? d4 + c3 : d4) : c3 = d4;
    switch (a4) {
      case 1:
        var e3 = -1;
        break;
      case 2:
        e3 = 250;
        break;
      case 5:
        e3 = 1073741823;
        break;
      case 4:
        e3 = 1e4;
        break;
      default:
        e3 = 5e3;
    }
    e3 = c3 + e3;
    a4 = { id: u3++, callback: b3, priorityLevel: a4, startTime: c3, expirationTime: e3, sortIndex: -1 };
    c3 > d4 ? (a4.sortIndex = c3, f2(t3, a4), null === h4(r2) && a4 === h4(t3) && (B3 ? (E3(L3), L3 = -1) : B3 = true, K3(H4, c3 - d4))) : (a4.sortIndex = e3, f2(r2, a4), A2 || z3 || (A2 = true, I3(J2)));
    return a4;
  };
  exports.unstable_shouldYield = M4;
  exports.unstable_wrapCallback = function(a4) {
    var b3 = y4;
    return function() {
      var c3 = y4;
      y4 = b3;
      try {
        return a4.apply(this, arguments);
      } finally {
        y4 = c3;
      }
    };
  };
})(scheduler_production_min);
{
  scheduler.exports = scheduler_production_min;
}
/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var aa = react.exports, ca = scheduler.exports;
function p$7(a4) {
  for (var b3 = "https://reactjs.org/docs/error-decoder.html?invariant=" + a4, c3 = 1; c3 < arguments.length; c3++)
    b3 += "&args[]=" + encodeURIComponent(arguments[c3]);
  return "Minified React error #" + a4 + "; visit " + b3 + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
}
var da = /* @__PURE__ */ new Set(), ea = {};
function fa(a4, b3) {
  ha(a4, b3);
  ha(a4 + "Capture", b3);
}
function ha(a4, b3) {
  ea[a4] = b3;
  for (a4 = 0; a4 < b3.length; a4++)
    da.add(b3[a4]);
}
var ia = !("undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement), ja = Object.prototype.hasOwnProperty, ka = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, la = {}, ma = {};
function oa(a4) {
  if (ja.call(ma, a4))
    return true;
  if (ja.call(la, a4))
    return false;
  if (ka.test(a4))
    return ma[a4] = true;
  la[a4] = true;
  return false;
}
function pa(a4, b3, c3, d4) {
  if (null !== c3 && 0 === c3.type)
    return false;
  switch (typeof b3) {
    case "function":
    case "symbol":
      return true;
    case "boolean":
      if (d4)
        return false;
      if (null !== c3)
        return !c3.acceptsBooleans;
      a4 = a4.toLowerCase().slice(0, 5);
      return "data-" !== a4 && "aria-" !== a4;
    default:
      return false;
  }
}
function qa(a4, b3, c3, d4) {
  if (null === b3 || "undefined" === typeof b3 || pa(a4, b3, c3, d4))
    return true;
  if (d4)
    return false;
  if (null !== c3)
    switch (c3.type) {
      case 3:
        return !b3;
      case 4:
        return false === b3;
      case 5:
        return isNaN(b3);
      case 6:
        return isNaN(b3) || 1 > b3;
    }
  return false;
}
function v$5(a4, b3, c3, d4, e3, f2, g2) {
  this.acceptsBooleans = 2 === b3 || 3 === b3 || 4 === b3;
  this.attributeName = d4;
  this.attributeNamespace = e3;
  this.mustUseProperty = c3;
  this.propertyName = a4;
  this.type = b3;
  this.sanitizeURL = f2;
  this.removeEmptyString = g2;
}
var z$1 = {};
"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a4) {
  z$1[a4] = new v$5(a4, 0, false, a4, null, false, false);
});
[["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(a4) {
  var b3 = a4[0];
  z$1[b3] = new v$5(b3, 1, false, a4[1], null, false, false);
});
["contentEditable", "draggable", "spellCheck", "value"].forEach(function(a4) {
  z$1[a4] = new v$5(a4, 2, false, a4.toLowerCase(), null, false, false);
});
["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(a4) {
  z$1[a4] = new v$5(a4, 2, false, a4, null, false, false);
});
"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a4) {
  z$1[a4] = new v$5(a4, 3, false, a4.toLowerCase(), null, false, false);
});
["checked", "multiple", "muted", "selected"].forEach(function(a4) {
  z$1[a4] = new v$5(a4, 3, true, a4, null, false, false);
});
["capture", "download"].forEach(function(a4) {
  z$1[a4] = new v$5(a4, 4, false, a4, null, false, false);
});
["cols", "rows", "size", "span"].forEach(function(a4) {
  z$1[a4] = new v$5(a4, 6, false, a4, null, false, false);
});
["rowSpan", "start"].forEach(function(a4) {
  z$1[a4] = new v$5(a4, 5, false, a4.toLowerCase(), null, false, false);
});
var ra = /[\-:]([a-z])/g;
function sa(a4) {
  return a4[1].toUpperCase();
}
"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a4) {
  var b3 = a4.replace(
    ra,
    sa
  );
  z$1[b3] = new v$5(b3, 1, false, a4, null, false, false);
});
"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a4) {
  var b3 = a4.replace(ra, sa);
  z$1[b3] = new v$5(b3, 1, false, a4, "http://www.w3.org/1999/xlink", false, false);
});
["xml:base", "xml:lang", "xml:space"].forEach(function(a4) {
  var b3 = a4.replace(ra, sa);
  z$1[b3] = new v$5(b3, 1, false, a4, "http://www.w3.org/XML/1998/namespace", false, false);
});
["tabIndex", "crossOrigin"].forEach(function(a4) {
  z$1[a4] = new v$5(a4, 1, false, a4.toLowerCase(), null, false, false);
});
z$1.xlinkHref = new v$5("xlinkHref", 1, false, "xlink:href", "http://www.w3.org/1999/xlink", true, false);
["src", "href", "action", "formAction"].forEach(function(a4) {
  z$1[a4] = new v$5(a4, 1, false, a4.toLowerCase(), null, true, true);
});
function ta(a4, b3, c3, d4) {
  var e3 = z$1.hasOwnProperty(b3) ? z$1[b3] : null;
  if (null !== e3 ? 0 !== e3.type : d4 || !(2 < b3.length) || "o" !== b3[0] && "O" !== b3[0] || "n" !== b3[1] && "N" !== b3[1])
    qa(b3, c3, e3, d4) && (c3 = null), d4 || null === e3 ? oa(b3) && (null === c3 ? a4.removeAttribute(b3) : a4.setAttribute(b3, "" + c3)) : e3.mustUseProperty ? a4[e3.propertyName] = null === c3 ? 3 === e3.type ? false : "" : c3 : (b3 = e3.attributeName, d4 = e3.attributeNamespace, null === c3 ? a4.removeAttribute(b3) : (e3 = e3.type, c3 = 3 === e3 || 4 === e3 && true === c3 ? "" : "" + c3, d4 ? a4.setAttributeNS(d4, b3, c3) : a4.setAttribute(b3, c3)));
}
var ua = aa.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, va = Symbol.for("react.element"), wa = Symbol.for("react.portal"), ya = Symbol.for("react.fragment"), za = Symbol.for("react.strict_mode"), Aa = Symbol.for("react.profiler"), Ba = Symbol.for("react.provider"), Ca = Symbol.for("react.context"), Da = Symbol.for("react.forward_ref"), Ea = Symbol.for("react.suspense"), Fa = Symbol.for("react.suspense_list"), Ga = Symbol.for("react.memo"), Ha = Symbol.for("react.lazy");
var Ia = Symbol.for("react.offscreen");
var Ja = Symbol.iterator;
function Ka(a4) {
  if (null === a4 || "object" !== typeof a4)
    return null;
  a4 = Ja && a4[Ja] || a4["@@iterator"];
  return "function" === typeof a4 ? a4 : null;
}
var A$3 = Object.assign, La;
function Ma(a4) {
  if (void 0 === La)
    try {
      throw Error();
    } catch (c3) {
      var b3 = c3.stack.trim().match(/\n( *(at )?)/);
      La = b3 && b3[1] || "";
    }
  return "\n" + La + a4;
}
var Na = false;
function Oa(a4, b3) {
  if (!a4 || Na)
    return "";
  Na = true;
  var c3 = Error.prepareStackTrace;
  Error.prepareStackTrace = void 0;
  try {
    if (b3)
      if (b3 = function() {
        throw Error();
      }, Object.defineProperty(b3.prototype, "props", { set: function() {
        throw Error();
      } }), "object" === typeof Reflect && Reflect.construct) {
        try {
          Reflect.construct(b3, []);
        } catch (l2) {
          var d4 = l2;
        }
        Reflect.construct(a4, [], b3);
      } else {
        try {
          b3.call();
        } catch (l2) {
          d4 = l2;
        }
        a4.call(b3.prototype);
      }
    else {
      try {
        throw Error();
      } catch (l2) {
        d4 = l2;
      }
      a4();
    }
  } catch (l2) {
    if (l2 && d4 && "string" === typeof l2.stack) {
      for (var e3 = l2.stack.split("\n"), f2 = d4.stack.split("\n"), g2 = e3.length - 1, h4 = f2.length - 1; 1 <= g2 && 0 <= h4 && e3[g2] !== f2[h4]; )
        h4--;
      for (; 1 <= g2 && 0 <= h4; g2--, h4--)
        if (e3[g2] !== f2[h4]) {
          if (1 !== g2 || 1 !== h4) {
            do
              if (g2--, h4--, 0 > h4 || e3[g2] !== f2[h4]) {
                var k3 = "\n" + e3[g2].replace(" at new ", " at ");
                a4.displayName && k3.includes("<anonymous>") && (k3 = k3.replace("<anonymous>", a4.displayName));
                return k3;
              }
            while (1 <= g2 && 0 <= h4);
          }
          break;
        }
    }
  } finally {
    Na = false, Error.prepareStackTrace = c3;
  }
  return (a4 = a4 ? a4.displayName || a4.name : "") ? Ma(a4) : "";
}
function Pa(a4) {
  switch (a4.tag) {
    case 5:
      return Ma(a4.type);
    case 16:
      return Ma("Lazy");
    case 13:
      return Ma("Suspense");
    case 19:
      return Ma("SuspenseList");
    case 0:
    case 2:
    case 15:
      return a4 = Oa(a4.type, false), a4;
    case 11:
      return a4 = Oa(a4.type.render, false), a4;
    case 1:
      return a4 = Oa(a4.type, true), a4;
    default:
      return "";
  }
}
function Qa(a4) {
  if (null == a4)
    return null;
  if ("function" === typeof a4)
    return a4.displayName || a4.name || null;
  if ("string" === typeof a4)
    return a4;
  switch (a4) {
    case ya:
      return "Fragment";
    case wa:
      return "Portal";
    case Aa:
      return "Profiler";
    case za:
      return "StrictMode";
    case Ea:
      return "Suspense";
    case Fa:
      return "SuspenseList";
  }
  if ("object" === typeof a4)
    switch (a4.$$typeof) {
      case Ca:
        return (a4.displayName || "Context") + ".Consumer";
      case Ba:
        return (a4._context.displayName || "Context") + ".Provider";
      case Da:
        var b3 = a4.render;
        a4 = a4.displayName;
        a4 || (a4 = b3.displayName || b3.name || "", a4 = "" !== a4 ? "ForwardRef(" + a4 + ")" : "ForwardRef");
        return a4;
      case Ga:
        return b3 = a4.displayName || null, null !== b3 ? b3 : Qa(a4.type) || "Memo";
      case Ha:
        b3 = a4._payload;
        a4 = a4._init;
        try {
          return Qa(a4(b3));
        } catch (c3) {
        }
    }
  return null;
}
function Ra(a4) {
  var b3 = a4.type;
  switch (a4.tag) {
    case 24:
      return "Cache";
    case 9:
      return (b3.displayName || "Context") + ".Consumer";
    case 10:
      return (b3._context.displayName || "Context") + ".Provider";
    case 18:
      return "DehydratedFragment";
    case 11:
      return a4 = b3.render, a4 = a4.displayName || a4.name || "", b3.displayName || ("" !== a4 ? "ForwardRef(" + a4 + ")" : "ForwardRef");
    case 7:
      return "Fragment";
    case 5:
      return b3;
    case 4:
      return "Portal";
    case 3:
      return "Root";
    case 6:
      return "Text";
    case 16:
      return Qa(b3);
    case 8:
      return b3 === za ? "StrictMode" : "Mode";
    case 22:
      return "Offscreen";
    case 12:
      return "Profiler";
    case 21:
      return "Scope";
    case 13:
      return "Suspense";
    case 19:
      return "SuspenseList";
    case 25:
      return "TracingMarker";
    case 1:
    case 0:
    case 17:
    case 2:
    case 14:
    case 15:
      if ("function" === typeof b3)
        return b3.displayName || b3.name || null;
      if ("string" === typeof b3)
        return b3;
  }
  return null;
}
function Sa(a4) {
  switch (typeof a4) {
    case "boolean":
    case "number":
    case "string":
    case "undefined":
      return a4;
    case "object":
      return a4;
    default:
      return "";
  }
}
function Ta(a4) {
  var b3 = a4.type;
  return (a4 = a4.nodeName) && "input" === a4.toLowerCase() && ("checkbox" === b3 || "radio" === b3);
}
function Ua(a4) {
  var b3 = Ta(a4) ? "checked" : "value", c3 = Object.getOwnPropertyDescriptor(a4.constructor.prototype, b3), d4 = "" + a4[b3];
  if (!a4.hasOwnProperty(b3) && "undefined" !== typeof c3 && "function" === typeof c3.get && "function" === typeof c3.set) {
    var e3 = c3.get, f2 = c3.set;
    Object.defineProperty(a4, b3, { configurable: true, get: function() {
      return e3.call(this);
    }, set: function(a5) {
      d4 = "" + a5;
      f2.call(this, a5);
    } });
    Object.defineProperty(a4, b3, { enumerable: c3.enumerable });
    return { getValue: function() {
      return d4;
    }, setValue: function(a5) {
      d4 = "" + a5;
    }, stopTracking: function() {
      a4._valueTracker = null;
      delete a4[b3];
    } };
  }
}
function Va(a4) {
  a4._valueTracker || (a4._valueTracker = Ua(a4));
}
function Wa(a4) {
  if (!a4)
    return false;
  var b3 = a4._valueTracker;
  if (!b3)
    return true;
  var c3 = b3.getValue();
  var d4 = "";
  a4 && (d4 = Ta(a4) ? a4.checked ? "true" : "false" : a4.value);
  a4 = d4;
  return a4 !== c3 ? (b3.setValue(a4), true) : false;
}
function Xa(a4) {
  a4 = a4 || ("undefined" !== typeof document ? document : void 0);
  if ("undefined" === typeof a4)
    return null;
  try {
    return a4.activeElement || a4.body;
  } catch (b3) {
    return a4.body;
  }
}
function Ya(a4, b3) {
  var c3 = b3.checked;
  return A$3({}, b3, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: null != c3 ? c3 : a4._wrapperState.initialChecked });
}
function Za(a4, b3) {
  var c3 = null == b3.defaultValue ? "" : b3.defaultValue, d4 = null != b3.checked ? b3.checked : b3.defaultChecked;
  c3 = Sa(null != b3.value ? b3.value : c3);
  a4._wrapperState = { initialChecked: d4, initialValue: c3, controlled: "checkbox" === b3.type || "radio" === b3.type ? null != b3.checked : null != b3.value };
}
function ab(a4, b3) {
  b3 = b3.checked;
  null != b3 && ta(a4, "checked", b3, false);
}
function bb(a4, b3) {
  ab(a4, b3);
  var c3 = Sa(b3.value), d4 = b3.type;
  if (null != c3)
    if ("number" === d4) {
      if (0 === c3 && "" === a4.value || a4.value != c3)
        a4.value = "" + c3;
    } else
      a4.value !== "" + c3 && (a4.value = "" + c3);
  else if ("submit" === d4 || "reset" === d4) {
    a4.removeAttribute("value");
    return;
  }
  b3.hasOwnProperty("value") ? cb(a4, b3.type, c3) : b3.hasOwnProperty("defaultValue") && cb(a4, b3.type, Sa(b3.defaultValue));
  null == b3.checked && null != b3.defaultChecked && (a4.defaultChecked = !!b3.defaultChecked);
}
function db(a4, b3, c3) {
  if (b3.hasOwnProperty("value") || b3.hasOwnProperty("defaultValue")) {
    var d4 = b3.type;
    if (!("submit" !== d4 && "reset" !== d4 || void 0 !== b3.value && null !== b3.value))
      return;
    b3 = "" + a4._wrapperState.initialValue;
    c3 || b3 === a4.value || (a4.value = b3);
    a4.defaultValue = b3;
  }
  c3 = a4.name;
  "" !== c3 && (a4.name = "");
  a4.defaultChecked = !!a4._wrapperState.initialChecked;
  "" !== c3 && (a4.name = c3);
}
function cb(a4, b3, c3) {
  if ("number" !== b3 || Xa(a4.ownerDocument) !== a4)
    null == c3 ? a4.defaultValue = "" + a4._wrapperState.initialValue : a4.defaultValue !== "" + c3 && (a4.defaultValue = "" + c3);
}
var eb = Array.isArray;
function fb(a4, b3, c3, d4) {
  a4 = a4.options;
  if (b3) {
    b3 = {};
    for (var e3 = 0; e3 < c3.length; e3++)
      b3["$" + c3[e3]] = true;
    for (c3 = 0; c3 < a4.length; c3++)
      e3 = b3.hasOwnProperty("$" + a4[c3].value), a4[c3].selected !== e3 && (a4[c3].selected = e3), e3 && d4 && (a4[c3].defaultSelected = true);
  } else {
    c3 = "" + Sa(c3);
    b3 = null;
    for (e3 = 0; e3 < a4.length; e3++) {
      if (a4[e3].value === c3) {
        a4[e3].selected = true;
        d4 && (a4[e3].defaultSelected = true);
        return;
      }
      null !== b3 || a4[e3].disabled || (b3 = a4[e3]);
    }
    null !== b3 && (b3.selected = true);
  }
}
function gb(a4, b3) {
  if (null != b3.dangerouslySetInnerHTML)
    throw Error(p$7(91));
  return A$3({}, b3, { value: void 0, defaultValue: void 0, children: "" + a4._wrapperState.initialValue });
}
function hb(a4, b3) {
  var c3 = b3.value;
  if (null == c3) {
    c3 = b3.children;
    b3 = b3.defaultValue;
    if (null != c3) {
      if (null != b3)
        throw Error(p$7(92));
      if (eb(c3)) {
        if (1 < c3.length)
          throw Error(p$7(93));
        c3 = c3[0];
      }
      b3 = c3;
    }
    null == b3 && (b3 = "");
    c3 = b3;
  }
  a4._wrapperState = { initialValue: Sa(c3) };
}
function ib(a4, b3) {
  var c3 = Sa(b3.value), d4 = Sa(b3.defaultValue);
  null != c3 && (c3 = "" + c3, c3 !== a4.value && (a4.value = c3), null == b3.defaultValue && a4.defaultValue !== c3 && (a4.defaultValue = c3));
  null != d4 && (a4.defaultValue = "" + d4);
}
function jb(a4) {
  var b3 = a4.textContent;
  b3 === a4._wrapperState.initialValue && "" !== b3 && null !== b3 && (a4.value = b3);
}
function kb(a4) {
  switch (a4) {
    case "svg":
      return "http://www.w3.org/2000/svg";
    case "math":
      return "http://www.w3.org/1998/Math/MathML";
    default:
      return "http://www.w3.org/1999/xhtml";
  }
}
function lb(a4, b3) {
  return null == a4 || "http://www.w3.org/1999/xhtml" === a4 ? kb(b3) : "http://www.w3.org/2000/svg" === a4 && "foreignObject" === b3 ? "http://www.w3.org/1999/xhtml" : a4;
}
var mb, nb = function(a4) {
  return "undefined" !== typeof MSApp && MSApp.execUnsafeLocalFunction ? function(b3, c3, d4, e3) {
    MSApp.execUnsafeLocalFunction(function() {
      return a4(b3, c3, d4, e3);
    });
  } : a4;
}(function(a4, b3) {
  if ("http://www.w3.org/2000/svg" !== a4.namespaceURI || "innerHTML" in a4)
    a4.innerHTML = b3;
  else {
    mb = mb || document.createElement("div");
    mb.innerHTML = "<svg>" + b3.valueOf().toString() + "</svg>";
    for (b3 = mb.firstChild; a4.firstChild; )
      a4.removeChild(a4.firstChild);
    for (; b3.firstChild; )
      a4.appendChild(b3.firstChild);
  }
});
function ob(a4, b3) {
  if (b3) {
    var c3 = a4.firstChild;
    if (c3 && c3 === a4.lastChild && 3 === c3.nodeType) {
      c3.nodeValue = b3;
      return;
    }
  }
  a4.textContent = b3;
}
var pb = {
  animationIterationCount: true,
  aspectRatio: true,
  borderImageOutset: true,
  borderImageSlice: true,
  borderImageWidth: true,
  boxFlex: true,
  boxFlexGroup: true,
  boxOrdinalGroup: true,
  columnCount: true,
  columns: true,
  flex: true,
  flexGrow: true,
  flexPositive: true,
  flexShrink: true,
  flexNegative: true,
  flexOrder: true,
  gridArea: true,
  gridRow: true,
  gridRowEnd: true,
  gridRowSpan: true,
  gridRowStart: true,
  gridColumn: true,
  gridColumnEnd: true,
  gridColumnSpan: true,
  gridColumnStart: true,
  fontWeight: true,
  lineClamp: true,
  lineHeight: true,
  opacity: true,
  order: true,
  orphans: true,
  tabSize: true,
  widows: true,
  zIndex: true,
  zoom: true,
  fillOpacity: true,
  floodOpacity: true,
  stopOpacity: true,
  strokeDasharray: true,
  strokeDashoffset: true,
  strokeMiterlimit: true,
  strokeOpacity: true,
  strokeWidth: true
}, qb = ["Webkit", "ms", "Moz", "O"];
Object.keys(pb).forEach(function(a4) {
  qb.forEach(function(b3) {
    b3 = b3 + a4.charAt(0).toUpperCase() + a4.substring(1);
    pb[b3] = pb[a4];
  });
});
function rb(a4, b3, c3) {
  return null == b3 || "boolean" === typeof b3 || "" === b3 ? "" : c3 || "number" !== typeof b3 || 0 === b3 || pb.hasOwnProperty(a4) && pb[a4] ? ("" + b3).trim() : b3 + "px";
}
function sb(a4, b3) {
  a4 = a4.style;
  for (var c3 in b3)
    if (b3.hasOwnProperty(c3)) {
      var d4 = 0 === c3.indexOf("--"), e3 = rb(c3, b3[c3], d4);
      "float" === c3 && (c3 = "cssFloat");
      d4 ? a4.setProperty(c3, e3) : a4[c3] = e3;
    }
}
var tb = A$3({ menuitem: true }, { area: true, base: true, br: true, col: true, embed: true, hr: true, img: true, input: true, keygen: true, link: true, meta: true, param: true, source: true, track: true, wbr: true });
function ub(a4, b3) {
  if (b3) {
    if (tb[a4] && (null != b3.children || null != b3.dangerouslySetInnerHTML))
      throw Error(p$7(137, a4));
    if (null != b3.dangerouslySetInnerHTML) {
      if (null != b3.children)
        throw Error(p$7(60));
      if ("object" !== typeof b3.dangerouslySetInnerHTML || !("__html" in b3.dangerouslySetInnerHTML))
        throw Error(p$7(61));
    }
    if (null != b3.style && "object" !== typeof b3.style)
      throw Error(p$7(62));
  }
}
function vb(a4, b3) {
  if (-1 === a4.indexOf("-"))
    return "string" === typeof b3.is;
  switch (a4) {
    case "annotation-xml":
    case "color-profile":
    case "font-face":
    case "font-face-src":
    case "font-face-uri":
    case "font-face-format":
    case "font-face-name":
    case "missing-glyph":
      return false;
    default:
      return true;
  }
}
var wb = null;
function xb(a4) {
  a4 = a4.target || a4.srcElement || window;
  a4.correspondingUseElement && (a4 = a4.correspondingUseElement);
  return 3 === a4.nodeType ? a4.parentNode : a4;
}
var yb = null, zb = null, Ab = null;
function Bb(a4) {
  if (a4 = Cb(a4)) {
    if ("function" !== typeof yb)
      throw Error(p$7(280));
    var b3 = a4.stateNode;
    b3 && (b3 = Db(b3), yb(a4.stateNode, a4.type, b3));
  }
}
function Eb(a4) {
  zb ? Ab ? Ab.push(a4) : Ab = [a4] : zb = a4;
}
function Fb() {
  if (zb) {
    var a4 = zb, b3 = Ab;
    Ab = zb = null;
    Bb(a4);
    if (b3)
      for (a4 = 0; a4 < b3.length; a4++)
        Bb(b3[a4]);
  }
}
function Gb(a4, b3) {
  return a4(b3);
}
function Hb() {
}
var Ib = false;
function Jb(a4, b3, c3) {
  if (Ib)
    return a4(b3, c3);
  Ib = true;
  try {
    return Gb(a4, b3, c3);
  } finally {
    if (Ib = false, null !== zb || null !== Ab)
      Hb(), Fb();
  }
}
function Kb(a4, b3) {
  var c3 = a4.stateNode;
  if (null === c3)
    return null;
  var d4 = Db(c3);
  if (null === d4)
    return null;
  c3 = d4[b3];
  a:
    switch (b3) {
      case "onClick":
      case "onClickCapture":
      case "onDoubleClick":
      case "onDoubleClickCapture":
      case "onMouseDown":
      case "onMouseDownCapture":
      case "onMouseMove":
      case "onMouseMoveCapture":
      case "onMouseUp":
      case "onMouseUpCapture":
      case "onMouseEnter":
        (d4 = !d4.disabled) || (a4 = a4.type, d4 = !("button" === a4 || "input" === a4 || "select" === a4 || "textarea" === a4));
        a4 = !d4;
        break a;
      default:
        a4 = false;
    }
  if (a4)
    return null;
  if (c3 && "function" !== typeof c3)
    throw Error(p$7(231, b3, typeof c3));
  return c3;
}
var Lb = false;
if (ia)
  try {
    var Mb = {};
    Object.defineProperty(Mb, "passive", { get: function() {
      Lb = true;
    } });
    window.addEventListener("test", Mb, Mb);
    window.removeEventListener("test", Mb, Mb);
  } catch (a4) {
    Lb = false;
  }
function Nb(a4, b3, c3, d4, e3, f2, g2, h4, k3) {
  var l2 = Array.prototype.slice.call(arguments, 3);
  try {
    b3.apply(c3, l2);
  } catch (m4) {
    this.onError(m4);
  }
}
var Ob = false, Pb = null, Qb = false, Rb = null, Sb = { onError: function(a4) {
  Ob = true;
  Pb = a4;
} };
function Tb(a4, b3, c3, d4, e3, f2, g2, h4, k3) {
  Ob = false;
  Pb = null;
  Nb.apply(Sb, arguments);
}
function Ub(a4, b3, c3, d4, e3, f2, g2, h4, k3) {
  Tb.apply(this, arguments);
  if (Ob) {
    if (Ob) {
      var l2 = Pb;
      Ob = false;
      Pb = null;
    } else
      throw Error(p$7(198));
    Qb || (Qb = true, Rb = l2);
  }
}
function Vb(a4) {
  var b3 = a4, c3 = a4;
  if (a4.alternate)
    for (; b3.return; )
      b3 = b3.return;
  else {
    a4 = b3;
    do
      b3 = a4, 0 !== (b3.flags & 4098) && (c3 = b3.return), a4 = b3.return;
    while (a4);
  }
  return 3 === b3.tag ? c3 : null;
}
function Wb(a4) {
  if (13 === a4.tag) {
    var b3 = a4.memoizedState;
    null === b3 && (a4 = a4.alternate, null !== a4 && (b3 = a4.memoizedState));
    if (null !== b3)
      return b3.dehydrated;
  }
  return null;
}
function Xb(a4) {
  if (Vb(a4) !== a4)
    throw Error(p$7(188));
}
function Yb(a4) {
  var b3 = a4.alternate;
  if (!b3) {
    b3 = Vb(a4);
    if (null === b3)
      throw Error(p$7(188));
    return b3 !== a4 ? null : a4;
  }
  for (var c3 = a4, d4 = b3; ; ) {
    var e3 = c3.return;
    if (null === e3)
      break;
    var f2 = e3.alternate;
    if (null === f2) {
      d4 = e3.return;
      if (null !== d4) {
        c3 = d4;
        continue;
      }
      break;
    }
    if (e3.child === f2.child) {
      for (f2 = e3.child; f2; ) {
        if (f2 === c3)
          return Xb(e3), a4;
        if (f2 === d4)
          return Xb(e3), b3;
        f2 = f2.sibling;
      }
      throw Error(p$7(188));
    }
    if (c3.return !== d4.return)
      c3 = e3, d4 = f2;
    else {
      for (var g2 = false, h4 = e3.child; h4; ) {
        if (h4 === c3) {
          g2 = true;
          c3 = e3;
          d4 = f2;
          break;
        }
        if (h4 === d4) {
          g2 = true;
          d4 = e3;
          c3 = f2;
          break;
        }
        h4 = h4.sibling;
      }
      if (!g2) {
        for (h4 = f2.child; h4; ) {
          if (h4 === c3) {
            g2 = true;
            c3 = f2;
            d4 = e3;
            break;
          }
          if (h4 === d4) {
            g2 = true;
            d4 = f2;
            c3 = e3;
            break;
          }
          h4 = h4.sibling;
        }
        if (!g2)
          throw Error(p$7(189));
      }
    }
    if (c3.alternate !== d4)
      throw Error(p$7(190));
  }
  if (3 !== c3.tag)
    throw Error(p$7(188));
  return c3.stateNode.current === c3 ? a4 : b3;
}
function Zb(a4) {
  a4 = Yb(a4);
  return null !== a4 ? $b(a4) : null;
}
function $b(a4) {
  if (5 === a4.tag || 6 === a4.tag)
    return a4;
  for (a4 = a4.child; null !== a4; ) {
    var b3 = $b(a4);
    if (null !== b3)
      return b3;
    a4 = a4.sibling;
  }
  return null;
}
var ac = ca.unstable_scheduleCallback, bc = ca.unstable_cancelCallback, cc = ca.unstable_shouldYield, dc = ca.unstable_requestPaint, B = ca.unstable_now, ec = ca.unstable_getCurrentPriorityLevel, fc = ca.unstable_ImmediatePriority, gc = ca.unstable_UserBlockingPriority, hc = ca.unstable_NormalPriority, ic = ca.unstable_LowPriority, jc = ca.unstable_IdlePriority, kc = null, lc = null;
function mc(a4) {
  if (lc && "function" === typeof lc.onCommitFiberRoot)
    try {
      lc.onCommitFiberRoot(kc, a4, void 0, 128 === (a4.current.flags & 128));
    } catch (b3) {
    }
}
var oc = Math.clz32 ? Math.clz32 : nc, pc = Math.log, qc = Math.LN2;
function nc(a4) {
  a4 >>>= 0;
  return 0 === a4 ? 32 : 31 - (pc(a4) / qc | 0) | 0;
}
var rc = 64, sc = 4194304;
function tc(a4) {
  switch (a4 & -a4) {
    case 1:
      return 1;
    case 2:
      return 2;
    case 4:
      return 4;
    case 8:
      return 8;
    case 16:
      return 16;
    case 32:
      return 32;
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
      return a4 & 4194240;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
      return a4 & 130023424;
    case 134217728:
      return 134217728;
    case 268435456:
      return 268435456;
    case 536870912:
      return 536870912;
    case 1073741824:
      return 1073741824;
    default:
      return a4;
  }
}
function uc(a4, b3) {
  var c3 = a4.pendingLanes;
  if (0 === c3)
    return 0;
  var d4 = 0, e3 = a4.suspendedLanes, f2 = a4.pingedLanes, g2 = c3 & 268435455;
  if (0 !== g2) {
    var h4 = g2 & ~e3;
    0 !== h4 ? d4 = tc(h4) : (f2 &= g2, 0 !== f2 && (d4 = tc(f2)));
  } else
    g2 = c3 & ~e3, 0 !== g2 ? d4 = tc(g2) : 0 !== f2 && (d4 = tc(f2));
  if (0 === d4)
    return 0;
  if (0 !== b3 && b3 !== d4 && 0 === (b3 & e3) && (e3 = d4 & -d4, f2 = b3 & -b3, e3 >= f2 || 16 === e3 && 0 !== (f2 & 4194240)))
    return b3;
  0 !== (d4 & 4) && (d4 |= c3 & 16);
  b3 = a4.entangledLanes;
  if (0 !== b3)
    for (a4 = a4.entanglements, b3 &= d4; 0 < b3; )
      c3 = 31 - oc(b3), e3 = 1 << c3, d4 |= a4[c3], b3 &= ~e3;
  return d4;
}
function vc(a4, b3) {
  switch (a4) {
    case 1:
    case 2:
    case 4:
      return b3 + 250;
    case 8:
    case 16:
    case 32:
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
      return b3 + 5e3;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
      return -1;
    case 134217728:
    case 268435456:
    case 536870912:
    case 1073741824:
      return -1;
    default:
      return -1;
  }
}
function wc(a4, b3) {
  for (var c3 = a4.suspendedLanes, d4 = a4.pingedLanes, e3 = a4.expirationTimes, f2 = a4.pendingLanes; 0 < f2; ) {
    var g2 = 31 - oc(f2), h4 = 1 << g2, k3 = e3[g2];
    if (-1 === k3) {
      if (0 === (h4 & c3) || 0 !== (h4 & d4))
        e3[g2] = vc(h4, b3);
    } else
      k3 <= b3 && (a4.expiredLanes |= h4);
    f2 &= ~h4;
  }
}
function xc(a4) {
  a4 = a4.pendingLanes & -1073741825;
  return 0 !== a4 ? a4 : a4 & 1073741824 ? 1073741824 : 0;
}
function yc() {
  var a4 = rc;
  rc <<= 1;
  0 === (rc & 4194240) && (rc = 64);
  return a4;
}
function zc(a4) {
  for (var b3 = [], c3 = 0; 31 > c3; c3++)
    b3.push(a4);
  return b3;
}
function Ac(a4, b3, c3) {
  a4.pendingLanes |= b3;
  536870912 !== b3 && (a4.suspendedLanes = 0, a4.pingedLanes = 0);
  a4 = a4.eventTimes;
  b3 = 31 - oc(b3);
  a4[b3] = c3;
}
function Bc(a4, b3) {
  var c3 = a4.pendingLanes & ~b3;
  a4.pendingLanes = b3;
  a4.suspendedLanes = 0;
  a4.pingedLanes = 0;
  a4.expiredLanes &= b3;
  a4.mutableReadLanes &= b3;
  a4.entangledLanes &= b3;
  b3 = a4.entanglements;
  var d4 = a4.eventTimes;
  for (a4 = a4.expirationTimes; 0 < c3; ) {
    var e3 = 31 - oc(c3), f2 = 1 << e3;
    b3[e3] = 0;
    d4[e3] = -1;
    a4[e3] = -1;
    c3 &= ~f2;
  }
}
function Cc(a4, b3) {
  var c3 = a4.entangledLanes |= b3;
  for (a4 = a4.entanglements; c3; ) {
    var d4 = 31 - oc(c3), e3 = 1 << d4;
    e3 & b3 | a4[d4] & b3 && (a4[d4] |= b3);
    c3 &= ~e3;
  }
}
var C$3 = 0;
function Dc(a4) {
  a4 &= -a4;
  return 1 < a4 ? 4 < a4 ? 0 !== (a4 & 268435455) ? 16 : 536870912 : 4 : 1;
}
var Ec, Fc, Gc, Hc, Ic, Jc = false, Kc = [], Lc = null, Mc = null, Nc = null, Oc = /* @__PURE__ */ new Map(), Pc = /* @__PURE__ */ new Map(), Qc = [], Rc = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
function Sc(a4, b3) {
  switch (a4) {
    case "focusin":
    case "focusout":
      Lc = null;
      break;
    case "dragenter":
    case "dragleave":
      Mc = null;
      break;
    case "mouseover":
    case "mouseout":
      Nc = null;
      break;
    case "pointerover":
    case "pointerout":
      Oc.delete(b3.pointerId);
      break;
    case "gotpointercapture":
    case "lostpointercapture":
      Pc.delete(b3.pointerId);
  }
}
function Tc(a4, b3, c3, d4, e3, f2) {
  if (null === a4 || a4.nativeEvent !== f2)
    return a4 = { blockedOn: b3, domEventName: c3, eventSystemFlags: d4, nativeEvent: f2, targetContainers: [e3] }, null !== b3 && (b3 = Cb(b3), null !== b3 && Fc(b3)), a4;
  a4.eventSystemFlags |= d4;
  b3 = a4.targetContainers;
  null !== e3 && -1 === b3.indexOf(e3) && b3.push(e3);
  return a4;
}
function Uc(a4, b3, c3, d4, e3) {
  switch (b3) {
    case "focusin":
      return Lc = Tc(Lc, a4, b3, c3, d4, e3), true;
    case "dragenter":
      return Mc = Tc(Mc, a4, b3, c3, d4, e3), true;
    case "mouseover":
      return Nc = Tc(Nc, a4, b3, c3, d4, e3), true;
    case "pointerover":
      var f2 = e3.pointerId;
      Oc.set(f2, Tc(Oc.get(f2) || null, a4, b3, c3, d4, e3));
      return true;
    case "gotpointercapture":
      return f2 = e3.pointerId, Pc.set(f2, Tc(Pc.get(f2) || null, a4, b3, c3, d4, e3)), true;
  }
  return false;
}
function Vc(a4) {
  var b3 = Wc(a4.target);
  if (null !== b3) {
    var c3 = Vb(b3);
    if (null !== c3) {
      if (b3 = c3.tag, 13 === b3) {
        if (b3 = Wb(c3), null !== b3) {
          a4.blockedOn = b3;
          Ic(a4.priority, function() {
            Gc(c3);
          });
          return;
        }
      } else if (3 === b3 && c3.stateNode.current.memoizedState.isDehydrated) {
        a4.blockedOn = 3 === c3.tag ? c3.stateNode.containerInfo : null;
        return;
      }
    }
  }
  a4.blockedOn = null;
}
function Xc(a4) {
  if (null !== a4.blockedOn)
    return false;
  for (var b3 = a4.targetContainers; 0 < b3.length; ) {
    var c3 = Yc(a4.domEventName, a4.eventSystemFlags, b3[0], a4.nativeEvent);
    if (null === c3) {
      c3 = a4.nativeEvent;
      var d4 = new c3.constructor(c3.type, c3);
      wb = d4;
      c3.target.dispatchEvent(d4);
      wb = null;
    } else
      return b3 = Cb(c3), null !== b3 && Fc(b3), a4.blockedOn = c3, false;
    b3.shift();
  }
  return true;
}
function Zc(a4, b3, c3) {
  Xc(a4) && c3.delete(b3);
}
function $c() {
  Jc = false;
  null !== Lc && Xc(Lc) && (Lc = null);
  null !== Mc && Xc(Mc) && (Mc = null);
  null !== Nc && Xc(Nc) && (Nc = null);
  Oc.forEach(Zc);
  Pc.forEach(Zc);
}
function ad(a4, b3) {
  a4.blockedOn === b3 && (a4.blockedOn = null, Jc || (Jc = true, ca.unstable_scheduleCallback(ca.unstable_NormalPriority, $c)));
}
function bd(a4) {
  function b3(b4) {
    return ad(b4, a4);
  }
  if (0 < Kc.length) {
    ad(Kc[0], a4);
    for (var c3 = 1; c3 < Kc.length; c3++) {
      var d4 = Kc[c3];
      d4.blockedOn === a4 && (d4.blockedOn = null);
    }
  }
  null !== Lc && ad(Lc, a4);
  null !== Mc && ad(Mc, a4);
  null !== Nc && ad(Nc, a4);
  Oc.forEach(b3);
  Pc.forEach(b3);
  for (c3 = 0; c3 < Qc.length; c3++)
    d4 = Qc[c3], d4.blockedOn === a4 && (d4.blockedOn = null);
  for (; 0 < Qc.length && (c3 = Qc[0], null === c3.blockedOn); )
    Vc(c3), null === c3.blockedOn && Qc.shift();
}
var cd = ua.ReactCurrentBatchConfig, dd = true;
function ed(a4, b3, c3, d4) {
  var e3 = C$3, f2 = cd.transition;
  cd.transition = null;
  try {
    C$3 = 1, fd(a4, b3, c3, d4);
  } finally {
    C$3 = e3, cd.transition = f2;
  }
}
function gd(a4, b3, c3, d4) {
  var e3 = C$3, f2 = cd.transition;
  cd.transition = null;
  try {
    C$3 = 4, fd(a4, b3, c3, d4);
  } finally {
    C$3 = e3, cd.transition = f2;
  }
}
function fd(a4, b3, c3, d4) {
  if (dd) {
    var e3 = Yc(a4, b3, c3, d4);
    if (null === e3)
      hd(a4, b3, d4, id, c3), Sc(a4, d4);
    else if (Uc(e3, a4, b3, c3, d4))
      d4.stopPropagation();
    else if (Sc(a4, d4), b3 & 4 && -1 < Rc.indexOf(a4)) {
      for (; null !== e3; ) {
        var f2 = Cb(e3);
        null !== f2 && Ec(f2);
        f2 = Yc(a4, b3, c3, d4);
        null === f2 && hd(a4, b3, d4, id, c3);
        if (f2 === e3)
          break;
        e3 = f2;
      }
      null !== e3 && d4.stopPropagation();
    } else
      hd(a4, b3, d4, null, c3);
  }
}
var id = null;
function Yc(a4, b3, c3, d4) {
  id = null;
  a4 = xb(d4);
  a4 = Wc(a4);
  if (null !== a4)
    if (b3 = Vb(a4), null === b3)
      a4 = null;
    else if (c3 = b3.tag, 13 === c3) {
      a4 = Wb(b3);
      if (null !== a4)
        return a4;
      a4 = null;
    } else if (3 === c3) {
      if (b3.stateNode.current.memoizedState.isDehydrated)
        return 3 === b3.tag ? b3.stateNode.containerInfo : null;
      a4 = null;
    } else
      b3 !== a4 && (a4 = null);
  id = a4;
  return null;
}
function jd(a4) {
  switch (a4) {
    case "cancel":
    case "click":
    case "close":
    case "contextmenu":
    case "copy":
    case "cut":
    case "auxclick":
    case "dblclick":
    case "dragend":
    case "dragstart":
    case "drop":
    case "focusin":
    case "focusout":
    case "input":
    case "invalid":
    case "keydown":
    case "keypress":
    case "keyup":
    case "mousedown":
    case "mouseup":
    case "paste":
    case "pause":
    case "play":
    case "pointercancel":
    case "pointerdown":
    case "pointerup":
    case "ratechange":
    case "reset":
    case "resize":
    case "seeked":
    case "submit":
    case "touchcancel":
    case "touchend":
    case "touchstart":
    case "volumechange":
    case "change":
    case "selectionchange":
    case "textInput":
    case "compositionstart":
    case "compositionend":
    case "compositionupdate":
    case "beforeblur":
    case "afterblur":
    case "beforeinput":
    case "blur":
    case "fullscreenchange":
    case "focus":
    case "hashchange":
    case "popstate":
    case "select":
    case "selectstart":
      return 1;
    case "drag":
    case "dragenter":
    case "dragexit":
    case "dragleave":
    case "dragover":
    case "mousemove":
    case "mouseout":
    case "mouseover":
    case "pointermove":
    case "pointerout":
    case "pointerover":
    case "scroll":
    case "toggle":
    case "touchmove":
    case "wheel":
    case "mouseenter":
    case "mouseleave":
    case "pointerenter":
    case "pointerleave":
      return 4;
    case "message":
      switch (ec()) {
        case fc:
          return 1;
        case gc:
          return 4;
        case hc:
        case ic:
          return 16;
        case jc:
          return 536870912;
        default:
          return 16;
      }
    default:
      return 16;
  }
}
var kd = null, ld = null, md = null;
function nd() {
  if (md)
    return md;
  var a4, b3 = ld, c3 = b3.length, d4, e3 = "value" in kd ? kd.value : kd.textContent, f2 = e3.length;
  for (a4 = 0; a4 < c3 && b3[a4] === e3[a4]; a4++)
    ;
  var g2 = c3 - a4;
  for (d4 = 1; d4 <= g2 && b3[c3 - d4] === e3[f2 - d4]; d4++)
    ;
  return md = e3.slice(a4, 1 < d4 ? 1 - d4 : void 0);
}
function od(a4) {
  var b3 = a4.keyCode;
  "charCode" in a4 ? (a4 = a4.charCode, 0 === a4 && 13 === b3 && (a4 = 13)) : a4 = b3;
  10 === a4 && (a4 = 13);
  return 32 <= a4 || 13 === a4 ? a4 : 0;
}
function pd() {
  return true;
}
function qd() {
  return false;
}
function rd(a4) {
  function b3(b4, d4, e3, f2, g2) {
    this._reactName = b4;
    this._targetInst = e3;
    this.type = d4;
    this.nativeEvent = f2;
    this.target = g2;
    this.currentTarget = null;
    for (var c3 in a4)
      a4.hasOwnProperty(c3) && (b4 = a4[c3], this[c3] = b4 ? b4(f2) : f2[c3]);
    this.isDefaultPrevented = (null != f2.defaultPrevented ? f2.defaultPrevented : false === f2.returnValue) ? pd : qd;
    this.isPropagationStopped = qd;
    return this;
  }
  A$3(b3.prototype, { preventDefault: function() {
    this.defaultPrevented = true;
    var a5 = this.nativeEvent;
    a5 && (a5.preventDefault ? a5.preventDefault() : "unknown" !== typeof a5.returnValue && (a5.returnValue = false), this.isDefaultPrevented = pd);
  }, stopPropagation: function() {
    var a5 = this.nativeEvent;
    a5 && (a5.stopPropagation ? a5.stopPropagation() : "unknown" !== typeof a5.cancelBubble && (a5.cancelBubble = true), this.isPropagationStopped = pd);
  }, persist: function() {
  }, isPersistent: pd });
  return b3;
}
var sd = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function(a4) {
  return a4.timeStamp || Date.now();
}, defaultPrevented: 0, isTrusted: 0 }, td = rd(sd), ud = A$3({}, sd, { view: 0, detail: 0 }), vd = rd(ud), wd, xd, yd, Ad = A$3({}, ud, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: zd, button: 0, buttons: 0, relatedTarget: function(a4) {
  return void 0 === a4.relatedTarget ? a4.fromElement === a4.srcElement ? a4.toElement : a4.fromElement : a4.relatedTarget;
}, movementX: function(a4) {
  if ("movementX" in a4)
    return a4.movementX;
  a4 !== yd && (yd && "mousemove" === a4.type ? (wd = a4.screenX - yd.screenX, xd = a4.screenY - yd.screenY) : xd = wd = 0, yd = a4);
  return wd;
}, movementY: function(a4) {
  return "movementY" in a4 ? a4.movementY : xd;
} }), Bd = rd(Ad), Cd = A$3({}, Ad, { dataTransfer: 0 }), Dd = rd(Cd), Ed = A$3({}, ud, { relatedTarget: 0 }), Fd = rd(Ed), Gd = A$3({}, sd, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }), Hd = rd(Gd), Id = A$3({}, sd, { clipboardData: function(a4) {
  return "clipboardData" in a4 ? a4.clipboardData : window.clipboardData;
} }), Jd = rd(Id), Kd = A$3({}, sd, { data: 0 }), Ld = rd(Kd), Md = {
  Esc: "Escape",
  Spacebar: " ",
  Left: "ArrowLeft",
  Up: "ArrowUp",
  Right: "ArrowRight",
  Down: "ArrowDown",
  Del: "Delete",
  Win: "OS",
  Menu: "ContextMenu",
  Apps: "ContextMenu",
  Scroll: "ScrollLock",
  MozPrintableKey: "Unidentified"
}, Nd = {
  8: "Backspace",
  9: "Tab",
  12: "Clear",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  19: "Pause",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  45: "Insert",
  46: "Delete",
  112: "F1",
  113: "F2",
  114: "F3",
  115: "F4",
  116: "F5",
  117: "F6",
  118: "F7",
  119: "F8",
  120: "F9",
  121: "F10",
  122: "F11",
  123: "F12",
  144: "NumLock",
  145: "ScrollLock",
  224: "Meta"
}, Od = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" };
function Pd(a4) {
  var b3 = this.nativeEvent;
  return b3.getModifierState ? b3.getModifierState(a4) : (a4 = Od[a4]) ? !!b3[a4] : false;
}
function zd() {
  return Pd;
}
var Qd = A$3({}, ud, { key: function(a4) {
  if (a4.key) {
    var b3 = Md[a4.key] || a4.key;
    if ("Unidentified" !== b3)
      return b3;
  }
  return "keypress" === a4.type ? (a4 = od(a4), 13 === a4 ? "Enter" : String.fromCharCode(a4)) : "keydown" === a4.type || "keyup" === a4.type ? Nd[a4.keyCode] || "Unidentified" : "";
}, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: zd, charCode: function(a4) {
  return "keypress" === a4.type ? od(a4) : 0;
}, keyCode: function(a4) {
  return "keydown" === a4.type || "keyup" === a4.type ? a4.keyCode : 0;
}, which: function(a4) {
  return "keypress" === a4.type ? od(a4) : "keydown" === a4.type || "keyup" === a4.type ? a4.keyCode : 0;
} }), Rd = rd(Qd), Sd = A$3({}, Ad, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 }), Td = rd(Sd), Ud = A$3({}, ud, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: zd }), Vd = rd(Ud), Wd = A$3({}, sd, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }), Xd = rd(Wd), Yd = A$3({}, Ad, {
  deltaX: function(a4) {
    return "deltaX" in a4 ? a4.deltaX : "wheelDeltaX" in a4 ? -a4.wheelDeltaX : 0;
  },
  deltaY: function(a4) {
    return "deltaY" in a4 ? a4.deltaY : "wheelDeltaY" in a4 ? -a4.wheelDeltaY : "wheelDelta" in a4 ? -a4.wheelDelta : 0;
  },
  deltaZ: 0,
  deltaMode: 0
}), Zd = rd(Yd), $d = [9, 13, 27, 32], ae$1 = ia && "CompositionEvent" in window, be$1 = null;
ia && "documentMode" in document && (be$1 = document.documentMode);
var ce = ia && "TextEvent" in window && !be$1, de$1 = ia && (!ae$1 || be$1 && 8 < be$1 && 11 >= be$1), ee = String.fromCharCode(32), fe$1 = false;
function ge$1(a4, b3) {
  switch (a4) {
    case "keyup":
      return -1 !== $d.indexOf(b3.keyCode);
    case "keydown":
      return 229 !== b3.keyCode;
    case "keypress":
    case "mousedown":
    case "focusout":
      return true;
    default:
      return false;
  }
}
function he$1(a4) {
  a4 = a4.detail;
  return "object" === typeof a4 && "data" in a4 ? a4.data : null;
}
var ie$2 = false;
function je$1(a4, b3) {
  switch (a4) {
    case "compositionend":
      return he$1(b3);
    case "keypress":
      if (32 !== b3.which)
        return null;
      fe$1 = true;
      return ee;
    case "textInput":
      return a4 = b3.data, a4 === ee && fe$1 ? null : a4;
    default:
      return null;
  }
}
function ke$1(a4, b3) {
  if (ie$2)
    return "compositionend" === a4 || !ae$1 && ge$1(a4, b3) ? (a4 = nd(), md = ld = kd = null, ie$2 = false, a4) : null;
  switch (a4) {
    case "paste":
      return null;
    case "keypress":
      if (!(b3.ctrlKey || b3.altKey || b3.metaKey) || b3.ctrlKey && b3.altKey) {
        if (b3.char && 1 < b3.char.length)
          return b3.char;
        if (b3.which)
          return String.fromCharCode(b3.which);
      }
      return null;
    case "compositionend":
      return de$1 && "ko" !== b3.locale ? null : b3.data;
    default:
      return null;
  }
}
var le$1 = { color: true, date: true, datetime: true, "datetime-local": true, email: true, month: true, number: true, password: true, range: true, search: true, tel: true, text: true, time: true, url: true, week: true };
function me$1(a4) {
  var b3 = a4 && a4.nodeName && a4.nodeName.toLowerCase();
  return "input" === b3 ? !!le$1[a4.type] : "textarea" === b3 ? true : false;
}
function ne(a4, b3, c3, d4) {
  Eb(d4);
  b3 = oe(b3, "onChange");
  0 < b3.length && (c3 = new td("onChange", "change", null, c3, d4), a4.push({ event: c3, listeners: b3 }));
}
var pe = null, qe$1 = null;
function re(a4) {
  se(a4, 0);
}
function te(a4) {
  var b3 = ue$1(a4);
  if (Wa(b3))
    return a4;
}
function ve$1(a4, b3) {
  if ("change" === a4)
    return b3;
}
var we$1 = false;
if (ia) {
  var xe$1;
  if (ia) {
    var ye$1 = "oninput" in document;
    if (!ye$1) {
      var ze$1 = document.createElement("div");
      ze$1.setAttribute("oninput", "return;");
      ye$1 = "function" === typeof ze$1.oninput;
    }
    xe$1 = ye$1;
  } else
    xe$1 = false;
  we$1 = xe$1 && (!document.documentMode || 9 < document.documentMode);
}
function Ae$1() {
  pe && (pe.detachEvent("onpropertychange", Be$1), qe$1 = pe = null);
}
function Be$1(a4) {
  if ("value" === a4.propertyName && te(qe$1)) {
    var b3 = [];
    ne(b3, qe$1, a4, xb(a4));
    Jb(re, b3);
  }
}
function Ce$1(a4, b3, c3) {
  "focusin" === a4 ? (Ae$1(), pe = b3, qe$1 = c3, pe.attachEvent("onpropertychange", Be$1)) : "focusout" === a4 && Ae$1();
}
function De$1(a4) {
  if ("selectionchange" === a4 || "keyup" === a4 || "keydown" === a4)
    return te(qe$1);
}
function Ee$1(a4, b3) {
  if ("click" === a4)
    return te(b3);
}
function Fe$1(a4, b3) {
  if ("input" === a4 || "change" === a4)
    return te(b3);
}
function Ge$1(a4, b3) {
  return a4 === b3 && (0 !== a4 || 1 / a4 === 1 / b3) || a4 !== a4 && b3 !== b3;
}
var He$1 = "function" === typeof Object.is ? Object.is : Ge$1;
function Ie$1(a4, b3) {
  if (He$1(a4, b3))
    return true;
  if ("object" !== typeof a4 || null === a4 || "object" !== typeof b3 || null === b3)
    return false;
  var c3 = Object.keys(a4), d4 = Object.keys(b3);
  if (c3.length !== d4.length)
    return false;
  for (d4 = 0; d4 < c3.length; d4++) {
    var e3 = c3[d4];
    if (!ja.call(b3, e3) || !He$1(a4[e3], b3[e3]))
      return false;
  }
  return true;
}
function Je$1(a4) {
  for (; a4 && a4.firstChild; )
    a4 = a4.firstChild;
  return a4;
}
function Ke$1(a4, b3) {
  var c3 = Je$1(a4);
  a4 = 0;
  for (var d4; c3; ) {
    if (3 === c3.nodeType) {
      d4 = a4 + c3.textContent.length;
      if (a4 <= b3 && d4 >= b3)
        return { node: c3, offset: b3 - a4 };
      a4 = d4;
    }
    a: {
      for (; c3; ) {
        if (c3.nextSibling) {
          c3 = c3.nextSibling;
          break a;
        }
        c3 = c3.parentNode;
      }
      c3 = void 0;
    }
    c3 = Je$1(c3);
  }
}
function Le$1(a4, b3) {
  return a4 && b3 ? a4 === b3 ? true : a4 && 3 === a4.nodeType ? false : b3 && 3 === b3.nodeType ? Le$1(a4, b3.parentNode) : "contains" in a4 ? a4.contains(b3) : a4.compareDocumentPosition ? !!(a4.compareDocumentPosition(b3) & 16) : false : false;
}
function Me$1() {
  for (var a4 = window, b3 = Xa(); b3 instanceof a4.HTMLIFrameElement; ) {
    try {
      var c3 = "string" === typeof b3.contentWindow.location.href;
    } catch (d4) {
      c3 = false;
    }
    if (c3)
      a4 = b3.contentWindow;
    else
      break;
    b3 = Xa(a4.document);
  }
  return b3;
}
function Ne$1(a4) {
  var b3 = a4 && a4.nodeName && a4.nodeName.toLowerCase();
  return b3 && ("input" === b3 && ("text" === a4.type || "search" === a4.type || "tel" === a4.type || "url" === a4.type || "password" === a4.type) || "textarea" === b3 || "true" === a4.contentEditable);
}
function Oe$1(a4) {
  var b3 = Me$1(), c3 = a4.focusedElem, d4 = a4.selectionRange;
  if (b3 !== c3 && c3 && c3.ownerDocument && Le$1(c3.ownerDocument.documentElement, c3)) {
    if (null !== d4 && Ne$1(c3)) {
      if (b3 = d4.start, a4 = d4.end, void 0 === a4 && (a4 = b3), "selectionStart" in c3)
        c3.selectionStart = b3, c3.selectionEnd = Math.min(a4, c3.value.length);
      else if (a4 = (b3 = c3.ownerDocument || document) && b3.defaultView || window, a4.getSelection) {
        a4 = a4.getSelection();
        var e3 = c3.textContent.length, f2 = Math.min(d4.start, e3);
        d4 = void 0 === d4.end ? f2 : Math.min(d4.end, e3);
        !a4.extend && f2 > d4 && (e3 = d4, d4 = f2, f2 = e3);
        e3 = Ke$1(c3, f2);
        var g2 = Ke$1(
          c3,
          d4
        );
        e3 && g2 && (1 !== a4.rangeCount || a4.anchorNode !== e3.node || a4.anchorOffset !== e3.offset || a4.focusNode !== g2.node || a4.focusOffset !== g2.offset) && (b3 = b3.createRange(), b3.setStart(e3.node, e3.offset), a4.removeAllRanges(), f2 > d4 ? (a4.addRange(b3), a4.extend(g2.node, g2.offset)) : (b3.setEnd(g2.node, g2.offset), a4.addRange(b3)));
      }
    }
    b3 = [];
    for (a4 = c3; a4 = a4.parentNode; )
      1 === a4.nodeType && b3.push({ element: a4, left: a4.scrollLeft, top: a4.scrollTop });
    "function" === typeof c3.focus && c3.focus();
    for (c3 = 0; c3 < b3.length; c3++)
      a4 = b3[c3], a4.element.scrollLeft = a4.left, a4.element.scrollTop = a4.top;
  }
}
var Pe$1 = ia && "documentMode" in document && 11 >= document.documentMode, Qe$1 = null, Re$1 = null, Se$1 = null, Te$1 = false;
function Ue(a4, b3, c3) {
  var d4 = c3.window === c3 ? c3.document : 9 === c3.nodeType ? c3 : c3.ownerDocument;
  Te$1 || null == Qe$1 || Qe$1 !== Xa(d4) || (d4 = Qe$1, "selectionStart" in d4 && Ne$1(d4) ? d4 = { start: d4.selectionStart, end: d4.selectionEnd } : (d4 = (d4.ownerDocument && d4.ownerDocument.defaultView || window).getSelection(), d4 = { anchorNode: d4.anchorNode, anchorOffset: d4.anchorOffset, focusNode: d4.focusNode, focusOffset: d4.focusOffset }), Se$1 && Ie$1(Se$1, d4) || (Se$1 = d4, d4 = oe(Re$1, "onSelect"), 0 < d4.length && (b3 = new td("onSelect", "select", null, b3, c3), a4.push({ event: b3, listeners: d4 }), b3.target = Qe$1)));
}
function Ve$1(a4, b3) {
  var c3 = {};
  c3[a4.toLowerCase()] = b3.toLowerCase();
  c3["Webkit" + a4] = "webkit" + b3;
  c3["Moz" + a4] = "moz" + b3;
  return c3;
}
var We$1 = { animationend: Ve$1("Animation", "AnimationEnd"), animationiteration: Ve$1("Animation", "AnimationIteration"), animationstart: Ve$1("Animation", "AnimationStart"), transitionend: Ve$1("Transition", "TransitionEnd") }, Xe$1 = {}, Ye$1 = {};
ia && (Ye$1 = document.createElement("div").style, "AnimationEvent" in window || (delete We$1.animationend.animation, delete We$1.animationiteration.animation, delete We$1.animationstart.animation), "TransitionEvent" in window || delete We$1.transitionend.transition);
function Ze$1(a4) {
  if (Xe$1[a4])
    return Xe$1[a4];
  if (!We$1[a4])
    return a4;
  var b3 = We$1[a4], c3;
  for (c3 in b3)
    if (b3.hasOwnProperty(c3) && c3 in Ye$1)
      return Xe$1[a4] = b3[c3];
  return a4;
}
var $e = Ze$1("animationend"), af = Ze$1("animationiteration"), bf = Ze$1("animationstart"), cf = Ze$1("transitionend"), df = /* @__PURE__ */ new Map(), ef = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
function ff(a4, b3) {
  df.set(a4, b3);
  fa(b3, [a4]);
}
for (var gf = 0; gf < ef.length; gf++) {
  var hf = ef[gf], jf = hf.toLowerCase(), kf = hf[0].toUpperCase() + hf.slice(1);
  ff(jf, "on" + kf);
}
ff($e, "onAnimationEnd");
ff(af, "onAnimationIteration");
ff(bf, "onAnimationStart");
ff("dblclick", "onDoubleClick");
ff("focusin", "onFocus");
ff("focusout", "onBlur");
ff(cf, "onTransitionEnd");
ha("onMouseEnter", ["mouseout", "mouseover"]);
ha("onMouseLeave", ["mouseout", "mouseover"]);
ha("onPointerEnter", ["pointerout", "pointerover"]);
ha("onPointerLeave", ["pointerout", "pointerover"]);
fa("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" "));
fa("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));
fa("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
fa("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" "));
fa("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" "));
fa("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
var lf = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), mf = new Set("cancel close invalid load scroll toggle".split(" ").concat(lf));
function nf(a4, b3, c3) {
  var d4 = a4.type || "unknown-event";
  a4.currentTarget = c3;
  Ub(d4, b3, void 0, a4);
  a4.currentTarget = null;
}
function se(a4, b3) {
  b3 = 0 !== (b3 & 4);
  for (var c3 = 0; c3 < a4.length; c3++) {
    var d4 = a4[c3], e3 = d4.event;
    d4 = d4.listeners;
    a: {
      var f2 = void 0;
      if (b3)
        for (var g2 = d4.length - 1; 0 <= g2; g2--) {
          var h4 = d4[g2], k3 = h4.instance, l2 = h4.currentTarget;
          h4 = h4.listener;
          if (k3 !== f2 && e3.isPropagationStopped())
            break a;
          nf(e3, h4, l2);
          f2 = k3;
        }
      else
        for (g2 = 0; g2 < d4.length; g2++) {
          h4 = d4[g2];
          k3 = h4.instance;
          l2 = h4.currentTarget;
          h4 = h4.listener;
          if (k3 !== f2 && e3.isPropagationStopped())
            break a;
          nf(e3, h4, l2);
          f2 = k3;
        }
    }
  }
  if (Qb)
    throw a4 = Rb, Qb = false, Rb = null, a4;
}
function D$2(a4, b3) {
  var c3 = b3[of];
  void 0 === c3 && (c3 = b3[of] = /* @__PURE__ */ new Set());
  var d4 = a4 + "__bubble";
  c3.has(d4) || (pf(b3, a4, 2, false), c3.add(d4));
}
function qf(a4, b3, c3) {
  var d4 = 0;
  b3 && (d4 |= 4);
  pf(c3, a4, d4, b3);
}
var rf = "_reactListening" + Math.random().toString(36).slice(2);
function sf(a4) {
  if (!a4[rf]) {
    a4[rf] = true;
    da.forEach(function(b4) {
      "selectionchange" !== b4 && (mf.has(b4) || qf(b4, false, a4), qf(b4, true, a4));
    });
    var b3 = 9 === a4.nodeType ? a4 : a4.ownerDocument;
    null === b3 || b3[rf] || (b3[rf] = true, qf("selectionchange", false, b3));
  }
}
function pf(a4, b3, c3, d4) {
  switch (jd(b3)) {
    case 1:
      var e3 = ed;
      break;
    case 4:
      e3 = gd;
      break;
    default:
      e3 = fd;
  }
  c3 = e3.bind(null, b3, c3, a4);
  e3 = void 0;
  !Lb || "touchstart" !== b3 && "touchmove" !== b3 && "wheel" !== b3 || (e3 = true);
  d4 ? void 0 !== e3 ? a4.addEventListener(b3, c3, { capture: true, passive: e3 }) : a4.addEventListener(b3, c3, true) : void 0 !== e3 ? a4.addEventListener(b3, c3, { passive: e3 }) : a4.addEventListener(b3, c3, false);
}
function hd(a4, b3, c3, d4, e3) {
  var f2 = d4;
  if (0 === (b3 & 1) && 0 === (b3 & 2) && null !== d4)
    a:
      for (; ; ) {
        if (null === d4)
          return;
        var g2 = d4.tag;
        if (3 === g2 || 4 === g2) {
          var h4 = d4.stateNode.containerInfo;
          if (h4 === e3 || 8 === h4.nodeType && h4.parentNode === e3)
            break;
          if (4 === g2)
            for (g2 = d4.return; null !== g2; ) {
              var k3 = g2.tag;
              if (3 === k3 || 4 === k3) {
                if (k3 = g2.stateNode.containerInfo, k3 === e3 || 8 === k3.nodeType && k3.parentNode === e3)
                  return;
              }
              g2 = g2.return;
            }
          for (; null !== h4; ) {
            g2 = Wc(h4);
            if (null === g2)
              return;
            k3 = g2.tag;
            if (5 === k3 || 6 === k3) {
              d4 = f2 = g2;
              continue a;
            }
            h4 = h4.parentNode;
          }
        }
        d4 = d4.return;
      }
  Jb(function() {
    var d5 = f2, e4 = xb(c3), g3 = [];
    a: {
      var h5 = df.get(a4);
      if (void 0 !== h5) {
        var k4 = td, n2 = a4;
        switch (a4) {
          case "keypress":
            if (0 === od(c3))
              break a;
          case "keydown":
          case "keyup":
            k4 = Rd;
            break;
          case "focusin":
            n2 = "focus";
            k4 = Fd;
            break;
          case "focusout":
            n2 = "blur";
            k4 = Fd;
            break;
          case "beforeblur":
          case "afterblur":
            k4 = Fd;
            break;
          case "click":
            if (2 === c3.button)
              break a;
          case "auxclick":
          case "dblclick":
          case "mousedown":
          case "mousemove":
          case "mouseup":
          case "mouseout":
          case "mouseover":
          case "contextmenu":
            k4 = Bd;
            break;
          case "drag":
          case "dragend":
          case "dragenter":
          case "dragexit":
          case "dragleave":
          case "dragover":
          case "dragstart":
          case "drop":
            k4 = Dd;
            break;
          case "touchcancel":
          case "touchend":
          case "touchmove":
          case "touchstart":
            k4 = Vd;
            break;
          case $e:
          case af:
          case bf:
            k4 = Hd;
            break;
          case cf:
            k4 = Xd;
            break;
          case "scroll":
            k4 = vd;
            break;
          case "wheel":
            k4 = Zd;
            break;
          case "copy":
          case "cut":
          case "paste":
            k4 = Jd;
            break;
          case "gotpointercapture":
          case "lostpointercapture":
          case "pointercancel":
          case "pointerdown":
          case "pointermove":
          case "pointerout":
          case "pointerover":
          case "pointerup":
            k4 = Td;
        }
        var t3 = 0 !== (b3 & 4), J2 = !t3 && "scroll" === a4, x3 = t3 ? null !== h5 ? h5 + "Capture" : null : h5;
        t3 = [];
        for (var w3 = d5, u3; null !== w3; ) {
          u3 = w3;
          var F2 = u3.stateNode;
          5 === u3.tag && null !== F2 && (u3 = F2, null !== x3 && (F2 = Kb(w3, x3), null != F2 && t3.push(tf(w3, F2, u3))));
          if (J2)
            break;
          w3 = w3.return;
        }
        0 < t3.length && (h5 = new k4(h5, n2, null, c3, e4), g3.push({ event: h5, listeners: t3 }));
      }
    }
    if (0 === (b3 & 7)) {
      a: {
        h5 = "mouseover" === a4 || "pointerover" === a4;
        k4 = "mouseout" === a4 || "pointerout" === a4;
        if (h5 && c3 !== wb && (n2 = c3.relatedTarget || c3.fromElement) && (Wc(n2) || n2[uf]))
          break a;
        if (k4 || h5) {
          h5 = e4.window === e4 ? e4 : (h5 = e4.ownerDocument) ? h5.defaultView || h5.parentWindow : window;
          if (k4) {
            if (n2 = c3.relatedTarget || c3.toElement, k4 = d5, n2 = n2 ? Wc(n2) : null, null !== n2 && (J2 = Vb(n2), n2 !== J2 || 5 !== n2.tag && 6 !== n2.tag))
              n2 = null;
          } else
            k4 = null, n2 = d5;
          if (k4 !== n2) {
            t3 = Bd;
            F2 = "onMouseLeave";
            x3 = "onMouseEnter";
            w3 = "mouse";
            if ("pointerout" === a4 || "pointerover" === a4)
              t3 = Td, F2 = "onPointerLeave", x3 = "onPointerEnter", w3 = "pointer";
            J2 = null == k4 ? h5 : ue$1(k4);
            u3 = null == n2 ? h5 : ue$1(n2);
            h5 = new t3(F2, w3 + "leave", k4, c3, e4);
            h5.target = J2;
            h5.relatedTarget = u3;
            F2 = null;
            Wc(e4) === d5 && (t3 = new t3(x3, w3 + "enter", n2, c3, e4), t3.target = u3, t3.relatedTarget = J2, F2 = t3);
            J2 = F2;
            if (k4 && n2)
              b: {
                t3 = k4;
                x3 = n2;
                w3 = 0;
                for (u3 = t3; u3; u3 = vf(u3))
                  w3++;
                u3 = 0;
                for (F2 = x3; F2; F2 = vf(F2))
                  u3++;
                for (; 0 < w3 - u3; )
                  t3 = vf(t3), w3--;
                for (; 0 < u3 - w3; )
                  x3 = vf(x3), u3--;
                for (; w3--; ) {
                  if (t3 === x3 || null !== x3 && t3 === x3.alternate)
                    break b;
                  t3 = vf(t3);
                  x3 = vf(x3);
                }
                t3 = null;
              }
            else
              t3 = null;
            null !== k4 && wf(g3, h5, k4, t3, false);
            null !== n2 && null !== J2 && wf(g3, J2, n2, t3, true);
          }
        }
      }
      a: {
        h5 = d5 ? ue$1(d5) : window;
        k4 = h5.nodeName && h5.nodeName.toLowerCase();
        if ("select" === k4 || "input" === k4 && "file" === h5.type)
          var na = ve$1;
        else if (me$1(h5))
          if (we$1)
            na = Fe$1;
          else {
            na = De$1;
            var xa = Ce$1;
          }
        else
          (k4 = h5.nodeName) && "input" === k4.toLowerCase() && ("checkbox" === h5.type || "radio" === h5.type) && (na = Ee$1);
        if (na && (na = na(a4, d5))) {
          ne(g3, na, c3, e4);
          break a;
        }
        xa && xa(a4, h5, d5);
        "focusout" === a4 && (xa = h5._wrapperState) && xa.controlled && "number" === h5.type && cb(h5, "number", h5.value);
      }
      xa = d5 ? ue$1(d5) : window;
      switch (a4) {
        case "focusin":
          if (me$1(xa) || "true" === xa.contentEditable)
            Qe$1 = xa, Re$1 = d5, Se$1 = null;
          break;
        case "focusout":
          Se$1 = Re$1 = Qe$1 = null;
          break;
        case "mousedown":
          Te$1 = true;
          break;
        case "contextmenu":
        case "mouseup":
        case "dragend":
          Te$1 = false;
          Ue(g3, c3, e4);
          break;
        case "selectionchange":
          if (Pe$1)
            break;
        case "keydown":
        case "keyup":
          Ue(g3, c3, e4);
      }
      var $a;
      if (ae$1)
        b: {
          switch (a4) {
            case "compositionstart":
              var ba = "onCompositionStart";
              break b;
            case "compositionend":
              ba = "onCompositionEnd";
              break b;
            case "compositionupdate":
              ba = "onCompositionUpdate";
              break b;
          }
          ba = void 0;
        }
      else
        ie$2 ? ge$1(a4, c3) && (ba = "onCompositionEnd") : "keydown" === a4 && 229 === c3.keyCode && (ba = "onCompositionStart");
      ba && (de$1 && "ko" !== c3.locale && (ie$2 || "onCompositionStart" !== ba ? "onCompositionEnd" === ba && ie$2 && ($a = nd()) : (kd = e4, ld = "value" in kd ? kd.value : kd.textContent, ie$2 = true)), xa = oe(d5, ba), 0 < xa.length && (ba = new Ld(ba, a4, null, c3, e4), g3.push({ event: ba, listeners: xa }), $a ? ba.data = $a : ($a = he$1(c3), null !== $a && (ba.data = $a))));
      if ($a = ce ? je$1(a4, c3) : ke$1(a4, c3))
        d5 = oe(d5, "onBeforeInput"), 0 < d5.length && (e4 = new Ld("onBeforeInput", "beforeinput", null, c3, e4), g3.push({ event: e4, listeners: d5 }), e4.data = $a);
    }
    se(g3, b3);
  });
}
function tf(a4, b3, c3) {
  return { instance: a4, listener: b3, currentTarget: c3 };
}
function oe(a4, b3) {
  for (var c3 = b3 + "Capture", d4 = []; null !== a4; ) {
    var e3 = a4, f2 = e3.stateNode;
    5 === e3.tag && null !== f2 && (e3 = f2, f2 = Kb(a4, c3), null != f2 && d4.unshift(tf(a4, f2, e3)), f2 = Kb(a4, b3), null != f2 && d4.push(tf(a4, f2, e3)));
    a4 = a4.return;
  }
  return d4;
}
function vf(a4) {
  if (null === a4)
    return null;
  do
    a4 = a4.return;
  while (a4 && 5 !== a4.tag);
  return a4 ? a4 : null;
}
function wf(a4, b3, c3, d4, e3) {
  for (var f2 = b3._reactName, g2 = []; null !== c3 && c3 !== d4; ) {
    var h4 = c3, k3 = h4.alternate, l2 = h4.stateNode;
    if (null !== k3 && k3 === d4)
      break;
    5 === h4.tag && null !== l2 && (h4 = l2, e3 ? (k3 = Kb(c3, f2), null != k3 && g2.unshift(tf(c3, k3, h4))) : e3 || (k3 = Kb(c3, f2), null != k3 && g2.push(tf(c3, k3, h4))));
    c3 = c3.return;
  }
  0 !== g2.length && a4.push({ event: b3, listeners: g2 });
}
var xf = /\r\n?/g, yf = /\u0000|\uFFFD/g;
function zf(a4) {
  return ("string" === typeof a4 ? a4 : "" + a4).replace(xf, "\n").replace(yf, "");
}
function Af(a4, b3, c3) {
  b3 = zf(b3);
  if (zf(a4) !== b3 && c3)
    throw Error(p$7(425));
}
function Bf() {
}
var Cf = null, Df = null;
function Ef(a4, b3) {
  return "textarea" === a4 || "noscript" === a4 || "string" === typeof b3.children || "number" === typeof b3.children || "object" === typeof b3.dangerouslySetInnerHTML && null !== b3.dangerouslySetInnerHTML && null != b3.dangerouslySetInnerHTML.__html;
}
var Ff = "function" === typeof setTimeout ? setTimeout : void 0, Gf = "function" === typeof clearTimeout ? clearTimeout : void 0, Hf = "function" === typeof Promise ? Promise : void 0, Jf = "function" === typeof queueMicrotask ? queueMicrotask : "undefined" !== typeof Hf ? function(a4) {
  return Hf.resolve(null).then(a4).catch(If);
} : Ff;
function If(a4) {
  setTimeout(function() {
    throw a4;
  });
}
function Kf(a4, b3) {
  var c3 = b3, d4 = 0;
  do {
    var e3 = c3.nextSibling;
    a4.removeChild(c3);
    if (e3 && 8 === e3.nodeType)
      if (c3 = e3.data, "/$" === c3) {
        if (0 === d4) {
          a4.removeChild(e3);
          bd(b3);
          return;
        }
        d4--;
      } else
        "$" !== c3 && "$?" !== c3 && "$!" !== c3 || d4++;
    c3 = e3;
  } while (c3);
  bd(b3);
}
function Lf(a4) {
  for (; null != a4; a4 = a4.nextSibling) {
    var b3 = a4.nodeType;
    if (1 === b3 || 3 === b3)
      break;
    if (8 === b3) {
      b3 = a4.data;
      if ("$" === b3 || "$!" === b3 || "$?" === b3)
        break;
      if ("/$" === b3)
        return null;
    }
  }
  return a4;
}
function Mf(a4) {
  a4 = a4.previousSibling;
  for (var b3 = 0; a4; ) {
    if (8 === a4.nodeType) {
      var c3 = a4.data;
      if ("$" === c3 || "$!" === c3 || "$?" === c3) {
        if (0 === b3)
          return a4;
        b3--;
      } else
        "/$" === c3 && b3++;
    }
    a4 = a4.previousSibling;
  }
  return null;
}
var Nf = Math.random().toString(36).slice(2), Of = "__reactFiber$" + Nf, Pf = "__reactProps$" + Nf, uf = "__reactContainer$" + Nf, of = "__reactEvents$" + Nf, Qf = "__reactListeners$" + Nf, Rf = "__reactHandles$" + Nf;
function Wc(a4) {
  var b3 = a4[Of];
  if (b3)
    return b3;
  for (var c3 = a4.parentNode; c3; ) {
    if (b3 = c3[uf] || c3[Of]) {
      c3 = b3.alternate;
      if (null !== b3.child || null !== c3 && null !== c3.child)
        for (a4 = Mf(a4); null !== a4; ) {
          if (c3 = a4[Of])
            return c3;
          a4 = Mf(a4);
        }
      return b3;
    }
    a4 = c3;
    c3 = a4.parentNode;
  }
  return null;
}
function Cb(a4) {
  a4 = a4[Of] || a4[uf];
  return !a4 || 5 !== a4.tag && 6 !== a4.tag && 13 !== a4.tag && 3 !== a4.tag ? null : a4;
}
function ue$1(a4) {
  if (5 === a4.tag || 6 === a4.tag)
    return a4.stateNode;
  throw Error(p$7(33));
}
function Db(a4) {
  return a4[Pf] || null;
}
var Sf = [], Tf = -1;
function Uf(a4) {
  return { current: a4 };
}
function E$4(a4) {
  0 > Tf || (a4.current = Sf[Tf], Sf[Tf] = null, Tf--);
}
function G(a4, b3) {
  Tf++;
  Sf[Tf] = a4.current;
  a4.current = b3;
}
var Vf = {}, H = Uf(Vf), Wf = Uf(false), Xf = Vf;
function Yf(a4, b3) {
  var c3 = a4.type.contextTypes;
  if (!c3)
    return Vf;
  var d4 = a4.stateNode;
  if (d4 && d4.__reactInternalMemoizedUnmaskedChildContext === b3)
    return d4.__reactInternalMemoizedMaskedChildContext;
  var e3 = {}, f2;
  for (f2 in c3)
    e3[f2] = b3[f2];
  d4 && (a4 = a4.stateNode, a4.__reactInternalMemoizedUnmaskedChildContext = b3, a4.__reactInternalMemoizedMaskedChildContext = e3);
  return e3;
}
function Zf(a4) {
  a4 = a4.childContextTypes;
  return null !== a4 && void 0 !== a4;
}
function $f() {
  E$4(Wf);
  E$4(H);
}
function ag(a4, b3, c3) {
  if (H.current !== Vf)
    throw Error(p$7(168));
  G(H, b3);
  G(Wf, c3);
}
function bg(a4, b3, c3) {
  var d4 = a4.stateNode;
  b3 = b3.childContextTypes;
  if ("function" !== typeof d4.getChildContext)
    return c3;
  d4 = d4.getChildContext();
  for (var e3 in d4)
    if (!(e3 in b3))
      throw Error(p$7(108, Ra(a4) || "Unknown", e3));
  return A$3({}, c3, d4);
}
function cg(a4) {
  a4 = (a4 = a4.stateNode) && a4.__reactInternalMemoizedMergedChildContext || Vf;
  Xf = H.current;
  G(H, a4);
  G(Wf, Wf.current);
  return true;
}
function dg(a4, b3, c3) {
  var d4 = a4.stateNode;
  if (!d4)
    throw Error(p$7(169));
  c3 ? (a4 = bg(a4, b3, Xf), d4.__reactInternalMemoizedMergedChildContext = a4, E$4(Wf), E$4(H), G(H, a4)) : E$4(Wf);
  G(Wf, c3);
}
var eg = null, fg = false, gg = false;
function hg(a4) {
  null === eg ? eg = [a4] : eg.push(a4);
}
function ig(a4) {
  fg = true;
  hg(a4);
}
function jg() {
  if (!gg && null !== eg) {
    gg = true;
    var a4 = 0, b3 = C$3;
    try {
      var c3 = eg;
      for (C$3 = 1; a4 < c3.length; a4++) {
        var d4 = c3[a4];
        do
          d4 = d4(true);
        while (null !== d4);
      }
      eg = null;
      fg = false;
    } catch (e3) {
      throw null !== eg && (eg = eg.slice(a4 + 1)), ac(fc, jg), e3;
    } finally {
      C$3 = b3, gg = false;
    }
  }
  return null;
}
var kg = [], lg = 0, mg = null, ng = 0, og = [], pg = 0, qg = null, rg = 1, sg = "";
function tg(a4, b3) {
  kg[lg++] = ng;
  kg[lg++] = mg;
  mg = a4;
  ng = b3;
}
function ug(a4, b3, c3) {
  og[pg++] = rg;
  og[pg++] = sg;
  og[pg++] = qg;
  qg = a4;
  var d4 = rg;
  a4 = sg;
  var e3 = 32 - oc(d4) - 1;
  d4 &= ~(1 << e3);
  c3 += 1;
  var f2 = 32 - oc(b3) + e3;
  if (30 < f2) {
    var g2 = e3 - e3 % 5;
    f2 = (d4 & (1 << g2) - 1).toString(32);
    d4 >>= g2;
    e3 -= g2;
    rg = 1 << 32 - oc(b3) + e3 | c3 << e3 | d4;
    sg = f2 + a4;
  } else
    rg = 1 << f2 | c3 << e3 | d4, sg = a4;
}
function vg(a4) {
  null !== a4.return && (tg(a4, 1), ug(a4, 1, 0));
}
function wg(a4) {
  for (; a4 === mg; )
    mg = kg[--lg], kg[lg] = null, ng = kg[--lg], kg[lg] = null;
  for (; a4 === qg; )
    qg = og[--pg], og[pg] = null, sg = og[--pg], og[pg] = null, rg = og[--pg], og[pg] = null;
}
var xg = null, yg = null, I$1 = false, zg = null;
function Ag(a4, b3) {
  var c3 = Bg(5, null, null, 0);
  c3.elementType = "DELETED";
  c3.stateNode = b3;
  c3.return = a4;
  b3 = a4.deletions;
  null === b3 ? (a4.deletions = [c3], a4.flags |= 16) : b3.push(c3);
}
function Cg(a4, b3) {
  switch (a4.tag) {
    case 5:
      var c3 = a4.type;
      b3 = 1 !== b3.nodeType || c3.toLowerCase() !== b3.nodeName.toLowerCase() ? null : b3;
      return null !== b3 ? (a4.stateNode = b3, xg = a4, yg = Lf(b3.firstChild), true) : false;
    case 6:
      return b3 = "" === a4.pendingProps || 3 !== b3.nodeType ? null : b3, null !== b3 ? (a4.stateNode = b3, xg = a4, yg = null, true) : false;
    case 13:
      return b3 = 8 !== b3.nodeType ? null : b3, null !== b3 ? (c3 = null !== qg ? { id: rg, overflow: sg } : null, a4.memoizedState = { dehydrated: b3, treeContext: c3, retryLane: 1073741824 }, c3 = Bg(18, null, null, 0), c3.stateNode = b3, c3.return = a4, a4.child = c3, xg = a4, yg = null, true) : false;
    default:
      return false;
  }
}
function Dg(a4) {
  return 0 !== (a4.mode & 1) && 0 === (a4.flags & 128);
}
function Eg(a4) {
  if (I$1) {
    var b3 = yg;
    if (b3) {
      var c3 = b3;
      if (!Cg(a4, b3)) {
        if (Dg(a4))
          throw Error(p$7(418));
        b3 = Lf(c3.nextSibling);
        var d4 = xg;
        b3 && Cg(a4, b3) ? Ag(d4, c3) : (a4.flags = a4.flags & -4097 | 2, I$1 = false, xg = a4);
      }
    } else {
      if (Dg(a4))
        throw Error(p$7(418));
      a4.flags = a4.flags & -4097 | 2;
      I$1 = false;
      xg = a4;
    }
  }
}
function Fg(a4) {
  for (a4 = a4.return; null !== a4 && 5 !== a4.tag && 3 !== a4.tag && 13 !== a4.tag; )
    a4 = a4.return;
  xg = a4;
}
function Gg(a4) {
  if (a4 !== xg)
    return false;
  if (!I$1)
    return Fg(a4), I$1 = true, false;
  var b3;
  (b3 = 3 !== a4.tag) && !(b3 = 5 !== a4.tag) && (b3 = a4.type, b3 = "head" !== b3 && "body" !== b3 && !Ef(a4.type, a4.memoizedProps));
  if (b3 && (b3 = yg)) {
    if (Dg(a4))
      throw Hg(), Error(p$7(418));
    for (; b3; )
      Ag(a4, b3), b3 = Lf(b3.nextSibling);
  }
  Fg(a4);
  if (13 === a4.tag) {
    a4 = a4.memoizedState;
    a4 = null !== a4 ? a4.dehydrated : null;
    if (!a4)
      throw Error(p$7(317));
    a: {
      a4 = a4.nextSibling;
      for (b3 = 0; a4; ) {
        if (8 === a4.nodeType) {
          var c3 = a4.data;
          if ("/$" === c3) {
            if (0 === b3) {
              yg = Lf(a4.nextSibling);
              break a;
            }
            b3--;
          } else
            "$" !== c3 && "$!" !== c3 && "$?" !== c3 || b3++;
        }
        a4 = a4.nextSibling;
      }
      yg = null;
    }
  } else
    yg = xg ? Lf(a4.stateNode.nextSibling) : null;
  return true;
}
function Hg() {
  for (var a4 = yg; a4; )
    a4 = Lf(a4.nextSibling);
}
function Ig() {
  yg = xg = null;
  I$1 = false;
}
function Jg(a4) {
  null === zg ? zg = [a4] : zg.push(a4);
}
var Kg = ua.ReactCurrentBatchConfig;
function Lg(a4, b3) {
  if (a4 && a4.defaultProps) {
    b3 = A$3({}, b3);
    a4 = a4.defaultProps;
    for (var c3 in a4)
      void 0 === b3[c3] && (b3[c3] = a4[c3]);
    return b3;
  }
  return b3;
}
var Mg = Uf(null), Ng = null, Og = null, Pg = null;
function Qg() {
  Pg = Og = Ng = null;
}
function Rg(a4) {
  var b3 = Mg.current;
  E$4(Mg);
  a4._currentValue = b3;
}
function Sg(a4, b3, c3) {
  for (; null !== a4; ) {
    var d4 = a4.alternate;
    (a4.childLanes & b3) !== b3 ? (a4.childLanes |= b3, null !== d4 && (d4.childLanes |= b3)) : null !== d4 && (d4.childLanes & b3) !== b3 && (d4.childLanes |= b3);
    if (a4 === c3)
      break;
    a4 = a4.return;
  }
}
function Tg(a4, b3) {
  Ng = a4;
  Pg = Og = null;
  a4 = a4.dependencies;
  null !== a4 && null !== a4.firstContext && (0 !== (a4.lanes & b3) && (Ug = true), a4.firstContext = null);
}
function Vg(a4) {
  var b3 = a4._currentValue;
  if (Pg !== a4)
    if (a4 = { context: a4, memoizedValue: b3, next: null }, null === Og) {
      if (null === Ng)
        throw Error(p$7(308));
      Og = a4;
      Ng.dependencies = { lanes: 0, firstContext: a4 };
    } else
      Og = Og.next = a4;
  return b3;
}
var Wg = null;
function Xg(a4) {
  null === Wg ? Wg = [a4] : Wg.push(a4);
}
function Yg(a4, b3, c3, d4) {
  var e3 = b3.interleaved;
  null === e3 ? (c3.next = c3, Xg(b3)) : (c3.next = e3.next, e3.next = c3);
  b3.interleaved = c3;
  return Zg(a4, d4);
}
function Zg(a4, b3) {
  a4.lanes |= b3;
  var c3 = a4.alternate;
  null !== c3 && (c3.lanes |= b3);
  c3 = a4;
  for (a4 = a4.return; null !== a4; )
    a4.childLanes |= b3, c3 = a4.alternate, null !== c3 && (c3.childLanes |= b3), c3 = a4, a4 = a4.return;
  return 3 === c3.tag ? c3.stateNode : null;
}
var $g = false;
function ah(a4) {
  a4.updateQueue = { baseState: a4.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null };
}
function bh(a4, b3) {
  a4 = a4.updateQueue;
  b3.updateQueue === a4 && (b3.updateQueue = { baseState: a4.baseState, firstBaseUpdate: a4.firstBaseUpdate, lastBaseUpdate: a4.lastBaseUpdate, shared: a4.shared, effects: a4.effects });
}
function ch(a4, b3) {
  return { eventTime: a4, lane: b3, tag: 0, payload: null, callback: null, next: null };
}
function dh(a4, b3, c3) {
  var d4 = a4.updateQueue;
  if (null === d4)
    return null;
  d4 = d4.shared;
  if (0 !== (K$1 & 2)) {
    var e3 = d4.pending;
    null === e3 ? b3.next = b3 : (b3.next = e3.next, e3.next = b3);
    d4.pending = b3;
    return Zg(a4, c3);
  }
  e3 = d4.interleaved;
  null === e3 ? (b3.next = b3, Xg(d4)) : (b3.next = e3.next, e3.next = b3);
  d4.interleaved = b3;
  return Zg(a4, c3);
}
function eh(a4, b3, c3) {
  b3 = b3.updateQueue;
  if (null !== b3 && (b3 = b3.shared, 0 !== (c3 & 4194240))) {
    var d4 = b3.lanes;
    d4 &= a4.pendingLanes;
    c3 |= d4;
    b3.lanes = c3;
    Cc(a4, c3);
  }
}
function fh(a4, b3) {
  var c3 = a4.updateQueue, d4 = a4.alternate;
  if (null !== d4 && (d4 = d4.updateQueue, c3 === d4)) {
    var e3 = null, f2 = null;
    c3 = c3.firstBaseUpdate;
    if (null !== c3) {
      do {
        var g2 = { eventTime: c3.eventTime, lane: c3.lane, tag: c3.tag, payload: c3.payload, callback: c3.callback, next: null };
        null === f2 ? e3 = f2 = g2 : f2 = f2.next = g2;
        c3 = c3.next;
      } while (null !== c3);
      null === f2 ? e3 = f2 = b3 : f2 = f2.next = b3;
    } else
      e3 = f2 = b3;
    c3 = { baseState: d4.baseState, firstBaseUpdate: e3, lastBaseUpdate: f2, shared: d4.shared, effects: d4.effects };
    a4.updateQueue = c3;
    return;
  }
  a4 = c3.lastBaseUpdate;
  null === a4 ? c3.firstBaseUpdate = b3 : a4.next = b3;
  c3.lastBaseUpdate = b3;
}
function gh(a4, b3, c3, d4) {
  var e3 = a4.updateQueue;
  $g = false;
  var f2 = e3.firstBaseUpdate, g2 = e3.lastBaseUpdate, h4 = e3.shared.pending;
  if (null !== h4) {
    e3.shared.pending = null;
    var k3 = h4, l2 = k3.next;
    k3.next = null;
    null === g2 ? f2 = l2 : g2.next = l2;
    g2 = k3;
    var m4 = a4.alternate;
    null !== m4 && (m4 = m4.updateQueue, h4 = m4.lastBaseUpdate, h4 !== g2 && (null === h4 ? m4.firstBaseUpdate = l2 : h4.next = l2, m4.lastBaseUpdate = k3));
  }
  if (null !== f2) {
    var q3 = e3.baseState;
    g2 = 0;
    m4 = l2 = k3 = null;
    h4 = f2;
    do {
      var r2 = h4.lane, y4 = h4.eventTime;
      if ((d4 & r2) === r2) {
        null !== m4 && (m4 = m4.next = {
          eventTime: y4,
          lane: 0,
          tag: h4.tag,
          payload: h4.payload,
          callback: h4.callback,
          next: null
        });
        a: {
          var n2 = a4, t3 = h4;
          r2 = b3;
          y4 = c3;
          switch (t3.tag) {
            case 1:
              n2 = t3.payload;
              if ("function" === typeof n2) {
                q3 = n2.call(y4, q3, r2);
                break a;
              }
              q3 = n2;
              break a;
            case 3:
              n2.flags = n2.flags & -65537 | 128;
            case 0:
              n2 = t3.payload;
              r2 = "function" === typeof n2 ? n2.call(y4, q3, r2) : n2;
              if (null === r2 || void 0 === r2)
                break a;
              q3 = A$3({}, q3, r2);
              break a;
            case 2:
              $g = true;
          }
        }
        null !== h4.callback && 0 !== h4.lane && (a4.flags |= 64, r2 = e3.effects, null === r2 ? e3.effects = [h4] : r2.push(h4));
      } else
        y4 = { eventTime: y4, lane: r2, tag: h4.tag, payload: h4.payload, callback: h4.callback, next: null }, null === m4 ? (l2 = m4 = y4, k3 = q3) : m4 = m4.next = y4, g2 |= r2;
      h4 = h4.next;
      if (null === h4)
        if (h4 = e3.shared.pending, null === h4)
          break;
        else
          r2 = h4, h4 = r2.next, r2.next = null, e3.lastBaseUpdate = r2, e3.shared.pending = null;
    } while (1);
    null === m4 && (k3 = q3);
    e3.baseState = k3;
    e3.firstBaseUpdate = l2;
    e3.lastBaseUpdate = m4;
    b3 = e3.shared.interleaved;
    if (null !== b3) {
      e3 = b3;
      do
        g2 |= e3.lane, e3 = e3.next;
      while (e3 !== b3);
    } else
      null === f2 && (e3.shared.lanes = 0);
    hh |= g2;
    a4.lanes = g2;
    a4.memoizedState = q3;
  }
}
function ih(a4, b3, c3) {
  a4 = b3.effects;
  b3.effects = null;
  if (null !== a4)
    for (b3 = 0; b3 < a4.length; b3++) {
      var d4 = a4[b3], e3 = d4.callback;
      if (null !== e3) {
        d4.callback = null;
        d4 = c3;
        if ("function" !== typeof e3)
          throw Error(p$7(191, e3));
        e3.call(d4);
      }
    }
}
var jh = new aa.Component().refs;
function kh(a4, b3, c3, d4) {
  b3 = a4.memoizedState;
  c3 = c3(d4, b3);
  c3 = null === c3 || void 0 === c3 ? b3 : A$3({}, b3, c3);
  a4.memoizedState = c3;
  0 === a4.lanes && (a4.updateQueue.baseState = c3);
}
var nh = { isMounted: function(a4) {
  return (a4 = a4._reactInternals) ? Vb(a4) === a4 : false;
}, enqueueSetState: function(a4, b3, c3) {
  a4 = a4._reactInternals;
  var d4 = L(), e3 = lh(a4), f2 = ch(d4, e3);
  f2.payload = b3;
  void 0 !== c3 && null !== c3 && (f2.callback = c3);
  b3 = dh(a4, f2, e3);
  null !== b3 && (mh(b3, a4, e3, d4), eh(b3, a4, e3));
}, enqueueReplaceState: function(a4, b3, c3) {
  a4 = a4._reactInternals;
  var d4 = L(), e3 = lh(a4), f2 = ch(d4, e3);
  f2.tag = 1;
  f2.payload = b3;
  void 0 !== c3 && null !== c3 && (f2.callback = c3);
  b3 = dh(a4, f2, e3);
  null !== b3 && (mh(b3, a4, e3, d4), eh(b3, a4, e3));
}, enqueueForceUpdate: function(a4, b3) {
  a4 = a4._reactInternals;
  var c3 = L(), d4 = lh(a4), e3 = ch(c3, d4);
  e3.tag = 2;
  void 0 !== b3 && null !== b3 && (e3.callback = b3);
  b3 = dh(a4, e3, d4);
  null !== b3 && (mh(b3, a4, d4, c3), eh(b3, a4, d4));
} };
function oh(a4, b3, c3, d4, e3, f2, g2) {
  a4 = a4.stateNode;
  return "function" === typeof a4.shouldComponentUpdate ? a4.shouldComponentUpdate(d4, f2, g2) : b3.prototype && b3.prototype.isPureReactComponent ? !Ie$1(c3, d4) || !Ie$1(e3, f2) : true;
}
function ph(a4, b3, c3) {
  var d4 = false, e3 = Vf;
  var f2 = b3.contextType;
  "object" === typeof f2 && null !== f2 ? f2 = Vg(f2) : (e3 = Zf(b3) ? Xf : H.current, d4 = b3.contextTypes, f2 = (d4 = null !== d4 && void 0 !== d4) ? Yf(a4, e3) : Vf);
  b3 = new b3(c3, f2);
  a4.memoizedState = null !== b3.state && void 0 !== b3.state ? b3.state : null;
  b3.updater = nh;
  a4.stateNode = b3;
  b3._reactInternals = a4;
  d4 && (a4 = a4.stateNode, a4.__reactInternalMemoizedUnmaskedChildContext = e3, a4.__reactInternalMemoizedMaskedChildContext = f2);
  return b3;
}
function qh(a4, b3, c3, d4) {
  a4 = b3.state;
  "function" === typeof b3.componentWillReceiveProps && b3.componentWillReceiveProps(c3, d4);
  "function" === typeof b3.UNSAFE_componentWillReceiveProps && b3.UNSAFE_componentWillReceiveProps(c3, d4);
  b3.state !== a4 && nh.enqueueReplaceState(b3, b3.state, null);
}
function rh(a4, b3, c3, d4) {
  var e3 = a4.stateNode;
  e3.props = c3;
  e3.state = a4.memoizedState;
  e3.refs = jh;
  ah(a4);
  var f2 = b3.contextType;
  "object" === typeof f2 && null !== f2 ? e3.context = Vg(f2) : (f2 = Zf(b3) ? Xf : H.current, e3.context = Yf(a4, f2));
  e3.state = a4.memoizedState;
  f2 = b3.getDerivedStateFromProps;
  "function" === typeof f2 && (kh(a4, b3, f2, c3), e3.state = a4.memoizedState);
  "function" === typeof b3.getDerivedStateFromProps || "function" === typeof e3.getSnapshotBeforeUpdate || "function" !== typeof e3.UNSAFE_componentWillMount && "function" !== typeof e3.componentWillMount || (b3 = e3.state, "function" === typeof e3.componentWillMount && e3.componentWillMount(), "function" === typeof e3.UNSAFE_componentWillMount && e3.UNSAFE_componentWillMount(), b3 !== e3.state && nh.enqueueReplaceState(e3, e3.state, null), gh(a4, c3, e3, d4), e3.state = a4.memoizedState);
  "function" === typeof e3.componentDidMount && (a4.flags |= 4194308);
}
function sh(a4, b3, c3) {
  a4 = c3.ref;
  if (null !== a4 && "function" !== typeof a4 && "object" !== typeof a4) {
    if (c3._owner) {
      c3 = c3._owner;
      if (c3) {
        if (1 !== c3.tag)
          throw Error(p$7(309));
        var d4 = c3.stateNode;
      }
      if (!d4)
        throw Error(p$7(147, a4));
      var e3 = d4, f2 = "" + a4;
      if (null !== b3 && null !== b3.ref && "function" === typeof b3.ref && b3.ref._stringRef === f2)
        return b3.ref;
      b3 = function(a5) {
        var b4 = e3.refs;
        b4 === jh && (b4 = e3.refs = {});
        null === a5 ? delete b4[f2] : b4[f2] = a5;
      };
      b3._stringRef = f2;
      return b3;
    }
    if ("string" !== typeof a4)
      throw Error(p$7(284));
    if (!c3._owner)
      throw Error(p$7(290, a4));
  }
  return a4;
}
function th(a4, b3) {
  a4 = Object.prototype.toString.call(b3);
  throw Error(p$7(31, "[object Object]" === a4 ? "object with keys {" + Object.keys(b3).join(", ") + "}" : a4));
}
function uh(a4) {
  var b3 = a4._init;
  return b3(a4._payload);
}
function vh(a4) {
  function b3(b4, c4) {
    if (a4) {
      var d5 = b4.deletions;
      null === d5 ? (b4.deletions = [c4], b4.flags |= 16) : d5.push(c4);
    }
  }
  function c3(c4, d5) {
    if (!a4)
      return null;
    for (; null !== d5; )
      b3(c4, d5), d5 = d5.sibling;
    return null;
  }
  function d4(a5, b4) {
    for (a5 = /* @__PURE__ */ new Map(); null !== b4; )
      null !== b4.key ? a5.set(b4.key, b4) : a5.set(b4.index, b4), b4 = b4.sibling;
    return a5;
  }
  function e3(a5, b4) {
    a5 = wh(a5, b4);
    a5.index = 0;
    a5.sibling = null;
    return a5;
  }
  function f2(b4, c4, d5) {
    b4.index = d5;
    if (!a4)
      return b4.flags |= 1048576, c4;
    d5 = b4.alternate;
    if (null !== d5)
      return d5 = d5.index, d5 < c4 ? (b4.flags |= 2, c4) : d5;
    b4.flags |= 2;
    return c4;
  }
  function g2(b4) {
    a4 && null === b4.alternate && (b4.flags |= 2);
    return b4;
  }
  function h4(a5, b4, c4, d5) {
    if (null === b4 || 6 !== b4.tag)
      return b4 = xh(c4, a5.mode, d5), b4.return = a5, b4;
    b4 = e3(b4, c4);
    b4.return = a5;
    return b4;
  }
  function k3(a5, b4, c4, d5) {
    var f3 = c4.type;
    if (f3 === ya)
      return m4(a5, b4, c4.props.children, d5, c4.key);
    if (null !== b4 && (b4.elementType === f3 || "object" === typeof f3 && null !== f3 && f3.$$typeof === Ha && uh(f3) === b4.type))
      return d5 = e3(b4, c4.props), d5.ref = sh(a5, b4, c4), d5.return = a5, d5;
    d5 = yh(c4.type, c4.key, c4.props, null, a5.mode, d5);
    d5.ref = sh(a5, b4, c4);
    d5.return = a5;
    return d5;
  }
  function l2(a5, b4, c4, d5) {
    if (null === b4 || 4 !== b4.tag || b4.stateNode.containerInfo !== c4.containerInfo || b4.stateNode.implementation !== c4.implementation)
      return b4 = zh(c4, a5.mode, d5), b4.return = a5, b4;
    b4 = e3(b4, c4.children || []);
    b4.return = a5;
    return b4;
  }
  function m4(a5, b4, c4, d5, f3) {
    if (null === b4 || 7 !== b4.tag)
      return b4 = Ah(c4, a5.mode, d5, f3), b4.return = a5, b4;
    b4 = e3(b4, c4);
    b4.return = a5;
    return b4;
  }
  function q3(a5, b4, c4) {
    if ("string" === typeof b4 && "" !== b4 || "number" === typeof b4)
      return b4 = xh("" + b4, a5.mode, c4), b4.return = a5, b4;
    if ("object" === typeof b4 && null !== b4) {
      switch (b4.$$typeof) {
        case va:
          return c4 = yh(b4.type, b4.key, b4.props, null, a5.mode, c4), c4.ref = sh(a5, null, b4), c4.return = a5, c4;
        case wa:
          return b4 = zh(b4, a5.mode, c4), b4.return = a5, b4;
        case Ha:
          var d5 = b4._init;
          return q3(a5, d5(b4._payload), c4);
      }
      if (eb(b4) || Ka(b4))
        return b4 = Ah(b4, a5.mode, c4, null), b4.return = a5, b4;
      th(a5, b4);
    }
    return null;
  }
  function r2(a5, b4, c4, d5) {
    var e4 = null !== b4 ? b4.key : null;
    if ("string" === typeof c4 && "" !== c4 || "number" === typeof c4)
      return null !== e4 ? null : h4(a5, b4, "" + c4, d5);
    if ("object" === typeof c4 && null !== c4) {
      switch (c4.$$typeof) {
        case va:
          return c4.key === e4 ? k3(a5, b4, c4, d5) : null;
        case wa:
          return c4.key === e4 ? l2(a5, b4, c4, d5) : null;
        case Ha:
          return e4 = c4._init, r2(
            a5,
            b4,
            e4(c4._payload),
            d5
          );
      }
      if (eb(c4) || Ka(c4))
        return null !== e4 ? null : m4(a5, b4, c4, d5, null);
      th(a5, c4);
    }
    return null;
  }
  function y4(a5, b4, c4, d5, e4) {
    if ("string" === typeof d5 && "" !== d5 || "number" === typeof d5)
      return a5 = a5.get(c4) || null, h4(b4, a5, "" + d5, e4);
    if ("object" === typeof d5 && null !== d5) {
      switch (d5.$$typeof) {
        case va:
          return a5 = a5.get(null === d5.key ? c4 : d5.key) || null, k3(b4, a5, d5, e4);
        case wa:
          return a5 = a5.get(null === d5.key ? c4 : d5.key) || null, l2(b4, a5, d5, e4);
        case Ha:
          var f3 = d5._init;
          return y4(a5, b4, c4, f3(d5._payload), e4);
      }
      if (eb(d5) || Ka(d5))
        return a5 = a5.get(c4) || null, m4(b4, a5, d5, e4, null);
      th(b4, d5);
    }
    return null;
  }
  function n2(e4, g3, h5, k4) {
    for (var l3 = null, m5 = null, u3 = g3, w3 = g3 = 0, x3 = null; null !== u3 && w3 < h5.length; w3++) {
      u3.index > w3 ? (x3 = u3, u3 = null) : x3 = u3.sibling;
      var n3 = r2(e4, u3, h5[w3], k4);
      if (null === n3) {
        null === u3 && (u3 = x3);
        break;
      }
      a4 && u3 && null === n3.alternate && b3(e4, u3);
      g3 = f2(n3, g3, w3);
      null === m5 ? l3 = n3 : m5.sibling = n3;
      m5 = n3;
      u3 = x3;
    }
    if (w3 === h5.length)
      return c3(e4, u3), I$1 && tg(e4, w3), l3;
    if (null === u3) {
      for (; w3 < h5.length; w3++)
        u3 = q3(e4, h5[w3], k4), null !== u3 && (g3 = f2(u3, g3, w3), null === m5 ? l3 = u3 : m5.sibling = u3, m5 = u3);
      I$1 && tg(e4, w3);
      return l3;
    }
    for (u3 = d4(e4, u3); w3 < h5.length; w3++)
      x3 = y4(u3, e4, w3, h5[w3], k4), null !== x3 && (a4 && null !== x3.alternate && u3.delete(null === x3.key ? w3 : x3.key), g3 = f2(x3, g3, w3), null === m5 ? l3 = x3 : m5.sibling = x3, m5 = x3);
    a4 && u3.forEach(function(a5) {
      return b3(e4, a5);
    });
    I$1 && tg(e4, w3);
    return l3;
  }
  function t3(e4, g3, h5, k4) {
    var l3 = Ka(h5);
    if ("function" !== typeof l3)
      throw Error(p$7(150));
    h5 = l3.call(h5);
    if (null == h5)
      throw Error(p$7(151));
    for (var u3 = l3 = null, m5 = g3, w3 = g3 = 0, x3 = null, n3 = h5.next(); null !== m5 && !n3.done; w3++, n3 = h5.next()) {
      m5.index > w3 ? (x3 = m5, m5 = null) : x3 = m5.sibling;
      var t4 = r2(e4, m5, n3.value, k4);
      if (null === t4) {
        null === m5 && (m5 = x3);
        break;
      }
      a4 && m5 && null === t4.alternate && b3(e4, m5);
      g3 = f2(t4, g3, w3);
      null === u3 ? l3 = t4 : u3.sibling = t4;
      u3 = t4;
      m5 = x3;
    }
    if (n3.done)
      return c3(
        e4,
        m5
      ), I$1 && tg(e4, w3), l3;
    if (null === m5) {
      for (; !n3.done; w3++, n3 = h5.next())
        n3 = q3(e4, n3.value, k4), null !== n3 && (g3 = f2(n3, g3, w3), null === u3 ? l3 = n3 : u3.sibling = n3, u3 = n3);
      I$1 && tg(e4, w3);
      return l3;
    }
    for (m5 = d4(e4, m5); !n3.done; w3++, n3 = h5.next())
      n3 = y4(m5, e4, w3, n3.value, k4), null !== n3 && (a4 && null !== n3.alternate && m5.delete(null === n3.key ? w3 : n3.key), g3 = f2(n3, g3, w3), null === u3 ? l3 = n3 : u3.sibling = n3, u3 = n3);
    a4 && m5.forEach(function(a5) {
      return b3(e4, a5);
    });
    I$1 && tg(e4, w3);
    return l3;
  }
  function J2(a5, d5, f3, h5) {
    "object" === typeof f3 && null !== f3 && f3.type === ya && null === f3.key && (f3 = f3.props.children);
    if ("object" === typeof f3 && null !== f3) {
      switch (f3.$$typeof) {
        case va:
          a: {
            for (var k4 = f3.key, l3 = d5; null !== l3; ) {
              if (l3.key === k4) {
                k4 = f3.type;
                if (k4 === ya) {
                  if (7 === l3.tag) {
                    c3(a5, l3.sibling);
                    d5 = e3(l3, f3.props.children);
                    d5.return = a5;
                    a5 = d5;
                    break a;
                  }
                } else if (l3.elementType === k4 || "object" === typeof k4 && null !== k4 && k4.$$typeof === Ha && uh(k4) === l3.type) {
                  c3(a5, l3.sibling);
                  d5 = e3(l3, f3.props);
                  d5.ref = sh(a5, l3, f3);
                  d5.return = a5;
                  a5 = d5;
                  break a;
                }
                c3(a5, l3);
                break;
              } else
                b3(a5, l3);
              l3 = l3.sibling;
            }
            f3.type === ya ? (d5 = Ah(f3.props.children, a5.mode, h5, f3.key), d5.return = a5, a5 = d5) : (h5 = yh(f3.type, f3.key, f3.props, null, a5.mode, h5), h5.ref = sh(a5, d5, f3), h5.return = a5, a5 = h5);
          }
          return g2(a5);
        case wa:
          a: {
            for (l3 = f3.key; null !== d5; ) {
              if (d5.key === l3)
                if (4 === d5.tag && d5.stateNode.containerInfo === f3.containerInfo && d5.stateNode.implementation === f3.implementation) {
                  c3(a5, d5.sibling);
                  d5 = e3(d5, f3.children || []);
                  d5.return = a5;
                  a5 = d5;
                  break a;
                } else {
                  c3(a5, d5);
                  break;
                }
              else
                b3(a5, d5);
              d5 = d5.sibling;
            }
            d5 = zh(f3, a5.mode, h5);
            d5.return = a5;
            a5 = d5;
          }
          return g2(a5);
        case Ha:
          return l3 = f3._init, J2(a5, d5, l3(f3._payload), h5);
      }
      if (eb(f3))
        return n2(a5, d5, f3, h5);
      if (Ka(f3))
        return t3(a5, d5, f3, h5);
      th(a5, f3);
    }
    return "string" === typeof f3 && "" !== f3 || "number" === typeof f3 ? (f3 = "" + f3, null !== d5 && 6 === d5.tag ? (c3(a5, d5.sibling), d5 = e3(d5, f3), d5.return = a5, a5 = d5) : (c3(a5, d5), d5 = xh(f3, a5.mode, h5), d5.return = a5, a5 = d5), g2(a5)) : c3(a5, d5);
  }
  return J2;
}
var Bh = vh(true), Ch = vh(false), Dh = {}, Eh = Uf(Dh), Fh = Uf(Dh), Gh = Uf(Dh);
function Hh(a4) {
  if (a4 === Dh)
    throw Error(p$7(174));
  return a4;
}
function Ih(a4, b3) {
  G(Gh, b3);
  G(Fh, a4);
  G(Eh, Dh);
  a4 = b3.nodeType;
  switch (a4) {
    case 9:
    case 11:
      b3 = (b3 = b3.documentElement) ? b3.namespaceURI : lb(null, "");
      break;
    default:
      a4 = 8 === a4 ? b3.parentNode : b3, b3 = a4.namespaceURI || null, a4 = a4.tagName, b3 = lb(b3, a4);
  }
  E$4(Eh);
  G(Eh, b3);
}
function Jh() {
  E$4(Eh);
  E$4(Fh);
  E$4(Gh);
}
function Kh(a4) {
  Hh(Gh.current);
  var b3 = Hh(Eh.current);
  var c3 = lb(b3, a4.type);
  b3 !== c3 && (G(Fh, a4), G(Eh, c3));
}
function Lh(a4) {
  Fh.current === a4 && (E$4(Eh), E$4(Fh));
}
var M$2 = Uf(0);
function Mh(a4) {
  for (var b3 = a4; null !== b3; ) {
    if (13 === b3.tag) {
      var c3 = b3.memoizedState;
      if (null !== c3 && (c3 = c3.dehydrated, null === c3 || "$?" === c3.data || "$!" === c3.data))
        return b3;
    } else if (19 === b3.tag && void 0 !== b3.memoizedProps.revealOrder) {
      if (0 !== (b3.flags & 128))
        return b3;
    } else if (null !== b3.child) {
      b3.child.return = b3;
      b3 = b3.child;
      continue;
    }
    if (b3 === a4)
      break;
    for (; null === b3.sibling; ) {
      if (null === b3.return || b3.return === a4)
        return null;
      b3 = b3.return;
    }
    b3.sibling.return = b3.return;
    b3 = b3.sibling;
  }
  return null;
}
var Nh = [];
function Oh() {
  for (var a4 = 0; a4 < Nh.length; a4++)
    Nh[a4]._workInProgressVersionPrimary = null;
  Nh.length = 0;
}
var Ph = ua.ReactCurrentDispatcher, Qh = ua.ReactCurrentBatchConfig, Rh = 0, N = null, O$3 = null, P$2 = null, Sh = false, Th = false, Uh = 0, Vh = 0;
function Q() {
  throw Error(p$7(321));
}
function Wh(a4, b3) {
  if (null === b3)
    return false;
  for (var c3 = 0; c3 < b3.length && c3 < a4.length; c3++)
    if (!He$1(a4[c3], b3[c3]))
      return false;
  return true;
}
function Xh(a4, b3, c3, d4, e3, f2) {
  Rh = f2;
  N = b3;
  b3.memoizedState = null;
  b3.updateQueue = null;
  b3.lanes = 0;
  Ph.current = null === a4 || null === a4.memoizedState ? Yh : Zh;
  a4 = c3(d4, e3);
  if (Th) {
    f2 = 0;
    do {
      Th = false;
      Uh = 0;
      if (25 <= f2)
        throw Error(p$7(301));
      f2 += 1;
      P$2 = O$3 = null;
      b3.updateQueue = null;
      Ph.current = $h;
      a4 = c3(d4, e3);
    } while (Th);
  }
  Ph.current = ai;
  b3 = null !== O$3 && null !== O$3.next;
  Rh = 0;
  P$2 = O$3 = N = null;
  Sh = false;
  if (b3)
    throw Error(p$7(300));
  return a4;
}
function bi() {
  var a4 = 0 !== Uh;
  Uh = 0;
  return a4;
}
function ci() {
  var a4 = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null };
  null === P$2 ? N.memoizedState = P$2 = a4 : P$2 = P$2.next = a4;
  return P$2;
}
function di() {
  if (null === O$3) {
    var a4 = N.alternate;
    a4 = null !== a4 ? a4.memoizedState : null;
  } else
    a4 = O$3.next;
  var b3 = null === P$2 ? N.memoizedState : P$2.next;
  if (null !== b3)
    P$2 = b3, O$3 = a4;
  else {
    if (null === a4)
      throw Error(p$7(310));
    O$3 = a4;
    a4 = { memoizedState: O$3.memoizedState, baseState: O$3.baseState, baseQueue: O$3.baseQueue, queue: O$3.queue, next: null };
    null === P$2 ? N.memoizedState = P$2 = a4 : P$2 = P$2.next = a4;
  }
  return P$2;
}
function ei(a4, b3) {
  return "function" === typeof b3 ? b3(a4) : b3;
}
function fi(a4) {
  var b3 = di(), c3 = b3.queue;
  if (null === c3)
    throw Error(p$7(311));
  c3.lastRenderedReducer = a4;
  var d4 = O$3, e3 = d4.baseQueue, f2 = c3.pending;
  if (null !== f2) {
    if (null !== e3) {
      var g2 = e3.next;
      e3.next = f2.next;
      f2.next = g2;
    }
    d4.baseQueue = e3 = f2;
    c3.pending = null;
  }
  if (null !== e3) {
    f2 = e3.next;
    d4 = d4.baseState;
    var h4 = g2 = null, k3 = null, l2 = f2;
    do {
      var m4 = l2.lane;
      if ((Rh & m4) === m4)
        null !== k3 && (k3 = k3.next = { lane: 0, action: l2.action, hasEagerState: l2.hasEagerState, eagerState: l2.eagerState, next: null }), d4 = l2.hasEagerState ? l2.eagerState : a4(d4, l2.action);
      else {
        var q3 = {
          lane: m4,
          action: l2.action,
          hasEagerState: l2.hasEagerState,
          eagerState: l2.eagerState,
          next: null
        };
        null === k3 ? (h4 = k3 = q3, g2 = d4) : k3 = k3.next = q3;
        N.lanes |= m4;
        hh |= m4;
      }
      l2 = l2.next;
    } while (null !== l2 && l2 !== f2);
    null === k3 ? g2 = d4 : k3.next = h4;
    He$1(d4, b3.memoizedState) || (Ug = true);
    b3.memoizedState = d4;
    b3.baseState = g2;
    b3.baseQueue = k3;
    c3.lastRenderedState = d4;
  }
  a4 = c3.interleaved;
  if (null !== a4) {
    e3 = a4;
    do
      f2 = e3.lane, N.lanes |= f2, hh |= f2, e3 = e3.next;
    while (e3 !== a4);
  } else
    null === e3 && (c3.lanes = 0);
  return [b3.memoizedState, c3.dispatch];
}
function gi(a4) {
  var b3 = di(), c3 = b3.queue;
  if (null === c3)
    throw Error(p$7(311));
  c3.lastRenderedReducer = a4;
  var d4 = c3.dispatch, e3 = c3.pending, f2 = b3.memoizedState;
  if (null !== e3) {
    c3.pending = null;
    var g2 = e3 = e3.next;
    do
      f2 = a4(f2, g2.action), g2 = g2.next;
    while (g2 !== e3);
    He$1(f2, b3.memoizedState) || (Ug = true);
    b3.memoizedState = f2;
    null === b3.baseQueue && (b3.baseState = f2);
    c3.lastRenderedState = f2;
  }
  return [f2, d4];
}
function hi() {
}
function ii(a4, b3) {
  var c3 = N, d4 = di(), e3 = b3(), f2 = !He$1(d4.memoizedState, e3);
  f2 && (d4.memoizedState = e3, Ug = true);
  d4 = d4.queue;
  ji(ki.bind(null, c3, d4, a4), [a4]);
  if (d4.getSnapshot !== b3 || f2 || null !== P$2 && P$2.memoizedState.tag & 1) {
    c3.flags |= 2048;
    li(9, mi.bind(null, c3, d4, e3, b3), void 0, null);
    if (null === R$5)
      throw Error(p$7(349));
    0 !== (Rh & 30) || ni(c3, b3, e3);
  }
  return e3;
}
function ni(a4, b3, c3) {
  a4.flags |= 16384;
  a4 = { getSnapshot: b3, value: c3 };
  b3 = N.updateQueue;
  null === b3 ? (b3 = { lastEffect: null, stores: null }, N.updateQueue = b3, b3.stores = [a4]) : (c3 = b3.stores, null === c3 ? b3.stores = [a4] : c3.push(a4));
}
function mi(a4, b3, c3, d4) {
  b3.value = c3;
  b3.getSnapshot = d4;
  oi(b3) && pi(a4);
}
function ki(a4, b3, c3) {
  return c3(function() {
    oi(b3) && pi(a4);
  });
}
function oi(a4) {
  var b3 = a4.getSnapshot;
  a4 = a4.value;
  try {
    var c3 = b3();
    return !He$1(a4, c3);
  } catch (d4) {
    return true;
  }
}
function pi(a4) {
  var b3 = Zg(a4, 1);
  null !== b3 && mh(b3, a4, 1, -1);
}
function qi(a4) {
  var b3 = ci();
  "function" === typeof a4 && (a4 = a4());
  b3.memoizedState = b3.baseState = a4;
  a4 = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: ei, lastRenderedState: a4 };
  b3.queue = a4;
  a4 = a4.dispatch = ri.bind(null, N, a4);
  return [b3.memoizedState, a4];
}
function li(a4, b3, c3, d4) {
  a4 = { tag: a4, create: b3, destroy: c3, deps: d4, next: null };
  b3 = N.updateQueue;
  null === b3 ? (b3 = { lastEffect: null, stores: null }, N.updateQueue = b3, b3.lastEffect = a4.next = a4) : (c3 = b3.lastEffect, null === c3 ? b3.lastEffect = a4.next = a4 : (d4 = c3.next, c3.next = a4, a4.next = d4, b3.lastEffect = a4));
  return a4;
}
function si() {
  return di().memoizedState;
}
function ti(a4, b3, c3, d4) {
  var e3 = ci();
  N.flags |= a4;
  e3.memoizedState = li(1 | b3, c3, void 0, void 0 === d4 ? null : d4);
}
function ui(a4, b3, c3, d4) {
  var e3 = di();
  d4 = void 0 === d4 ? null : d4;
  var f2 = void 0;
  if (null !== O$3) {
    var g2 = O$3.memoizedState;
    f2 = g2.destroy;
    if (null !== d4 && Wh(d4, g2.deps)) {
      e3.memoizedState = li(b3, c3, f2, d4);
      return;
    }
  }
  N.flags |= a4;
  e3.memoizedState = li(1 | b3, c3, f2, d4);
}
function vi(a4, b3) {
  return ti(8390656, 8, a4, b3);
}
function ji(a4, b3) {
  return ui(2048, 8, a4, b3);
}
function wi(a4, b3) {
  return ui(4, 2, a4, b3);
}
function xi(a4, b3) {
  return ui(4, 4, a4, b3);
}
function yi(a4, b3) {
  if ("function" === typeof b3)
    return a4 = a4(), b3(a4), function() {
      b3(null);
    };
  if (null !== b3 && void 0 !== b3)
    return a4 = a4(), b3.current = a4, function() {
      b3.current = null;
    };
}
function zi(a4, b3, c3) {
  c3 = null !== c3 && void 0 !== c3 ? c3.concat([a4]) : null;
  return ui(4, 4, yi.bind(null, b3, a4), c3);
}
function Ai() {
}
function Bi(a4, b3) {
  var c3 = di();
  b3 = void 0 === b3 ? null : b3;
  var d4 = c3.memoizedState;
  if (null !== d4 && null !== b3 && Wh(b3, d4[1]))
    return d4[0];
  c3.memoizedState = [a4, b3];
  return a4;
}
function Ci(a4, b3) {
  var c3 = di();
  b3 = void 0 === b3 ? null : b3;
  var d4 = c3.memoizedState;
  if (null !== d4 && null !== b3 && Wh(b3, d4[1]))
    return d4[0];
  a4 = a4();
  c3.memoizedState = [a4, b3];
  return a4;
}
function Di(a4, b3, c3) {
  if (0 === (Rh & 21))
    return a4.baseState && (a4.baseState = false, Ug = true), a4.memoizedState = c3;
  He$1(c3, b3) || (c3 = yc(), N.lanes |= c3, hh |= c3, a4.baseState = true);
  return b3;
}
function Ei(a4, b3) {
  var c3 = C$3;
  C$3 = 0 !== c3 && 4 > c3 ? c3 : 4;
  a4(true);
  var d4 = Qh.transition;
  Qh.transition = {};
  try {
    a4(false), b3();
  } finally {
    C$3 = c3, Qh.transition = d4;
  }
}
function Fi() {
  return di().memoizedState;
}
function Gi(a4, b3, c3) {
  var d4 = lh(a4);
  c3 = { lane: d4, action: c3, hasEagerState: false, eagerState: null, next: null };
  if (Hi(a4))
    Ii(b3, c3);
  else if (c3 = Yg(a4, b3, c3, d4), null !== c3) {
    var e3 = L();
    mh(c3, a4, d4, e3);
    Ji(c3, b3, d4);
  }
}
function ri(a4, b3, c3) {
  var d4 = lh(a4), e3 = { lane: d4, action: c3, hasEagerState: false, eagerState: null, next: null };
  if (Hi(a4))
    Ii(b3, e3);
  else {
    var f2 = a4.alternate;
    if (0 === a4.lanes && (null === f2 || 0 === f2.lanes) && (f2 = b3.lastRenderedReducer, null !== f2))
      try {
        var g2 = b3.lastRenderedState, h4 = f2(g2, c3);
        e3.hasEagerState = true;
        e3.eagerState = h4;
        if (He$1(h4, g2)) {
          var k3 = b3.interleaved;
          null === k3 ? (e3.next = e3, Xg(b3)) : (e3.next = k3.next, k3.next = e3);
          b3.interleaved = e3;
          return;
        }
      } catch (l2) {
      } finally {
      }
    c3 = Yg(a4, b3, e3, d4);
    null !== c3 && (e3 = L(), mh(c3, a4, d4, e3), Ji(c3, b3, d4));
  }
}
function Hi(a4) {
  var b3 = a4.alternate;
  return a4 === N || null !== b3 && b3 === N;
}
function Ii(a4, b3) {
  Th = Sh = true;
  var c3 = a4.pending;
  null === c3 ? b3.next = b3 : (b3.next = c3.next, c3.next = b3);
  a4.pending = b3;
}
function Ji(a4, b3, c3) {
  if (0 !== (c3 & 4194240)) {
    var d4 = b3.lanes;
    d4 &= a4.pendingLanes;
    c3 |= d4;
    b3.lanes = c3;
    Cc(a4, c3);
  }
}
var ai = { readContext: Vg, useCallback: Q, useContext: Q, useEffect: Q, useImperativeHandle: Q, useInsertionEffect: Q, useLayoutEffect: Q, useMemo: Q, useReducer: Q, useRef: Q, useState: Q, useDebugValue: Q, useDeferredValue: Q, useTransition: Q, useMutableSource: Q, useSyncExternalStore: Q, useId: Q, unstable_isNewReconciler: false }, Yh = { readContext: Vg, useCallback: function(a4, b3) {
  ci().memoizedState = [a4, void 0 === b3 ? null : b3];
  return a4;
}, useContext: Vg, useEffect: vi, useImperativeHandle: function(a4, b3, c3) {
  c3 = null !== c3 && void 0 !== c3 ? c3.concat([a4]) : null;
  return ti(
    4194308,
    4,
    yi.bind(null, b3, a4),
    c3
  );
}, useLayoutEffect: function(a4, b3) {
  return ti(4194308, 4, a4, b3);
}, useInsertionEffect: function(a4, b3) {
  return ti(4, 2, a4, b3);
}, useMemo: function(a4, b3) {
  var c3 = ci();
  b3 = void 0 === b3 ? null : b3;
  a4 = a4();
  c3.memoizedState = [a4, b3];
  return a4;
}, useReducer: function(a4, b3, c3) {
  var d4 = ci();
  b3 = void 0 !== c3 ? c3(b3) : b3;
  d4.memoizedState = d4.baseState = b3;
  a4 = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: a4, lastRenderedState: b3 };
  d4.queue = a4;
  a4 = a4.dispatch = Gi.bind(null, N, a4);
  return [d4.memoizedState, a4];
}, useRef: function(a4) {
  var b3 = ci();
  a4 = { current: a4 };
  return b3.memoizedState = a4;
}, useState: qi, useDebugValue: Ai, useDeferredValue: function(a4) {
  return ci().memoizedState = a4;
}, useTransition: function() {
  var a4 = qi(false), b3 = a4[0];
  a4 = Ei.bind(null, a4[1]);
  ci().memoizedState = a4;
  return [b3, a4];
}, useMutableSource: function() {
}, useSyncExternalStore: function(a4, b3, c3) {
  var d4 = N, e3 = ci();
  if (I$1) {
    if (void 0 === c3)
      throw Error(p$7(407));
    c3 = c3();
  } else {
    c3 = b3();
    if (null === R$5)
      throw Error(p$7(349));
    0 !== (Rh & 30) || ni(d4, b3, c3);
  }
  e3.memoizedState = c3;
  var f2 = { value: c3, getSnapshot: b3 };
  e3.queue = f2;
  vi(ki.bind(
    null,
    d4,
    f2,
    a4
  ), [a4]);
  d4.flags |= 2048;
  li(9, mi.bind(null, d4, f2, c3, b3), void 0, null);
  return c3;
}, useId: function() {
  var a4 = ci(), b3 = R$5.identifierPrefix;
  if (I$1) {
    var c3 = sg;
    var d4 = rg;
    c3 = (d4 & ~(1 << 32 - oc(d4) - 1)).toString(32) + c3;
    b3 = ":" + b3 + "R" + c3;
    c3 = Uh++;
    0 < c3 && (b3 += "H" + c3.toString(32));
    b3 += ":";
  } else
    c3 = Vh++, b3 = ":" + b3 + "r" + c3.toString(32) + ":";
  return a4.memoizedState = b3;
}, unstable_isNewReconciler: false }, Zh = {
  readContext: Vg,
  useCallback: Bi,
  useContext: Vg,
  useEffect: ji,
  useImperativeHandle: zi,
  useInsertionEffect: wi,
  useLayoutEffect: xi,
  useMemo: Ci,
  useReducer: fi,
  useRef: si,
  useState: function() {
    return fi(ei);
  },
  useDebugValue: Ai,
  useDeferredValue: function(a4) {
    var b3 = di();
    return Di(b3, O$3.memoizedState, a4);
  },
  useTransition: function() {
    var a4 = fi(ei)[0], b3 = di().memoizedState;
    return [a4, b3];
  },
  useMutableSource: hi,
  useSyncExternalStore: ii,
  useId: Fi,
  unstable_isNewReconciler: false
}, $h = { readContext: Vg, useCallback: Bi, useContext: Vg, useEffect: ji, useImperativeHandle: zi, useInsertionEffect: wi, useLayoutEffect: xi, useMemo: Ci, useReducer: gi, useRef: si, useState: function() {
  return gi(ei);
}, useDebugValue: Ai, useDeferredValue: function(a4) {
  var b3 = di();
  return null === O$3 ? b3.memoizedState = a4 : Di(b3, O$3.memoizedState, a4);
}, useTransition: function() {
  var a4 = gi(ei)[0], b3 = di().memoizedState;
  return [a4, b3];
}, useMutableSource: hi, useSyncExternalStore: ii, useId: Fi, unstable_isNewReconciler: false };
function Ki(a4, b3) {
  try {
    var c3 = "", d4 = b3;
    do
      c3 += Pa(d4), d4 = d4.return;
    while (d4);
    var e3 = c3;
  } catch (f2) {
    e3 = "\nError generating stack: " + f2.message + "\n" + f2.stack;
  }
  return { value: a4, source: b3, stack: e3, digest: null };
}
function Li(a4, b3, c3) {
  return { value: a4, source: null, stack: null != c3 ? c3 : null, digest: null != b3 ? b3 : null };
}
function Mi(a4, b3) {
  try {
    console.error(b3.value);
  } catch (c3) {
    setTimeout(function() {
      throw c3;
    });
  }
}
var Ni = "function" === typeof WeakMap ? WeakMap : Map;
function Oi(a4, b3, c3) {
  c3 = ch(-1, c3);
  c3.tag = 3;
  c3.payload = { element: null };
  var d4 = b3.value;
  c3.callback = function() {
    Pi || (Pi = true, Qi = d4);
    Mi(a4, b3);
  };
  return c3;
}
function Ri(a4, b3, c3) {
  c3 = ch(-1, c3);
  c3.tag = 3;
  var d4 = a4.type.getDerivedStateFromError;
  if ("function" === typeof d4) {
    var e3 = b3.value;
    c3.payload = function() {
      return d4(e3);
    };
    c3.callback = function() {
      Mi(a4, b3);
    };
  }
  var f2 = a4.stateNode;
  null !== f2 && "function" === typeof f2.componentDidCatch && (c3.callback = function() {
    Mi(a4, b3);
    "function" !== typeof d4 && (null === Si ? Si = /* @__PURE__ */ new Set([this]) : Si.add(this));
    var c4 = b3.stack;
    this.componentDidCatch(b3.value, { componentStack: null !== c4 ? c4 : "" });
  });
  return c3;
}
function Ti(a4, b3, c3) {
  var d4 = a4.pingCache;
  if (null === d4) {
    d4 = a4.pingCache = new Ni();
    var e3 = /* @__PURE__ */ new Set();
    d4.set(b3, e3);
  } else
    e3 = d4.get(b3), void 0 === e3 && (e3 = /* @__PURE__ */ new Set(), d4.set(b3, e3));
  e3.has(c3) || (e3.add(c3), a4 = Ui.bind(null, a4, b3, c3), b3.then(a4, a4));
}
function Vi(a4) {
  do {
    var b3;
    if (b3 = 13 === a4.tag)
      b3 = a4.memoizedState, b3 = null !== b3 ? null !== b3.dehydrated ? true : false : true;
    if (b3)
      return a4;
    a4 = a4.return;
  } while (null !== a4);
  return null;
}
function Wi(a4, b3, c3, d4, e3) {
  if (0 === (a4.mode & 1))
    return a4 === b3 ? a4.flags |= 65536 : (a4.flags |= 128, c3.flags |= 131072, c3.flags &= -52805, 1 === c3.tag && (null === c3.alternate ? c3.tag = 17 : (b3 = ch(-1, 1), b3.tag = 2, dh(c3, b3, 1))), c3.lanes |= 1), a4;
  a4.flags |= 65536;
  a4.lanes = e3;
  return a4;
}
var Xi = ua.ReactCurrentOwner, Ug = false;
function Yi(a4, b3, c3, d4) {
  b3.child = null === a4 ? Ch(b3, null, c3, d4) : Bh(b3, a4.child, c3, d4);
}
function Zi(a4, b3, c3, d4, e3) {
  c3 = c3.render;
  var f2 = b3.ref;
  Tg(b3, e3);
  d4 = Xh(a4, b3, c3, d4, f2, e3);
  c3 = bi();
  if (null !== a4 && !Ug)
    return b3.updateQueue = a4.updateQueue, b3.flags &= -2053, a4.lanes &= ~e3, $i(a4, b3, e3);
  I$1 && c3 && vg(b3);
  b3.flags |= 1;
  Yi(a4, b3, d4, e3);
  return b3.child;
}
function aj(a4, b3, c3, d4, e3) {
  if (null === a4) {
    var f2 = c3.type;
    if ("function" === typeof f2 && !bj(f2) && void 0 === f2.defaultProps && null === c3.compare && void 0 === c3.defaultProps)
      return b3.tag = 15, b3.type = f2, cj(a4, b3, f2, d4, e3);
    a4 = yh(c3.type, null, d4, b3, b3.mode, e3);
    a4.ref = b3.ref;
    a4.return = b3;
    return b3.child = a4;
  }
  f2 = a4.child;
  if (0 === (a4.lanes & e3)) {
    var g2 = f2.memoizedProps;
    c3 = c3.compare;
    c3 = null !== c3 ? c3 : Ie$1;
    if (c3(g2, d4) && a4.ref === b3.ref)
      return $i(a4, b3, e3);
  }
  b3.flags |= 1;
  a4 = wh(f2, d4);
  a4.ref = b3.ref;
  a4.return = b3;
  return b3.child = a4;
}
function cj(a4, b3, c3, d4, e3) {
  if (null !== a4) {
    var f2 = a4.memoizedProps;
    if (Ie$1(f2, d4) && a4.ref === b3.ref)
      if (Ug = false, b3.pendingProps = d4 = f2, 0 !== (a4.lanes & e3))
        0 !== (a4.flags & 131072) && (Ug = true);
      else
        return b3.lanes = a4.lanes, $i(a4, b3, e3);
  }
  return dj(a4, b3, c3, d4, e3);
}
function ej(a4, b3, c3) {
  var d4 = b3.pendingProps, e3 = d4.children, f2 = null !== a4 ? a4.memoizedState : null;
  if ("hidden" === d4.mode)
    if (0 === (b3.mode & 1))
      b3.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, G(fj, gj), gj |= c3;
    else {
      if (0 === (c3 & 1073741824))
        return a4 = null !== f2 ? f2.baseLanes | c3 : c3, b3.lanes = b3.childLanes = 1073741824, b3.memoizedState = { baseLanes: a4, cachePool: null, transitions: null }, b3.updateQueue = null, G(fj, gj), gj |= a4, null;
      b3.memoizedState = { baseLanes: 0, cachePool: null, transitions: null };
      d4 = null !== f2 ? f2.baseLanes : c3;
      G(fj, gj);
      gj |= d4;
    }
  else
    null !== f2 ? (d4 = f2.baseLanes | c3, b3.memoizedState = null) : d4 = c3, G(fj, gj), gj |= d4;
  Yi(a4, b3, e3, c3);
  return b3.child;
}
function hj(a4, b3) {
  var c3 = b3.ref;
  if (null === a4 && null !== c3 || null !== a4 && a4.ref !== c3)
    b3.flags |= 512, b3.flags |= 2097152;
}
function dj(a4, b3, c3, d4, e3) {
  var f2 = Zf(c3) ? Xf : H.current;
  f2 = Yf(b3, f2);
  Tg(b3, e3);
  c3 = Xh(a4, b3, c3, d4, f2, e3);
  d4 = bi();
  if (null !== a4 && !Ug)
    return b3.updateQueue = a4.updateQueue, b3.flags &= -2053, a4.lanes &= ~e3, $i(a4, b3, e3);
  I$1 && d4 && vg(b3);
  b3.flags |= 1;
  Yi(a4, b3, c3, e3);
  return b3.child;
}
function ij(a4, b3, c3, d4, e3) {
  if (Zf(c3)) {
    var f2 = true;
    cg(b3);
  } else
    f2 = false;
  Tg(b3, e3);
  if (null === b3.stateNode)
    jj(a4, b3), ph(b3, c3, d4), rh(b3, c3, d4, e3), d4 = true;
  else if (null === a4) {
    var g2 = b3.stateNode, h4 = b3.memoizedProps;
    g2.props = h4;
    var k3 = g2.context, l2 = c3.contextType;
    "object" === typeof l2 && null !== l2 ? l2 = Vg(l2) : (l2 = Zf(c3) ? Xf : H.current, l2 = Yf(b3, l2));
    var m4 = c3.getDerivedStateFromProps, q3 = "function" === typeof m4 || "function" === typeof g2.getSnapshotBeforeUpdate;
    q3 || "function" !== typeof g2.UNSAFE_componentWillReceiveProps && "function" !== typeof g2.componentWillReceiveProps || (h4 !== d4 || k3 !== l2) && qh(b3, g2, d4, l2);
    $g = false;
    var r2 = b3.memoizedState;
    g2.state = r2;
    gh(b3, d4, g2, e3);
    k3 = b3.memoizedState;
    h4 !== d4 || r2 !== k3 || Wf.current || $g ? ("function" === typeof m4 && (kh(b3, c3, m4, d4), k3 = b3.memoizedState), (h4 = $g || oh(b3, c3, h4, d4, r2, k3, l2)) ? (q3 || "function" !== typeof g2.UNSAFE_componentWillMount && "function" !== typeof g2.componentWillMount || ("function" === typeof g2.componentWillMount && g2.componentWillMount(), "function" === typeof g2.UNSAFE_componentWillMount && g2.UNSAFE_componentWillMount()), "function" === typeof g2.componentDidMount && (b3.flags |= 4194308)) : ("function" === typeof g2.componentDidMount && (b3.flags |= 4194308), b3.memoizedProps = d4, b3.memoizedState = k3), g2.props = d4, g2.state = k3, g2.context = l2, d4 = h4) : ("function" === typeof g2.componentDidMount && (b3.flags |= 4194308), d4 = false);
  } else {
    g2 = b3.stateNode;
    bh(a4, b3);
    h4 = b3.memoizedProps;
    l2 = b3.type === b3.elementType ? h4 : Lg(b3.type, h4);
    g2.props = l2;
    q3 = b3.pendingProps;
    r2 = g2.context;
    k3 = c3.contextType;
    "object" === typeof k3 && null !== k3 ? k3 = Vg(k3) : (k3 = Zf(c3) ? Xf : H.current, k3 = Yf(b3, k3));
    var y4 = c3.getDerivedStateFromProps;
    (m4 = "function" === typeof y4 || "function" === typeof g2.getSnapshotBeforeUpdate) || "function" !== typeof g2.UNSAFE_componentWillReceiveProps && "function" !== typeof g2.componentWillReceiveProps || (h4 !== q3 || r2 !== k3) && qh(b3, g2, d4, k3);
    $g = false;
    r2 = b3.memoizedState;
    g2.state = r2;
    gh(b3, d4, g2, e3);
    var n2 = b3.memoizedState;
    h4 !== q3 || r2 !== n2 || Wf.current || $g ? ("function" === typeof y4 && (kh(b3, c3, y4, d4), n2 = b3.memoizedState), (l2 = $g || oh(b3, c3, l2, d4, r2, n2, k3) || false) ? (m4 || "function" !== typeof g2.UNSAFE_componentWillUpdate && "function" !== typeof g2.componentWillUpdate || ("function" === typeof g2.componentWillUpdate && g2.componentWillUpdate(d4, n2, k3), "function" === typeof g2.UNSAFE_componentWillUpdate && g2.UNSAFE_componentWillUpdate(d4, n2, k3)), "function" === typeof g2.componentDidUpdate && (b3.flags |= 4), "function" === typeof g2.getSnapshotBeforeUpdate && (b3.flags |= 1024)) : ("function" !== typeof g2.componentDidUpdate || h4 === a4.memoizedProps && r2 === a4.memoizedState || (b3.flags |= 4), "function" !== typeof g2.getSnapshotBeforeUpdate || h4 === a4.memoizedProps && r2 === a4.memoizedState || (b3.flags |= 1024), b3.memoizedProps = d4, b3.memoizedState = n2), g2.props = d4, g2.state = n2, g2.context = k3, d4 = l2) : ("function" !== typeof g2.componentDidUpdate || h4 === a4.memoizedProps && r2 === a4.memoizedState || (b3.flags |= 4), "function" !== typeof g2.getSnapshotBeforeUpdate || h4 === a4.memoizedProps && r2 === a4.memoizedState || (b3.flags |= 1024), d4 = false);
  }
  return kj(a4, b3, c3, d4, f2, e3);
}
function kj(a4, b3, c3, d4, e3, f2) {
  hj(a4, b3);
  var g2 = 0 !== (b3.flags & 128);
  if (!d4 && !g2)
    return e3 && dg(b3, c3, false), $i(a4, b3, f2);
  d4 = b3.stateNode;
  Xi.current = b3;
  var h4 = g2 && "function" !== typeof c3.getDerivedStateFromError ? null : d4.render();
  b3.flags |= 1;
  null !== a4 && g2 ? (b3.child = Bh(b3, a4.child, null, f2), b3.child = Bh(b3, null, h4, f2)) : Yi(a4, b3, h4, f2);
  b3.memoizedState = d4.state;
  e3 && dg(b3, c3, true);
  return b3.child;
}
function lj(a4) {
  var b3 = a4.stateNode;
  b3.pendingContext ? ag(a4, b3.pendingContext, b3.pendingContext !== b3.context) : b3.context && ag(a4, b3.context, false);
  Ih(a4, b3.containerInfo);
}
function mj(a4, b3, c3, d4, e3) {
  Ig();
  Jg(e3);
  b3.flags |= 256;
  Yi(a4, b3, c3, d4);
  return b3.child;
}
var nj = { dehydrated: null, treeContext: null, retryLane: 0 };
function oj(a4) {
  return { baseLanes: a4, cachePool: null, transitions: null };
}
function pj(a4, b3, c3) {
  var d4 = b3.pendingProps, e3 = M$2.current, f2 = false, g2 = 0 !== (b3.flags & 128), h4;
  (h4 = g2) || (h4 = null !== a4 && null === a4.memoizedState ? false : 0 !== (e3 & 2));
  if (h4)
    f2 = true, b3.flags &= -129;
  else if (null === a4 || null !== a4.memoizedState)
    e3 |= 1;
  G(M$2, e3 & 1);
  if (null === a4) {
    Eg(b3);
    a4 = b3.memoizedState;
    if (null !== a4 && (a4 = a4.dehydrated, null !== a4))
      return 0 === (b3.mode & 1) ? b3.lanes = 1 : "$!" === a4.data ? b3.lanes = 8 : b3.lanes = 1073741824, null;
    g2 = d4.children;
    a4 = d4.fallback;
    return f2 ? (d4 = b3.mode, f2 = b3.child, g2 = { mode: "hidden", children: g2 }, 0 === (d4 & 1) && null !== f2 ? (f2.childLanes = 0, f2.pendingProps = g2) : f2 = qj(g2, d4, 0, null), a4 = Ah(a4, d4, c3, null), f2.return = b3, a4.return = b3, f2.sibling = a4, b3.child = f2, b3.child.memoizedState = oj(c3), b3.memoizedState = nj, a4) : rj(b3, g2);
  }
  e3 = a4.memoizedState;
  if (null !== e3 && (h4 = e3.dehydrated, null !== h4))
    return sj(a4, b3, g2, d4, h4, e3, c3);
  if (f2) {
    f2 = d4.fallback;
    g2 = b3.mode;
    e3 = a4.child;
    h4 = e3.sibling;
    var k3 = { mode: "hidden", children: d4.children };
    0 === (g2 & 1) && b3.child !== e3 ? (d4 = b3.child, d4.childLanes = 0, d4.pendingProps = k3, b3.deletions = null) : (d4 = wh(e3, k3), d4.subtreeFlags = e3.subtreeFlags & 14680064);
    null !== h4 ? f2 = wh(h4, f2) : (f2 = Ah(f2, g2, c3, null), f2.flags |= 2);
    f2.return = b3;
    d4.return = b3;
    d4.sibling = f2;
    b3.child = d4;
    d4 = f2;
    f2 = b3.child;
    g2 = a4.child.memoizedState;
    g2 = null === g2 ? oj(c3) : { baseLanes: g2.baseLanes | c3, cachePool: null, transitions: g2.transitions };
    f2.memoizedState = g2;
    f2.childLanes = a4.childLanes & ~c3;
    b3.memoizedState = nj;
    return d4;
  }
  f2 = a4.child;
  a4 = f2.sibling;
  d4 = wh(f2, { mode: "visible", children: d4.children });
  0 === (b3.mode & 1) && (d4.lanes = c3);
  d4.return = b3;
  d4.sibling = null;
  null !== a4 && (c3 = b3.deletions, null === c3 ? (b3.deletions = [a4], b3.flags |= 16) : c3.push(a4));
  b3.child = d4;
  b3.memoizedState = null;
  return d4;
}
function rj(a4, b3) {
  b3 = qj({ mode: "visible", children: b3 }, a4.mode, 0, null);
  b3.return = a4;
  return a4.child = b3;
}
function tj(a4, b3, c3, d4) {
  null !== d4 && Jg(d4);
  Bh(b3, a4.child, null, c3);
  a4 = rj(b3, b3.pendingProps.children);
  a4.flags |= 2;
  b3.memoizedState = null;
  return a4;
}
function sj(a4, b3, c3, d4, e3, f2, g2) {
  if (c3) {
    if (b3.flags & 256)
      return b3.flags &= -257, d4 = Li(Error(p$7(422))), tj(a4, b3, g2, d4);
    if (null !== b3.memoizedState)
      return b3.child = a4.child, b3.flags |= 128, null;
    f2 = d4.fallback;
    e3 = b3.mode;
    d4 = qj({ mode: "visible", children: d4.children }, e3, 0, null);
    f2 = Ah(f2, e3, g2, null);
    f2.flags |= 2;
    d4.return = b3;
    f2.return = b3;
    d4.sibling = f2;
    b3.child = d4;
    0 !== (b3.mode & 1) && Bh(b3, a4.child, null, g2);
    b3.child.memoizedState = oj(g2);
    b3.memoizedState = nj;
    return f2;
  }
  if (0 === (b3.mode & 1))
    return tj(a4, b3, g2, null);
  if ("$!" === e3.data) {
    d4 = e3.nextSibling && e3.nextSibling.dataset;
    if (d4)
      var h4 = d4.dgst;
    d4 = h4;
    f2 = Error(p$7(419));
    d4 = Li(f2, d4, void 0);
    return tj(a4, b3, g2, d4);
  }
  h4 = 0 !== (g2 & a4.childLanes);
  if (Ug || h4) {
    d4 = R$5;
    if (null !== d4) {
      switch (g2 & -g2) {
        case 4:
          e3 = 2;
          break;
        case 16:
          e3 = 8;
          break;
        case 64:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
        case 67108864:
          e3 = 32;
          break;
        case 536870912:
          e3 = 268435456;
          break;
        default:
          e3 = 0;
      }
      e3 = 0 !== (e3 & (d4.suspendedLanes | g2)) ? 0 : e3;
      0 !== e3 && e3 !== f2.retryLane && (f2.retryLane = e3, Zg(a4, e3), mh(d4, a4, e3, -1));
    }
    uj();
    d4 = Li(Error(p$7(421)));
    return tj(a4, b3, g2, d4);
  }
  if ("$?" === e3.data)
    return b3.flags |= 128, b3.child = a4.child, b3 = vj.bind(null, a4), e3._reactRetry = b3, null;
  a4 = f2.treeContext;
  yg = Lf(e3.nextSibling);
  xg = b3;
  I$1 = true;
  zg = null;
  null !== a4 && (og[pg++] = rg, og[pg++] = sg, og[pg++] = qg, rg = a4.id, sg = a4.overflow, qg = b3);
  b3 = rj(b3, d4.children);
  b3.flags |= 4096;
  return b3;
}
function wj(a4, b3, c3) {
  a4.lanes |= b3;
  var d4 = a4.alternate;
  null !== d4 && (d4.lanes |= b3);
  Sg(a4.return, b3, c3);
}
function xj(a4, b3, c3, d4, e3) {
  var f2 = a4.memoizedState;
  null === f2 ? a4.memoizedState = { isBackwards: b3, rendering: null, renderingStartTime: 0, last: d4, tail: c3, tailMode: e3 } : (f2.isBackwards = b3, f2.rendering = null, f2.renderingStartTime = 0, f2.last = d4, f2.tail = c3, f2.tailMode = e3);
}
function yj(a4, b3, c3) {
  var d4 = b3.pendingProps, e3 = d4.revealOrder, f2 = d4.tail;
  Yi(a4, b3, d4.children, c3);
  d4 = M$2.current;
  if (0 !== (d4 & 2))
    d4 = d4 & 1 | 2, b3.flags |= 128;
  else {
    if (null !== a4 && 0 !== (a4.flags & 128))
      a:
        for (a4 = b3.child; null !== a4; ) {
          if (13 === a4.tag)
            null !== a4.memoizedState && wj(a4, c3, b3);
          else if (19 === a4.tag)
            wj(a4, c3, b3);
          else if (null !== a4.child) {
            a4.child.return = a4;
            a4 = a4.child;
            continue;
          }
          if (a4 === b3)
            break a;
          for (; null === a4.sibling; ) {
            if (null === a4.return || a4.return === b3)
              break a;
            a4 = a4.return;
          }
          a4.sibling.return = a4.return;
          a4 = a4.sibling;
        }
    d4 &= 1;
  }
  G(M$2, d4);
  if (0 === (b3.mode & 1))
    b3.memoizedState = null;
  else
    switch (e3) {
      case "forwards":
        c3 = b3.child;
        for (e3 = null; null !== c3; )
          a4 = c3.alternate, null !== a4 && null === Mh(a4) && (e3 = c3), c3 = c3.sibling;
        c3 = e3;
        null === c3 ? (e3 = b3.child, b3.child = null) : (e3 = c3.sibling, c3.sibling = null);
        xj(b3, false, e3, c3, f2);
        break;
      case "backwards":
        c3 = null;
        e3 = b3.child;
        for (b3.child = null; null !== e3; ) {
          a4 = e3.alternate;
          if (null !== a4 && null === Mh(a4)) {
            b3.child = e3;
            break;
          }
          a4 = e3.sibling;
          e3.sibling = c3;
          c3 = e3;
          e3 = a4;
        }
        xj(b3, true, c3, null, f2);
        break;
      case "together":
        xj(b3, false, null, null, void 0);
        break;
      default:
        b3.memoizedState = null;
    }
  return b3.child;
}
function jj(a4, b3) {
  0 === (b3.mode & 1) && null !== a4 && (a4.alternate = null, b3.alternate = null, b3.flags |= 2);
}
function $i(a4, b3, c3) {
  null !== a4 && (b3.dependencies = a4.dependencies);
  hh |= b3.lanes;
  if (0 === (c3 & b3.childLanes))
    return null;
  if (null !== a4 && b3.child !== a4.child)
    throw Error(p$7(153));
  if (null !== b3.child) {
    a4 = b3.child;
    c3 = wh(a4, a4.pendingProps);
    b3.child = c3;
    for (c3.return = b3; null !== a4.sibling; )
      a4 = a4.sibling, c3 = c3.sibling = wh(a4, a4.pendingProps), c3.return = b3;
    c3.sibling = null;
  }
  return b3.child;
}
function zj(a4, b3, c3) {
  switch (b3.tag) {
    case 3:
      lj(b3);
      Ig();
      break;
    case 5:
      Kh(b3);
      break;
    case 1:
      Zf(b3.type) && cg(b3);
      break;
    case 4:
      Ih(b3, b3.stateNode.containerInfo);
      break;
    case 10:
      var d4 = b3.type._context, e3 = b3.memoizedProps.value;
      G(Mg, d4._currentValue);
      d4._currentValue = e3;
      break;
    case 13:
      d4 = b3.memoizedState;
      if (null !== d4) {
        if (null !== d4.dehydrated)
          return G(M$2, M$2.current & 1), b3.flags |= 128, null;
        if (0 !== (c3 & b3.child.childLanes))
          return pj(a4, b3, c3);
        G(M$2, M$2.current & 1);
        a4 = $i(a4, b3, c3);
        return null !== a4 ? a4.sibling : null;
      }
      G(M$2, M$2.current & 1);
      break;
    case 19:
      d4 = 0 !== (c3 & b3.childLanes);
      if (0 !== (a4.flags & 128)) {
        if (d4)
          return yj(a4, b3, c3);
        b3.flags |= 128;
      }
      e3 = b3.memoizedState;
      null !== e3 && (e3.rendering = null, e3.tail = null, e3.lastEffect = null);
      G(M$2, M$2.current);
      if (d4)
        break;
      else
        return null;
    case 22:
    case 23:
      return b3.lanes = 0, ej(a4, b3, c3);
  }
  return $i(a4, b3, c3);
}
var Aj, Bj, Cj, Dj;
Aj = function(a4, b3) {
  for (var c3 = b3.child; null !== c3; ) {
    if (5 === c3.tag || 6 === c3.tag)
      a4.appendChild(c3.stateNode);
    else if (4 !== c3.tag && null !== c3.child) {
      c3.child.return = c3;
      c3 = c3.child;
      continue;
    }
    if (c3 === b3)
      break;
    for (; null === c3.sibling; ) {
      if (null === c3.return || c3.return === b3)
        return;
      c3 = c3.return;
    }
    c3.sibling.return = c3.return;
    c3 = c3.sibling;
  }
};
Bj = function() {
};
Cj = function(a4, b3, c3, d4) {
  var e3 = a4.memoizedProps;
  if (e3 !== d4) {
    a4 = b3.stateNode;
    Hh(Eh.current);
    var f2 = null;
    switch (c3) {
      case "input":
        e3 = Ya(a4, e3);
        d4 = Ya(a4, d4);
        f2 = [];
        break;
      case "select":
        e3 = A$3({}, e3, { value: void 0 });
        d4 = A$3({}, d4, { value: void 0 });
        f2 = [];
        break;
      case "textarea":
        e3 = gb(a4, e3);
        d4 = gb(a4, d4);
        f2 = [];
        break;
      default:
        "function" !== typeof e3.onClick && "function" === typeof d4.onClick && (a4.onclick = Bf);
    }
    ub(c3, d4);
    var g2;
    c3 = null;
    for (l2 in e3)
      if (!d4.hasOwnProperty(l2) && e3.hasOwnProperty(l2) && null != e3[l2])
        if ("style" === l2) {
          var h4 = e3[l2];
          for (g2 in h4)
            h4.hasOwnProperty(g2) && (c3 || (c3 = {}), c3[g2] = "");
        } else
          "dangerouslySetInnerHTML" !== l2 && "children" !== l2 && "suppressContentEditableWarning" !== l2 && "suppressHydrationWarning" !== l2 && "autoFocus" !== l2 && (ea.hasOwnProperty(l2) ? f2 || (f2 = []) : (f2 = f2 || []).push(l2, null));
    for (l2 in d4) {
      var k3 = d4[l2];
      h4 = null != e3 ? e3[l2] : void 0;
      if (d4.hasOwnProperty(l2) && k3 !== h4 && (null != k3 || null != h4))
        if ("style" === l2)
          if (h4) {
            for (g2 in h4)
              !h4.hasOwnProperty(g2) || k3 && k3.hasOwnProperty(g2) || (c3 || (c3 = {}), c3[g2] = "");
            for (g2 in k3)
              k3.hasOwnProperty(g2) && h4[g2] !== k3[g2] && (c3 || (c3 = {}), c3[g2] = k3[g2]);
          } else
            c3 || (f2 || (f2 = []), f2.push(
              l2,
              c3
            )), c3 = k3;
        else
          "dangerouslySetInnerHTML" === l2 ? (k3 = k3 ? k3.__html : void 0, h4 = h4 ? h4.__html : void 0, null != k3 && h4 !== k3 && (f2 = f2 || []).push(l2, k3)) : "children" === l2 ? "string" !== typeof k3 && "number" !== typeof k3 || (f2 = f2 || []).push(l2, "" + k3) : "suppressContentEditableWarning" !== l2 && "suppressHydrationWarning" !== l2 && (ea.hasOwnProperty(l2) ? (null != k3 && "onScroll" === l2 && D$2("scroll", a4), f2 || h4 === k3 || (f2 = [])) : (f2 = f2 || []).push(l2, k3));
    }
    c3 && (f2 = f2 || []).push("style", c3);
    var l2 = f2;
    if (b3.updateQueue = l2)
      b3.flags |= 4;
  }
};
Dj = function(a4, b3, c3, d4) {
  c3 !== d4 && (b3.flags |= 4);
};
function Ej(a4, b3) {
  if (!I$1)
    switch (a4.tailMode) {
      case "hidden":
        b3 = a4.tail;
        for (var c3 = null; null !== b3; )
          null !== b3.alternate && (c3 = b3), b3 = b3.sibling;
        null === c3 ? a4.tail = null : c3.sibling = null;
        break;
      case "collapsed":
        c3 = a4.tail;
        for (var d4 = null; null !== c3; )
          null !== c3.alternate && (d4 = c3), c3 = c3.sibling;
        null === d4 ? b3 || null === a4.tail ? a4.tail = null : a4.tail.sibling = null : d4.sibling = null;
    }
}
function S$2(a4) {
  var b3 = null !== a4.alternate && a4.alternate.child === a4.child, c3 = 0, d4 = 0;
  if (b3)
    for (var e3 = a4.child; null !== e3; )
      c3 |= e3.lanes | e3.childLanes, d4 |= e3.subtreeFlags & 14680064, d4 |= e3.flags & 14680064, e3.return = a4, e3 = e3.sibling;
  else
    for (e3 = a4.child; null !== e3; )
      c3 |= e3.lanes | e3.childLanes, d4 |= e3.subtreeFlags, d4 |= e3.flags, e3.return = a4, e3 = e3.sibling;
  a4.subtreeFlags |= d4;
  a4.childLanes = c3;
  return b3;
}
function Fj(a4, b3, c3) {
  var d4 = b3.pendingProps;
  wg(b3);
  switch (b3.tag) {
    case 2:
    case 16:
    case 15:
    case 0:
    case 11:
    case 7:
    case 8:
    case 12:
    case 9:
    case 14:
      return S$2(b3), null;
    case 1:
      return Zf(b3.type) && $f(), S$2(b3), null;
    case 3:
      d4 = b3.stateNode;
      Jh();
      E$4(Wf);
      E$4(H);
      Oh();
      d4.pendingContext && (d4.context = d4.pendingContext, d4.pendingContext = null);
      if (null === a4 || null === a4.child)
        Gg(b3) ? b3.flags |= 4 : null === a4 || a4.memoizedState.isDehydrated && 0 === (b3.flags & 256) || (b3.flags |= 1024, null !== zg && (Gj(zg), zg = null));
      Bj(a4, b3);
      S$2(b3);
      return null;
    case 5:
      Lh(b3);
      var e3 = Hh(Gh.current);
      c3 = b3.type;
      if (null !== a4 && null != b3.stateNode)
        Cj(a4, b3, c3, d4, e3), a4.ref !== b3.ref && (b3.flags |= 512, b3.flags |= 2097152);
      else {
        if (!d4) {
          if (null === b3.stateNode)
            throw Error(p$7(166));
          S$2(b3);
          return null;
        }
        a4 = Hh(Eh.current);
        if (Gg(b3)) {
          d4 = b3.stateNode;
          c3 = b3.type;
          var f2 = b3.memoizedProps;
          d4[Of] = b3;
          d4[Pf] = f2;
          a4 = 0 !== (b3.mode & 1);
          switch (c3) {
            case "dialog":
              D$2("cancel", d4);
              D$2("close", d4);
              break;
            case "iframe":
            case "object":
            case "embed":
              D$2("load", d4);
              break;
            case "video":
            case "audio":
              for (e3 = 0; e3 < lf.length; e3++)
                D$2(lf[e3], d4);
              break;
            case "source":
              D$2("error", d4);
              break;
            case "img":
            case "image":
            case "link":
              D$2(
                "error",
                d4
              );
              D$2("load", d4);
              break;
            case "details":
              D$2("toggle", d4);
              break;
            case "input":
              Za(d4, f2);
              D$2("invalid", d4);
              break;
            case "select":
              d4._wrapperState = { wasMultiple: !!f2.multiple };
              D$2("invalid", d4);
              break;
            case "textarea":
              hb(d4, f2), D$2("invalid", d4);
          }
          ub(c3, f2);
          e3 = null;
          for (var g2 in f2)
            if (f2.hasOwnProperty(g2)) {
              var h4 = f2[g2];
              "children" === g2 ? "string" === typeof h4 ? d4.textContent !== h4 && (true !== f2.suppressHydrationWarning && Af(d4.textContent, h4, a4), e3 = ["children", h4]) : "number" === typeof h4 && d4.textContent !== "" + h4 && (true !== f2.suppressHydrationWarning && Af(
                d4.textContent,
                h4,
                a4
              ), e3 = ["children", "" + h4]) : ea.hasOwnProperty(g2) && null != h4 && "onScroll" === g2 && D$2("scroll", d4);
            }
          switch (c3) {
            case "input":
              Va(d4);
              db(d4, f2, true);
              break;
            case "textarea":
              Va(d4);
              jb(d4);
              break;
            case "select":
            case "option":
              break;
            default:
              "function" === typeof f2.onClick && (d4.onclick = Bf);
          }
          d4 = e3;
          b3.updateQueue = d4;
          null !== d4 && (b3.flags |= 4);
        } else {
          g2 = 9 === e3.nodeType ? e3 : e3.ownerDocument;
          "http://www.w3.org/1999/xhtml" === a4 && (a4 = kb(c3));
          "http://www.w3.org/1999/xhtml" === a4 ? "script" === c3 ? (a4 = g2.createElement("div"), a4.innerHTML = "<script><\/script>", a4 = a4.removeChild(a4.firstChild)) : "string" === typeof d4.is ? a4 = g2.createElement(c3, { is: d4.is }) : (a4 = g2.createElement(c3), "select" === c3 && (g2 = a4, d4.multiple ? g2.multiple = true : d4.size && (g2.size = d4.size))) : a4 = g2.createElementNS(a4, c3);
          a4[Of] = b3;
          a4[Pf] = d4;
          Aj(a4, b3, false, false);
          b3.stateNode = a4;
          a: {
            g2 = vb(c3, d4);
            switch (c3) {
              case "dialog":
                D$2("cancel", a4);
                D$2("close", a4);
                e3 = d4;
                break;
              case "iframe":
              case "object":
              case "embed":
                D$2("load", a4);
                e3 = d4;
                break;
              case "video":
              case "audio":
                for (e3 = 0; e3 < lf.length; e3++)
                  D$2(lf[e3], a4);
                e3 = d4;
                break;
              case "source":
                D$2("error", a4);
                e3 = d4;
                break;
              case "img":
              case "image":
              case "link":
                D$2(
                  "error",
                  a4
                );
                D$2("load", a4);
                e3 = d4;
                break;
              case "details":
                D$2("toggle", a4);
                e3 = d4;
                break;
              case "input":
                Za(a4, d4);
                e3 = Ya(a4, d4);
                D$2("invalid", a4);
                break;
              case "option":
                e3 = d4;
                break;
              case "select":
                a4._wrapperState = { wasMultiple: !!d4.multiple };
                e3 = A$3({}, d4, { value: void 0 });
                D$2("invalid", a4);
                break;
              case "textarea":
                hb(a4, d4);
                e3 = gb(a4, d4);
                D$2("invalid", a4);
                break;
              default:
                e3 = d4;
            }
            ub(c3, e3);
            h4 = e3;
            for (f2 in h4)
              if (h4.hasOwnProperty(f2)) {
                var k3 = h4[f2];
                "style" === f2 ? sb(a4, k3) : "dangerouslySetInnerHTML" === f2 ? (k3 = k3 ? k3.__html : void 0, null != k3 && nb(a4, k3)) : "children" === f2 ? "string" === typeof k3 ? ("textarea" !== c3 || "" !== k3) && ob(a4, k3) : "number" === typeof k3 && ob(a4, "" + k3) : "suppressContentEditableWarning" !== f2 && "suppressHydrationWarning" !== f2 && "autoFocus" !== f2 && (ea.hasOwnProperty(f2) ? null != k3 && "onScroll" === f2 && D$2("scroll", a4) : null != k3 && ta(a4, f2, k3, g2));
              }
            switch (c3) {
              case "input":
                Va(a4);
                db(a4, d4, false);
                break;
              case "textarea":
                Va(a4);
                jb(a4);
                break;
              case "option":
                null != d4.value && a4.setAttribute("value", "" + Sa(d4.value));
                break;
              case "select":
                a4.multiple = !!d4.multiple;
                f2 = d4.value;
                null != f2 ? fb(a4, !!d4.multiple, f2, false) : null != d4.defaultValue && fb(
                  a4,
                  !!d4.multiple,
                  d4.defaultValue,
                  true
                );
                break;
              default:
                "function" === typeof e3.onClick && (a4.onclick = Bf);
            }
            switch (c3) {
              case "button":
              case "input":
              case "select":
              case "textarea":
                d4 = !!d4.autoFocus;
                break a;
              case "img":
                d4 = true;
                break a;
              default:
                d4 = false;
            }
          }
          d4 && (b3.flags |= 4);
        }
        null !== b3.ref && (b3.flags |= 512, b3.flags |= 2097152);
      }
      S$2(b3);
      return null;
    case 6:
      if (a4 && null != b3.stateNode)
        Dj(a4, b3, a4.memoizedProps, d4);
      else {
        if ("string" !== typeof d4 && null === b3.stateNode)
          throw Error(p$7(166));
        c3 = Hh(Gh.current);
        Hh(Eh.current);
        if (Gg(b3)) {
          d4 = b3.stateNode;
          c3 = b3.memoizedProps;
          d4[Of] = b3;
          if (f2 = d4.nodeValue !== c3) {
            if (a4 = xg, null !== a4)
              switch (a4.tag) {
                case 3:
                  Af(d4.nodeValue, c3, 0 !== (a4.mode & 1));
                  break;
                case 5:
                  true !== a4.memoizedProps.suppressHydrationWarning && Af(d4.nodeValue, c3, 0 !== (a4.mode & 1));
              }
          }
          f2 && (b3.flags |= 4);
        } else
          d4 = (9 === c3.nodeType ? c3 : c3.ownerDocument).createTextNode(d4), d4[Of] = b3, b3.stateNode = d4;
      }
      S$2(b3);
      return null;
    case 13:
      E$4(M$2);
      d4 = b3.memoizedState;
      if (null === a4 || null !== a4.memoizedState && null !== a4.memoizedState.dehydrated) {
        if (I$1 && null !== yg && 0 !== (b3.mode & 1) && 0 === (b3.flags & 128))
          Hg(), Ig(), b3.flags |= 98560, f2 = false;
        else if (f2 = Gg(b3), null !== d4 && null !== d4.dehydrated) {
          if (null === a4) {
            if (!f2)
              throw Error(p$7(318));
            f2 = b3.memoizedState;
            f2 = null !== f2 ? f2.dehydrated : null;
            if (!f2)
              throw Error(p$7(317));
            f2[Of] = b3;
          } else
            Ig(), 0 === (b3.flags & 128) && (b3.memoizedState = null), b3.flags |= 4;
          S$2(b3);
          f2 = false;
        } else
          null !== zg && (Gj(zg), zg = null), f2 = true;
        if (!f2)
          return b3.flags & 65536 ? b3 : null;
      }
      if (0 !== (b3.flags & 128))
        return b3.lanes = c3, b3;
      d4 = null !== d4;
      d4 !== (null !== a4 && null !== a4.memoizedState) && d4 && (b3.child.flags |= 8192, 0 !== (b3.mode & 1) && (null === a4 || 0 !== (M$2.current & 1) ? 0 === T$2 && (T$2 = 3) : uj()));
      null !== b3.updateQueue && (b3.flags |= 4);
      S$2(b3);
      return null;
    case 4:
      return Jh(), Bj(a4, b3), null === a4 && sf(b3.stateNode.containerInfo), S$2(b3), null;
    case 10:
      return Rg(b3.type._context), S$2(b3), null;
    case 17:
      return Zf(b3.type) && $f(), S$2(b3), null;
    case 19:
      E$4(M$2);
      f2 = b3.memoizedState;
      if (null === f2)
        return S$2(b3), null;
      d4 = 0 !== (b3.flags & 128);
      g2 = f2.rendering;
      if (null === g2)
        if (d4)
          Ej(f2, false);
        else {
          if (0 !== T$2 || null !== a4 && 0 !== (a4.flags & 128))
            for (a4 = b3.child; null !== a4; ) {
              g2 = Mh(a4);
              if (null !== g2) {
                b3.flags |= 128;
                Ej(f2, false);
                d4 = g2.updateQueue;
                null !== d4 && (b3.updateQueue = d4, b3.flags |= 4);
                b3.subtreeFlags = 0;
                d4 = c3;
                for (c3 = b3.child; null !== c3; )
                  f2 = c3, a4 = d4, f2.flags &= 14680066, g2 = f2.alternate, null === g2 ? (f2.childLanes = 0, f2.lanes = a4, f2.child = null, f2.subtreeFlags = 0, f2.memoizedProps = null, f2.memoizedState = null, f2.updateQueue = null, f2.dependencies = null, f2.stateNode = null) : (f2.childLanes = g2.childLanes, f2.lanes = g2.lanes, f2.child = g2.child, f2.subtreeFlags = 0, f2.deletions = null, f2.memoizedProps = g2.memoizedProps, f2.memoizedState = g2.memoizedState, f2.updateQueue = g2.updateQueue, f2.type = g2.type, a4 = g2.dependencies, f2.dependencies = null === a4 ? null : { lanes: a4.lanes, firstContext: a4.firstContext }), c3 = c3.sibling;
                G(M$2, M$2.current & 1 | 2);
                return b3.child;
              }
              a4 = a4.sibling;
            }
          null !== f2.tail && B() > Hj && (b3.flags |= 128, d4 = true, Ej(f2, false), b3.lanes = 4194304);
        }
      else {
        if (!d4)
          if (a4 = Mh(g2), null !== a4) {
            if (b3.flags |= 128, d4 = true, c3 = a4.updateQueue, null !== c3 && (b3.updateQueue = c3, b3.flags |= 4), Ej(f2, true), null === f2.tail && "hidden" === f2.tailMode && !g2.alternate && !I$1)
              return S$2(b3), null;
          } else
            2 * B() - f2.renderingStartTime > Hj && 1073741824 !== c3 && (b3.flags |= 128, d4 = true, Ej(f2, false), b3.lanes = 4194304);
        f2.isBackwards ? (g2.sibling = b3.child, b3.child = g2) : (c3 = f2.last, null !== c3 ? c3.sibling = g2 : b3.child = g2, f2.last = g2);
      }
      if (null !== f2.tail)
        return b3 = f2.tail, f2.rendering = b3, f2.tail = b3.sibling, f2.renderingStartTime = B(), b3.sibling = null, c3 = M$2.current, G(M$2, d4 ? c3 & 1 | 2 : c3 & 1), b3;
      S$2(b3);
      return null;
    case 22:
    case 23:
      return Ij(), d4 = null !== b3.memoizedState, null !== a4 && null !== a4.memoizedState !== d4 && (b3.flags |= 8192), d4 && 0 !== (b3.mode & 1) ? 0 !== (gj & 1073741824) && (S$2(b3), b3.subtreeFlags & 6 && (b3.flags |= 8192)) : S$2(b3), null;
    case 24:
      return null;
    case 25:
      return null;
  }
  throw Error(p$7(156, b3.tag));
}
function Jj(a4, b3) {
  wg(b3);
  switch (b3.tag) {
    case 1:
      return Zf(b3.type) && $f(), a4 = b3.flags, a4 & 65536 ? (b3.flags = a4 & -65537 | 128, b3) : null;
    case 3:
      return Jh(), E$4(Wf), E$4(H), Oh(), a4 = b3.flags, 0 !== (a4 & 65536) && 0 === (a4 & 128) ? (b3.flags = a4 & -65537 | 128, b3) : null;
    case 5:
      return Lh(b3), null;
    case 13:
      E$4(M$2);
      a4 = b3.memoizedState;
      if (null !== a4 && null !== a4.dehydrated) {
        if (null === b3.alternate)
          throw Error(p$7(340));
        Ig();
      }
      a4 = b3.flags;
      return a4 & 65536 ? (b3.flags = a4 & -65537 | 128, b3) : null;
    case 19:
      return E$4(M$2), null;
    case 4:
      return Jh(), null;
    case 10:
      return Rg(b3.type._context), null;
    case 22:
    case 23:
      return Ij(), null;
    case 24:
      return null;
    default:
      return null;
  }
}
var Kj = false, U$1 = false, Lj = "function" === typeof WeakSet ? WeakSet : Set, V$1 = null;
function Mj(a4, b3) {
  var c3 = a4.ref;
  if (null !== c3)
    if ("function" === typeof c3)
      try {
        c3(null);
      } catch (d4) {
        W(a4, b3, d4);
      }
    else
      c3.current = null;
}
function Nj(a4, b3, c3) {
  try {
    c3();
  } catch (d4) {
    W(a4, b3, d4);
  }
}
var Oj = false;
function Pj(a4, b3) {
  Cf = dd;
  a4 = Me$1();
  if (Ne$1(a4)) {
    if ("selectionStart" in a4)
      var c3 = { start: a4.selectionStart, end: a4.selectionEnd };
    else
      a: {
        c3 = (c3 = a4.ownerDocument) && c3.defaultView || window;
        var d4 = c3.getSelection && c3.getSelection();
        if (d4 && 0 !== d4.rangeCount) {
          c3 = d4.anchorNode;
          var e3 = d4.anchorOffset, f2 = d4.focusNode;
          d4 = d4.focusOffset;
          try {
            c3.nodeType, f2.nodeType;
          } catch (F2) {
            c3 = null;
            break a;
          }
          var g2 = 0, h4 = -1, k3 = -1, l2 = 0, m4 = 0, q3 = a4, r2 = null;
          b:
            for (; ; ) {
              for (var y4; ; ) {
                q3 !== c3 || 0 !== e3 && 3 !== q3.nodeType || (h4 = g2 + e3);
                q3 !== f2 || 0 !== d4 && 3 !== q3.nodeType || (k3 = g2 + d4);
                3 === q3.nodeType && (g2 += q3.nodeValue.length);
                if (null === (y4 = q3.firstChild))
                  break;
                r2 = q3;
                q3 = y4;
              }
              for (; ; ) {
                if (q3 === a4)
                  break b;
                r2 === c3 && ++l2 === e3 && (h4 = g2);
                r2 === f2 && ++m4 === d4 && (k3 = g2);
                if (null !== (y4 = q3.nextSibling))
                  break;
                q3 = r2;
                r2 = q3.parentNode;
              }
              q3 = y4;
            }
          c3 = -1 === h4 || -1 === k3 ? null : { start: h4, end: k3 };
        } else
          c3 = null;
      }
    c3 = c3 || { start: 0, end: 0 };
  } else
    c3 = null;
  Df = { focusedElem: a4, selectionRange: c3 };
  dd = false;
  for (V$1 = b3; null !== V$1; )
    if (b3 = V$1, a4 = b3.child, 0 !== (b3.subtreeFlags & 1028) && null !== a4)
      a4.return = b3, V$1 = a4;
    else
      for (; null !== V$1; ) {
        b3 = V$1;
        try {
          var n2 = b3.alternate;
          if (0 !== (b3.flags & 1024))
            switch (b3.tag) {
              case 0:
              case 11:
              case 15:
                break;
              case 1:
                if (null !== n2) {
                  var t3 = n2.memoizedProps, J2 = n2.memoizedState, x3 = b3.stateNode, w3 = x3.getSnapshotBeforeUpdate(b3.elementType === b3.type ? t3 : Lg(b3.type, t3), J2);
                  x3.__reactInternalSnapshotBeforeUpdate = w3;
                }
                break;
              case 3:
                var u3 = b3.stateNode.containerInfo;
                1 === u3.nodeType ? u3.textContent = "" : 9 === u3.nodeType && u3.documentElement && u3.removeChild(u3.documentElement);
                break;
              case 5:
              case 6:
              case 4:
              case 17:
                break;
              default:
                throw Error(p$7(163));
            }
        } catch (F2) {
          W(b3, b3.return, F2);
        }
        a4 = b3.sibling;
        if (null !== a4) {
          a4.return = b3.return;
          V$1 = a4;
          break;
        }
        V$1 = b3.return;
      }
  n2 = Oj;
  Oj = false;
  return n2;
}
function Qj(a4, b3, c3) {
  var d4 = b3.updateQueue;
  d4 = null !== d4 ? d4.lastEffect : null;
  if (null !== d4) {
    var e3 = d4 = d4.next;
    do {
      if ((e3.tag & a4) === a4) {
        var f2 = e3.destroy;
        e3.destroy = void 0;
        void 0 !== f2 && Nj(b3, c3, f2);
      }
      e3 = e3.next;
    } while (e3 !== d4);
  }
}
function Rj(a4, b3) {
  b3 = b3.updateQueue;
  b3 = null !== b3 ? b3.lastEffect : null;
  if (null !== b3) {
    var c3 = b3 = b3.next;
    do {
      if ((c3.tag & a4) === a4) {
        var d4 = c3.create;
        c3.destroy = d4();
      }
      c3 = c3.next;
    } while (c3 !== b3);
  }
}
function Sj(a4) {
  var b3 = a4.ref;
  if (null !== b3) {
    var c3 = a4.stateNode;
    switch (a4.tag) {
      case 5:
        a4 = c3;
        break;
      default:
        a4 = c3;
    }
    "function" === typeof b3 ? b3(a4) : b3.current = a4;
  }
}
function Tj(a4) {
  var b3 = a4.alternate;
  null !== b3 && (a4.alternate = null, Tj(b3));
  a4.child = null;
  a4.deletions = null;
  a4.sibling = null;
  5 === a4.tag && (b3 = a4.stateNode, null !== b3 && (delete b3[Of], delete b3[Pf], delete b3[of], delete b3[Qf], delete b3[Rf]));
  a4.stateNode = null;
  a4.return = null;
  a4.dependencies = null;
  a4.memoizedProps = null;
  a4.memoizedState = null;
  a4.pendingProps = null;
  a4.stateNode = null;
  a4.updateQueue = null;
}
function Uj(a4) {
  return 5 === a4.tag || 3 === a4.tag || 4 === a4.tag;
}
function Vj(a4) {
  a:
    for (; ; ) {
      for (; null === a4.sibling; ) {
        if (null === a4.return || Uj(a4.return))
          return null;
        a4 = a4.return;
      }
      a4.sibling.return = a4.return;
      for (a4 = a4.sibling; 5 !== a4.tag && 6 !== a4.tag && 18 !== a4.tag; ) {
        if (a4.flags & 2)
          continue a;
        if (null === a4.child || 4 === a4.tag)
          continue a;
        else
          a4.child.return = a4, a4 = a4.child;
      }
      if (!(a4.flags & 2))
        return a4.stateNode;
    }
}
function Wj(a4, b3, c3) {
  var d4 = a4.tag;
  if (5 === d4 || 6 === d4)
    a4 = a4.stateNode, b3 ? 8 === c3.nodeType ? c3.parentNode.insertBefore(a4, b3) : c3.insertBefore(a4, b3) : (8 === c3.nodeType ? (b3 = c3.parentNode, b3.insertBefore(a4, c3)) : (b3 = c3, b3.appendChild(a4)), c3 = c3._reactRootContainer, null !== c3 && void 0 !== c3 || null !== b3.onclick || (b3.onclick = Bf));
  else if (4 !== d4 && (a4 = a4.child, null !== a4))
    for (Wj(a4, b3, c3), a4 = a4.sibling; null !== a4; )
      Wj(a4, b3, c3), a4 = a4.sibling;
}
function Xj(a4, b3, c3) {
  var d4 = a4.tag;
  if (5 === d4 || 6 === d4)
    a4 = a4.stateNode, b3 ? c3.insertBefore(a4, b3) : c3.appendChild(a4);
  else if (4 !== d4 && (a4 = a4.child, null !== a4))
    for (Xj(a4, b3, c3), a4 = a4.sibling; null !== a4; )
      Xj(a4, b3, c3), a4 = a4.sibling;
}
var X = null, Yj = false;
function Zj(a4, b3, c3) {
  for (c3 = c3.child; null !== c3; )
    ak(a4, b3, c3), c3 = c3.sibling;
}
function ak(a4, b3, c3) {
  if (lc && "function" === typeof lc.onCommitFiberUnmount)
    try {
      lc.onCommitFiberUnmount(kc, c3);
    } catch (h4) {
    }
  switch (c3.tag) {
    case 5:
      U$1 || Mj(c3, b3);
    case 6:
      var d4 = X, e3 = Yj;
      X = null;
      Zj(a4, b3, c3);
      X = d4;
      Yj = e3;
      null !== X && (Yj ? (a4 = X, c3 = c3.stateNode, 8 === a4.nodeType ? a4.parentNode.removeChild(c3) : a4.removeChild(c3)) : X.removeChild(c3.stateNode));
      break;
    case 18:
      null !== X && (Yj ? (a4 = X, c3 = c3.stateNode, 8 === a4.nodeType ? Kf(a4.parentNode, c3) : 1 === a4.nodeType && Kf(a4, c3), bd(a4)) : Kf(X, c3.stateNode));
      break;
    case 4:
      d4 = X;
      e3 = Yj;
      X = c3.stateNode.containerInfo;
      Yj = true;
      Zj(a4, b3, c3);
      X = d4;
      Yj = e3;
      break;
    case 0:
    case 11:
    case 14:
    case 15:
      if (!U$1 && (d4 = c3.updateQueue, null !== d4 && (d4 = d4.lastEffect, null !== d4))) {
        e3 = d4 = d4.next;
        do {
          var f2 = e3, g2 = f2.destroy;
          f2 = f2.tag;
          void 0 !== g2 && (0 !== (f2 & 2) ? Nj(c3, b3, g2) : 0 !== (f2 & 4) && Nj(c3, b3, g2));
          e3 = e3.next;
        } while (e3 !== d4);
      }
      Zj(a4, b3, c3);
      break;
    case 1:
      if (!U$1 && (Mj(c3, b3), d4 = c3.stateNode, "function" === typeof d4.componentWillUnmount))
        try {
          d4.props = c3.memoizedProps, d4.state = c3.memoizedState, d4.componentWillUnmount();
        } catch (h4) {
          W(c3, b3, h4);
        }
      Zj(a4, b3, c3);
      break;
    case 21:
      Zj(a4, b3, c3);
      break;
    case 22:
      c3.mode & 1 ? (U$1 = (d4 = U$1) || null !== c3.memoizedState, Zj(a4, b3, c3), U$1 = d4) : Zj(a4, b3, c3);
      break;
    default:
      Zj(a4, b3, c3);
  }
}
function bk(a4) {
  var b3 = a4.updateQueue;
  if (null !== b3) {
    a4.updateQueue = null;
    var c3 = a4.stateNode;
    null === c3 && (c3 = a4.stateNode = new Lj());
    b3.forEach(function(b4) {
      var d4 = ck.bind(null, a4, b4);
      c3.has(b4) || (c3.add(b4), b4.then(d4, d4));
    });
  }
}
function dk(a4, b3) {
  var c3 = b3.deletions;
  if (null !== c3)
    for (var d4 = 0; d4 < c3.length; d4++) {
      var e3 = c3[d4];
      try {
        var f2 = a4, g2 = b3, h4 = g2;
        a:
          for (; null !== h4; ) {
            switch (h4.tag) {
              case 5:
                X = h4.stateNode;
                Yj = false;
                break a;
              case 3:
                X = h4.stateNode.containerInfo;
                Yj = true;
                break a;
              case 4:
                X = h4.stateNode.containerInfo;
                Yj = true;
                break a;
            }
            h4 = h4.return;
          }
        if (null === X)
          throw Error(p$7(160));
        ak(f2, g2, e3);
        X = null;
        Yj = false;
        var k3 = e3.alternate;
        null !== k3 && (k3.return = null);
        e3.return = null;
      } catch (l2) {
        W(e3, b3, l2);
      }
    }
  if (b3.subtreeFlags & 12854)
    for (b3 = b3.child; null !== b3; )
      ek(b3, a4), b3 = b3.sibling;
}
function ek(a4, b3) {
  var c3 = a4.alternate, d4 = a4.flags;
  switch (a4.tag) {
    case 0:
    case 11:
    case 14:
    case 15:
      dk(b3, a4);
      fk(a4);
      if (d4 & 4) {
        try {
          Qj(3, a4, a4.return), Rj(3, a4);
        } catch (t3) {
          W(a4, a4.return, t3);
        }
        try {
          Qj(5, a4, a4.return);
        } catch (t3) {
          W(a4, a4.return, t3);
        }
      }
      break;
    case 1:
      dk(b3, a4);
      fk(a4);
      d4 & 512 && null !== c3 && Mj(c3, c3.return);
      break;
    case 5:
      dk(b3, a4);
      fk(a4);
      d4 & 512 && null !== c3 && Mj(c3, c3.return);
      if (a4.flags & 32) {
        var e3 = a4.stateNode;
        try {
          ob(e3, "");
        } catch (t3) {
          W(a4, a4.return, t3);
        }
      }
      if (d4 & 4 && (e3 = a4.stateNode, null != e3)) {
        var f2 = a4.memoizedProps, g2 = null !== c3 ? c3.memoizedProps : f2, h4 = a4.type, k3 = a4.updateQueue;
        a4.updateQueue = null;
        if (null !== k3)
          try {
            "input" === h4 && "radio" === f2.type && null != f2.name && ab(e3, f2);
            vb(h4, g2);
            var l2 = vb(h4, f2);
            for (g2 = 0; g2 < k3.length; g2 += 2) {
              var m4 = k3[g2], q3 = k3[g2 + 1];
              "style" === m4 ? sb(e3, q3) : "dangerouslySetInnerHTML" === m4 ? nb(e3, q3) : "children" === m4 ? ob(e3, q3) : ta(e3, m4, q3, l2);
            }
            switch (h4) {
              case "input":
                bb(e3, f2);
                break;
              case "textarea":
                ib(e3, f2);
                break;
              case "select":
                var r2 = e3._wrapperState.wasMultiple;
                e3._wrapperState.wasMultiple = !!f2.multiple;
                var y4 = f2.value;
                null != y4 ? fb(e3, !!f2.multiple, y4, false) : r2 !== !!f2.multiple && (null != f2.defaultValue ? fb(
                  e3,
                  !!f2.multiple,
                  f2.defaultValue,
                  true
                ) : fb(e3, !!f2.multiple, f2.multiple ? [] : "", false));
            }
            e3[Pf] = f2;
          } catch (t3) {
            W(a4, a4.return, t3);
          }
      }
      break;
    case 6:
      dk(b3, a4);
      fk(a4);
      if (d4 & 4) {
        if (null === a4.stateNode)
          throw Error(p$7(162));
        e3 = a4.stateNode;
        f2 = a4.memoizedProps;
        try {
          e3.nodeValue = f2;
        } catch (t3) {
          W(a4, a4.return, t3);
        }
      }
      break;
    case 3:
      dk(b3, a4);
      fk(a4);
      if (d4 & 4 && null !== c3 && c3.memoizedState.isDehydrated)
        try {
          bd(b3.containerInfo);
        } catch (t3) {
          W(a4, a4.return, t3);
        }
      break;
    case 4:
      dk(b3, a4);
      fk(a4);
      break;
    case 13:
      dk(b3, a4);
      fk(a4);
      e3 = a4.child;
      e3.flags & 8192 && (f2 = null !== e3.memoizedState, e3.stateNode.isHidden = f2, !f2 || null !== e3.alternate && null !== e3.alternate.memoizedState || (gk = B()));
      d4 & 4 && bk(a4);
      break;
    case 22:
      m4 = null !== c3 && null !== c3.memoizedState;
      a4.mode & 1 ? (U$1 = (l2 = U$1) || m4, dk(b3, a4), U$1 = l2) : dk(b3, a4);
      fk(a4);
      if (d4 & 8192) {
        l2 = null !== a4.memoizedState;
        if ((a4.stateNode.isHidden = l2) && !m4 && 0 !== (a4.mode & 1))
          for (V$1 = a4, m4 = a4.child; null !== m4; ) {
            for (q3 = V$1 = m4; null !== V$1; ) {
              r2 = V$1;
              y4 = r2.child;
              switch (r2.tag) {
                case 0:
                case 11:
                case 14:
                case 15:
                  Qj(4, r2, r2.return);
                  break;
                case 1:
                  Mj(r2, r2.return);
                  var n2 = r2.stateNode;
                  if ("function" === typeof n2.componentWillUnmount) {
                    d4 = r2;
                    c3 = r2.return;
                    try {
                      b3 = d4, n2.props = b3.memoizedProps, n2.state = b3.memoizedState, n2.componentWillUnmount();
                    } catch (t3) {
                      W(d4, c3, t3);
                    }
                  }
                  break;
                case 5:
                  Mj(r2, r2.return);
                  break;
                case 22:
                  if (null !== r2.memoizedState) {
                    hk(q3);
                    continue;
                  }
              }
              null !== y4 ? (y4.return = r2, V$1 = y4) : hk(q3);
            }
            m4 = m4.sibling;
          }
        a:
          for (m4 = null, q3 = a4; ; ) {
            if (5 === q3.tag) {
              if (null === m4) {
                m4 = q3;
                try {
                  e3 = q3.stateNode, l2 ? (f2 = e3.style, "function" === typeof f2.setProperty ? f2.setProperty("display", "none", "important") : f2.display = "none") : (h4 = q3.stateNode, k3 = q3.memoizedProps.style, g2 = void 0 !== k3 && null !== k3 && k3.hasOwnProperty("display") ? k3.display : null, h4.style.display = rb("display", g2));
                } catch (t3) {
                  W(a4, a4.return, t3);
                }
              }
            } else if (6 === q3.tag) {
              if (null === m4)
                try {
                  q3.stateNode.nodeValue = l2 ? "" : q3.memoizedProps;
                } catch (t3) {
                  W(a4, a4.return, t3);
                }
            } else if ((22 !== q3.tag && 23 !== q3.tag || null === q3.memoizedState || q3 === a4) && null !== q3.child) {
              q3.child.return = q3;
              q3 = q3.child;
              continue;
            }
            if (q3 === a4)
              break a;
            for (; null === q3.sibling; ) {
              if (null === q3.return || q3.return === a4)
                break a;
              m4 === q3 && (m4 = null);
              q3 = q3.return;
            }
            m4 === q3 && (m4 = null);
            q3.sibling.return = q3.return;
            q3 = q3.sibling;
          }
      }
      break;
    case 19:
      dk(b3, a4);
      fk(a4);
      d4 & 4 && bk(a4);
      break;
    case 21:
      break;
    default:
      dk(
        b3,
        a4
      ), fk(a4);
  }
}
function fk(a4) {
  var b3 = a4.flags;
  if (b3 & 2) {
    try {
      a: {
        for (var c3 = a4.return; null !== c3; ) {
          if (Uj(c3)) {
            var d4 = c3;
            break a;
          }
          c3 = c3.return;
        }
        throw Error(p$7(160));
      }
      switch (d4.tag) {
        case 5:
          var e3 = d4.stateNode;
          d4.flags & 32 && (ob(e3, ""), d4.flags &= -33);
          var f2 = Vj(a4);
          Xj(a4, f2, e3);
          break;
        case 3:
        case 4:
          var g2 = d4.stateNode.containerInfo, h4 = Vj(a4);
          Wj(a4, h4, g2);
          break;
        default:
          throw Error(p$7(161));
      }
    } catch (k3) {
      W(a4, a4.return, k3);
    }
    a4.flags &= -3;
  }
  b3 & 4096 && (a4.flags &= -4097);
}
function ik(a4, b3, c3) {
  V$1 = a4;
  jk(a4);
}
function jk(a4, b3, c3) {
  for (var d4 = 0 !== (a4.mode & 1); null !== V$1; ) {
    var e3 = V$1, f2 = e3.child;
    if (22 === e3.tag && d4) {
      var g2 = null !== e3.memoizedState || Kj;
      if (!g2) {
        var h4 = e3.alternate, k3 = null !== h4 && null !== h4.memoizedState || U$1;
        h4 = Kj;
        var l2 = U$1;
        Kj = g2;
        if ((U$1 = k3) && !l2)
          for (V$1 = e3; null !== V$1; )
            g2 = V$1, k3 = g2.child, 22 === g2.tag && null !== g2.memoizedState ? kk(e3) : null !== k3 ? (k3.return = g2, V$1 = k3) : kk(e3);
        for (; null !== f2; )
          V$1 = f2, jk(f2), f2 = f2.sibling;
        V$1 = e3;
        Kj = h4;
        U$1 = l2;
      }
      lk(a4);
    } else
      0 !== (e3.subtreeFlags & 8772) && null !== f2 ? (f2.return = e3, V$1 = f2) : lk(a4);
  }
}
function lk(a4) {
  for (; null !== V$1; ) {
    var b3 = V$1;
    if (0 !== (b3.flags & 8772)) {
      var c3 = b3.alternate;
      try {
        if (0 !== (b3.flags & 8772))
          switch (b3.tag) {
            case 0:
            case 11:
            case 15:
              U$1 || Rj(5, b3);
              break;
            case 1:
              var d4 = b3.stateNode;
              if (b3.flags & 4 && !U$1)
                if (null === c3)
                  d4.componentDidMount();
                else {
                  var e3 = b3.elementType === b3.type ? c3.memoizedProps : Lg(b3.type, c3.memoizedProps);
                  d4.componentDidUpdate(e3, c3.memoizedState, d4.__reactInternalSnapshotBeforeUpdate);
                }
              var f2 = b3.updateQueue;
              null !== f2 && ih(b3, f2, d4);
              break;
            case 3:
              var g2 = b3.updateQueue;
              if (null !== g2) {
                c3 = null;
                if (null !== b3.child)
                  switch (b3.child.tag) {
                    case 5:
                      c3 = b3.child.stateNode;
                      break;
                    case 1:
                      c3 = b3.child.stateNode;
                  }
                ih(b3, g2, c3);
              }
              break;
            case 5:
              var h4 = b3.stateNode;
              if (null === c3 && b3.flags & 4) {
                c3 = h4;
                var k3 = b3.memoizedProps;
                switch (b3.type) {
                  case "button":
                  case "input":
                  case "select":
                  case "textarea":
                    k3.autoFocus && c3.focus();
                    break;
                  case "img":
                    k3.src && (c3.src = k3.src);
                }
              }
              break;
            case 6:
              break;
            case 4:
              break;
            case 12:
              break;
            case 13:
              if (null === b3.memoizedState) {
                var l2 = b3.alternate;
                if (null !== l2) {
                  var m4 = l2.memoizedState;
                  if (null !== m4) {
                    var q3 = m4.dehydrated;
                    null !== q3 && bd(q3);
                  }
                }
              }
              break;
            case 19:
            case 17:
            case 21:
            case 22:
            case 23:
            case 25:
              break;
            default:
              throw Error(p$7(163));
          }
        U$1 || b3.flags & 512 && Sj(b3);
      } catch (r2) {
        W(b3, b3.return, r2);
      }
    }
    if (b3 === a4) {
      V$1 = null;
      break;
    }
    c3 = b3.sibling;
    if (null !== c3) {
      c3.return = b3.return;
      V$1 = c3;
      break;
    }
    V$1 = b3.return;
  }
}
function hk(a4) {
  for (; null !== V$1; ) {
    var b3 = V$1;
    if (b3 === a4) {
      V$1 = null;
      break;
    }
    var c3 = b3.sibling;
    if (null !== c3) {
      c3.return = b3.return;
      V$1 = c3;
      break;
    }
    V$1 = b3.return;
  }
}
function kk(a4) {
  for (; null !== V$1; ) {
    var b3 = V$1;
    try {
      switch (b3.tag) {
        case 0:
        case 11:
        case 15:
          var c3 = b3.return;
          try {
            Rj(4, b3);
          } catch (k3) {
            W(b3, c3, k3);
          }
          break;
        case 1:
          var d4 = b3.stateNode;
          if ("function" === typeof d4.componentDidMount) {
            var e3 = b3.return;
            try {
              d4.componentDidMount();
            } catch (k3) {
              W(b3, e3, k3);
            }
          }
          var f2 = b3.return;
          try {
            Sj(b3);
          } catch (k3) {
            W(b3, f2, k3);
          }
          break;
        case 5:
          var g2 = b3.return;
          try {
            Sj(b3);
          } catch (k3) {
            W(b3, g2, k3);
          }
      }
    } catch (k3) {
      W(b3, b3.return, k3);
    }
    if (b3 === a4) {
      V$1 = null;
      break;
    }
    var h4 = b3.sibling;
    if (null !== h4) {
      h4.return = b3.return;
      V$1 = h4;
      break;
    }
    V$1 = b3.return;
  }
}
var mk = Math.ceil, nk = ua.ReactCurrentDispatcher, ok = ua.ReactCurrentOwner, pk = ua.ReactCurrentBatchConfig, K$1 = 0, R$5 = null, Y = null, Z = 0, gj = 0, fj = Uf(0), T$2 = 0, qk = null, hh = 0, rk = 0, sk = 0, tk = null, uk = null, gk = 0, Hj = Infinity, vk = null, Pi = false, Qi = null, Si = null, wk = false, xk = null, yk = 0, zk = 0, Ak = null, Bk = -1, Ck = 0;
function L() {
  return 0 !== (K$1 & 6) ? B() : -1 !== Bk ? Bk : Bk = B();
}
function lh(a4) {
  if (0 === (a4.mode & 1))
    return 1;
  if (0 !== (K$1 & 2) && 0 !== Z)
    return Z & -Z;
  if (null !== Kg.transition)
    return 0 === Ck && (Ck = yc()), Ck;
  a4 = C$3;
  if (0 !== a4)
    return a4;
  a4 = window.event;
  a4 = void 0 === a4 ? 16 : jd(a4.type);
  return a4;
}
function mh(a4, b3, c3, d4) {
  if (50 < zk)
    throw zk = 0, Ak = null, Error(p$7(185));
  Ac(a4, c3, d4);
  if (0 === (K$1 & 2) || a4 !== R$5)
    a4 === R$5 && (0 === (K$1 & 2) && (rk |= c3), 4 === T$2 && Dk(a4, Z)), Ek(a4, d4), 1 === c3 && 0 === K$1 && 0 === (b3.mode & 1) && (Hj = B() + 500, fg && jg());
}
function Ek(a4, b3) {
  var c3 = a4.callbackNode;
  wc(a4, b3);
  var d4 = uc(a4, a4 === R$5 ? Z : 0);
  if (0 === d4)
    null !== c3 && bc(c3), a4.callbackNode = null, a4.callbackPriority = 0;
  else if (b3 = d4 & -d4, a4.callbackPriority !== b3) {
    null != c3 && bc(c3);
    if (1 === b3)
      0 === a4.tag ? ig(Fk.bind(null, a4)) : hg(Fk.bind(null, a4)), Jf(function() {
        0 === (K$1 & 6) && jg();
      }), c3 = null;
    else {
      switch (Dc(d4)) {
        case 1:
          c3 = fc;
          break;
        case 4:
          c3 = gc;
          break;
        case 16:
          c3 = hc;
          break;
        case 536870912:
          c3 = jc;
          break;
        default:
          c3 = hc;
      }
      c3 = Gk(c3, Hk.bind(null, a4));
    }
    a4.callbackPriority = b3;
    a4.callbackNode = c3;
  }
}
function Hk(a4, b3) {
  Bk = -1;
  Ck = 0;
  if (0 !== (K$1 & 6))
    throw Error(p$7(327));
  var c3 = a4.callbackNode;
  if (Ik() && a4.callbackNode !== c3)
    return null;
  var d4 = uc(a4, a4 === R$5 ? Z : 0);
  if (0 === d4)
    return null;
  if (0 !== (d4 & 30) || 0 !== (d4 & a4.expiredLanes) || b3)
    b3 = Jk(a4, d4);
  else {
    b3 = d4;
    var e3 = K$1;
    K$1 |= 2;
    var f2 = Kk();
    if (R$5 !== a4 || Z !== b3)
      vk = null, Hj = B() + 500, Lk(a4, b3);
    do
      try {
        Mk();
        break;
      } catch (h4) {
        Nk(a4, h4);
      }
    while (1);
    Qg();
    nk.current = f2;
    K$1 = e3;
    null !== Y ? b3 = 0 : (R$5 = null, Z = 0, b3 = T$2);
  }
  if (0 !== b3) {
    2 === b3 && (e3 = xc(a4), 0 !== e3 && (d4 = e3, b3 = Ok(a4, e3)));
    if (1 === b3)
      throw c3 = qk, Lk(a4, 0), Dk(a4, d4), Ek(a4, B()), c3;
    if (6 === b3)
      Dk(a4, d4);
    else {
      e3 = a4.current.alternate;
      if (0 === (d4 & 30) && !Pk(e3) && (b3 = Jk(a4, d4), 2 === b3 && (f2 = xc(a4), 0 !== f2 && (d4 = f2, b3 = Ok(a4, f2))), 1 === b3))
        throw c3 = qk, Lk(a4, 0), Dk(a4, d4), Ek(a4, B()), c3;
      a4.finishedWork = e3;
      a4.finishedLanes = d4;
      switch (b3) {
        case 0:
        case 1:
          throw Error(p$7(345));
        case 2:
          Qk(a4, uk, vk);
          break;
        case 3:
          Dk(a4, d4);
          if ((d4 & 130023424) === d4 && (b3 = gk + 500 - B(), 10 < b3)) {
            if (0 !== uc(a4, 0))
              break;
            e3 = a4.suspendedLanes;
            if ((e3 & d4) !== d4) {
              L();
              a4.pingedLanes |= a4.suspendedLanes & e3;
              break;
            }
            a4.timeoutHandle = Ff(Qk.bind(null, a4, uk, vk), b3);
            break;
          }
          Qk(a4, uk, vk);
          break;
        case 4:
          Dk(a4, d4);
          if ((d4 & 4194240) === d4)
            break;
          b3 = a4.eventTimes;
          for (e3 = -1; 0 < d4; ) {
            var g2 = 31 - oc(d4);
            f2 = 1 << g2;
            g2 = b3[g2];
            g2 > e3 && (e3 = g2);
            d4 &= ~f2;
          }
          d4 = e3;
          d4 = B() - d4;
          d4 = (120 > d4 ? 120 : 480 > d4 ? 480 : 1080 > d4 ? 1080 : 1920 > d4 ? 1920 : 3e3 > d4 ? 3e3 : 4320 > d4 ? 4320 : 1960 * mk(d4 / 1960)) - d4;
          if (10 < d4) {
            a4.timeoutHandle = Ff(Qk.bind(null, a4, uk, vk), d4);
            break;
          }
          Qk(a4, uk, vk);
          break;
        case 5:
          Qk(a4, uk, vk);
          break;
        default:
          throw Error(p$7(329));
      }
    }
  }
  Ek(a4, B());
  return a4.callbackNode === c3 ? Hk.bind(null, a4) : null;
}
function Ok(a4, b3) {
  var c3 = tk;
  a4.current.memoizedState.isDehydrated && (Lk(a4, b3).flags |= 256);
  a4 = Jk(a4, b3);
  2 !== a4 && (b3 = uk, uk = c3, null !== b3 && Gj(b3));
  return a4;
}
function Gj(a4) {
  null === uk ? uk = a4 : uk.push.apply(uk, a4);
}
function Pk(a4) {
  for (var b3 = a4; ; ) {
    if (b3.flags & 16384) {
      var c3 = b3.updateQueue;
      if (null !== c3 && (c3 = c3.stores, null !== c3))
        for (var d4 = 0; d4 < c3.length; d4++) {
          var e3 = c3[d4], f2 = e3.getSnapshot;
          e3 = e3.value;
          try {
            if (!He$1(f2(), e3))
              return false;
          } catch (g2) {
            return false;
          }
        }
    }
    c3 = b3.child;
    if (b3.subtreeFlags & 16384 && null !== c3)
      c3.return = b3, b3 = c3;
    else {
      if (b3 === a4)
        break;
      for (; null === b3.sibling; ) {
        if (null === b3.return || b3.return === a4)
          return true;
        b3 = b3.return;
      }
      b3.sibling.return = b3.return;
      b3 = b3.sibling;
    }
  }
  return true;
}
function Dk(a4, b3) {
  b3 &= ~sk;
  b3 &= ~rk;
  a4.suspendedLanes |= b3;
  a4.pingedLanes &= ~b3;
  for (a4 = a4.expirationTimes; 0 < b3; ) {
    var c3 = 31 - oc(b3), d4 = 1 << c3;
    a4[c3] = -1;
    b3 &= ~d4;
  }
}
function Fk(a4) {
  if (0 !== (K$1 & 6))
    throw Error(p$7(327));
  Ik();
  var b3 = uc(a4, 0);
  if (0 === (b3 & 1))
    return Ek(a4, B()), null;
  var c3 = Jk(a4, b3);
  if (0 !== a4.tag && 2 === c3) {
    var d4 = xc(a4);
    0 !== d4 && (b3 = d4, c3 = Ok(a4, d4));
  }
  if (1 === c3)
    throw c3 = qk, Lk(a4, 0), Dk(a4, b3), Ek(a4, B()), c3;
  if (6 === c3)
    throw Error(p$7(345));
  a4.finishedWork = a4.current.alternate;
  a4.finishedLanes = b3;
  Qk(a4, uk, vk);
  Ek(a4, B());
  return null;
}
function Rk(a4, b3) {
  var c3 = K$1;
  K$1 |= 1;
  try {
    return a4(b3);
  } finally {
    K$1 = c3, 0 === K$1 && (Hj = B() + 500, fg && jg());
  }
}
function Sk(a4) {
  null !== xk && 0 === xk.tag && 0 === (K$1 & 6) && Ik();
  var b3 = K$1;
  K$1 |= 1;
  var c3 = pk.transition, d4 = C$3;
  try {
    if (pk.transition = null, C$3 = 1, a4)
      return a4();
  } finally {
    C$3 = d4, pk.transition = c3, K$1 = b3, 0 === (K$1 & 6) && jg();
  }
}
function Ij() {
  gj = fj.current;
  E$4(fj);
}
function Lk(a4, b3) {
  a4.finishedWork = null;
  a4.finishedLanes = 0;
  var c3 = a4.timeoutHandle;
  -1 !== c3 && (a4.timeoutHandle = -1, Gf(c3));
  if (null !== Y)
    for (c3 = Y.return; null !== c3; ) {
      var d4 = c3;
      wg(d4);
      switch (d4.tag) {
        case 1:
          d4 = d4.type.childContextTypes;
          null !== d4 && void 0 !== d4 && $f();
          break;
        case 3:
          Jh();
          E$4(Wf);
          E$4(H);
          Oh();
          break;
        case 5:
          Lh(d4);
          break;
        case 4:
          Jh();
          break;
        case 13:
          E$4(M$2);
          break;
        case 19:
          E$4(M$2);
          break;
        case 10:
          Rg(d4.type._context);
          break;
        case 22:
        case 23:
          Ij();
      }
      c3 = c3.return;
    }
  R$5 = a4;
  Y = a4 = wh(a4.current, null);
  Z = gj = b3;
  T$2 = 0;
  qk = null;
  sk = rk = hh = 0;
  uk = tk = null;
  if (null !== Wg) {
    for (b3 = 0; b3 < Wg.length; b3++)
      if (c3 = Wg[b3], d4 = c3.interleaved, null !== d4) {
        c3.interleaved = null;
        var e3 = d4.next, f2 = c3.pending;
        if (null !== f2) {
          var g2 = f2.next;
          f2.next = e3;
          d4.next = g2;
        }
        c3.pending = d4;
      }
    Wg = null;
  }
  return a4;
}
function Nk(a4, b3) {
  do {
    var c3 = Y;
    try {
      Qg();
      Ph.current = ai;
      if (Sh) {
        for (var d4 = N.memoizedState; null !== d4; ) {
          var e3 = d4.queue;
          null !== e3 && (e3.pending = null);
          d4 = d4.next;
        }
        Sh = false;
      }
      Rh = 0;
      P$2 = O$3 = N = null;
      Th = false;
      Uh = 0;
      ok.current = null;
      if (null === c3 || null === c3.return) {
        T$2 = 1;
        qk = b3;
        Y = null;
        break;
      }
      a: {
        var f2 = a4, g2 = c3.return, h4 = c3, k3 = b3;
        b3 = Z;
        h4.flags |= 32768;
        if (null !== k3 && "object" === typeof k3 && "function" === typeof k3.then) {
          var l2 = k3, m4 = h4, q3 = m4.tag;
          if (0 === (m4.mode & 1) && (0 === q3 || 11 === q3 || 15 === q3)) {
            var r2 = m4.alternate;
            r2 ? (m4.updateQueue = r2.updateQueue, m4.memoizedState = r2.memoizedState, m4.lanes = r2.lanes) : (m4.updateQueue = null, m4.memoizedState = null);
          }
          var y4 = Vi(g2);
          if (null !== y4) {
            y4.flags &= -257;
            Wi(y4, g2, h4, f2, b3);
            y4.mode & 1 && Ti(f2, l2, b3);
            b3 = y4;
            k3 = l2;
            var n2 = b3.updateQueue;
            if (null === n2) {
              var t3 = /* @__PURE__ */ new Set();
              t3.add(k3);
              b3.updateQueue = t3;
            } else
              n2.add(k3);
            break a;
          } else {
            if (0 === (b3 & 1)) {
              Ti(f2, l2, b3);
              uj();
              break a;
            }
            k3 = Error(p$7(426));
          }
        } else if (I$1 && h4.mode & 1) {
          var J2 = Vi(g2);
          if (null !== J2) {
            0 === (J2.flags & 65536) && (J2.flags |= 256);
            Wi(J2, g2, h4, f2, b3);
            Jg(Ki(k3, h4));
            break a;
          }
        }
        f2 = k3 = Ki(k3, h4);
        4 !== T$2 && (T$2 = 2);
        null === tk ? tk = [f2] : tk.push(f2);
        f2 = g2;
        do {
          switch (f2.tag) {
            case 3:
              f2.flags |= 65536;
              b3 &= -b3;
              f2.lanes |= b3;
              var x3 = Oi(f2, k3, b3);
              fh(f2, x3);
              break a;
            case 1:
              h4 = k3;
              var w3 = f2.type, u3 = f2.stateNode;
              if (0 === (f2.flags & 128) && ("function" === typeof w3.getDerivedStateFromError || null !== u3 && "function" === typeof u3.componentDidCatch && (null === Si || !Si.has(u3)))) {
                f2.flags |= 65536;
                b3 &= -b3;
                f2.lanes |= b3;
                var F2 = Ri(f2, h4, b3);
                fh(f2, F2);
                break a;
              }
          }
          f2 = f2.return;
        } while (null !== f2);
      }
      Tk(c3);
    } catch (na) {
      b3 = na;
      Y === c3 && null !== c3 && (Y = c3 = c3.return);
      continue;
    }
    break;
  } while (1);
}
function Kk() {
  var a4 = nk.current;
  nk.current = ai;
  return null === a4 ? ai : a4;
}
function uj() {
  if (0 === T$2 || 3 === T$2 || 2 === T$2)
    T$2 = 4;
  null === R$5 || 0 === (hh & 268435455) && 0 === (rk & 268435455) || Dk(R$5, Z);
}
function Jk(a4, b3) {
  var c3 = K$1;
  K$1 |= 2;
  var d4 = Kk();
  if (R$5 !== a4 || Z !== b3)
    vk = null, Lk(a4, b3);
  do
    try {
      Uk();
      break;
    } catch (e3) {
      Nk(a4, e3);
    }
  while (1);
  Qg();
  K$1 = c3;
  nk.current = d4;
  if (null !== Y)
    throw Error(p$7(261));
  R$5 = null;
  Z = 0;
  return T$2;
}
function Uk() {
  for (; null !== Y; )
    Vk(Y);
}
function Mk() {
  for (; null !== Y && !cc(); )
    Vk(Y);
}
function Vk(a4) {
  var b3 = Wk(a4.alternate, a4, gj);
  a4.memoizedProps = a4.pendingProps;
  null === b3 ? Tk(a4) : Y = b3;
  ok.current = null;
}
function Tk(a4) {
  var b3 = a4;
  do {
    var c3 = b3.alternate;
    a4 = b3.return;
    if (0 === (b3.flags & 32768)) {
      if (c3 = Fj(c3, b3, gj), null !== c3) {
        Y = c3;
        return;
      }
    } else {
      c3 = Jj(c3, b3);
      if (null !== c3) {
        c3.flags &= 32767;
        Y = c3;
        return;
      }
      if (null !== a4)
        a4.flags |= 32768, a4.subtreeFlags = 0, a4.deletions = null;
      else {
        T$2 = 6;
        Y = null;
        return;
      }
    }
    b3 = b3.sibling;
    if (null !== b3) {
      Y = b3;
      return;
    }
    Y = b3 = a4;
  } while (null !== b3);
  0 === T$2 && (T$2 = 5);
}
function Qk(a4, b3, c3) {
  var d4 = C$3, e3 = pk.transition;
  try {
    pk.transition = null, C$3 = 1, Xk(a4, b3, c3, d4);
  } finally {
    pk.transition = e3, C$3 = d4;
  }
  return null;
}
function Xk(a4, b3, c3, d4) {
  do
    Ik();
  while (null !== xk);
  if (0 !== (K$1 & 6))
    throw Error(p$7(327));
  c3 = a4.finishedWork;
  var e3 = a4.finishedLanes;
  if (null === c3)
    return null;
  a4.finishedWork = null;
  a4.finishedLanes = 0;
  if (c3 === a4.current)
    throw Error(p$7(177));
  a4.callbackNode = null;
  a4.callbackPriority = 0;
  var f2 = c3.lanes | c3.childLanes;
  Bc(a4, f2);
  a4 === R$5 && (Y = R$5 = null, Z = 0);
  0 === (c3.subtreeFlags & 2064) && 0 === (c3.flags & 2064) || wk || (wk = true, Gk(hc, function() {
    Ik();
    return null;
  }));
  f2 = 0 !== (c3.flags & 15990);
  if (0 !== (c3.subtreeFlags & 15990) || f2) {
    f2 = pk.transition;
    pk.transition = null;
    var g2 = C$3;
    C$3 = 1;
    var h4 = K$1;
    K$1 |= 4;
    ok.current = null;
    Pj(a4, c3);
    ek(c3, a4);
    Oe$1(Df);
    dd = !!Cf;
    Df = Cf = null;
    a4.current = c3;
    ik(c3);
    dc();
    K$1 = h4;
    C$3 = g2;
    pk.transition = f2;
  } else
    a4.current = c3;
  wk && (wk = false, xk = a4, yk = e3);
  f2 = a4.pendingLanes;
  0 === f2 && (Si = null);
  mc(c3.stateNode);
  Ek(a4, B());
  if (null !== b3)
    for (d4 = a4.onRecoverableError, c3 = 0; c3 < b3.length; c3++)
      e3 = b3[c3], d4(e3.value, { componentStack: e3.stack, digest: e3.digest });
  if (Pi)
    throw Pi = false, a4 = Qi, Qi = null, a4;
  0 !== (yk & 1) && 0 !== a4.tag && Ik();
  f2 = a4.pendingLanes;
  0 !== (f2 & 1) ? a4 === Ak ? zk++ : (zk = 0, Ak = a4) : zk = 0;
  jg();
  return null;
}
function Ik() {
  if (null !== xk) {
    var a4 = Dc(yk), b3 = pk.transition, c3 = C$3;
    try {
      pk.transition = null;
      C$3 = 16 > a4 ? 16 : a4;
      if (null === xk)
        var d4 = false;
      else {
        a4 = xk;
        xk = null;
        yk = 0;
        if (0 !== (K$1 & 6))
          throw Error(p$7(331));
        var e3 = K$1;
        K$1 |= 4;
        for (V$1 = a4.current; null !== V$1; ) {
          var f2 = V$1, g2 = f2.child;
          if (0 !== (V$1.flags & 16)) {
            var h4 = f2.deletions;
            if (null !== h4) {
              for (var k3 = 0; k3 < h4.length; k3++) {
                var l2 = h4[k3];
                for (V$1 = l2; null !== V$1; ) {
                  var m4 = V$1;
                  switch (m4.tag) {
                    case 0:
                    case 11:
                    case 15:
                      Qj(8, m4, f2);
                  }
                  var q3 = m4.child;
                  if (null !== q3)
                    q3.return = m4, V$1 = q3;
                  else
                    for (; null !== V$1; ) {
                      m4 = V$1;
                      var r2 = m4.sibling, y4 = m4.return;
                      Tj(m4);
                      if (m4 === l2) {
                        V$1 = null;
                        break;
                      }
                      if (null !== r2) {
                        r2.return = y4;
                        V$1 = r2;
                        break;
                      }
                      V$1 = y4;
                    }
                }
              }
              var n2 = f2.alternate;
              if (null !== n2) {
                var t3 = n2.child;
                if (null !== t3) {
                  n2.child = null;
                  do {
                    var J2 = t3.sibling;
                    t3.sibling = null;
                    t3 = J2;
                  } while (null !== t3);
                }
              }
              V$1 = f2;
            }
          }
          if (0 !== (f2.subtreeFlags & 2064) && null !== g2)
            g2.return = f2, V$1 = g2;
          else
            b:
              for (; null !== V$1; ) {
                f2 = V$1;
                if (0 !== (f2.flags & 2048))
                  switch (f2.tag) {
                    case 0:
                    case 11:
                    case 15:
                      Qj(9, f2, f2.return);
                  }
                var x3 = f2.sibling;
                if (null !== x3) {
                  x3.return = f2.return;
                  V$1 = x3;
                  break b;
                }
                V$1 = f2.return;
              }
        }
        var w3 = a4.current;
        for (V$1 = w3; null !== V$1; ) {
          g2 = V$1;
          var u3 = g2.child;
          if (0 !== (g2.subtreeFlags & 2064) && null !== u3)
            u3.return = g2, V$1 = u3;
          else
            b:
              for (g2 = w3; null !== V$1; ) {
                h4 = V$1;
                if (0 !== (h4.flags & 2048))
                  try {
                    switch (h4.tag) {
                      case 0:
                      case 11:
                      case 15:
                        Rj(9, h4);
                    }
                  } catch (na) {
                    W(h4, h4.return, na);
                  }
                if (h4 === g2) {
                  V$1 = null;
                  break b;
                }
                var F2 = h4.sibling;
                if (null !== F2) {
                  F2.return = h4.return;
                  V$1 = F2;
                  break b;
                }
                V$1 = h4.return;
              }
        }
        K$1 = e3;
        jg();
        if (lc && "function" === typeof lc.onPostCommitFiberRoot)
          try {
            lc.onPostCommitFiberRoot(kc, a4);
          } catch (na) {
          }
        d4 = true;
      }
      return d4;
    } finally {
      C$3 = c3, pk.transition = b3;
    }
  }
  return false;
}
function Yk(a4, b3, c3) {
  b3 = Ki(c3, b3);
  b3 = Oi(a4, b3, 1);
  a4 = dh(a4, b3, 1);
  b3 = L();
  null !== a4 && (Ac(a4, 1, b3), Ek(a4, b3));
}
function W(a4, b3, c3) {
  if (3 === a4.tag)
    Yk(a4, a4, c3);
  else
    for (; null !== b3; ) {
      if (3 === b3.tag) {
        Yk(b3, a4, c3);
        break;
      } else if (1 === b3.tag) {
        var d4 = b3.stateNode;
        if ("function" === typeof b3.type.getDerivedStateFromError || "function" === typeof d4.componentDidCatch && (null === Si || !Si.has(d4))) {
          a4 = Ki(c3, a4);
          a4 = Ri(b3, a4, 1);
          b3 = dh(b3, a4, 1);
          a4 = L();
          null !== b3 && (Ac(b3, 1, a4), Ek(b3, a4));
          break;
        }
      }
      b3 = b3.return;
    }
}
function Ui(a4, b3, c3) {
  var d4 = a4.pingCache;
  null !== d4 && d4.delete(b3);
  b3 = L();
  a4.pingedLanes |= a4.suspendedLanes & c3;
  R$5 === a4 && (Z & c3) === c3 && (4 === T$2 || 3 === T$2 && (Z & 130023424) === Z && 500 > B() - gk ? Lk(a4, 0) : sk |= c3);
  Ek(a4, b3);
}
function Zk(a4, b3) {
  0 === b3 && (0 === (a4.mode & 1) ? b3 = 1 : (b3 = sc, sc <<= 1, 0 === (sc & 130023424) && (sc = 4194304)));
  var c3 = L();
  a4 = Zg(a4, b3);
  null !== a4 && (Ac(a4, b3, c3), Ek(a4, c3));
}
function vj(a4) {
  var b3 = a4.memoizedState, c3 = 0;
  null !== b3 && (c3 = b3.retryLane);
  Zk(a4, c3);
}
function ck(a4, b3) {
  var c3 = 0;
  switch (a4.tag) {
    case 13:
      var d4 = a4.stateNode;
      var e3 = a4.memoizedState;
      null !== e3 && (c3 = e3.retryLane);
      break;
    case 19:
      d4 = a4.stateNode;
      break;
    default:
      throw Error(p$7(314));
  }
  null !== d4 && d4.delete(b3);
  Zk(a4, c3);
}
var Wk;
Wk = function(a4, b3, c3) {
  if (null !== a4)
    if (a4.memoizedProps !== b3.pendingProps || Wf.current)
      Ug = true;
    else {
      if (0 === (a4.lanes & c3) && 0 === (b3.flags & 128))
        return Ug = false, zj(a4, b3, c3);
      Ug = 0 !== (a4.flags & 131072) ? true : false;
    }
  else
    Ug = false, I$1 && 0 !== (b3.flags & 1048576) && ug(b3, ng, b3.index);
  b3.lanes = 0;
  switch (b3.tag) {
    case 2:
      var d4 = b3.type;
      jj(a4, b3);
      a4 = b3.pendingProps;
      var e3 = Yf(b3, H.current);
      Tg(b3, c3);
      e3 = Xh(null, b3, d4, a4, e3, c3);
      var f2 = bi();
      b3.flags |= 1;
      "object" === typeof e3 && null !== e3 && "function" === typeof e3.render && void 0 === e3.$$typeof ? (b3.tag = 1, b3.memoizedState = null, b3.updateQueue = null, Zf(d4) ? (f2 = true, cg(b3)) : f2 = false, b3.memoizedState = null !== e3.state && void 0 !== e3.state ? e3.state : null, ah(b3), e3.updater = nh, b3.stateNode = e3, e3._reactInternals = b3, rh(b3, d4, a4, c3), b3 = kj(null, b3, d4, true, f2, c3)) : (b3.tag = 0, I$1 && f2 && vg(b3), Yi(null, b3, e3, c3), b3 = b3.child);
      return b3;
    case 16:
      d4 = b3.elementType;
      a: {
        jj(a4, b3);
        a4 = b3.pendingProps;
        e3 = d4._init;
        d4 = e3(d4._payload);
        b3.type = d4;
        e3 = b3.tag = $k(d4);
        a4 = Lg(d4, a4);
        switch (e3) {
          case 0:
            b3 = dj(null, b3, d4, a4, c3);
            break a;
          case 1:
            b3 = ij(null, b3, d4, a4, c3);
            break a;
          case 11:
            b3 = Zi(null, b3, d4, a4, c3);
            break a;
          case 14:
            b3 = aj(null, b3, d4, Lg(d4.type, a4), c3);
            break a;
        }
        throw Error(p$7(
          306,
          d4,
          ""
        ));
      }
      return b3;
    case 0:
      return d4 = b3.type, e3 = b3.pendingProps, e3 = b3.elementType === d4 ? e3 : Lg(d4, e3), dj(a4, b3, d4, e3, c3);
    case 1:
      return d4 = b3.type, e3 = b3.pendingProps, e3 = b3.elementType === d4 ? e3 : Lg(d4, e3), ij(a4, b3, d4, e3, c3);
    case 3:
      a: {
        lj(b3);
        if (null === a4)
          throw Error(p$7(387));
        d4 = b3.pendingProps;
        f2 = b3.memoizedState;
        e3 = f2.element;
        bh(a4, b3);
        gh(b3, d4, null, c3);
        var g2 = b3.memoizedState;
        d4 = g2.element;
        if (f2.isDehydrated)
          if (f2 = { element: d4, isDehydrated: false, cache: g2.cache, pendingSuspenseBoundaries: g2.pendingSuspenseBoundaries, transitions: g2.transitions }, b3.updateQueue.baseState = f2, b3.memoizedState = f2, b3.flags & 256) {
            e3 = Ki(Error(p$7(423)), b3);
            b3 = mj(a4, b3, d4, c3, e3);
            break a;
          } else if (d4 !== e3) {
            e3 = Ki(Error(p$7(424)), b3);
            b3 = mj(a4, b3, d4, c3, e3);
            break a;
          } else
            for (yg = Lf(b3.stateNode.containerInfo.firstChild), xg = b3, I$1 = true, zg = null, c3 = Ch(b3, null, d4, c3), b3.child = c3; c3; )
              c3.flags = c3.flags & -3 | 4096, c3 = c3.sibling;
        else {
          Ig();
          if (d4 === e3) {
            b3 = $i(a4, b3, c3);
            break a;
          }
          Yi(a4, b3, d4, c3);
        }
        b3 = b3.child;
      }
      return b3;
    case 5:
      return Kh(b3), null === a4 && Eg(b3), d4 = b3.type, e3 = b3.pendingProps, f2 = null !== a4 ? a4.memoizedProps : null, g2 = e3.children, Ef(d4, e3) ? g2 = null : null !== f2 && Ef(d4, f2) && (b3.flags |= 32), hj(a4, b3), Yi(a4, b3, g2, c3), b3.child;
    case 6:
      return null === a4 && Eg(b3), null;
    case 13:
      return pj(a4, b3, c3);
    case 4:
      return Ih(b3, b3.stateNode.containerInfo), d4 = b3.pendingProps, null === a4 ? b3.child = Bh(b3, null, d4, c3) : Yi(a4, b3, d4, c3), b3.child;
    case 11:
      return d4 = b3.type, e3 = b3.pendingProps, e3 = b3.elementType === d4 ? e3 : Lg(d4, e3), Zi(a4, b3, d4, e3, c3);
    case 7:
      return Yi(a4, b3, b3.pendingProps, c3), b3.child;
    case 8:
      return Yi(a4, b3, b3.pendingProps.children, c3), b3.child;
    case 12:
      return Yi(a4, b3, b3.pendingProps.children, c3), b3.child;
    case 10:
      a: {
        d4 = b3.type._context;
        e3 = b3.pendingProps;
        f2 = b3.memoizedProps;
        g2 = e3.value;
        G(Mg, d4._currentValue);
        d4._currentValue = g2;
        if (null !== f2)
          if (He$1(f2.value, g2)) {
            if (f2.children === e3.children && !Wf.current) {
              b3 = $i(a4, b3, c3);
              break a;
            }
          } else
            for (f2 = b3.child, null !== f2 && (f2.return = b3); null !== f2; ) {
              var h4 = f2.dependencies;
              if (null !== h4) {
                g2 = f2.child;
                for (var k3 = h4.firstContext; null !== k3; ) {
                  if (k3.context === d4) {
                    if (1 === f2.tag) {
                      k3 = ch(-1, c3 & -c3);
                      k3.tag = 2;
                      var l2 = f2.updateQueue;
                      if (null !== l2) {
                        l2 = l2.shared;
                        var m4 = l2.pending;
                        null === m4 ? k3.next = k3 : (k3.next = m4.next, m4.next = k3);
                        l2.pending = k3;
                      }
                    }
                    f2.lanes |= c3;
                    k3 = f2.alternate;
                    null !== k3 && (k3.lanes |= c3);
                    Sg(
                      f2.return,
                      c3,
                      b3
                    );
                    h4.lanes |= c3;
                    break;
                  }
                  k3 = k3.next;
                }
              } else if (10 === f2.tag)
                g2 = f2.type === b3.type ? null : f2.child;
              else if (18 === f2.tag) {
                g2 = f2.return;
                if (null === g2)
                  throw Error(p$7(341));
                g2.lanes |= c3;
                h4 = g2.alternate;
                null !== h4 && (h4.lanes |= c3);
                Sg(g2, c3, b3);
                g2 = f2.sibling;
              } else
                g2 = f2.child;
              if (null !== g2)
                g2.return = f2;
              else
                for (g2 = f2; null !== g2; ) {
                  if (g2 === b3) {
                    g2 = null;
                    break;
                  }
                  f2 = g2.sibling;
                  if (null !== f2) {
                    f2.return = g2.return;
                    g2 = f2;
                    break;
                  }
                  g2 = g2.return;
                }
              f2 = g2;
            }
        Yi(a4, b3, e3.children, c3);
        b3 = b3.child;
      }
      return b3;
    case 9:
      return e3 = b3.type, d4 = b3.pendingProps.children, Tg(b3, c3), e3 = Vg(e3), d4 = d4(e3), b3.flags |= 1, Yi(a4, b3, d4, c3), b3.child;
    case 14:
      return d4 = b3.type, e3 = Lg(d4, b3.pendingProps), e3 = Lg(d4.type, e3), aj(a4, b3, d4, e3, c3);
    case 15:
      return cj(a4, b3, b3.type, b3.pendingProps, c3);
    case 17:
      return d4 = b3.type, e3 = b3.pendingProps, e3 = b3.elementType === d4 ? e3 : Lg(d4, e3), jj(a4, b3), b3.tag = 1, Zf(d4) ? (a4 = true, cg(b3)) : a4 = false, Tg(b3, c3), ph(b3, d4, e3), rh(b3, d4, e3, c3), kj(null, b3, d4, true, a4, c3);
    case 19:
      return yj(a4, b3, c3);
    case 22:
      return ej(a4, b3, c3);
  }
  throw Error(p$7(156, b3.tag));
};
function Gk(a4, b3) {
  return ac(a4, b3);
}
function al(a4, b3, c3, d4) {
  this.tag = a4;
  this.key = c3;
  this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null;
  this.index = 0;
  this.ref = null;
  this.pendingProps = b3;
  this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null;
  this.mode = d4;
  this.subtreeFlags = this.flags = 0;
  this.deletions = null;
  this.childLanes = this.lanes = 0;
  this.alternate = null;
}
function Bg(a4, b3, c3, d4) {
  return new al(a4, b3, c3, d4);
}
function bj(a4) {
  a4 = a4.prototype;
  return !(!a4 || !a4.isReactComponent);
}
function $k(a4) {
  if ("function" === typeof a4)
    return bj(a4) ? 1 : 0;
  if (void 0 !== a4 && null !== a4) {
    a4 = a4.$$typeof;
    if (a4 === Da)
      return 11;
    if (a4 === Ga)
      return 14;
  }
  return 2;
}
function wh(a4, b3) {
  var c3 = a4.alternate;
  null === c3 ? (c3 = Bg(a4.tag, b3, a4.key, a4.mode), c3.elementType = a4.elementType, c3.type = a4.type, c3.stateNode = a4.stateNode, c3.alternate = a4, a4.alternate = c3) : (c3.pendingProps = b3, c3.type = a4.type, c3.flags = 0, c3.subtreeFlags = 0, c3.deletions = null);
  c3.flags = a4.flags & 14680064;
  c3.childLanes = a4.childLanes;
  c3.lanes = a4.lanes;
  c3.child = a4.child;
  c3.memoizedProps = a4.memoizedProps;
  c3.memoizedState = a4.memoizedState;
  c3.updateQueue = a4.updateQueue;
  b3 = a4.dependencies;
  c3.dependencies = null === b3 ? null : { lanes: b3.lanes, firstContext: b3.firstContext };
  c3.sibling = a4.sibling;
  c3.index = a4.index;
  c3.ref = a4.ref;
  return c3;
}
function yh(a4, b3, c3, d4, e3, f2) {
  var g2 = 2;
  d4 = a4;
  if ("function" === typeof a4)
    bj(a4) && (g2 = 1);
  else if ("string" === typeof a4)
    g2 = 5;
  else
    a:
      switch (a4) {
        case ya:
          return Ah(c3.children, e3, f2, b3);
        case za:
          g2 = 8;
          e3 |= 8;
          break;
        case Aa:
          return a4 = Bg(12, c3, b3, e3 | 2), a4.elementType = Aa, a4.lanes = f2, a4;
        case Ea:
          return a4 = Bg(13, c3, b3, e3), a4.elementType = Ea, a4.lanes = f2, a4;
        case Fa:
          return a4 = Bg(19, c3, b3, e3), a4.elementType = Fa, a4.lanes = f2, a4;
        case Ia:
          return qj(c3, e3, f2, b3);
        default:
          if ("object" === typeof a4 && null !== a4)
            switch (a4.$$typeof) {
              case Ba:
                g2 = 10;
                break a;
              case Ca:
                g2 = 9;
                break a;
              case Da:
                g2 = 11;
                break a;
              case Ga:
                g2 = 14;
                break a;
              case Ha:
                g2 = 16;
                d4 = null;
                break a;
            }
          throw Error(p$7(130, null == a4 ? a4 : typeof a4, ""));
      }
  b3 = Bg(g2, c3, b3, e3);
  b3.elementType = a4;
  b3.type = d4;
  b3.lanes = f2;
  return b3;
}
function Ah(a4, b3, c3, d4) {
  a4 = Bg(7, a4, d4, b3);
  a4.lanes = c3;
  return a4;
}
function qj(a4, b3, c3, d4) {
  a4 = Bg(22, a4, d4, b3);
  a4.elementType = Ia;
  a4.lanes = c3;
  a4.stateNode = { isHidden: false };
  return a4;
}
function xh(a4, b3, c3) {
  a4 = Bg(6, a4, null, b3);
  a4.lanes = c3;
  return a4;
}
function zh(a4, b3, c3) {
  b3 = Bg(4, null !== a4.children ? a4.children : [], a4.key, b3);
  b3.lanes = c3;
  b3.stateNode = { containerInfo: a4.containerInfo, pendingChildren: null, implementation: a4.implementation };
  return b3;
}
function bl(a4, b3, c3, d4, e3) {
  this.tag = b3;
  this.containerInfo = a4;
  this.finishedWork = this.pingCache = this.current = this.pendingChildren = null;
  this.timeoutHandle = -1;
  this.callbackNode = this.pendingContext = this.context = null;
  this.callbackPriority = 0;
  this.eventTimes = zc(0);
  this.expirationTimes = zc(-1);
  this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0;
  this.entanglements = zc(0);
  this.identifierPrefix = d4;
  this.onRecoverableError = e3;
  this.mutableSourceEagerHydrationData = null;
}
function cl(a4, b3, c3, d4, e3, f2, g2, h4, k3) {
  a4 = new bl(a4, b3, c3, h4, k3);
  1 === b3 ? (b3 = 1, true === f2 && (b3 |= 8)) : b3 = 0;
  f2 = Bg(3, null, null, b3);
  a4.current = f2;
  f2.stateNode = a4;
  f2.memoizedState = { element: d4, isDehydrated: c3, cache: null, transitions: null, pendingSuspenseBoundaries: null };
  ah(f2);
  return a4;
}
function dl(a4, b3, c3) {
  var d4 = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
  return { $$typeof: wa, key: null == d4 ? null : "" + d4, children: a4, containerInfo: b3, implementation: c3 };
}
function el(a4) {
  if (!a4)
    return Vf;
  a4 = a4._reactInternals;
  a: {
    if (Vb(a4) !== a4 || 1 !== a4.tag)
      throw Error(p$7(170));
    var b3 = a4;
    do {
      switch (b3.tag) {
        case 3:
          b3 = b3.stateNode.context;
          break a;
        case 1:
          if (Zf(b3.type)) {
            b3 = b3.stateNode.__reactInternalMemoizedMergedChildContext;
            break a;
          }
      }
      b3 = b3.return;
    } while (null !== b3);
    throw Error(p$7(171));
  }
  if (1 === a4.tag) {
    var c3 = a4.type;
    if (Zf(c3))
      return bg(a4, c3, b3);
  }
  return b3;
}
function fl(a4, b3, c3, d4, e3, f2, g2, h4, k3) {
  a4 = cl(c3, d4, true, a4, e3, f2, g2, h4, k3);
  a4.context = el(null);
  c3 = a4.current;
  d4 = L();
  e3 = lh(c3);
  f2 = ch(d4, e3);
  f2.callback = void 0 !== b3 && null !== b3 ? b3 : null;
  dh(c3, f2, e3);
  a4.current.lanes = e3;
  Ac(a4, e3, d4);
  Ek(a4, d4);
  return a4;
}
function gl(a4, b3, c3, d4) {
  var e3 = b3.current, f2 = L(), g2 = lh(e3);
  c3 = el(c3);
  null === b3.context ? b3.context = c3 : b3.pendingContext = c3;
  b3 = ch(f2, g2);
  b3.payload = { element: a4 };
  d4 = void 0 === d4 ? null : d4;
  null !== d4 && (b3.callback = d4);
  a4 = dh(e3, b3, g2);
  null !== a4 && (mh(a4, e3, g2, f2), eh(a4, e3, g2));
  return g2;
}
function hl(a4) {
  a4 = a4.current;
  if (!a4.child)
    return null;
  switch (a4.child.tag) {
    case 5:
      return a4.child.stateNode;
    default:
      return a4.child.stateNode;
  }
}
function il(a4, b3) {
  a4 = a4.memoizedState;
  if (null !== a4 && null !== a4.dehydrated) {
    var c3 = a4.retryLane;
    a4.retryLane = 0 !== c3 && c3 < b3 ? c3 : b3;
  }
}
function jl(a4, b3) {
  il(a4, b3);
  (a4 = a4.alternate) && il(a4, b3);
}
function kl() {
  return null;
}
var ll = "function" === typeof reportError ? reportError : function(a4) {
  console.error(a4);
};
function ml(a4) {
  this._internalRoot = a4;
}
nl.prototype.render = ml.prototype.render = function(a4) {
  var b3 = this._internalRoot;
  if (null === b3)
    throw Error(p$7(409));
  gl(a4, b3, null, null);
};
nl.prototype.unmount = ml.prototype.unmount = function() {
  var a4 = this._internalRoot;
  if (null !== a4) {
    this._internalRoot = null;
    var b3 = a4.containerInfo;
    Sk(function() {
      gl(null, a4, null, null);
    });
    b3[uf] = null;
  }
};
function nl(a4) {
  this._internalRoot = a4;
}
nl.prototype.unstable_scheduleHydration = function(a4) {
  if (a4) {
    var b3 = Hc();
    a4 = { blockedOn: null, target: a4, priority: b3 };
    for (var c3 = 0; c3 < Qc.length && 0 !== b3 && b3 < Qc[c3].priority; c3++)
      ;
    Qc.splice(c3, 0, a4);
    0 === c3 && Vc(a4);
  }
};
function ol(a4) {
  return !(!a4 || 1 !== a4.nodeType && 9 !== a4.nodeType && 11 !== a4.nodeType);
}
function pl(a4) {
  return !(!a4 || 1 !== a4.nodeType && 9 !== a4.nodeType && 11 !== a4.nodeType && (8 !== a4.nodeType || " react-mount-point-unstable " !== a4.nodeValue));
}
function ql() {
}
function rl(a4, b3, c3, d4, e3) {
  if (e3) {
    if ("function" === typeof d4) {
      var f2 = d4;
      d4 = function() {
        var a5 = hl(g2);
        f2.call(a5);
      };
    }
    var g2 = fl(b3, d4, a4, 0, null, false, false, "", ql);
    a4._reactRootContainer = g2;
    a4[uf] = g2.current;
    sf(8 === a4.nodeType ? a4.parentNode : a4);
    Sk();
    return g2;
  }
  for (; e3 = a4.lastChild; )
    a4.removeChild(e3);
  if ("function" === typeof d4) {
    var h4 = d4;
    d4 = function() {
      var a5 = hl(k3);
      h4.call(a5);
    };
  }
  var k3 = cl(a4, 0, false, null, null, false, false, "", ql);
  a4._reactRootContainer = k3;
  a4[uf] = k3.current;
  sf(8 === a4.nodeType ? a4.parentNode : a4);
  Sk(function() {
    gl(b3, k3, c3, d4);
  });
  return k3;
}
function sl(a4, b3, c3, d4, e3) {
  var f2 = c3._reactRootContainer;
  if (f2) {
    var g2 = f2;
    if ("function" === typeof e3) {
      var h4 = e3;
      e3 = function() {
        var a5 = hl(g2);
        h4.call(a5);
      };
    }
    gl(b3, g2, a4, e3);
  } else
    g2 = rl(c3, b3, a4, e3, d4);
  return hl(g2);
}
Ec = function(a4) {
  switch (a4.tag) {
    case 3:
      var b3 = a4.stateNode;
      if (b3.current.memoizedState.isDehydrated) {
        var c3 = tc(b3.pendingLanes);
        0 !== c3 && (Cc(b3, c3 | 1), Ek(b3, B()), 0 === (K$1 & 6) && (Hj = B() + 500, jg()));
      }
      break;
    case 13:
      Sk(function() {
        var b4 = Zg(a4, 1);
        if (null !== b4) {
          var c4 = L();
          mh(b4, a4, 1, c4);
        }
      }), jl(a4, 1);
  }
};
Fc = function(a4) {
  if (13 === a4.tag) {
    var b3 = Zg(a4, 134217728);
    if (null !== b3) {
      var c3 = L();
      mh(b3, a4, 134217728, c3);
    }
    jl(a4, 134217728);
  }
};
Gc = function(a4) {
  if (13 === a4.tag) {
    var b3 = lh(a4), c3 = Zg(a4, b3);
    if (null !== c3) {
      var d4 = L();
      mh(c3, a4, b3, d4);
    }
    jl(a4, b3);
  }
};
Hc = function() {
  return C$3;
};
Ic = function(a4, b3) {
  var c3 = C$3;
  try {
    return C$3 = a4, b3();
  } finally {
    C$3 = c3;
  }
};
yb = function(a4, b3, c3) {
  switch (b3) {
    case "input":
      bb(a4, c3);
      b3 = c3.name;
      if ("radio" === c3.type && null != b3) {
        for (c3 = a4; c3.parentNode; )
          c3 = c3.parentNode;
        c3 = c3.querySelectorAll("input[name=" + JSON.stringify("" + b3) + '][type="radio"]');
        for (b3 = 0; b3 < c3.length; b3++) {
          var d4 = c3[b3];
          if (d4 !== a4 && d4.form === a4.form) {
            var e3 = Db(d4);
            if (!e3)
              throw Error(p$7(90));
            Wa(d4);
            bb(d4, e3);
          }
        }
      }
      break;
    case "textarea":
      ib(a4, c3);
      break;
    case "select":
      b3 = c3.value, null != b3 && fb(a4, !!c3.multiple, b3, false);
  }
};
Gb = Rk;
Hb = Sk;
var tl = { usingClientEntryPoint: false, Events: [Cb, ue$1, Db, Eb, Fb, Rk] }, ul = { findFiberByHostInstance: Wc, bundleType: 0, version: "18.2.0", rendererPackageName: "react-dom" };
var vl = { bundleType: ul.bundleType, version: ul.version, rendererPackageName: ul.rendererPackageName, rendererConfig: ul.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: ua.ReactCurrentDispatcher, findHostInstanceByFiber: function(a4) {
  a4 = Zb(a4);
  return null === a4 ? null : a4.stateNode;
}, findFiberByHostInstance: ul.findFiberByHostInstance || kl, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.2.0-next-9e3b772b8-20220608" };
if ("undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) {
  var wl = __REACT_DEVTOOLS_GLOBAL_HOOK__;
  if (!wl.isDisabled && wl.supportsFiber)
    try {
      kc = wl.inject(vl), lc = wl;
    } catch (a4) {
    }
}
reactDom_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = tl;
reactDom_production_min.createPortal = function(a4, b3) {
  var c3 = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
  if (!ol(b3))
    throw Error(p$7(200));
  return dl(a4, b3, null, c3);
};
reactDom_production_min.createRoot = function(a4, b3) {
  if (!ol(a4))
    throw Error(p$7(299));
  var c3 = false, d4 = "", e3 = ll;
  null !== b3 && void 0 !== b3 && (true === b3.unstable_strictMode && (c3 = true), void 0 !== b3.identifierPrefix && (d4 = b3.identifierPrefix), void 0 !== b3.onRecoverableError && (e3 = b3.onRecoverableError));
  b3 = cl(a4, 1, false, null, null, c3, false, d4, e3);
  a4[uf] = b3.current;
  sf(8 === a4.nodeType ? a4.parentNode : a4);
  return new ml(b3);
};
reactDom_production_min.findDOMNode = function(a4) {
  if (null == a4)
    return null;
  if (1 === a4.nodeType)
    return a4;
  var b3 = a4._reactInternals;
  if (void 0 === b3) {
    if ("function" === typeof a4.render)
      throw Error(p$7(188));
    a4 = Object.keys(a4).join(",");
    throw Error(p$7(268, a4));
  }
  a4 = Zb(b3);
  a4 = null === a4 ? null : a4.stateNode;
  return a4;
};
reactDom_production_min.flushSync = function(a4) {
  return Sk(a4);
};
reactDom_production_min.hydrate = function(a4, b3, c3) {
  if (!pl(b3))
    throw Error(p$7(200));
  return sl(null, a4, b3, true, c3);
};
reactDom_production_min.hydrateRoot = function(a4, b3, c3) {
  if (!ol(a4))
    throw Error(p$7(405));
  var d4 = null != c3 && c3.hydratedSources || null, e3 = false, f2 = "", g2 = ll;
  null !== c3 && void 0 !== c3 && (true === c3.unstable_strictMode && (e3 = true), void 0 !== c3.identifierPrefix && (f2 = c3.identifierPrefix), void 0 !== c3.onRecoverableError && (g2 = c3.onRecoverableError));
  b3 = fl(b3, null, a4, 1, null != c3 ? c3 : null, e3, false, f2, g2);
  a4[uf] = b3.current;
  sf(a4);
  if (d4)
    for (a4 = 0; a4 < d4.length; a4++)
      c3 = d4[a4], e3 = c3._getVersion, e3 = e3(c3._source), null == b3.mutableSourceEagerHydrationData ? b3.mutableSourceEagerHydrationData = [c3, e3] : b3.mutableSourceEagerHydrationData.push(
        c3,
        e3
      );
  return new nl(b3);
};
reactDom_production_min.render = function(a4, b3, c3) {
  if (!pl(b3))
    throw Error(p$7(200));
  return sl(null, a4, b3, false, c3);
};
reactDom_production_min.unmountComponentAtNode = function(a4) {
  if (!pl(a4))
    throw Error(p$7(40));
  return a4._reactRootContainer ? (Sk(function() {
    sl(null, null, a4, false, function() {
      a4._reactRootContainer = null;
      a4[uf] = null;
    });
  }), true) : false;
};
reactDom_production_min.unstable_batchedUpdates = Rk;
reactDom_production_min.unstable_renderSubtreeIntoContainer = function(a4, b3, c3, d4) {
  if (!pl(c3))
    throw Error(p$7(200));
  if (null == a4 || void 0 === a4._reactInternals)
    throw Error(p$7(38));
  return sl(a4, b3, c3, false, d4);
};
reactDom_production_min.version = "18.2.0-next-9e3b772b8-20220608";
function checkDCE() {
  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== "function") {
    return;
  }
  try {
    __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
  } catch (err) {
    console.error(err);
  }
}
{
  checkDCE();
  reactDom.exports = reactDom_production_min;
}
var ae = reactDom.exports;
var createRoot;
var m$8 = reactDom.exports;
{
  createRoot = m$8.createRoot;
  m$8.hydrateRoot;
}
function sheetForTag(tag) {
  if (tag.sheet) {
    return tag.sheet;
  }
  for (var i3 = 0; i3 < document.styleSheets.length; i3++) {
    if (document.styleSheets[i3].ownerNode === tag) {
      return document.styleSheets[i3];
    }
  }
}
function createStyleElement(options) {
  var tag = document.createElement("style");
  tag.setAttribute("data-emotion", options.key);
  if (options.nonce !== void 0) {
    tag.setAttribute("nonce", options.nonce);
  }
  tag.appendChild(document.createTextNode(""));
  tag.setAttribute("data-s", "");
  return tag;
}
var StyleSheet = /* @__PURE__ */ function() {
  function StyleSheet2(options) {
    var _this = this;
    this._insertTag = function(tag) {
      var before;
      if (_this.tags.length === 0) {
        if (_this.insertionPoint) {
          before = _this.insertionPoint.nextSibling;
        } else if (_this.prepend) {
          before = _this.container.firstChild;
        } else {
          before = _this.before;
        }
      } else {
        before = _this.tags[_this.tags.length - 1].nextSibling;
      }
      _this.container.insertBefore(tag, before);
      _this.tags.push(tag);
    };
    this.isSpeedy = options.speedy === void 0 ? true : options.speedy;
    this.tags = [];
    this.ctr = 0;
    this.nonce = options.nonce;
    this.key = options.key;
    this.container = options.container;
    this.prepend = options.prepend;
    this.insertionPoint = options.insertionPoint;
    this.before = null;
  }
  var _proto = StyleSheet2.prototype;
  _proto.hydrate = function hydrate(nodes) {
    nodes.forEach(this._insertTag);
  };
  _proto.insert = function insert(rule) {
    if (this.ctr % (this.isSpeedy ? 65e3 : 1) === 0) {
      this._insertTag(createStyleElement(this));
    }
    var tag = this.tags[this.tags.length - 1];
    if (this.isSpeedy) {
      var sheet = sheetForTag(tag);
      try {
        sheet.insertRule(rule, sheet.cssRules.length);
      } catch (e3) {
      }
    } else {
      tag.appendChild(document.createTextNode(rule));
    }
    this.ctr++;
  };
  _proto.flush = function flush() {
    this.tags.forEach(function(tag) {
      return tag.parentNode && tag.parentNode.removeChild(tag);
    });
    this.tags = [];
    this.ctr = 0;
  };
  return StyleSheet2;
}();
var MS = "-ms-";
var MOZ = "-moz-";
var WEBKIT = "-webkit-";
var COMMENT = "comm";
var RULESET = "rule";
var DECLARATION = "decl";
var IMPORT = "@import";
var KEYFRAMES = "@keyframes";
var abs = Math.abs;
var from = String.fromCharCode;
var assign$1 = Object.assign;
function hash$2(value, length2) {
  return charat(value, 0) ^ 45 ? (((length2 << 2 ^ charat(value, 0)) << 2 ^ charat(value, 1)) << 2 ^ charat(value, 2)) << 2 ^ charat(value, 3) : 0;
}
function trim(value) {
  return value.trim();
}
function match$2(value, pattern) {
  return (value = pattern.exec(value)) ? value[0] : value;
}
function replace$1(value, pattern, replacement) {
  return value.replace(pattern, replacement);
}
function indexof(value, search) {
  return value.indexOf(search);
}
function charat(value, index2) {
  return value.charCodeAt(index2) | 0;
}
function substr(value, begin, end2) {
  return value.slice(begin, end2);
}
function strlen(value) {
  return value.length;
}
function sizeof(value) {
  return value.length;
}
function append$1(value, array) {
  return array.push(value), value;
}
function combine$1(array, callback) {
  return array.map(callback).join("");
}
var line = 1;
var column = 1;
var length = 0;
var position = 0;
var character = 0;
var characters = "";
function node(value, root2, parent, type, props, children, length2) {
  return { value, root: root2, parent, type, props, children, line, column, length: length2, return: "" };
}
function copy$1(root2, props) {
  return assign$1(node("", null, null, "", null, null, 0), root2, { length: -root2.length }, props);
}
function char() {
  return character;
}
function prev() {
  character = position > 0 ? charat(characters, --position) : 0;
  if (column--, character === 10)
    column = 1, line--;
  return character;
}
function next() {
  character = position < length ? charat(characters, position++) : 0;
  if (column++, character === 10)
    column = 1, line++;
  return character;
}
function peek() {
  return charat(characters, position);
}
function caret() {
  return position;
}
function slice(begin, end2) {
  return substr(characters, begin, end2);
}
function token(type) {
  switch (type) {
    case 0:
    case 9:
    case 10:
    case 13:
    case 32:
      return 5;
    case 33:
    case 43:
    case 44:
    case 47:
    case 62:
    case 64:
    case 126:
    case 59:
    case 123:
    case 125:
      return 4;
    case 58:
      return 3;
    case 34:
    case 39:
    case 40:
    case 91:
      return 2;
    case 41:
    case 93:
      return 1;
  }
  return 0;
}
function alloc(value) {
  return line = column = 1, length = strlen(characters = value), position = 0, [];
}
function dealloc(value) {
  return characters = "", value;
}
function delimit(type) {
  return trim(slice(position - 1, delimiter(type === 91 ? type + 2 : type === 40 ? type + 1 : type)));
}
function whitespace(type) {
  while (character = peek())
    if (character < 33)
      next();
    else
      break;
  return token(type) > 2 || token(character) > 3 ? "" : " ";
}
function escaping(index2, count) {
  while (--count && next())
    if (character < 48 || character > 102 || character > 57 && character < 65 || character > 70 && character < 97)
      break;
  return slice(index2, caret() + (count < 6 && peek() == 32 && next() == 32));
}
function delimiter(type) {
  while (next())
    switch (character) {
      case type:
        return position;
      case 34:
      case 39:
        if (type !== 34 && type !== 39)
          delimiter(character);
        break;
      case 40:
        if (type === 41)
          delimiter(type);
        break;
      case 92:
        next();
        break;
    }
  return position;
}
function commenter(type, index2) {
  while (next())
    if (type + character === 47 + 10)
      break;
    else if (type + character === 42 + 42 && peek() === 47)
      break;
  return "/*" + slice(index2, position - 1) + "*" + from(type === 47 ? type : next());
}
function identifier(index2) {
  while (!token(peek()))
    next();
  return slice(index2, position);
}
function compile(value) {
  return dealloc(parse$3("", null, null, null, [""], value = alloc(value), 0, [0], value));
}
function parse$3(value, root2, parent, rule, rules, rulesets, pseudo, points, declarations) {
  var index2 = 0;
  var offset2 = 0;
  var length2 = pseudo;
  var atrule = 0;
  var property = 0;
  var previous = 0;
  var variable = 1;
  var scanning = 1;
  var ampersand = 1;
  var character2 = 0;
  var type = "";
  var props = rules;
  var children = rulesets;
  var reference2 = rule;
  var characters2 = type;
  while (scanning)
    switch (previous = character2, character2 = next()) {
      case 40:
        if (previous != 108 && charat(characters2, length2 - 1) == 58) {
          if (indexof(characters2 += replace$1(delimit(character2), "&", "&\f"), "&\f") != -1)
            ampersand = -1;
          break;
        }
      case 34:
      case 39:
      case 91:
        characters2 += delimit(character2);
        break;
      case 9:
      case 10:
      case 13:
      case 32:
        characters2 += whitespace(previous);
        break;
      case 92:
        characters2 += escaping(caret() - 1, 7);
        continue;
      case 47:
        switch (peek()) {
          case 42:
          case 47:
            append$1(comment(commenter(next(), caret()), root2, parent), declarations);
            break;
          default:
            characters2 += "/";
        }
        break;
      case 123 * variable:
        points[index2++] = strlen(characters2) * ampersand;
      case 125 * variable:
      case 59:
      case 0:
        switch (character2) {
          case 0:
          case 125:
            scanning = 0;
          case 59 + offset2:
            if (property > 0 && strlen(characters2) - length2)
              append$1(property > 32 ? declaration(characters2 + ";", rule, parent, length2 - 1) : declaration(replace$1(characters2, " ", "") + ";", rule, parent, length2 - 2), declarations);
            break;
          case 59:
            characters2 += ";";
          default:
            append$1(reference2 = ruleset(characters2, root2, parent, index2, offset2, rules, points, type, props = [], children = [], length2), rulesets);
            if (character2 === 123)
              if (offset2 === 0)
                parse$3(characters2, root2, reference2, reference2, props, rulesets, length2, points, children);
              else
                switch (atrule === 99 && charat(characters2, 3) === 110 ? 100 : atrule) {
                  case 100:
                  case 109:
                  case 115:
                    parse$3(value, reference2, reference2, rule && append$1(ruleset(value, reference2, reference2, 0, 0, rules, points, type, rules, props = [], length2), children), rules, children, length2, points, rule ? props : children);
                    break;
                  default:
                    parse$3(characters2, reference2, reference2, reference2, [""], children, 0, points, children);
                }
        }
        index2 = offset2 = property = 0, variable = ampersand = 1, type = characters2 = "", length2 = pseudo;
        break;
      case 58:
        length2 = 1 + strlen(characters2), property = previous;
      default:
        if (variable < 1) {
          if (character2 == 123)
            --variable;
          else if (character2 == 125 && variable++ == 0 && prev() == 125)
            continue;
        }
        switch (characters2 += from(character2), character2 * variable) {
          case 38:
            ampersand = offset2 > 0 ? 1 : (characters2 += "\f", -1);
            break;
          case 44:
            points[index2++] = (strlen(characters2) - 1) * ampersand, ampersand = 1;
            break;
          case 64:
            if (peek() === 45)
              characters2 += delimit(next());
            atrule = peek(), offset2 = length2 = strlen(type = characters2 += identifier(caret())), character2++;
            break;
          case 45:
            if (previous === 45 && strlen(characters2) == 2)
              variable = 0;
        }
    }
  return rulesets;
}
function ruleset(value, root2, parent, index2, offset2, rules, points, type, props, children, length2) {
  var post = offset2 - 1;
  var rule = offset2 === 0 ? rules : [""];
  var size = sizeof(rule);
  for (var i3 = 0, j2 = 0, k3 = 0; i3 < index2; ++i3)
    for (var x3 = 0, y4 = substr(value, post + 1, post = abs(j2 = points[i3])), z3 = value; x3 < size; ++x3)
      if (z3 = trim(j2 > 0 ? rule[x3] + " " + y4 : replace$1(y4, /&\f/g, rule[x3])))
        props[k3++] = z3;
  return node(value, root2, parent, offset2 === 0 ? RULESET : type, props, children, length2);
}
function comment(value, root2, parent) {
  return node(value, root2, parent, COMMENT, from(char()), substr(value, 2, -2), 0);
}
function declaration(value, root2, parent, length2) {
  return node(value, root2, parent, DECLARATION, substr(value, 0, length2), substr(value, length2 + 1, -1), length2);
}
function serialize(children, callback) {
  var output = "";
  var length2 = sizeof(children);
  for (var i3 = 0; i3 < length2; i3++)
    output += callback(children[i3], i3, children, callback) || "";
  return output;
}
function stringify(element, index2, children, callback) {
  switch (element.type) {
    case IMPORT:
    case DECLARATION:
      return element.return = element.return || element.value;
    case COMMENT:
      return "";
    case KEYFRAMES:
      return element.return = element.value + "{" + serialize(element.children, callback) + "}";
    case RULESET:
      element.value = element.props.join(",");
  }
  return strlen(children = serialize(element.children, callback)) ? element.return = element.value + "{" + children + "}" : "";
}
function middleware(collection) {
  var length2 = sizeof(collection);
  return function(element, index2, children, callback) {
    var output = "";
    for (var i3 = 0; i3 < length2; i3++)
      output += collection[i3](element, index2, children, callback) || "";
    return output;
  };
}
function rulesheet(callback) {
  return function(element) {
    if (!element.root) {
      if (element = element.return)
        callback(element);
    }
  };
}
function memoize(fn3) {
  var cache = /* @__PURE__ */ Object.create(null);
  return function(arg) {
    if (cache[arg] === void 0)
      cache[arg] = fn3(arg);
    return cache[arg];
  };
}
var identifierWithPointTracking = function identifierWithPointTracking2(begin, points, index2) {
  var previous = 0;
  var character2 = 0;
  while (true) {
    previous = character2;
    character2 = peek();
    if (previous === 38 && character2 === 12) {
      points[index2] = 1;
    }
    if (token(character2)) {
      break;
    }
    next();
  }
  return slice(begin, position);
};
var toRules = function toRules2(parsed, points) {
  var index2 = -1;
  var character2 = 44;
  do {
    switch (token(character2)) {
      case 0:
        if (character2 === 38 && peek() === 12) {
          points[index2] = 1;
        }
        parsed[index2] += identifierWithPointTracking(position - 1, points, index2);
        break;
      case 2:
        parsed[index2] += delimit(character2);
        break;
      case 4:
        if (character2 === 44) {
          parsed[++index2] = peek() === 58 ? "&\f" : "";
          points[index2] = parsed[index2].length;
          break;
        }
      default:
        parsed[index2] += from(character2);
    }
  } while (character2 = next());
  return parsed;
};
var getRules = function getRules2(value, points) {
  return dealloc(toRules(alloc(value), points));
};
var fixedElements = /* @__PURE__ */ new WeakMap();
var compat = function compat2(element) {
  if (element.type !== "rule" || !element.parent || element.length < 1) {
    return;
  }
  var value = element.value, parent = element.parent;
  var isImplicitRule = element.column === parent.column && element.line === parent.line;
  while (parent.type !== "rule") {
    parent = parent.parent;
    if (!parent)
      return;
  }
  if (element.props.length === 1 && value.charCodeAt(0) !== 58 && !fixedElements.get(parent)) {
    return;
  }
  if (isImplicitRule) {
    return;
  }
  fixedElements.set(element, true);
  var points = [];
  var rules = getRules(value, points);
  var parentRules = parent.props;
  for (var i3 = 0, k3 = 0; i3 < rules.length; i3++) {
    for (var j2 = 0; j2 < parentRules.length; j2++, k3++) {
      element.props[k3] = points[i3] ? rules[i3].replace(/&\f/g, parentRules[j2]) : parentRules[j2] + " " + rules[i3];
    }
  }
};
var removeLabel = function removeLabel2(element) {
  if (element.type === "decl") {
    var value = element.value;
    if (value.charCodeAt(0) === 108 && value.charCodeAt(2) === 98) {
      element["return"] = "";
      element.value = "";
    }
  }
};
function prefix(value, length2) {
  switch (hash$2(value, length2)) {
    case 5103:
      return WEBKIT + "print-" + value + value;
    case 5737:
    case 4201:
    case 3177:
    case 3433:
    case 1641:
    case 4457:
    case 2921:
    case 5572:
    case 6356:
    case 5844:
    case 3191:
    case 6645:
    case 3005:
    case 6391:
    case 5879:
    case 5623:
    case 6135:
    case 4599:
    case 4855:
    case 4215:
    case 6389:
    case 5109:
    case 5365:
    case 5621:
    case 3829:
      return WEBKIT + value + value;
    case 5349:
    case 4246:
    case 4810:
    case 6968:
    case 2756:
      return WEBKIT + value + MOZ + value + MS + value + value;
    case 6828:
    case 4268:
      return WEBKIT + value + MS + value + value;
    case 6165:
      return WEBKIT + value + MS + "flex-" + value + value;
    case 5187:
      return WEBKIT + value + replace$1(value, /(\w+).+(:[^]+)/, WEBKIT + "box-$1$2" + MS + "flex-$1$2") + value;
    case 5443:
      return WEBKIT + value + MS + "flex-item-" + replace$1(value, /flex-|-self/, "") + value;
    case 4675:
      return WEBKIT + value + MS + "flex-line-pack" + replace$1(value, /align-content|flex-|-self/, "") + value;
    case 5548:
      return WEBKIT + value + MS + replace$1(value, "shrink", "negative") + value;
    case 5292:
      return WEBKIT + value + MS + replace$1(value, "basis", "preferred-size") + value;
    case 6060:
      return WEBKIT + "box-" + replace$1(value, "-grow", "") + WEBKIT + value + MS + replace$1(value, "grow", "positive") + value;
    case 4554:
      return WEBKIT + replace$1(value, /([^-])(transform)/g, "$1" + WEBKIT + "$2") + value;
    case 6187:
      return replace$1(replace$1(replace$1(value, /(zoom-|grab)/, WEBKIT + "$1"), /(image-set)/, WEBKIT + "$1"), value, "") + value;
    case 5495:
    case 3959:
      return replace$1(value, /(image-set\([^]*)/, WEBKIT + "$1$`$1");
    case 4968:
      return replace$1(replace$1(value, /(.+:)(flex-)?(.*)/, WEBKIT + "box-pack:$3" + MS + "flex-pack:$3"), /s.+-b[^;]+/, "justify") + WEBKIT + value + value;
    case 4095:
    case 3583:
    case 4068:
    case 2532:
      return replace$1(value, /(.+)-inline(.+)/, WEBKIT + "$1$2") + value;
    case 8116:
    case 7059:
    case 5753:
    case 5535:
    case 5445:
    case 5701:
    case 4933:
    case 4677:
    case 5533:
    case 5789:
    case 5021:
    case 4765:
      if (strlen(value) - 1 - length2 > 6)
        switch (charat(value, length2 + 1)) {
          case 109:
            if (charat(value, length2 + 4) !== 45)
              break;
          case 102:
            return replace$1(value, /(.+:)(.+)-([^]+)/, "$1" + WEBKIT + "$2-$3$1" + MOZ + (charat(value, length2 + 3) == 108 ? "$3" : "$2-$3")) + value;
          case 115:
            return ~indexof(value, "stretch") ? prefix(replace$1(value, "stretch", "fill-available"), length2) + value : value;
        }
      break;
    case 4949:
      if (charat(value, length2 + 1) !== 115)
        break;
    case 6444:
      switch (charat(value, strlen(value) - 3 - (~indexof(value, "!important") && 10))) {
        case 107:
          return replace$1(value, ":", ":" + WEBKIT) + value;
        case 101:
          return replace$1(value, /(.+:)([^;!]+)(;|!.+)?/, "$1" + WEBKIT + (charat(value, 14) === 45 ? "inline-" : "") + "box$3$1" + WEBKIT + "$2$3$1" + MS + "$2box$3") + value;
      }
      break;
    case 5936:
      switch (charat(value, length2 + 11)) {
        case 114:
          return WEBKIT + value + MS + replace$1(value, /[svh]\w+-[tblr]{2}/, "tb") + value;
        case 108:
          return WEBKIT + value + MS + replace$1(value, /[svh]\w+-[tblr]{2}/, "tb-rl") + value;
        case 45:
          return WEBKIT + value + MS + replace$1(value, /[svh]\w+-[tblr]{2}/, "lr") + value;
      }
      return WEBKIT + value + MS + value + value;
  }
  return value;
}
var prefixer = function prefixer2(element, index2, children, callback) {
  if (element.length > -1) {
    if (!element["return"])
      switch (element.type) {
        case DECLARATION:
          element["return"] = prefix(element.value, element.length);
          break;
        case KEYFRAMES:
          return serialize([copy$1(element, {
            value: replace$1(element.value, "@", "@" + WEBKIT)
          })], callback);
        case RULESET:
          if (element.length)
            return combine$1(element.props, function(value) {
              switch (match$2(value, /(::plac\w+|:read-\w+)/)) {
                case ":read-only":
                case ":read-write":
                  return serialize([copy$1(element, {
                    props: [replace$1(value, /:(read-\w+)/, ":" + MOZ + "$1")]
                  })], callback);
                case "::placeholder":
                  return serialize([copy$1(element, {
                    props: [replace$1(value, /:(plac\w+)/, ":" + WEBKIT + "input-$1")]
                  }), copy$1(element, {
                    props: [replace$1(value, /:(plac\w+)/, ":" + MOZ + "$1")]
                  }), copy$1(element, {
                    props: [replace$1(value, /:(plac\w+)/, MS + "input-$1")]
                  })], callback);
              }
              return "";
            });
      }
  }
};
var defaultStylisPlugins = [prefixer];
var createCache = function createCache2(options) {
  var key = options.key;
  if (key === "css") {
    var ssrStyles = document.querySelectorAll("style[data-emotion]:not([data-s])");
    Array.prototype.forEach.call(ssrStyles, function(node2) {
      var dataEmotionAttribute = node2.getAttribute("data-emotion");
      if (dataEmotionAttribute.indexOf(" ") === -1) {
        return;
      }
      document.head.appendChild(node2);
      node2.setAttribute("data-s", "");
    });
  }
  var stylisPlugins = options.stylisPlugins || defaultStylisPlugins;
  var inserted = {};
  var container;
  var nodesToHydrate = [];
  {
    container = options.container || document.head;
    Array.prototype.forEach.call(
      document.querySelectorAll('style[data-emotion^="' + key + ' "]'),
      function(node2) {
        var attrib = node2.getAttribute("data-emotion").split(" ");
        for (var i3 = 1; i3 < attrib.length; i3++) {
          inserted[attrib[i3]] = true;
        }
        nodesToHydrate.push(node2);
      }
    );
  }
  var _insert;
  var omnipresentPlugins = [compat, removeLabel];
  {
    var currentSheet;
    var finalizingPlugins = [stringify, rulesheet(function(rule) {
      currentSheet.insert(rule);
    })];
    var serializer = middleware(omnipresentPlugins.concat(stylisPlugins, finalizingPlugins));
    var stylis = function stylis2(styles) {
      return serialize(compile(styles), serializer);
    };
    _insert = function insert(selector, serialized, sheet, shouldCache) {
      currentSheet = sheet;
      stylis(selector ? selector + "{" + serialized.styles + "}" : serialized.styles);
      if (shouldCache) {
        cache.inserted[serialized.name] = true;
      }
    };
  }
  var cache = {
    key,
    sheet: new StyleSheet({
      key,
      container,
      nonce: options.nonce,
      speedy: options.speedy,
      prepend: options.prepend,
      insertionPoint: options.insertionPoint
    }),
    nonce: options.nonce,
    inserted,
    registered: {},
    insert: _insert
  };
  cache.sheet.hydrate(nodesToHydrate);
  return cache;
};
function _extends$1() {
  _extends$1 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i3 = 1; i3 < arguments.length; i3++) {
      var source = arguments[i3];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$1.apply(this, arguments);
}
var reactIs$1 = { exports: {} };
var reactIs_production_min = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var b$5 = "function" === typeof Symbol && Symbol.for, c$6 = b$5 ? Symbol.for("react.element") : 60103, d$7 = b$5 ? Symbol.for("react.portal") : 60106, e$2 = b$5 ? Symbol.for("react.fragment") : 60107, f$8 = b$5 ? Symbol.for("react.strict_mode") : 60108, g$4 = b$5 ? Symbol.for("react.profiler") : 60114, h$5 = b$5 ? Symbol.for("react.provider") : 60109, k$2 = b$5 ? Symbol.for("react.context") : 60110, l$6 = b$5 ? Symbol.for("react.async_mode") : 60111, m$7 = b$5 ? Symbol.for("react.concurrent_mode") : 60111, n$5 = b$5 ? Symbol.for("react.forward_ref") : 60112, p$6 = b$5 ? Symbol.for("react.suspense") : 60113, q$1 = b$5 ? Symbol.for("react.suspense_list") : 60120, r$5 = b$5 ? Symbol.for("react.memo") : 60115, t$5 = b$5 ? Symbol.for("react.lazy") : 60116, v$4 = b$5 ? Symbol.for("react.block") : 60121, w$4 = b$5 ? Symbol.for("react.fundamental") : 60117, x$4 = b$5 ? Symbol.for("react.responder") : 60118, y$2 = b$5 ? Symbol.for("react.scope") : 60119;
function z(a4) {
  if ("object" === typeof a4 && null !== a4) {
    var u3 = a4.$$typeof;
    switch (u3) {
      case c$6:
        switch (a4 = a4.type, a4) {
          case l$6:
          case m$7:
          case e$2:
          case g$4:
          case f$8:
          case p$6:
            return a4;
          default:
            switch (a4 = a4 && a4.$$typeof, a4) {
              case k$2:
              case n$5:
              case t$5:
              case r$5:
              case h$5:
                return a4;
              default:
                return u3;
            }
        }
      case d$7:
        return u3;
    }
  }
}
function A$2(a4) {
  return z(a4) === m$7;
}
reactIs_production_min.AsyncMode = l$6;
reactIs_production_min.ConcurrentMode = m$7;
reactIs_production_min.ContextConsumer = k$2;
reactIs_production_min.ContextProvider = h$5;
reactIs_production_min.Element = c$6;
reactIs_production_min.ForwardRef = n$5;
reactIs_production_min.Fragment = e$2;
reactIs_production_min.Lazy = t$5;
reactIs_production_min.Memo = r$5;
reactIs_production_min.Portal = d$7;
reactIs_production_min.Profiler = g$4;
reactIs_production_min.StrictMode = f$8;
reactIs_production_min.Suspense = p$6;
reactIs_production_min.isAsyncMode = function(a4) {
  return A$2(a4) || z(a4) === l$6;
};
reactIs_production_min.isConcurrentMode = A$2;
reactIs_production_min.isContextConsumer = function(a4) {
  return z(a4) === k$2;
};
reactIs_production_min.isContextProvider = function(a4) {
  return z(a4) === h$5;
};
reactIs_production_min.isElement = function(a4) {
  return "object" === typeof a4 && null !== a4 && a4.$$typeof === c$6;
};
reactIs_production_min.isForwardRef = function(a4) {
  return z(a4) === n$5;
};
reactIs_production_min.isFragment = function(a4) {
  return z(a4) === e$2;
};
reactIs_production_min.isLazy = function(a4) {
  return z(a4) === t$5;
};
reactIs_production_min.isMemo = function(a4) {
  return z(a4) === r$5;
};
reactIs_production_min.isPortal = function(a4) {
  return z(a4) === d$7;
};
reactIs_production_min.isProfiler = function(a4) {
  return z(a4) === g$4;
};
reactIs_production_min.isStrictMode = function(a4) {
  return z(a4) === f$8;
};
reactIs_production_min.isSuspense = function(a4) {
  return z(a4) === p$6;
};
reactIs_production_min.isValidElementType = function(a4) {
  return "string" === typeof a4 || "function" === typeof a4 || a4 === e$2 || a4 === m$7 || a4 === g$4 || a4 === f$8 || a4 === p$6 || a4 === q$1 || "object" === typeof a4 && null !== a4 && (a4.$$typeof === t$5 || a4.$$typeof === r$5 || a4.$$typeof === h$5 || a4.$$typeof === k$2 || a4.$$typeof === n$5 || a4.$$typeof === w$4 || a4.$$typeof === x$4 || a4.$$typeof === y$2 || a4.$$typeof === v$4);
};
reactIs_production_min.typeOf = z;
{
  reactIs$1.exports = reactIs_production_min;
}
var reactIs = reactIs$1.exports;
var FORWARD_REF_STATICS = {
  "$$typeof": true,
  render: true,
  defaultProps: true,
  displayName: true,
  propTypes: true
};
var MEMO_STATICS = {
  "$$typeof": true,
  compare: true,
  defaultProps: true,
  displayName: true,
  propTypes: true,
  type: true
};
var TYPE_STATICS = {};
TYPE_STATICS[reactIs.ForwardRef] = FORWARD_REF_STATICS;
TYPE_STATICS[reactIs.Memo] = MEMO_STATICS;
var isBrowser$3 = true;
function getRegisteredStyles(registered, registeredStyles, classNames) {
  var rawClassName = "";
  classNames.split(" ").forEach(function(className) {
    if (registered[className] !== void 0) {
      registeredStyles.push(registered[className] + ";");
    } else {
      rawClassName += className + " ";
    }
  });
  return rawClassName;
}
var registerStyles = function registerStyles2(cache, serialized, isStringTag) {
  var className = cache.key + "-" + serialized.name;
  if ((isStringTag === false || isBrowser$3 === false) && cache.registered[className] === void 0) {
    cache.registered[className] = serialized.styles;
  }
};
var insertStyles = function insertStyles2(cache, serialized, isStringTag) {
  registerStyles(cache, serialized, isStringTag);
  var className = cache.key + "-" + serialized.name;
  if (cache.inserted[serialized.name] === void 0) {
    var current = serialized;
    do {
      cache.insert(serialized === current ? "." + className : "", current, cache.sheet, true);
      current = current.next;
    } while (current !== void 0);
  }
};
function murmur2(str) {
  var h4 = 0;
  var k3, i3 = 0, len = str.length;
  for (; len >= 4; ++i3, len -= 4) {
    k3 = str.charCodeAt(i3) & 255 | (str.charCodeAt(++i3) & 255) << 8 | (str.charCodeAt(++i3) & 255) << 16 | (str.charCodeAt(++i3) & 255) << 24;
    k3 = (k3 & 65535) * 1540483477 + ((k3 >>> 16) * 59797 << 16);
    k3 ^= k3 >>> 24;
    h4 = (k3 & 65535) * 1540483477 + ((k3 >>> 16) * 59797 << 16) ^ (h4 & 65535) * 1540483477 + ((h4 >>> 16) * 59797 << 16);
  }
  switch (len) {
    case 3:
      h4 ^= (str.charCodeAt(i3 + 2) & 255) << 16;
    case 2:
      h4 ^= (str.charCodeAt(i3 + 1) & 255) << 8;
    case 1:
      h4 ^= str.charCodeAt(i3) & 255;
      h4 = (h4 & 65535) * 1540483477 + ((h4 >>> 16) * 59797 << 16);
  }
  h4 ^= h4 >>> 13;
  h4 = (h4 & 65535) * 1540483477 + ((h4 >>> 16) * 59797 << 16);
  return ((h4 ^ h4 >>> 15) >>> 0).toString(36);
}
var unitlessKeys = {
  animationIterationCount: 1,
  borderImageOutset: 1,
  borderImageSlice: 1,
  borderImageWidth: 1,
  boxFlex: 1,
  boxFlexGroup: 1,
  boxOrdinalGroup: 1,
  columnCount: 1,
  columns: 1,
  flex: 1,
  flexGrow: 1,
  flexPositive: 1,
  flexShrink: 1,
  flexNegative: 1,
  flexOrder: 1,
  gridRow: 1,
  gridRowEnd: 1,
  gridRowSpan: 1,
  gridRowStart: 1,
  gridColumn: 1,
  gridColumnEnd: 1,
  gridColumnSpan: 1,
  gridColumnStart: 1,
  msGridRow: 1,
  msGridRowSpan: 1,
  msGridColumn: 1,
  msGridColumnSpan: 1,
  fontWeight: 1,
  lineHeight: 1,
  opacity: 1,
  order: 1,
  orphans: 1,
  tabSize: 1,
  widows: 1,
  zIndex: 1,
  zoom: 1,
  WebkitLineClamp: 1,
  fillOpacity: 1,
  floodOpacity: 1,
  stopOpacity: 1,
  strokeDasharray: 1,
  strokeDashoffset: 1,
  strokeMiterlimit: 1,
  strokeOpacity: 1,
  strokeWidth: 1
};
var hyphenateRegex = /[A-Z]|^ms/g;
var animationRegex = /_EMO_([^_]+?)_([^]*?)_EMO_/g;
var isCustomProperty = function isCustomProperty2(property) {
  return property.charCodeAt(1) === 45;
};
var isProcessableValue = function isProcessableValue2(value) {
  return value != null && typeof value !== "boolean";
};
var processStyleName = /* @__PURE__ */ memoize(function(styleName) {
  return isCustomProperty(styleName) ? styleName : styleName.replace(hyphenateRegex, "-$&").toLowerCase();
});
var processStyleValue = function processStyleValue2(key, value) {
  switch (key) {
    case "animation":
    case "animationName": {
      if (typeof value === "string") {
        return value.replace(animationRegex, function(match2, p1, p2) {
          cursor = {
            name: p1,
            styles: p2,
            next: cursor
          };
          return p1;
        });
      }
    }
  }
  if (unitlessKeys[key] !== 1 && !isCustomProperty(key) && typeof value === "number" && value !== 0) {
    return value + "px";
  }
  return value;
};
var noComponentSelectorMessage = "Component selectors can only be used in conjunction with @emotion/babel-plugin, the swc Emotion plugin, or another Emotion-aware compiler transform.";
function handleInterpolation(mergedProps, registered, interpolation) {
  if (interpolation == null) {
    return "";
  }
  if (interpolation.__emotion_styles !== void 0) {
    return interpolation;
  }
  switch (typeof interpolation) {
    case "boolean": {
      return "";
    }
    case "object": {
      if (interpolation.anim === 1) {
        cursor = {
          name: interpolation.name,
          styles: interpolation.styles,
          next: cursor
        };
        return interpolation.name;
      }
      if (interpolation.styles !== void 0) {
        var next2 = interpolation.next;
        if (next2 !== void 0) {
          while (next2 !== void 0) {
            cursor = {
              name: next2.name,
              styles: next2.styles,
              next: cursor
            };
            next2 = next2.next;
          }
        }
        var styles = interpolation.styles + ";";
        return styles;
      }
      return createStringFromObject(mergedProps, registered, interpolation);
    }
    case "function": {
      if (mergedProps !== void 0) {
        var previousCursor = cursor;
        var result = interpolation(mergedProps);
        cursor = previousCursor;
        return handleInterpolation(mergedProps, registered, result);
      }
      break;
    }
  }
  if (registered == null) {
    return interpolation;
  }
  var cached = registered[interpolation];
  return cached !== void 0 ? cached : interpolation;
}
function createStringFromObject(mergedProps, registered, obj) {
  var string = "";
  if (Array.isArray(obj)) {
    for (var i3 = 0; i3 < obj.length; i3++) {
      string += handleInterpolation(mergedProps, registered, obj[i3]) + ";";
    }
  } else {
    for (var _key in obj) {
      var value = obj[_key];
      if (typeof value !== "object") {
        if (registered != null && registered[value] !== void 0) {
          string += _key + "{" + registered[value] + "}";
        } else if (isProcessableValue(value)) {
          string += processStyleName(_key) + ":" + processStyleValue(_key, value) + ";";
        }
      } else {
        if (_key === "NO_COMPONENT_SELECTOR" && false) {
          throw new Error(noComponentSelectorMessage);
        }
        if (Array.isArray(value) && typeof value[0] === "string" && (registered == null || registered[value[0]] === void 0)) {
          for (var _i = 0; _i < value.length; _i++) {
            if (isProcessableValue(value[_i])) {
              string += processStyleName(_key) + ":" + processStyleValue(_key, value[_i]) + ";";
            }
          }
        } else {
          var interpolated = handleInterpolation(mergedProps, registered, value);
          switch (_key) {
            case "animation":
            case "animationName": {
              string += processStyleName(_key) + ":" + interpolated + ";";
              break;
            }
            default: {
              string += _key + "{" + interpolated + "}";
            }
          }
        }
      }
    }
  }
  return string;
}
var labelPattern = /label:\s*([^\s;\n{]+)\s*(;|$)/g;
var cursor;
var serializeStyles = function serializeStyles2(args, registered, mergedProps) {
  if (args.length === 1 && typeof args[0] === "object" && args[0] !== null && args[0].styles !== void 0) {
    return args[0];
  }
  var stringMode = true;
  var styles = "";
  cursor = void 0;
  var strings = args[0];
  if (strings == null || strings.raw === void 0) {
    stringMode = false;
    styles += handleInterpolation(mergedProps, registered, strings);
  } else {
    styles += strings[0];
  }
  for (var i3 = 1; i3 < args.length; i3++) {
    styles += handleInterpolation(mergedProps, registered, args[i3]);
    if (stringMode) {
      styles += strings[i3];
    }
  }
  labelPattern.lastIndex = 0;
  var identifierName = "";
  var match2;
  while ((match2 = labelPattern.exec(styles)) !== null) {
    identifierName += "-" + match2[1];
  }
  var name = murmur2(styles) + identifierName;
  return {
    name,
    styles,
    next: cursor
  };
};
var syncFallback = function syncFallback2(create2) {
  return create2();
};
var useInsertionEffect = React["useInsertionEffect"] ? React["useInsertionEffect"] : false;
var useInsertionEffectAlwaysWithSyncFallback = useInsertionEffect || syncFallback;
var useInsertionEffectWithLayoutFallback = useInsertionEffect || react.exports.useLayoutEffect;
var hasOwnProperty$1 = {}.hasOwnProperty;
var EmotionCacheContext = /* @__PURE__ */ react.exports.createContext(
  typeof HTMLElement !== "undefined" ? /* @__PURE__ */ createCache({
    key: "css"
  }) : null
);
EmotionCacheContext.Provider;
var withEmotionCache = function withEmotionCache2(func) {
  return /* @__PURE__ */ react.exports.forwardRef(function(props, ref) {
    var cache = react.exports.useContext(EmotionCacheContext);
    return func(props, cache, ref);
  });
};
var ThemeContext = /* @__PURE__ */ react.exports.createContext({});
var typePropName = "__EMOTION_TYPE_PLEASE_DO_NOT_USE__";
var createEmotionProps = function createEmotionProps2(type, props) {
  var newProps = {};
  for (var key in props) {
    if (hasOwnProperty$1.call(props, key)) {
      newProps[key] = props[key];
    }
  }
  newProps[typePropName] = type;
  return newProps;
};
var Insertion$2 = function Insertion(_ref2) {
  var cache = _ref2.cache, serialized = _ref2.serialized, isStringTag = _ref2.isStringTag;
  registerStyles(cache, serialized, isStringTag);
  useInsertionEffectAlwaysWithSyncFallback(function() {
    return insertStyles(cache, serialized, isStringTag);
  });
  return null;
};
var Emotion = /* @__PURE__ */ withEmotionCache(function(props, cache, ref) {
  var cssProp = props.css;
  if (typeof cssProp === "string" && cache.registered[cssProp] !== void 0) {
    cssProp = cache.registered[cssProp];
  }
  var WrappedComponent = props[typePropName];
  var registeredStyles = [cssProp];
  var className = "";
  if (typeof props.className === "string") {
    className = getRegisteredStyles(cache.registered, registeredStyles, props.className);
  } else if (props.className != null) {
    className = props.className + " ";
  }
  var serialized = serializeStyles(registeredStyles, void 0, react.exports.useContext(ThemeContext));
  className += cache.key + "-" + serialized.name;
  var newProps = {};
  for (var key in props) {
    if (hasOwnProperty$1.call(props, key) && key !== "css" && key !== typePropName && true) {
      newProps[key] = props[key];
    }
  }
  newProps.ref = ref;
  newProps.className = className;
  return /* @__PURE__ */ react.exports.createElement(react.exports.Fragment, null, /* @__PURE__ */ react.exports.createElement(Insertion$2, {
    cache,
    serialized,
    isStringTag: typeof WrappedComponent === "string"
  }), /* @__PURE__ */ react.exports.createElement(WrappedComponent, newProps));
});
var Global = /* @__PURE__ */ withEmotionCache(function(props, cache) {
  var styles = props.styles;
  var serialized = serializeStyles([styles], void 0, react.exports.useContext(ThemeContext));
  var sheetRef = react.exports.useRef();
  useInsertionEffectWithLayoutFallback(function() {
    var key = cache.key + "-global";
    var sheet = new cache.sheet.constructor({
      key,
      nonce: cache.sheet.nonce,
      container: cache.sheet.container,
      speedy: cache.sheet.isSpeedy
    });
    var rehydrating = false;
    var node2 = document.querySelector('style[data-emotion="' + key + " " + serialized.name + '"]');
    if (cache.sheet.tags.length) {
      sheet.before = cache.sheet.tags[0];
    }
    if (node2 !== null) {
      rehydrating = true;
      node2.setAttribute("data-emotion", key);
      sheet.hydrate([node2]);
    }
    sheetRef.current = [sheet, rehydrating];
    return function() {
      sheet.flush();
    };
  }, [cache]);
  useInsertionEffectWithLayoutFallback(function() {
    var sheetRefCurrent = sheetRef.current;
    var sheet = sheetRefCurrent[0], rehydrating = sheetRefCurrent[1];
    if (rehydrating) {
      sheetRefCurrent[1] = false;
      return;
    }
    if (serialized.next !== void 0) {
      insertStyles(cache, serialized.next, true);
    }
    if (sheet.tags.length) {
      var element = sheet.tags[sheet.tags.length - 1].nextElementSibling;
      sheet.before = element;
      sheet.flush();
    }
    cache.insert("", serialized, sheet, false);
  }, [cache, serialized.name]);
  return null;
});
function css$1() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  return serializeStyles(args);
}
var keyframes = function keyframes2() {
  var insertable = css$1.apply(void 0, arguments);
  var name = "animation-" + insertable.name;
  return {
    name,
    styles: "@keyframes " + name + "{" + insertable.styles + "}",
    anim: 1,
    toString: function toString2() {
      return "_EMO_" + this.name + "_" + this.styles + "_EMO_";
    }
  };
};
var classnames$1 = function classnames(args) {
  var len = args.length;
  var i3 = 0;
  var cls = "";
  for (; i3 < len; i3++) {
    var arg = args[i3];
    if (arg == null)
      continue;
    var toAdd = void 0;
    switch (typeof arg) {
      case "boolean":
        break;
      case "object": {
        if (Array.isArray(arg)) {
          toAdd = classnames(arg);
        } else {
          toAdd = "";
          for (var k3 in arg) {
            if (arg[k3] && k3) {
              toAdd && (toAdd += " ");
              toAdd += k3;
            }
          }
        }
        break;
      }
      default: {
        toAdd = arg;
      }
    }
    if (toAdd) {
      cls && (cls += " ");
      cls += toAdd;
    }
  }
  return cls;
};
function merge(registered, css2, className) {
  var registeredStyles = [];
  var rawClassName = getRegisteredStyles(registered, registeredStyles, className);
  if (registeredStyles.length < 2) {
    return className;
  }
  return rawClassName + css2(registeredStyles);
}
var Insertion$1 = function Insertion2(_ref2) {
  var cache = _ref2.cache, serializedArr = _ref2.serializedArr;
  useInsertionEffectAlwaysWithSyncFallback(function() {
    for (var i3 = 0; i3 < serializedArr.length; i3++) {
      insertStyles(cache, serializedArr[i3], false);
    }
  });
  return null;
};
var ClassNames = /* @__PURE__ */ withEmotionCache(function(props, cache) {
  var hasRendered = false;
  var serializedArr = [];
  var css2 = function css3() {
    if (hasRendered && false) {
      throw new Error("css can only be used during render");
    }
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    var serialized = serializeStyles(args, cache.registered);
    serializedArr.push(serialized);
    registerStyles(cache, serialized, false);
    return cache.key + "-" + serialized.name;
  };
  var cx = function cx2() {
    if (hasRendered && false) {
      throw new Error("cx can only be used during render");
    }
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }
    return merge(cache.registered, css2, classnames$1(args));
  };
  var content = {
    css: css2,
    cx,
    theme: react.exports.useContext(ThemeContext)
  };
  var ele = props.children(content);
  hasRendered = true;
  return /* @__PURE__ */ react.exports.createElement(react.exports.Fragment, null, /* @__PURE__ */ react.exports.createElement(Insertion$1, {
    cache,
    serializedArr
  }), ele);
});
var reactPropsRegex = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|abbr|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|download|draggable|encType|enterKeyHint|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|translate|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|incremental|fallback|inert|itemProp|itemScope|itemType|itemID|itemRef|on|option|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/;
var isPropValid = /* @__PURE__ */ memoize(
  function(prop) {
    return reactPropsRegex.test(prop) || prop.charCodeAt(0) === 111 && prop.charCodeAt(1) === 110 && prop.charCodeAt(2) < 91;
  }
);
var testOmitPropsOnStringTag = isPropValid;
var testOmitPropsOnComponent = function testOmitPropsOnComponent2(key) {
  return key !== "theme";
};
var getDefaultShouldForwardProp = function getDefaultShouldForwardProp2(tag) {
  return typeof tag === "string" && tag.charCodeAt(0) > 96 ? testOmitPropsOnStringTag : testOmitPropsOnComponent;
};
var composeShouldForwardProps = function composeShouldForwardProps2(tag, options, isReal) {
  var shouldForwardProp;
  if (options) {
    var optionsShouldForwardProp = options.shouldForwardProp;
    shouldForwardProp = tag.__emotion_forwardProp && optionsShouldForwardProp ? function(propName) {
      return tag.__emotion_forwardProp(propName) && optionsShouldForwardProp(propName);
    } : optionsShouldForwardProp;
  }
  if (typeof shouldForwardProp !== "function" && isReal) {
    shouldForwardProp = tag.__emotion_forwardProp;
  }
  return shouldForwardProp;
};
var Insertion3 = function Insertion4(_ref2) {
  var cache = _ref2.cache, serialized = _ref2.serialized, isStringTag = _ref2.isStringTag;
  registerStyles(cache, serialized, isStringTag);
  useInsertionEffectAlwaysWithSyncFallback(function() {
    return insertStyles(cache, serialized, isStringTag);
  });
  return null;
};
var createStyled = function createStyled2(tag, options) {
  var isReal = tag.__emotion_real === tag;
  var baseTag = isReal && tag.__emotion_base || tag;
  var identifierName;
  var targetClassName;
  if (options !== void 0) {
    identifierName = options.label;
    targetClassName = options.target;
  }
  var shouldForwardProp = composeShouldForwardProps(tag, options, isReal);
  var defaultShouldForwardProp = shouldForwardProp || getDefaultShouldForwardProp(baseTag);
  var shouldUseAs = !defaultShouldForwardProp("as");
  return function() {
    var args = arguments;
    var styles = isReal && tag.__emotion_styles !== void 0 ? tag.__emotion_styles.slice(0) : [];
    if (identifierName !== void 0) {
      styles.push("label:" + identifierName + ";");
    }
    if (args[0] == null || args[0].raw === void 0) {
      styles.push.apply(styles, args);
    } else {
      styles.push(args[0][0]);
      var len = args.length;
      var i3 = 1;
      for (; i3 < len; i3++) {
        styles.push(args[i3], args[0][i3]);
      }
    }
    var Styled = withEmotionCache(function(props, cache, ref) {
      var FinalTag = shouldUseAs && props.as || baseTag;
      var className = "";
      var classInterpolations = [];
      var mergedProps = props;
      if (props.theme == null) {
        mergedProps = {};
        for (var key in props) {
          mergedProps[key] = props[key];
        }
        mergedProps.theme = react.exports.useContext(ThemeContext);
      }
      if (typeof props.className === "string") {
        className = getRegisteredStyles(cache.registered, classInterpolations, props.className);
      } else if (props.className != null) {
        className = props.className + " ";
      }
      var serialized = serializeStyles(styles.concat(classInterpolations), cache.registered, mergedProps);
      className += cache.key + "-" + serialized.name;
      if (targetClassName !== void 0) {
        className += " " + targetClassName;
      }
      var finalShouldForwardProp = shouldUseAs && shouldForwardProp === void 0 ? getDefaultShouldForwardProp(FinalTag) : defaultShouldForwardProp;
      var newProps = {};
      for (var _key in props) {
        if (shouldUseAs && _key === "as")
          continue;
        if (finalShouldForwardProp(_key)) {
          newProps[_key] = props[_key];
        }
      }
      newProps.className = className;
      newProps.ref = ref;
      return /* @__PURE__ */ react.exports.createElement(react.exports.Fragment, null, /* @__PURE__ */ react.exports.createElement(Insertion3, {
        cache,
        serialized,
        isStringTag: typeof FinalTag === "string"
      }), /* @__PURE__ */ react.exports.createElement(FinalTag, newProps));
    });
    Styled.displayName = identifierName !== void 0 ? identifierName : "Styled(" + (typeof baseTag === "string" ? baseTag : baseTag.displayName || baseTag.name || "Component") + ")";
    Styled.defaultProps = tag.defaultProps;
    Styled.__emotion_real = Styled;
    Styled.__emotion_base = baseTag;
    Styled.__emotion_styles = styles;
    Styled.__emotion_forwardProp = shouldForwardProp;
    Object.defineProperty(Styled, "toString", {
      value: function value() {
        if (targetClassName === void 0 && false) {
          return "NO_COMPONENT_SELECTOR";
        }
        return "." + targetClassName;
      }
    });
    Styled.withComponent = function(nextTag, nextOptions) {
      return createStyled2(nextTag, _extends$1({}, options, nextOptions, {
        shouldForwardProp: composeShouldForwardProps(Styled, nextOptions, true)
      })).apply(void 0, styles);
    };
    return Styled;
  };
};
function useCombinedRefs() {
  for (var _len = arguments.length, refs = new Array(_len), _key = 0; _key < _len; _key++) {
    refs[_key] = arguments[_key];
  }
  return react.exports.useMemo(
    () => (node2) => {
      refs.forEach((ref) => ref(node2));
    },
    refs
  );
}
const canUseDOM = typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined";
function isWindow(element) {
  const elementString = Object.prototype.toString.call(element);
  return elementString === "[object Window]" || elementString === "[object global]";
}
function isNode(node2) {
  return "nodeType" in node2;
}
function getWindow$1(target) {
  var _target$ownerDocument, _target$ownerDocument2;
  if (!target) {
    return window;
  }
  if (isWindow(target)) {
    return target;
  }
  if (!isNode(target)) {
    return window;
  }
  return (_target$ownerDocument = (_target$ownerDocument2 = target.ownerDocument) == null ? void 0 : _target$ownerDocument2.defaultView) != null ? _target$ownerDocument : window;
}
function isDocument(node2) {
  const {
    Document: Document2
  } = getWindow$1(node2);
  return node2 instanceof Document2;
}
function isHTMLElement$1(node2) {
  if (isWindow(node2)) {
    return false;
  }
  return node2 instanceof getWindow$1(node2).HTMLElement;
}
function isSVGElement(node2) {
  return node2 instanceof getWindow$1(node2).SVGElement;
}
function getOwnerDocument$1(target) {
  if (!target) {
    return document;
  }
  if (isWindow(target)) {
    return target.document;
  }
  if (!isNode(target)) {
    return document;
  }
  if (isDocument(target)) {
    return target;
  }
  if (isHTMLElement$1(target)) {
    return target.ownerDocument;
  }
  return document;
}
const useIsomorphicLayoutEffect$3 = canUseDOM ? react.exports.useLayoutEffect : react.exports.useEffect;
function useEvent(handler) {
  const handlerRef = react.exports.useRef(handler);
  useIsomorphicLayoutEffect$3(() => {
    handlerRef.current = handler;
  });
  return react.exports.useCallback(function() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return handlerRef.current == null ? void 0 : handlerRef.current(...args);
  }, []);
}
function useInterval() {
  const intervalRef = react.exports.useRef(null);
  const set2 = react.exports.useCallback((listener, duration2) => {
    intervalRef.current = setInterval(listener, duration2);
  }, []);
  const clear = react.exports.useCallback(() => {
    if (intervalRef.current !== null) {
      clearInterval(intervalRef.current);
      intervalRef.current = null;
    }
  }, []);
  return [set2, clear];
}
function useLazyMemo(callback, dependencies) {
  const valueRef = react.exports.useRef();
  return react.exports.useMemo(
    () => {
      const newValue = callback(valueRef.current);
      valueRef.current = newValue;
      return newValue;
    },
    [...dependencies]
  );
}
function useNodeRef(onChange) {
  const onChangeHandler = useEvent(onChange);
  const node2 = react.exports.useRef(null);
  const setNodeRef = react.exports.useCallback(
    (element) => {
      if (element !== node2.current) {
        onChangeHandler == null ? void 0 : onChangeHandler(element, node2.current);
      }
      node2.current = element;
    },
    []
  );
  return [node2, setNodeRef];
}
let ids = {};
function useUniqueId(prefix2, value) {
  return react.exports.useMemo(() => {
    if (value) {
      return value;
    }
    const id2 = ids[prefix2] == null ? 0 : ids[prefix2] + 1;
    ids[prefix2] = id2;
    return prefix2 + "-" + id2;
  }, [prefix2, value]);
}
function createAdjustmentFn(modifier) {
  return function(object) {
    for (var _len = arguments.length, adjustments = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      adjustments[_key - 1] = arguments[_key];
    }
    return adjustments.reduce((accumulator, adjustment) => {
      const entries = Object.entries(adjustment);
      for (const [key, valueAdjustment] of entries) {
        const value = accumulator[key];
        if (value != null) {
          accumulator[key] = value + modifier * valueAdjustment;
        }
      }
      return accumulator;
    }, {
      ...object
    });
  };
}
const add = /* @__PURE__ */ createAdjustmentFn(1);
const subtract = /* @__PURE__ */ createAdjustmentFn(-1);
function hasViewportRelativeCoordinates(event) {
  return "clientX" in event && "clientY" in event;
}
function isKeyboardEvent(event) {
  if (!event) {
    return false;
  }
  const {
    KeyboardEvent: KeyboardEvent2
  } = getWindow$1(event.target);
  return KeyboardEvent2 && event instanceof KeyboardEvent2;
}
function isTouchEvent(event) {
  if (!event) {
    return false;
  }
  const {
    TouchEvent
  } = getWindow$1(event.target);
  return TouchEvent && event instanceof TouchEvent;
}
function getEventCoordinates(event) {
  if (isTouchEvent(event)) {
    if (event.touches && event.touches.length) {
      const {
        clientX: x3,
        clientY: y4
      } = event.touches[0];
      return {
        x: x3,
        y: y4
      };
    } else if (event.changedTouches && event.changedTouches.length) {
      const {
        clientX: x3,
        clientY: y4
      } = event.changedTouches[0];
      return {
        x: x3,
        y: y4
      };
    }
  }
  if (hasViewportRelativeCoordinates(event)) {
    return {
      x: event.clientX,
      y: event.clientY
    };
  }
  return null;
}
const CSS = /* @__PURE__ */ Object.freeze({
  Translate: {
    toString(transform) {
      if (!transform) {
        return;
      }
      const {
        x: x3,
        y: y4
      } = transform;
      return "translate3d(" + (x3 ? Math.round(x3) : 0) + "px, " + (y4 ? Math.round(y4) : 0) + "px, 0)";
    }
  },
  Scale: {
    toString(transform) {
      if (!transform) {
        return;
      }
      const {
        scaleX: scaleX2,
        scaleY: scaleY2
      } = transform;
      return "scaleX(" + scaleX2 + ") scaleY(" + scaleY2 + ")";
    }
  },
  Transform: {
    toString(transform) {
      if (!transform) {
        return;
      }
      return [CSS.Translate.toString(transform), CSS.Scale.toString(transform)].join(" ");
    }
  },
  Transition: {
    toString(_ref2) {
      let {
        property,
        duration: duration2,
        easing
      } = _ref2;
      return property + " " + duration2 + "ms " + easing;
    }
  }
});
var jsxRuntime = { exports: {} };
var reactJsxRuntime_production_min = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var f$7 = react.exports, k$1 = Symbol.for("react.element"), l$5 = Symbol.for("react.fragment"), m$6 = Object.prototype.hasOwnProperty, n$4 = f$7.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, p$5 = { key: true, ref: true, __self: true, __source: true };
function q(c3, a4, g2) {
  var b3, d4 = {}, e3 = null, h4 = null;
  void 0 !== g2 && (e3 = "" + g2);
  void 0 !== a4.key && (e3 = "" + a4.key);
  void 0 !== a4.ref && (h4 = a4.ref);
  for (b3 in a4)
    m$6.call(a4, b3) && !p$5.hasOwnProperty(b3) && (d4[b3] = a4[b3]);
  if (c3 && c3.defaultProps)
    for (b3 in a4 = c3.defaultProps, a4)
      void 0 === d4[b3] && (d4[b3] = a4[b3]);
  return { $$typeof: k$1, type: c3, key: e3, ref: h4, props: d4, _owner: n$4.current };
}
reactJsxRuntime_production_min.Fragment = l$5;
reactJsxRuntime_production_min.jsx = q;
reactJsxRuntime_production_min.jsxs = q;
{
  jsxRuntime.exports = reactJsxRuntime_production_min;
}
const jsx$1 = jsxRuntime.exports.jsx;
const jsxs$1 = jsxRuntime.exports.jsxs;
const Fragment$2 = jsxRuntime.exports.Fragment;
var Fragment$1 = Fragment$2;
function jsx(type, props, key) {
  if (!hasOwnProperty$1.call(props, "css")) {
    return jsx$1(type, props, key);
  }
  return jsx$1(Emotion, createEmotionProps(type, props), key);
}
function jsxs(type, props, key) {
  if (!hasOwnProperty$1.call(props, "css")) {
    return jsxs$1(type, props, key);
  }
  return jsxs$1(Emotion, createEmotionProps(type, props), key);
}
const hiddenStyles = {
  display: "none"
};
function HiddenText(_ref2) {
  let {
    id: id2,
    value
  } = _ref2;
  return /* @__PURE__ */ jsx("div", {
    id: id2,
    style: hiddenStyles,
    children: value
  });
}
const visuallyHidden = {
  position: "fixed",
  width: 1,
  height: 1,
  margin: -1,
  border: 0,
  padding: 0,
  overflow: "hidden",
  clip: "rect(0 0 0 0)",
  clipPath: "inset(100%)",
  whiteSpace: "nowrap"
};
function LiveRegion(_ref2) {
  let {
    id: id2,
    announcement
  } = _ref2;
  return /* @__PURE__ */ jsx("div", {
    id: id2,
    style: visuallyHidden,
    role: "status",
    "aria-live": "assertive",
    "aria-atomic": true,
    children: announcement
  });
}
function useAnnouncement() {
  const [announcement, setAnnouncement] = react.exports.useState("");
  const announce = react.exports.useCallback((value) => {
    if (value != null) {
      setAnnouncement(value);
    }
  }, []);
  return {
    announce,
    announcement
  };
}
const screenReaderInstructions = {
  draggable: `
    To pick up a draggable item, press the space bar.
    While dragging, use the arrow keys to move the item.
    Press space again to drop the item in its new position, or press escape to cancel.
  `
};
const defaultAnnouncements = {
  onDragStart(id2) {
    return `Picked up draggable item ${id2}.`;
  },
  onDragOver(id2, overId) {
    if (overId) {
      return `Draggable item ${id2} was moved over droppable area ${overId}.`;
    }
    return `Draggable item ${id2} is no longer over a droppable area.`;
  },
  onDragEnd(id2, overId) {
    if (overId) {
      return `Draggable item ${id2} was dropped over droppable area ${overId}`;
    }
    return `Draggable item ${id2} was dropped.`;
  },
  onDragCancel(id2) {
    return `Dragging was cancelled. Draggable item ${id2} was dropped.`;
  }
};
var Action;
(function(Action2) {
  Action2["DragStart"] = "dragStart";
  Action2["DragMove"] = "dragMove";
  Action2["DragEnd"] = "dragEnd";
  Action2["DragCancel"] = "dragCancel";
  Action2["DragOver"] = "dragOver";
  Action2["RegisterDroppable"] = "registerDroppable";
  Action2["SetDroppableDisabled"] = "setDroppableDisabled";
  Action2["UnregisterDroppable"] = "unregisterDroppable";
})(Action || (Action = {}));
function noop$1(..._args) {
}
class DroppableContainersMap extends Map {
  get(id2) {
    var _super$get;
    return id2 != null ? (_super$get = super.get(id2)) != null ? _super$get : void 0 : void 0;
  }
  toArray() {
    return Array.from(this.values());
  }
  getEnabled() {
    return this.toArray().filter(({
      disabled
    }) => !disabled);
  }
  getNodeFor(id2) {
    var _this$get$node$curren, _this$get;
    return (_this$get$node$curren = (_this$get = this.get(id2)) == null ? void 0 : _this$get.node.current) != null ? _this$get$node$curren : void 0;
  }
}
const Context$1 = /* @__PURE__ */ react.exports.createContext({
  activatorEvent: null,
  active: null,
  activeNode: null,
  activeNodeRect: null,
  activeNodeClientRect: null,
  activators: [],
  ariaDescribedById: {
    draggable: ""
  },
  containerNodeRect: null,
  dispatch: noop$1,
  draggableNodes: {},
  droppableRects: /* @__PURE__ */ new Map(),
  droppableContainers: /* @__PURE__ */ new DroppableContainersMap(),
  over: null,
  dragOverlay: {
    nodeRef: {
      current: null
    },
    rect: null,
    setRef: noop$1
  },
  scrollableAncestors: [],
  scrollableAncestorRects: [],
  recomputeLayouts: noop$1,
  windowRect: null,
  willRecomputeLayouts: false
});
function getInitialState() {
  return {
    draggable: {
      active: null,
      initialCoordinates: {
        x: 0,
        y: 0
      },
      nodes: {},
      translate: {
        x: 0,
        y: 0
      }
    },
    droppable: {
      containers: new DroppableContainersMap()
    }
  };
}
function reducer(state, action) {
  switch (action.type) {
    case Action.DragStart:
      return {
        ...state,
        draggable: {
          ...state.draggable,
          initialCoordinates: action.initialCoordinates,
          active: action.active
        }
      };
    case Action.DragMove:
      if (!state.draggable.active) {
        return state;
      }
      return {
        ...state,
        draggable: {
          ...state.draggable,
          translate: {
            x: action.coordinates.x - state.draggable.initialCoordinates.x,
            y: action.coordinates.y - state.draggable.initialCoordinates.y
          }
        }
      };
    case Action.DragEnd:
    case Action.DragCancel:
      return {
        ...state,
        draggable: {
          ...state.draggable,
          active: null,
          initialCoordinates: {
            x: 0,
            y: 0
          },
          translate: {
            x: 0,
            y: 0
          }
        }
      };
    case Action.RegisterDroppable: {
      const {
        element
      } = action;
      const {
        id: id2
      } = element;
      const containers = new DroppableContainersMap(state.droppable.containers);
      containers.set(id2, element);
      return {
        ...state,
        droppable: {
          ...state.droppable,
          containers
        }
      };
    }
    case Action.SetDroppableDisabled: {
      const {
        id: id2,
        key,
        disabled
      } = action;
      const element = state.droppable.containers.get(id2);
      if (!element || key !== element.key) {
        return state;
      }
      const containers = new DroppableContainersMap(state.droppable.containers);
      containers.set(id2, {
        ...element,
        disabled
      });
      return {
        ...state,
        droppable: {
          ...state.droppable,
          containers
        }
      };
    }
    case Action.UnregisterDroppable: {
      const {
        id: id2,
        key
      } = action;
      const element = state.droppable.containers.get(id2);
      if (!element || key !== element.key) {
        return state;
      }
      const containers = new DroppableContainersMap(state.droppable.containers);
      containers.delete(id2);
      return {
        ...state,
        droppable: {
          ...state.droppable,
          containers
        }
      };
    }
    default: {
      return state;
    }
  }
}
const DndMonitorContext = /* @__PURE__ */ react.exports.createContext({
  type: null,
  event: null
});
function useDndMonitor({
  onDragStart,
  onDragMove,
  onDragOver,
  onDragEnd,
  onDragCancel
}) {
  const monitorState = react.exports.useContext(DndMonitorContext);
  const previousMonitorState = react.exports.useRef(monitorState);
  react.exports.useEffect(() => {
    if (monitorState !== previousMonitorState.current) {
      const {
        type,
        event
      } = monitorState;
      switch (type) {
        case Action.DragStart:
          onDragStart == null ? void 0 : onDragStart(event);
          break;
        case Action.DragMove:
          onDragMove == null ? void 0 : onDragMove(event);
          break;
        case Action.DragOver:
          onDragOver == null ? void 0 : onDragOver(event);
          break;
        case Action.DragCancel:
          onDragCancel == null ? void 0 : onDragCancel(event);
          break;
        case Action.DragEnd:
          onDragEnd == null ? void 0 : onDragEnd(event);
          break;
      }
      previousMonitorState.current = monitorState;
    }
  }, [monitorState, onDragStart, onDragMove, onDragOver, onDragEnd, onDragCancel]);
}
function Accessibility({
  announcements = defaultAnnouncements,
  hiddenTextDescribedById,
  screenReaderInstructions: screenReaderInstructions2
}) {
  const {
    announce,
    announcement
  } = useAnnouncement();
  const liveRegionId = useUniqueId(`DndLiveRegion`);
  const [mounted, setMounted] = react.exports.useState(false);
  react.exports.useEffect(() => {
    setMounted(true);
  }, []);
  useDndMonitor(react.exports.useMemo(() => ({
    onDragStart({
      active
    }) {
      announce(announcements.onDragStart(active.id));
    },
    onDragMove({
      active,
      over
    }) {
      if (announcements.onDragMove) {
        announce(announcements.onDragMove(active.id, over == null ? void 0 : over.id));
      }
    },
    onDragOver({
      active,
      over
    }) {
      announce(announcements.onDragOver(active.id, over == null ? void 0 : over.id));
    },
    onDragEnd({
      active,
      over
    }) {
      announce(announcements.onDragEnd(active.id, over == null ? void 0 : over.id));
    },
    onDragCancel({
      active
    }) {
      announce(announcements.onDragCancel(active.id));
    }
  }), [announce, announcements]));
  return mounted ? reactDom.exports.createPortal(/* @__PURE__ */ jsxs(Fragment$1, {
    children: [/* @__PURE__ */ jsx(HiddenText, {
      id: hiddenTextDescribedById,
      value: screenReaderInstructions2.draggable
    }), /* @__PURE__ */ jsx(LiveRegion, {
      id: liveRegionId,
      announcement
    })]
  }), document.body) : null;
}
const defaultCoordinates = /* @__PURE__ */ Object.freeze({
  x: 0,
  y: 0
});
function distanceBetween(p1, p2) {
  return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));
}
function centerOfRectangle(rect, left2 = rect.offsetLeft, top2 = rect.offsetTop) {
  return {
    x: left2 + rect.width * 0.5,
    y: top2 + rect.height * 0.5
  };
}
const closestCenter = ({
  collisionRect,
  droppableContainers
}) => {
  const centerRect = centerOfRectangle(collisionRect, collisionRect.left, collisionRect.top);
  let minDistanceToCenter = Infinity;
  let minDroppableContainer = null;
  for (const droppableContainer of droppableContainers) {
    const {
      rect: {
        current: rect
      }
    } = droppableContainer;
    if (rect) {
      const distBetween = distanceBetween(centerOfRectangle(rect), centerRect);
      if (distBetween < minDistanceToCenter) {
        minDistanceToCenter = distBetween;
        minDroppableContainer = droppableContainer.id;
      }
    }
  }
  return minDroppableContainer;
};
function adjustScale(transform, rect1, rect2) {
  return {
    ...transform,
    scaleX: rect1 && rect2 ? rect1.width / rect2.width : 1,
    scaleY: rect1 && rect2 ? rect1.height / rect2.height : 1
  };
}
function getRectDelta(rect1, rect2) {
  return rect1 && rect2 ? {
    x: rect1.left - rect2.left,
    y: rect1.top - rect2.top
  } : defaultCoordinates;
}
function createRectAdjustmentFn(modifier) {
  return function adjustViewRect(viewRect, ...adjustments) {
    return adjustments.reduce((acc, adjustment) => ({
      ...acc,
      top: acc.top + modifier * adjustment.y,
      bottom: acc.bottom + modifier * adjustment.y,
      left: acc.left + modifier * adjustment.x,
      right: acc.right + modifier * adjustment.x,
      offsetLeft: acc.offsetLeft + modifier * adjustment.x,
      offsetTop: acc.offsetTop + modifier * adjustment.y
    }), {
      ...viewRect
    });
  };
}
const getAdjustedRect = /* @__PURE__ */ createRectAdjustmentFn(1);
function isFixed(node2, computedStyle = window.getComputedStyle(node2)) {
  return computedStyle.position === "fixed";
}
function isScrollable(node2, computedStyle = window.getComputedStyle(node2)) {
  const overflowRegex = /(auto|scroll|overlay)/;
  const properties = ["overflow", "overflowX", "overflowY"];
  return properties.find((property) => {
    const value = computedStyle[property];
    return typeof value === "string" ? overflowRegex.test(value) : false;
  }) != null;
}
function getScrollableAncestors(element) {
  const scrollParents = [];
  function findScrollableAncestors(node2) {
    if (!node2) {
      return scrollParents;
    }
    if (isDocument(node2) && node2.scrollingElement != null && !scrollParents.includes(node2.scrollingElement)) {
      scrollParents.push(node2.scrollingElement);
      return scrollParents;
    }
    if (!isHTMLElement$1(node2) || isSVGElement(node2)) {
      return scrollParents;
    }
    if (scrollParents.includes(node2)) {
      return scrollParents;
    }
    const computedStyle = window.getComputedStyle(node2);
    if (isScrollable(node2, computedStyle)) {
      scrollParents.push(node2);
    }
    if (isFixed(node2, computedStyle)) {
      return scrollParents;
    }
    return findScrollableAncestors(node2.parentNode);
  }
  return element ? findScrollableAncestors(element.parentNode) : scrollParents;
}
function getScrollableElement(element) {
  if (!canUseDOM || !element) {
    return null;
  }
  if (isWindow(element)) {
    return element;
  }
  if (!isNode(element)) {
    return null;
  }
  if (isDocument(element) || element === getOwnerDocument$1(element).scrollingElement) {
    return window;
  }
  if (isHTMLElement$1(element)) {
    return element;
  }
  return null;
}
function getScrollCoordinates(element) {
  if (isWindow(element)) {
    return {
      x: element.scrollX,
      y: element.scrollY
    };
  }
  return {
    x: element.scrollLeft,
    y: element.scrollTop
  };
}
var Direction;
(function(Direction2) {
  Direction2[Direction2["Forward"] = 1] = "Forward";
  Direction2[Direction2["Backward"] = -1] = "Backward";
})(Direction || (Direction = {}));
function getScrollPosition(scrollingContainer) {
  const minScroll = {
    x: 0,
    y: 0
  };
  const maxScroll = {
    x: scrollingContainer.scrollWidth - scrollingContainer.clientWidth,
    y: scrollingContainer.scrollHeight - scrollingContainer.clientHeight
  };
  const isTop = scrollingContainer.scrollTop <= minScroll.y;
  const isLeft = scrollingContainer.scrollLeft <= minScroll.x;
  const isBottom = scrollingContainer.scrollTop >= maxScroll.y;
  const isRight = scrollingContainer.scrollLeft >= maxScroll.x;
  return {
    isTop,
    isLeft,
    isBottom,
    isRight,
    maxScroll,
    minScroll
  };
}
function isDocumentScrollingElement(element) {
  if (!canUseDOM || !element) {
    return false;
  }
  return element === document.scrollingElement;
}
const defaultThreshold = {
  x: 0.2,
  y: 0.2
};
function getScrollDirectionAndSpeed(scrollContainer, scrollContainerRect, {
  top: top2,
  left: left2,
  right: right2,
  bottom: bottom2
}, acceleration = 10, thresholdPercentage = defaultThreshold) {
  const {
    clientHeight,
    clientWidth
  } = scrollContainer;
  const finalScrollContainerRect = isDocumentScrollingElement(scrollContainer) ? {
    top: 0,
    left: 0,
    right: clientWidth,
    bottom: clientHeight,
    width: clientWidth,
    height: clientHeight
  } : scrollContainerRect;
  const {
    isTop,
    isBottom,
    isLeft,
    isRight
  } = getScrollPosition(scrollContainer);
  const direction = {
    x: 0,
    y: 0
  };
  const speed = {
    x: 0,
    y: 0
  };
  const threshold = {
    height: finalScrollContainerRect.height * thresholdPercentage.y,
    width: finalScrollContainerRect.width * thresholdPercentage.x
  };
  if (!isTop && top2 <= finalScrollContainerRect.top + threshold.height) {
    direction.y = Direction.Backward;
    speed.y = acceleration * Math.abs((finalScrollContainerRect.top + threshold.height - top2) / threshold.height);
  } else if (!isBottom && bottom2 >= finalScrollContainerRect.bottom - threshold.height) {
    direction.y = Direction.Forward;
    speed.y = acceleration * Math.abs((finalScrollContainerRect.bottom - threshold.height - bottom2) / threshold.height);
  }
  if (!isRight && right2 >= finalScrollContainerRect.right - threshold.width) {
    direction.x = Direction.Forward;
    speed.x = acceleration * Math.abs((finalScrollContainerRect.right - threshold.width - right2) / threshold.width);
  } else if (!isLeft && left2 <= finalScrollContainerRect.left + threshold.width) {
    direction.x = Direction.Backward;
    speed.x = acceleration * Math.abs((finalScrollContainerRect.left + threshold.width - left2) / threshold.width);
  }
  return {
    direction,
    speed
  };
}
function getScrollElementRect(element) {
  if (element === document.scrollingElement) {
    const {
      innerWidth,
      innerHeight: innerHeight2
    } = window;
    return {
      top: 0,
      left: 0,
      right: innerWidth,
      bottom: innerHeight2,
      width: innerWidth,
      height: innerHeight2
    };
  }
  const {
    top: top2,
    left: left2,
    right: right2,
    bottom: bottom2
  } = element.getBoundingClientRect();
  return {
    top: top2,
    left: left2,
    right: right2,
    bottom: bottom2,
    width: element.clientWidth,
    height: element.clientHeight
  };
}
function getScrollOffsets(scrollableAncestors) {
  return scrollableAncestors.reduce((acc, node2) => {
    return add(acc, getScrollCoordinates(node2));
  }, defaultCoordinates);
}
function getEdgeOffset(node2, parent, offset2 = defaultCoordinates) {
  if (!node2 || !isHTMLElement$1(node2)) {
    return offset2;
  }
  const nodeOffset = {
    x: offset2.x + node2.offsetLeft,
    y: offset2.y + node2.offsetTop
  };
  if (node2.offsetParent === parent) {
    return nodeOffset;
  }
  return getEdgeOffset(node2.offsetParent, parent, nodeOffset);
}
function getLayoutRect$1(element) {
  const {
    offsetWidth: width,
    offsetHeight: height
  } = element;
  const {
    x: offsetLeft,
    y: offsetTop2
  } = getEdgeOffset(element, null);
  return {
    width,
    height,
    offsetTop: offsetTop2,
    offsetLeft
  };
}
function getBoundingClientRect$1(element) {
  if (isWindow(element)) {
    const width2 = window.innerWidth;
    const height2 = window.innerHeight;
    return {
      top: 0,
      left: 0,
      right: width2,
      bottom: height2,
      width: width2,
      height: height2,
      offsetTop: 0,
      offsetLeft: 0
    };
  }
  const {
    offsetTop: offsetTop2,
    offsetLeft
  } = getLayoutRect$1(element);
  const {
    width,
    height,
    top: top2,
    bottom: bottom2,
    left: left2,
    right: right2
  } = element.getBoundingClientRect();
  return {
    width,
    height,
    top: top2,
    bottom: bottom2,
    right: right2,
    left: left2,
    offsetTop: offsetTop2,
    offsetLeft
  };
}
function getViewRect(element) {
  const {
    width,
    height,
    offsetTop: offsetTop2,
    offsetLeft
  } = getLayoutRect$1(element);
  const scrollableAncestors = getScrollableAncestors(element);
  const scrollOffsets = getScrollOffsets(scrollableAncestors);
  const top2 = offsetTop2 - scrollOffsets.y;
  const left2 = offsetLeft - scrollOffsets.x;
  return {
    width,
    height,
    top: top2,
    bottom: top2 + height,
    right: left2 + width,
    left: left2,
    offsetTop: offsetTop2,
    offsetLeft
  };
}
function isViewRect(entry) {
  return "top" in entry;
}
function cornersOfRectangle(rect, left2 = rect.offsetLeft, top2 = rect.offsetTop) {
  return [{
    x: left2,
    y: top2
  }, {
    x: left2 + rect.width,
    y: top2
  }, {
    x: left2,
    y: top2 + rect.height
  }, {
    x: left2 + rect.width,
    y: top2 + rect.height
  }];
}
const closestCorners = ({
  collisionRect,
  droppableContainers
}) => {
  let minDistanceToCorners = Infinity;
  let minDistanceContainer = null;
  const corners = cornersOfRectangle(collisionRect, collisionRect.left, collisionRect.top);
  for (const droppableContainer of droppableContainers) {
    const {
      rect: {
        current: rect
      }
    } = droppableContainer;
    if (rect) {
      const rectCorners = cornersOfRectangle(rect, isViewRect(rect) ? rect.left : void 0, isViewRect(rect) ? rect.top : void 0);
      const distances = corners.reduce((accumulator, corner, index2) => {
        return accumulator + distanceBetween(rectCorners[index2], corner);
      }, 0);
      const effectiveDistance = Number((distances / 4).toFixed(4));
      if (effectiveDistance < minDistanceToCorners) {
        minDistanceToCorners = effectiveDistance;
        minDistanceContainer = droppableContainer.id;
      }
    }
  }
  return minDistanceContainer;
};
function getIntersectionRatio(entry, target) {
  const top2 = Math.max(target.top, entry.offsetTop);
  const left2 = Math.max(target.left, entry.offsetLeft);
  const right2 = Math.min(target.left + target.width, entry.offsetLeft + entry.width);
  const bottom2 = Math.min(target.top + target.height, entry.offsetTop + entry.height);
  const width = right2 - left2;
  const height = bottom2 - top2;
  if (left2 < right2 && top2 < bottom2) {
    const targetArea = target.width * target.height;
    const entryArea = entry.width * entry.height;
    const intersectionArea = width * height;
    const intersectionRatio = intersectionArea / (targetArea + entryArea - intersectionArea);
    return Number(intersectionRatio.toFixed(4));
  }
  return 0;
}
const rectIntersection = ({
  collisionRect,
  droppableContainers
}) => {
  let maxIntersectionRatio = 0;
  let maxIntersectingDroppableContainer = null;
  for (const droppableContainer of droppableContainers) {
    const {
      rect: {
        current: rect
      }
    } = droppableContainer;
    if (rect) {
      const intersectionRatio = getIntersectionRatio(rect, collisionRect);
      if (intersectionRatio > maxIntersectionRatio) {
        maxIntersectionRatio = intersectionRatio;
        maxIntersectingDroppableContainer = droppableContainer.id;
      }
    }
  }
  return maxIntersectingDroppableContainer;
};
var AutoScrollActivator;
(function(AutoScrollActivator2) {
  AutoScrollActivator2[AutoScrollActivator2["Pointer"] = 0] = "Pointer";
  AutoScrollActivator2[AutoScrollActivator2["DraggableRect"] = 1] = "DraggableRect";
})(AutoScrollActivator || (AutoScrollActivator = {}));
var TraversalOrder;
(function(TraversalOrder2) {
  TraversalOrder2[TraversalOrder2["TreeOrder"] = 0] = "TreeOrder";
  TraversalOrder2[TraversalOrder2["ReversedTreeOrder"] = 1] = "ReversedTreeOrder";
})(TraversalOrder || (TraversalOrder = {}));
function useAutoScroller({
  acceleration,
  activator = AutoScrollActivator.Pointer,
  canScroll,
  draggingRect,
  enabled,
  interval = 5,
  order: order2 = TraversalOrder.TreeOrder,
  pointerCoordinates,
  scrollableAncestors,
  scrollableAncestorRects,
  threshold
}) {
  const [setAutoScrollInterval, clearAutoScrollInterval] = useInterval();
  const scrollSpeed = react.exports.useRef({
    x: 1,
    y: 1
  });
  const rect = react.exports.useMemo(() => {
    switch (activator) {
      case AutoScrollActivator.Pointer:
        return pointerCoordinates ? {
          top: pointerCoordinates.y,
          bottom: pointerCoordinates.y,
          left: pointerCoordinates.x,
          right: pointerCoordinates.x
        } : null;
      case AutoScrollActivator.DraggableRect:
        return draggingRect;
    }
    return null;
  }, [activator, draggingRect, pointerCoordinates]);
  const scrollDirection = react.exports.useRef(defaultCoordinates);
  const scrollContainerRef = react.exports.useRef(null);
  const autoScroll2 = react.exports.useCallback(() => {
    const scrollContainer = scrollContainerRef.current;
    if (!scrollContainer) {
      return;
    }
    const scrollLeft = scrollSpeed.current.x * scrollDirection.current.x;
    const scrollTop = scrollSpeed.current.y * scrollDirection.current.y;
    scrollContainer.scrollBy(scrollLeft, scrollTop);
  }, []);
  const sortedScrollableAncestors = react.exports.useMemo(() => order2 === TraversalOrder.TreeOrder ? [...scrollableAncestors].reverse() : scrollableAncestors, [order2, scrollableAncestors]);
  react.exports.useEffect(
    () => {
      if (!enabled || !scrollableAncestors.length || !rect) {
        clearAutoScrollInterval();
        return;
      }
      for (const scrollContainer of sortedScrollableAncestors) {
        if ((canScroll == null ? void 0 : canScroll(scrollContainer)) === false) {
          continue;
        }
        const index2 = scrollableAncestors.indexOf(scrollContainer);
        const scrolllContainerRect = scrollableAncestorRects[index2];
        if (!scrolllContainerRect) {
          continue;
        }
        const {
          direction,
          speed
        } = getScrollDirectionAndSpeed(scrollContainer, scrolllContainerRect, rect, acceleration, threshold);
        if (speed.x > 0 || speed.y > 0) {
          clearAutoScrollInterval();
          scrollContainerRef.current = scrollContainer;
          setAutoScrollInterval(autoScroll2, interval);
          scrollSpeed.current = speed;
          scrollDirection.current = direction;
          return;
        }
      }
      scrollSpeed.current = {
        x: 0,
        y: 0
      };
      scrollDirection.current = {
        x: 0,
        y: 0
      };
      clearAutoScrollInterval();
    },
    [
      acceleration,
      autoScroll2,
      canScroll,
      clearAutoScrollInterval,
      enabled,
      interval,
      JSON.stringify(rect),
      setAutoScrollInterval,
      scrollableAncestors,
      sortedScrollableAncestors,
      scrollableAncestorRects,
      JSON.stringify(threshold)
    ]
  );
}
function useCachedNode(draggableNodes, id2) {
  const draggableNode = id2 !== null ? draggableNodes[id2] : void 0;
  const node2 = draggableNode ? draggableNode.node.current : null;
  return useLazyMemo((cachedNode) => {
    var _ref2;
    if (id2 === null) {
      return null;
    }
    return (_ref2 = node2 != null ? node2 : cachedNode) != null ? _ref2 : null;
  }, [node2, id2]);
}
function useCombineActivators(sensors, getSyntheticHandler) {
  return react.exports.useMemo(() => sensors.reduce((accumulator, sensor) => {
    const {
      sensor: Sensor
    } = sensor;
    const sensorActivators = Sensor.activators.map((activator) => ({
      eventName: activator.eventName,
      handler: getSyntheticHandler(activator.handler, sensor)
    }));
    return [...accumulator, ...sensorActivators];
  }, []), [sensors, getSyntheticHandler]);
}
function useData$1(data) {
  const dataRef = react.exports.useRef(data);
  useIsomorphicLayoutEffect$3(() => {
    if (dataRef.current !== data) {
      dataRef.current = data;
    }
  }, [data]);
  return dataRef;
}
var MeasuringStrategy;
(function(MeasuringStrategy2) {
  MeasuringStrategy2[MeasuringStrategy2["Always"] = 0] = "Always";
  MeasuringStrategy2[MeasuringStrategy2["BeforeDragging"] = 1] = "BeforeDragging";
  MeasuringStrategy2[MeasuringStrategy2["WhileDragging"] = 2] = "WhileDragging";
})(MeasuringStrategy || (MeasuringStrategy = {}));
var MeasuringFrequency;
(function(MeasuringFrequency2) {
  MeasuringFrequency2["Optimized"] = "optimized";
})(MeasuringFrequency || (MeasuringFrequency = {}));
const defaultValue = /* @__PURE__ */ new Map();
const defaultConfig = {
  measure: getLayoutRect$1,
  strategy: MeasuringStrategy.WhileDragging,
  frequency: MeasuringFrequency.Optimized
};
function useDroppableMeasuring(containers, {
  dragging,
  dependencies,
  config
}) {
  const [willRecomputeLayouts, setWillRecomputeLayouts] = react.exports.useState(false);
  const {
    frequency,
    measure,
    strategy
  } = {
    ...defaultConfig,
    ...config
  };
  const containersRef = react.exports.useRef(containers);
  const recomputeLayouts = react.exports.useCallback(() => setWillRecomputeLayouts(true), []);
  const recomputeLayoutsTimeoutId = react.exports.useRef(null);
  const disabled = isDisabled();
  const layoutRectMap = useLazyMemo((previousValue) => {
    if (disabled && !dragging) {
      return defaultValue;
    }
    if (!previousValue || previousValue === defaultValue || containersRef.current !== containers || willRecomputeLayouts) {
      for (let container of containers) {
        if (!container) {
          continue;
        }
        container.rect.current = container.node.current ? measure(container.node.current) : null;
      }
      return createLayoutRectMap(containers);
    }
    return previousValue;
  }, [containers, dragging, disabled, measure, willRecomputeLayouts]);
  react.exports.useEffect(() => {
    containersRef.current = containers;
  }, [containers]);
  react.exports.useEffect(() => {
    if (willRecomputeLayouts) {
      setWillRecomputeLayouts(false);
    }
  }, [willRecomputeLayouts]);
  react.exports.useEffect(
    function recompute() {
      if (disabled) {
        return;
      }
      requestAnimationFrame(recomputeLayouts);
    },
    [dragging, disabled]
  );
  react.exports.useEffect(
    function forceRecomputeLayouts() {
      if (disabled || typeof frequency !== "number" || recomputeLayoutsTimeoutId.current !== null) {
        return;
      }
      recomputeLayoutsTimeoutId.current = setTimeout(() => {
        recomputeLayouts();
        recomputeLayoutsTimeoutId.current = null;
      }, frequency);
    },
    [frequency, disabled, recomputeLayouts, ...dependencies]
  );
  return {
    layoutRectMap,
    recomputeLayouts,
    willRecomputeLayouts
  };
  function isDisabled() {
    switch (strategy) {
      case MeasuringStrategy.Always:
        return false;
      case MeasuringStrategy.BeforeDragging:
        return dragging;
      default:
        return !dragging;
    }
  }
}
function createLayoutRectMap(containers) {
  const layoutRectMap = /* @__PURE__ */ new Map();
  if (containers) {
    for (const container of containers) {
      if (!container) {
        continue;
      }
      const {
        id: id2,
        rect
      } = container;
      if (rect.current == null) {
        continue;
      }
      layoutRectMap.set(id2, rect.current);
    }
  }
  return layoutRectMap;
}
function useScrollOffsets(elements) {
  const [scrollCoordinates, setScrollCoordinates] = react.exports.useState(null);
  const prevElements = react.exports.useRef(elements);
  const handleScroll2 = react.exports.useCallback((event) => {
    const scrollingElement = getScrollableElement(event.target);
    if (!scrollingElement) {
      return;
    }
    setScrollCoordinates((scrollCoordinates2) => {
      if (!scrollCoordinates2) {
        return null;
      }
      scrollCoordinates2.set(scrollingElement, getScrollCoordinates(scrollingElement));
      return new Map(scrollCoordinates2);
    });
  }, []);
  react.exports.useEffect(() => {
    const previousElements = prevElements.current;
    if (elements !== previousElements) {
      cleanup(previousElements);
      const entries = elements.map((element) => {
        const scrollableElement = getScrollableElement(element);
        if (scrollableElement) {
          scrollableElement.addEventListener("scroll", handleScroll2, {
            passive: true
          });
          return [scrollableElement, getScrollCoordinates(scrollableElement)];
        }
        return null;
      }).filter((entry) => entry != null);
      setScrollCoordinates(entries.length ? new Map(entries) : null);
      prevElements.current = elements;
    }
    return () => {
      cleanup(elements);
      cleanup(previousElements);
    };
    function cleanup(elements2) {
      elements2.forEach((element) => {
        const scrollableElement = getScrollableElement(element);
        scrollableElement == null ? void 0 : scrollableElement.removeEventListener("scroll", handleScroll2);
      });
    }
  }, [handleScroll2, elements]);
  return react.exports.useMemo(() => {
    if (elements.length) {
      return scrollCoordinates ? Array.from(scrollCoordinates.values()).reduce((acc, coordinates) => add(acc, coordinates), defaultCoordinates) : getScrollOffsets(elements);
    }
    return defaultCoordinates;
  }, [elements, scrollCoordinates]);
}
const defaultValue$1 = [];
function useScrollableAncestors(node2) {
  const previousNode = react.exports.useRef(node2);
  const ancestors = useLazyMemo((previousValue) => {
    if (!node2) {
      return defaultValue$1;
    }
    if (previousValue && node2 && previousNode.current && node2.parentNode === previousNode.current.parentNode) {
      return previousValue;
    }
    return getScrollableAncestors(node2);
  }, [node2]);
  react.exports.useEffect(() => {
    previousNode.current = node2;
  }, [node2]);
  return ancestors;
}
function useSensorSetup(sensors) {
  react.exports.useEffect(
    () => {
      if (!canUseDOM) {
        return;
      }
      const teardownFns = sensors.map(({
        sensor
      }) => sensor.setup == null ? void 0 : sensor.setup());
      return () => {
        for (const teardown of teardownFns) {
          teardown == null ? void 0 : teardown();
        }
      };
    },
    sensors.map(({
      sensor
    }) => sensor)
  );
}
function useSyntheticListeners(listeners, id2) {
  return react.exports.useMemo(() => {
    return listeners.reduce((acc, {
      eventName,
      handler
    }) => {
      acc[eventName] = (event) => {
        handler(event, id2);
      };
      return acc;
    }, {});
  }, [listeners, id2]);
}
const useClientRect = /* @__PURE__ */ createUseRectFn(getBoundingClientRect$1);
const useClientRects = /* @__PURE__ */ createUseRectsFn(getBoundingClientRect$1);
function useRect$1(element, getRect2, forceRecompute) {
  const previousElement = react.exports.useRef(element);
  return useLazyMemo((previousValue) => {
    if (!element) {
      return null;
    }
    if (forceRecompute || !previousValue && element || element !== previousElement.current) {
      if (isHTMLElement$1(element) && element.parentNode == null) {
        return null;
      }
      return getRect2(element);
    }
    return previousValue != null ? previousValue : null;
  }, [element, forceRecompute, getRect2]);
}
function createUseRectFn(getRect2) {
  return (element, forceRecompute) => useRect$1(element, getRect2, forceRecompute);
}
function createUseRectsFn(getRect2) {
  const defaultValue2 = [];
  return function useRects(elements, forceRecompute) {
    const previousElements = react.exports.useRef(elements);
    return useLazyMemo((previousValue) => {
      if (!elements.length) {
        return defaultValue2;
      }
      if (forceRecompute || !previousValue && elements.length || elements !== previousElements.current) {
        return elements.map((element) => getRect2(element));
      }
      return previousValue != null ? previousValue : defaultValue2;
    }, [elements, forceRecompute]);
  };
}
function getMeasurableNode(node2) {
  if (!node2) {
    return null;
  }
  if (node2.children.length > 1) {
    return node2;
  }
  const firstChild = node2.children[0];
  return isHTMLElement$1(firstChild) ? firstChild : node2;
}
function getDragOverlayRect(element) {
  const {
    width,
    height,
    offsetLeft,
    offsetTop: offsetTop2
  } = getLayoutRect$1(element);
  return {
    top: offsetTop2,
    bottom: offsetTop2 + height,
    left: offsetLeft,
    right: offsetLeft + width,
    width,
    height,
    offsetTop: offsetTop2,
    offsetLeft
  };
}
const useDragOverlayRect = /* @__PURE__ */ createUseRectFn(getDragOverlayRect);
function useDragOverlayMeasuring({
  disabled,
  forceRecompute
}) {
  const [nodeRef, setRef3] = useNodeRef();
  const rect = useDragOverlayRect(disabled ? null : getMeasurableNode(nodeRef.current), forceRecompute);
  return react.exports.useMemo(() => ({
    nodeRef,
    rect,
    setRef: setRef3
  }), [rect, nodeRef, setRef3]);
}
function useSensor(sensor, options) {
  return react.exports.useMemo(
    () => ({
      sensor,
      options: options != null ? options : {}
    }),
    [sensor, options]
  );
}
function useSensors(...sensors) {
  return react.exports.useMemo(
    () => [...sensors].filter((sensor) => sensor != null),
    [...sensors]
  );
}
class Listeners {
  constructor(target) {
    this.target = target;
    this.listeners = [];
    this.removeAll = () => {
      this.listeners.forEach((listener) => {
        var _this$target;
        return (_this$target = this.target) == null ? void 0 : _this$target.removeEventListener(...listener);
      });
    };
  }
  add(eventName, handler, options) {
    var _this$target2;
    (_this$target2 = this.target) == null ? void 0 : _this$target2.addEventListener(eventName, handler, options);
    this.listeners.push([eventName, handler, options]);
  }
}
function getEventListenerTarget(target) {
  const {
    EventTarget
  } = getWindow$1(target);
  return target instanceof EventTarget ? target : getOwnerDocument$1(target);
}
function hasExceededDistance(delta, measurement) {
  const dx = Math.abs(delta.x);
  const dy = Math.abs(delta.y);
  if (typeof measurement === "number") {
    return Math.sqrt(dx ** 2 + dy ** 2) > measurement;
  }
  if ("x" in measurement && "y" in measurement) {
    return dx > measurement.x && dy > measurement.y;
  }
  if ("x" in measurement) {
    return dx > measurement.x;
  }
  if ("y" in measurement) {
    return dy > measurement.y;
  }
  return false;
}
var EventName;
(function(EventName2) {
  EventName2["Click"] = "click";
  EventName2["DragStart"] = "dragstart";
  EventName2["Keydown"] = "keydown";
  EventName2["ContextMenu"] = "contextmenu";
  EventName2["Resize"] = "resize";
  EventName2["SelectionChange"] = "selectionchange";
  EventName2["VisibilityChange"] = "visibilitychange";
})(EventName || (EventName = {}));
function preventDefault$1(event) {
  event.preventDefault();
}
function stopPropagation$1(event) {
  event.stopPropagation();
}
var KeyboardCode;
(function(KeyboardCode2) {
  KeyboardCode2["Space"] = "Space";
  KeyboardCode2["Down"] = "ArrowDown";
  KeyboardCode2["Right"] = "ArrowRight";
  KeyboardCode2["Left"] = "ArrowLeft";
  KeyboardCode2["Up"] = "ArrowUp";
  KeyboardCode2["Esc"] = "Escape";
  KeyboardCode2["Enter"] = "Enter";
})(KeyboardCode || (KeyboardCode = {}));
const defaultKeyboardCodes = {
  start: [KeyboardCode.Space, KeyboardCode.Enter],
  cancel: [KeyboardCode.Esc],
  end: [KeyboardCode.Space, KeyboardCode.Enter]
};
const defaultKeyboardCoordinateGetter = (event, {
  currentCoordinates
}) => {
  switch (event.code) {
    case KeyboardCode.Right:
      return {
        ...currentCoordinates,
        x: currentCoordinates.x + 25
      };
    case KeyboardCode.Left:
      return {
        ...currentCoordinates,
        x: currentCoordinates.x - 25
      };
    case KeyboardCode.Down:
      return {
        ...currentCoordinates,
        y: currentCoordinates.y + 25
      };
    case KeyboardCode.Up:
      return {
        ...currentCoordinates,
        y: currentCoordinates.y - 25
      };
  }
  return void 0;
};
class KeyboardSensor {
  constructor(props) {
    this.props = props;
    this.autoScrollEnabled = false;
    this.coordinates = defaultCoordinates;
    const {
      event: {
        target
      }
    } = props;
    this.props = props;
    this.listeners = new Listeners(getOwnerDocument$1(target));
    this.windowListeners = new Listeners(getWindow$1(target));
    this.handleKeyDown = this.handleKeyDown.bind(this);
    this.handleCancel = this.handleCancel.bind(this);
    this.attach();
  }
  attach() {
    this.handleStart();
    this.windowListeners.add(EventName.Resize, this.handleCancel);
    this.windowListeners.add(EventName.VisibilityChange, this.handleCancel);
    setTimeout(() => this.listeners.add(EventName.Keydown, this.handleKeyDown));
  }
  handleStart() {
    const {
      activeNode,
      onStart
    } = this.props;
    if (!activeNode.node.current) {
      throw new Error("Active draggable node is undefined");
    }
    const activeNodeRect = getBoundingClientRect$1(activeNode.node.current);
    const coordinates = {
      x: activeNodeRect.left,
      y: activeNodeRect.top
    };
    this.coordinates = coordinates;
    onStart(coordinates);
  }
  handleKeyDown(event) {
    if (isKeyboardEvent(event)) {
      const {
        coordinates
      } = this;
      const {
        active,
        context,
        options
      } = this.props;
      const {
        keyboardCodes = defaultKeyboardCodes,
        coordinateGetter = defaultKeyboardCoordinateGetter,
        scrollBehavior = "smooth"
      } = options;
      const {
        code
      } = event;
      if (keyboardCodes.end.includes(code)) {
        this.handleEnd(event);
        return;
      }
      if (keyboardCodes.cancel.includes(code)) {
        this.handleCancel(event);
        return;
      }
      const newCoordinates = coordinateGetter(event, {
        active,
        context: context.current,
        currentCoordinates: coordinates
      });
      if (newCoordinates) {
        const scrollDelta = {
          x: 0,
          y: 0
        };
        const {
          scrollableAncestors
        } = context.current;
        for (const scrollContainer of scrollableAncestors) {
          const direction = event.code;
          const coordinatesDelta = subtract(newCoordinates, coordinates);
          const {
            isTop,
            isRight,
            isLeft,
            isBottom,
            maxScroll,
            minScroll
          } = getScrollPosition(scrollContainer);
          const scrollElementRect = getScrollElementRect(scrollContainer);
          const clampedCoordinates = {
            x: Math.min(direction === KeyboardCode.Right ? scrollElementRect.right - scrollElementRect.width / 2 : scrollElementRect.right, Math.max(direction === KeyboardCode.Right ? scrollElementRect.left : scrollElementRect.left + scrollElementRect.width / 2, newCoordinates.x)),
            y: Math.min(direction === KeyboardCode.Down ? scrollElementRect.bottom - scrollElementRect.height / 2 : scrollElementRect.bottom, Math.max(direction === KeyboardCode.Down ? scrollElementRect.top : scrollElementRect.top + scrollElementRect.height / 2, newCoordinates.y))
          };
          const canScrollX = direction === KeyboardCode.Right && !isRight || direction === KeyboardCode.Left && !isLeft;
          const canScrollY = direction === KeyboardCode.Down && !isBottom || direction === KeyboardCode.Up && !isTop;
          if (canScrollX && clampedCoordinates.x !== newCoordinates.x) {
            const canFullyScrollToNewCoordinates = direction === KeyboardCode.Right && scrollContainer.scrollLeft + coordinatesDelta.x <= maxScroll.x || direction === KeyboardCode.Left && scrollContainer.scrollLeft + coordinatesDelta.x >= minScroll.x;
            if (canFullyScrollToNewCoordinates) {
              scrollContainer.scrollBy({
                left: coordinatesDelta.x,
                behavior: scrollBehavior
              });
              return;
            }
            scrollDelta.x = direction === KeyboardCode.Right ? scrollContainer.scrollLeft - maxScroll.x : scrollContainer.scrollLeft - minScroll.x;
            scrollContainer.scrollBy({
              left: -scrollDelta.x,
              behavior: scrollBehavior
            });
            break;
          } else if (canScrollY && clampedCoordinates.y !== newCoordinates.y) {
            const canFullyScrollToNewCoordinates = direction === KeyboardCode.Down && scrollContainer.scrollTop + coordinatesDelta.y <= maxScroll.y || direction === KeyboardCode.Up && scrollContainer.scrollTop + coordinatesDelta.y >= minScroll.y;
            if (canFullyScrollToNewCoordinates) {
              scrollContainer.scrollBy({
                top: coordinatesDelta.y,
                behavior: scrollBehavior
              });
              return;
            }
            scrollDelta.y = direction === KeyboardCode.Down ? scrollContainer.scrollTop - maxScroll.y : scrollContainer.scrollTop - minScroll.y;
            scrollContainer.scrollBy({
              top: -scrollDelta.y,
              behavior: scrollBehavior
            });
            break;
          }
        }
        this.handleMove(event, add(newCoordinates, scrollDelta));
      }
    }
  }
  handleMove(event, coordinates) {
    const {
      onMove
    } = this.props;
    event.preventDefault();
    onMove(coordinates);
    this.coordinates = coordinates;
  }
  handleEnd(event) {
    const {
      onEnd
    } = this.props;
    event.preventDefault();
    this.detach();
    onEnd();
  }
  handleCancel(event) {
    const {
      onCancel
    } = this.props;
    event.preventDefault();
    this.detach();
    onCancel();
  }
  detach() {
    this.listeners.removeAll();
    this.windowListeners.removeAll();
  }
}
KeyboardSensor.activators = [{
  eventName: "onKeyDown",
  handler: (event, {
    keyboardCodes = defaultKeyboardCodes,
    onActivation
  }) => {
    const {
      code
    } = event.nativeEvent;
    if (keyboardCodes.start.includes(code)) {
      event.preventDefault();
      onActivation == null ? void 0 : onActivation({
        event: event.nativeEvent
      });
      return true;
    }
    return false;
  }
}];
function isDistanceConstraint(constraint) {
  return Boolean(constraint && "distance" in constraint);
}
function isDelayConstraint(constraint) {
  return Boolean(constraint && "delay" in constraint);
}
class AbstractPointerSensor {
  constructor(props, events2, listenerTarget = getEventListenerTarget(props.event.target)) {
    this.props = props;
    this.events = events2;
    this.autoScrollEnabled = true;
    this.activated = false;
    this.timeoutId = null;
    const {
      event
    } = props;
    const {
      target
    } = event;
    this.props = props;
    this.events = events2;
    this.document = getOwnerDocument$1(target);
    this.documentListeners = new Listeners(this.document);
    this.listeners = new Listeners(listenerTarget);
    this.windowListeners = new Listeners(getWindow$1(target));
    this.initialCoordinates = getEventCoordinates(event);
    this.handleStart = this.handleStart.bind(this);
    this.handleMove = this.handleMove.bind(this);
    this.handleEnd = this.handleEnd.bind(this);
    this.handleCancel = this.handleCancel.bind(this);
    this.handleKeydown = this.handleKeydown.bind(this);
    this.removeTextSelection = this.removeTextSelection.bind(this);
    this.attach();
  }
  attach() {
    const {
      events: events2,
      props: {
        options: {
          activationConstraint
        }
      }
    } = this;
    this.listeners.add(events2.move.name, this.handleMove, {
      passive: false
    });
    this.listeners.add(events2.end.name, this.handleEnd);
    this.windowListeners.add(EventName.Resize, this.handleCancel);
    this.windowListeners.add(EventName.DragStart, preventDefault$1);
    this.windowListeners.add(EventName.VisibilityChange, this.handleCancel);
    this.windowListeners.add(EventName.ContextMenu, preventDefault$1);
    this.documentListeners.add(EventName.Keydown, this.handleKeydown);
    if (activationConstraint) {
      if (isDistanceConstraint(activationConstraint)) {
        return;
      }
      if (isDelayConstraint(activationConstraint)) {
        this.timeoutId = setTimeout(this.handleStart, activationConstraint.delay);
        return;
      }
    }
    this.handleStart();
  }
  detach() {
    this.listeners.removeAll();
    this.windowListeners.removeAll();
    setTimeout(this.documentListeners.removeAll, 50);
    if (this.timeoutId !== null) {
      clearTimeout(this.timeoutId);
      this.timeoutId = null;
    }
  }
  handleStart() {
    const {
      initialCoordinates
    } = this;
    const {
      onStart
    } = this.props;
    if (initialCoordinates) {
      this.activated = true;
      this.documentListeners.add(EventName.Click, stopPropagation$1, {
        capture: true
      });
      this.removeTextSelection();
      this.documentListeners.add(EventName.SelectionChange, this.removeTextSelection);
      onStart(initialCoordinates);
    }
  }
  handleMove(event) {
    const {
      activated,
      initialCoordinates,
      props
    } = this;
    const {
      onMove,
      options: {
        activationConstraint
      }
    } = props;
    if (!initialCoordinates) {
      return;
    }
    const coordinates = getEventCoordinates(event);
    const delta = subtract(initialCoordinates, coordinates);
    if (!activated && activationConstraint) {
      if (isDelayConstraint(activationConstraint)) {
        if (hasExceededDistance(delta, activationConstraint.tolerance)) {
          return this.handleCancel();
        }
        return;
      }
      if (isDistanceConstraint(activationConstraint)) {
        if (activationConstraint.tolerance != null && hasExceededDistance(delta, activationConstraint.tolerance)) {
          return this.handleCancel();
        }
        if (hasExceededDistance(delta, activationConstraint.distance)) {
          return this.handleStart();
        }
        return;
      }
    }
    if (event.cancelable) {
      event.preventDefault();
    }
    onMove(coordinates);
  }
  handleEnd() {
    const {
      onEnd
    } = this.props;
    this.detach();
    onEnd();
  }
  handleCancel() {
    const {
      onCancel
    } = this.props;
    this.detach();
    onCancel();
  }
  handleKeydown(event) {
    if (event.code === KeyboardCode.Esc) {
      this.handleCancel();
    }
  }
  removeTextSelection() {
    var _this$document$getSel;
    (_this$document$getSel = this.document.getSelection()) == null ? void 0 : _this$document$getSel.removeAllRanges();
  }
}
const events = {
  move: {
    name: "pointermove"
  },
  end: {
    name: "pointerup"
  }
};
class PointerSensor extends AbstractPointerSensor {
  constructor(props) {
    const {
      event
    } = props;
    const listenerTarget = getOwnerDocument$1(event.target);
    super(props, events, listenerTarget);
  }
}
PointerSensor.activators = [{
  eventName: "onPointerDown",
  handler: ({
    nativeEvent: event
  }, {
    onActivation
  }) => {
    if (!event.isPrimary || event.button !== 0) {
      return false;
    }
    onActivation == null ? void 0 : onActivation({
      event
    });
    return true;
  }
}];
const events$1 = {
  move: {
    name: "mousemove"
  },
  end: {
    name: "mouseup"
  }
};
var MouseButton;
(function(MouseButton2) {
  MouseButton2[MouseButton2["RightClick"] = 2] = "RightClick";
})(MouseButton || (MouseButton = {}));
class MouseSensor extends AbstractPointerSensor {
  constructor(props) {
    super(props, events$1, getOwnerDocument$1(props.event.target));
  }
}
MouseSensor.activators = [{
  eventName: "onMouseDown",
  handler: ({
    nativeEvent: event
  }, {
    onActivation
  }) => {
    if (event.button === MouseButton.RightClick) {
      return false;
    }
    onActivation == null ? void 0 : onActivation({
      event
    });
    return true;
  }
}];
const events$2 = {
  move: {
    name: "touchmove"
  },
  end: {
    name: "touchend"
  }
};
class TouchSensor extends AbstractPointerSensor {
  constructor(props) {
    super(props, events$2);
  }
  static setup() {
    window.addEventListener(events$2.move.name, noop2, {
      capture: false,
      passive: false
    });
    return function teardown() {
      window.removeEventListener(events$2.move.name, noop2);
    };
    function noop2() {
    }
  }
}
TouchSensor.activators = [{
  eventName: "onTouchStart",
  handler: ({
    nativeEvent: event
  }, {
    onActivation
  }) => {
    const {
      touches
    } = event;
    if (touches.length > 1) {
      return false;
    }
    onActivation == null ? void 0 : onActivation({
      event
    });
    return true;
  }
}];
function applyModifiers(modifiers2, {
  transform,
  ...args
}) {
  return (modifiers2 == null ? void 0 : modifiers2.length) ? modifiers2.reduce((accumulator, modifier) => {
    return modifier({
      transform: accumulator,
      ...args
    });
  }, transform) : transform;
}
const defaultSensors = [{
  sensor: PointerSensor,
  options: {}
}, {
  sensor: KeyboardSensor,
  options: {}
}];
const defaultData = {
  current: {}
};
const ActiveDraggableContext = /* @__PURE__ */ react.exports.createContext({
  ...defaultCoordinates,
  scaleX: 1,
  scaleY: 1
});
const DndContext = /* @__PURE__ */ react.exports.memo(function DndContext2({
  id: id2,
  autoScroll: autoScroll2 = true,
  announcements,
  children,
  sensors = defaultSensors,
  collisionDetection = rectIntersection,
  measuring,
  modifiers: modifiers2,
  screenReaderInstructions: screenReaderInstructions$1 = screenReaderInstructions,
  ...props
}) {
  var _measuring$draggable$, _measuring$draggable, _sensorContext$curren, _dragOverlay$rect, _over$rect;
  const store = react.exports.useReducer(reducer, void 0, getInitialState);
  const [state, dispatch] = store;
  const [monitorState, setMonitorState] = react.exports.useState(() => ({
    type: null,
    event: null
  }));
  const [isDragging, setIsDragging] = react.exports.useState(false);
  const {
    draggable: {
      active: activeId,
      nodes: draggableNodes,
      translate
    },
    droppable: {
      containers: droppableContainers
    }
  } = state;
  const node2 = activeId ? draggableNodes[activeId] : null;
  const activeRects = react.exports.useRef({
    initial: null,
    translated: null
  });
  const active = react.exports.useMemo(() => {
    var _node$data;
    return activeId != null ? {
      id: activeId,
      data: (_node$data = node2 == null ? void 0 : node2.data) != null ? _node$data : defaultData,
      rect: activeRects
    } : null;
  }, [activeId, node2]);
  const activeRef = react.exports.useRef(null);
  const [activeSensor, setActiveSensor] = react.exports.useState(null);
  const [activatorEvent, setActivatorEvent] = react.exports.useState(null);
  const latestProps = react.exports.useRef(props);
  const draggableDescribedById = useUniqueId(`DndDescribedBy`, id2);
  const enabledDroppableContainers = react.exports.useMemo(() => {
    return droppableContainers.getEnabled();
  }, [droppableContainers]);
  const {
    layoutRectMap: droppableRects,
    recomputeLayouts,
    willRecomputeLayouts
  } = useDroppableMeasuring(enabledDroppableContainers, {
    dragging: isDragging,
    dependencies: [translate.x, translate.y],
    config: measuring == null ? void 0 : measuring.droppable
  });
  const activeNode = useCachedNode(draggableNodes, activeId);
  const activationCoordinates = activatorEvent ? getEventCoordinates(activatorEvent) : null;
  const activeNodeRect = useRect$1(activeNode, (_measuring$draggable$ = measuring == null ? void 0 : (_measuring$draggable = measuring.draggable) == null ? void 0 : _measuring$draggable.measure) != null ? _measuring$draggable$ : getViewRect);
  const activeNodeClientRect = useClientRect(activeNode);
  const initialActiveNodeRectRef = react.exports.useRef(null);
  const initialActiveNodeRect = initialActiveNodeRectRef.current;
  const sensorContext = react.exports.useRef({
    active: null,
    activeNode,
    collisionRect: null,
    droppableRects,
    draggableNodes,
    draggingNodeRect: null,
    droppableContainers,
    over: null,
    scrollableAncestors: [],
    scrollAdjustedTranslate: null,
    translatedRect: null
  });
  const overNode = droppableContainers.getNodeFor((_sensorContext$curren = sensorContext.current.over) == null ? void 0 : _sensorContext$curren.id);
  const windowRect2 = useClientRect(activeNode ? activeNode.ownerDocument.defaultView : null);
  const containerNodeRect = useClientRect(activeNode ? activeNode.parentElement : null);
  const scrollableAncestors = useScrollableAncestors(activeId ? overNode != null ? overNode : activeNode : null);
  const scrollableAncestorRects = useClientRects(scrollableAncestors);
  const dragOverlay = useDragOverlayMeasuring({
    disabled: activeId == null,
    forceRecompute: willRecomputeLayouts
  });
  const draggingNodeRect = (_dragOverlay$rect = dragOverlay.rect) != null ? _dragOverlay$rect : activeNodeRect;
  const nodeRectDelta = draggingNodeRect === activeNodeRect ? getRectDelta(activeNodeRect, initialActiveNodeRect) : defaultCoordinates;
  const modifiedTranslate = applyModifiers(modifiers2, {
    transform: {
      x: translate.x - nodeRectDelta.x,
      y: translate.y - nodeRectDelta.y,
      scaleX: 1,
      scaleY: 1
    },
    activatorEvent,
    active,
    activeNodeRect: activeNodeClientRect,
    containerNodeRect,
    draggingNodeRect,
    over: sensorContext.current.over,
    overlayNodeRect: dragOverlay.rect,
    scrollableAncestors,
    scrollableAncestorRects,
    windowRect: windowRect2
  });
  const pointerCoordinates = activationCoordinates ? add(activationCoordinates, translate) : null;
  const scrollAdjustment = useScrollOffsets(scrollableAncestors);
  const scrollAdjustedTranslate = add(modifiedTranslate, scrollAdjustment);
  const translatedRect = draggingNodeRect ? getAdjustedRect(draggingNodeRect, modifiedTranslate) : null;
  const collisionRect = translatedRect ? getAdjustedRect(translatedRect, scrollAdjustment) : null;
  const overId = active && collisionRect ? collisionDetection({
    active,
    collisionRect,
    droppableContainers: enabledDroppableContainers
  }) : null;
  const [over, setOver] = react.exports.useState(null);
  const transform = adjustScale(modifiedTranslate, (_over$rect = over == null ? void 0 : over.rect) != null ? _over$rect : null, activeNodeRect);
  const instantiateSensor = react.exports.useCallback((event, {
    sensor: Sensor,
    options
  }) => {
    if (!activeRef.current) {
      return;
    }
    const activeNode2 = draggableNodes[activeRef.current];
    if (!activeNode2) {
      return;
    }
    const sensorInstance = new Sensor({
      active: activeRef.current,
      activeNode: activeNode2,
      event: event.nativeEvent,
      options,
      context: sensorContext,
      onStart(initialCoordinates) {
        const id3 = activeRef.current;
        if (!id3) {
          return;
        }
        const node3 = draggableNodes[id3];
        if (!node3) {
          return;
        }
        const {
          onDragStart
        } = latestProps.current;
        const event2 = {
          active: {
            id: id3,
            data: node3.data,
            rect: activeRects
          }
        };
        reactDom.exports.unstable_batchedUpdates(() => {
          dispatch({
            type: Action.DragStart,
            initialCoordinates,
            active: id3
          });
          setMonitorState({
            type: Action.DragStart,
            event: event2
          });
        });
        onDragStart == null ? void 0 : onDragStart(event2);
      },
      onMove(coordinates) {
        dispatch({
          type: Action.DragMove,
          coordinates
        });
      },
      onEnd: createHandler(Action.DragEnd),
      onCancel: createHandler(Action.DragCancel)
    });
    reactDom.exports.unstable_batchedUpdates(() => {
      setActiveSensor(sensorInstance);
      setActivatorEvent(event.nativeEvent);
    });
    function createHandler(type) {
      return async function handler() {
        const {
          active: active2,
          over: over2,
          scrollAdjustedTranslate: scrollAdjustedTranslate2
        } = sensorContext.current;
        let event2 = null;
        if (active2 && scrollAdjustedTranslate2) {
          const {
            cancelDrop
          } = latestProps.current;
          event2 = {
            active: active2,
            delta: scrollAdjustedTranslate2,
            over: over2
          };
          if (type === Action.DragEnd && typeof cancelDrop === "function") {
            const shouldCancel = await Promise.resolve(cancelDrop(event2));
            if (shouldCancel) {
              type = Action.DragCancel;
            }
          }
        }
        activeRef.current = null;
        reactDom.exports.unstable_batchedUpdates(() => {
          dispatch({
            type
          });
          setOver(null);
          setIsDragging(false);
          setActiveSensor(null);
          setActivatorEvent(null);
          if (event2) {
            setMonitorState({
              type,
              event: event2
            });
          }
        });
        if (event2) {
          const {
            onDragCancel,
            onDragEnd
          } = latestProps.current;
          const handler2 = type === Action.DragEnd ? onDragEnd : onDragCancel;
          handler2 == null ? void 0 : handler2(event2);
        }
      };
    }
  }, [dispatch, draggableNodes]);
  const bindActivatorToSensorInstantiator = react.exports.useCallback((handler, sensor) => {
    return (event, active2) => {
      const nativeEvent = event.nativeEvent;
      if (activeRef.current !== null || nativeEvent.dndKit || nativeEvent.defaultPrevented) {
        return;
      }
      if (handler(event, sensor.options) === true) {
        nativeEvent.dndKit = {
          capturedBy: sensor.sensor
        };
        activeRef.current = active2;
        instantiateSensor(event, sensor);
      }
    };
  }, [instantiateSensor]);
  const activators = useCombineActivators(sensors, bindActivatorToSensorInstantiator);
  useSensorSetup(sensors);
  useIsomorphicLayoutEffect$3(
    () => {
      latestProps.current = props;
    },
    Object.values(props)
  );
  react.exports.useEffect(() => {
    if (activeId != null) {
      setIsDragging(true);
    }
  }, [activeId]);
  react.exports.useEffect(() => {
    if (!active) {
      initialActiveNodeRectRef.current = null;
    }
    if (active && activeNodeRect && !initialActiveNodeRectRef.current) {
      initialActiveNodeRectRef.current = activeNodeRect;
    }
  }, [activeNodeRect, active]);
  react.exports.useEffect(() => {
    const {
      onDragMove
    } = latestProps.current;
    const {
      active: active2,
      over: over2
    } = sensorContext.current;
    if (!active2) {
      return;
    }
    const event = {
      active: active2,
      delta: {
        x: scrollAdjustedTranslate.x,
        y: scrollAdjustedTranslate.y
      },
      over: over2
    };
    setMonitorState({
      type: Action.DragMove,
      event
    });
    onDragMove == null ? void 0 : onDragMove(event);
  }, [scrollAdjustedTranslate.x, scrollAdjustedTranslate.y]);
  react.exports.useEffect(
    () => {
      const {
        active: active2,
        droppableContainers: droppableContainers2,
        scrollAdjustedTranslate: scrollAdjustedTranslate2
      } = sensorContext.current;
      if (!active2 || !activeRef.current || !scrollAdjustedTranslate2) {
        return;
      }
      const {
        onDragOver
      } = latestProps.current;
      const overContainer = droppableContainers2.get(overId);
      const over2 = overContainer && overContainer.rect.current ? {
        id: overContainer.id,
        rect: overContainer.rect.current,
        data: overContainer.data,
        disabled: overContainer.disabled
      } : null;
      const event = {
        active: active2,
        delta: {
          x: scrollAdjustedTranslate2.x,
          y: scrollAdjustedTranslate2.y
        },
        over: over2
      };
      reactDom.exports.unstable_batchedUpdates(() => {
        setOver(over2);
        setMonitorState({
          type: Action.DragOver,
          event
        });
        onDragOver == null ? void 0 : onDragOver(event);
      });
    },
    [overId]
  );
  useIsomorphicLayoutEffect$3(() => {
    sensorContext.current = {
      active,
      activeNode,
      collisionRect,
      droppableRects,
      draggableNodes,
      draggingNodeRect,
      droppableContainers,
      over,
      scrollableAncestors,
      scrollAdjustedTranslate,
      translatedRect
    };
    activeRects.current = {
      initial: draggingNodeRect,
      translated: translatedRect
    };
  }, [active, activeNode, collisionRect, draggableNodes, draggingNodeRect, droppableRects, droppableContainers, over, scrollableAncestors, scrollAdjustedTranslate, translatedRect]);
  useAutoScroller({
    ...getAutoScrollerOptions(),
    draggingRect: translatedRect,
    pointerCoordinates,
    scrollableAncestors,
    scrollableAncestorRects
  });
  const contextValue = react.exports.useMemo(() => {
    const memoizedContext = {
      active,
      activeNode,
      activeNodeRect,
      activeNodeClientRect,
      activatorEvent,
      activators,
      ariaDescribedById: {
        draggable: draggableDescribedById
      },
      containerNodeRect,
      dispatch,
      dragOverlay,
      draggableNodes,
      droppableContainers,
      droppableRects,
      over,
      recomputeLayouts,
      scrollableAncestors,
      scrollableAncestorRects,
      willRecomputeLayouts,
      windowRect: windowRect2
    };
    return memoizedContext;
  }, [active, activeNode, activeNodeClientRect, activeNodeRect, activatorEvent, activators, containerNodeRect, dragOverlay, dispatch, draggableNodes, draggableDescribedById, droppableContainers, droppableRects, over, recomputeLayouts, scrollableAncestors, scrollableAncestorRects, willRecomputeLayouts, windowRect2]);
  return /* @__PURE__ */ jsxs(DndMonitorContext.Provider, {
    value: monitorState,
    children: [/* @__PURE__ */ jsx(Context$1.Provider, {
      value: contextValue,
      children: /* @__PURE__ */ jsx(ActiveDraggableContext.Provider, {
        value: transform,
        children
      })
    }), /* @__PURE__ */ jsx(Accessibility, {
      announcements,
      hiddenTextDescribedById: draggableDescribedById,
      screenReaderInstructions: screenReaderInstructions$1
    })]
  });
  function getAutoScrollerOptions() {
    const activeSensorDisablesAutoscroll = (activeSensor == null ? void 0 : activeSensor.autoScrollEnabled) === false;
    const autoScrollGloballyDisabled = typeof autoScroll2 === "object" ? autoScroll2.enabled === false : autoScroll2 === false;
    const enabled = !activeSensorDisablesAutoscroll && !autoScrollGloballyDisabled;
    if (typeof autoScroll2 === "object") {
      return {
        ...autoScroll2,
        enabled
      };
    }
    return {
      enabled
    };
  }
});
const NullContext = /* @__PURE__ */ react.exports.createContext(null);
const defaultRole = "button";
const ID_PREFIX$1 = "Droppable";
function useDraggable({
  id: id2,
  data,
  disabled = false,
  attributes
}) {
  const key = useUniqueId(ID_PREFIX$1);
  const {
    active,
    activeNodeRect,
    activatorEvent,
    ariaDescribedById,
    draggableNodes,
    droppableRects,
    activators,
    over
  } = react.exports.useContext(Context$1);
  const {
    role = defaultRole,
    roleDescription = "draggable",
    tabIndex = 0
  } = attributes != null ? attributes : {};
  const isDragging = (active == null ? void 0 : active.id) === id2;
  const transform = react.exports.useContext(isDragging ? ActiveDraggableContext : NullContext);
  const [node2, setNodeRef] = useNodeRef();
  const listeners = useSyntheticListeners(activators, id2);
  const dataRef = useData$1(data);
  react.exports.useEffect(
    () => {
      draggableNodes[id2] = {
        id: id2,
        key,
        node: node2,
        data: dataRef
      };
      return () => {
        const node3 = draggableNodes[id2];
        if (node3 && node3.key === key) {
          delete draggableNodes[id2];
        }
      };
    },
    [draggableNodes, id2]
  );
  const memoizedAttributes = react.exports.useMemo(() => ({
    role,
    tabIndex,
    "aria-pressed": isDragging && role === defaultRole ? true : void 0,
    "aria-roledescription": roleDescription,
    "aria-describedby": ariaDescribedById.draggable
  }), [role, tabIndex, isDragging, roleDescription, ariaDescribedById.draggable]);
  return {
    active,
    activeNodeRect,
    activatorEvent,
    attributes: memoizedAttributes,
    droppableRects,
    isDragging,
    listeners: disabled ? void 0 : listeners,
    node: node2,
    over,
    setNodeRef,
    transform
  };
}
function useDndContext() {
  return react.exports.useContext(Context$1);
}
const ID_PREFIX$1$1 = "Droppable";
function useDroppable({
  data,
  disabled = false,
  id: id2
}) {
  const key = useUniqueId(ID_PREFIX$1$1);
  const {
    active,
    dispatch,
    over
  } = react.exports.useContext(Context$1);
  const rect = react.exports.useRef(null);
  const [nodeRef, setNodeRef] = useNodeRef();
  const dataRef = useData$1(data);
  useIsomorphicLayoutEffect$3(
    () => {
      dispatch({
        type: Action.RegisterDroppable,
        element: {
          id: id2,
          key,
          disabled,
          node: nodeRef,
          rect,
          data: dataRef
        }
      });
      return () => dispatch({
        type: Action.UnregisterDroppable,
        key,
        id: id2
      });
    },
    [id2]
  );
  react.exports.useEffect(
    () => {
      dispatch({
        type: Action.SetDroppableDisabled,
        id: id2,
        key,
        disabled
      });
    },
    [disabled]
  );
  return {
    active,
    rect,
    isOver: (over == null ? void 0 : over.id) === id2,
    node: nodeRef,
    over,
    setNodeRef
  };
}
function restrictToBoundingRect(transform, rect, boundingRect) {
  const value = {
    ...transform
  };
  if (rect.top + transform.y <= boundingRect.top) {
    value.y = boundingRect.top - rect.top;
  } else if (rect.bottom + transform.y >= boundingRect.top + boundingRect.height) {
    value.y = boundingRect.top + boundingRect.height - rect.bottom;
  }
  if (rect.left + transform.x <= boundingRect.left) {
    value.x = boundingRect.left - rect.left;
  } else if (rect.right + transform.x >= boundingRect.left + boundingRect.width) {
    value.x = boundingRect.left + boundingRect.width - rect.right;
  }
  return value;
}
const restrictToParentElement = ({
  transform,
  activeNodeRect,
  containerNodeRect
}) => {
  if (!activeNodeRect || !containerNodeRect) {
    return transform;
  }
  return restrictToBoundingRect(transform, activeNodeRect, containerNodeRect);
};
const restrictToVerticalAxis = ({
  transform
}) => {
  return {
    ...transform,
    x: 0
  };
};
function arrayMove(array, from3, to) {
  const newArray = array.slice();
  newArray.splice(to < 0 ? newArray.length + to : to, 0, newArray.splice(from3, 1)[0]);
  return newArray;
}
function getSortedRects(items, layoutRects) {
  return items.reduce((accumulator, id2, index2) => {
    const layoutRect = layoutRects.get(id2);
    if (layoutRect) {
      accumulator[index2] = layoutRect;
    }
    return accumulator;
  }, Array(items.length));
}
function isValidIndex(index2) {
  return index2 !== null && index2 >= 0;
}
const rectSortingStrategy = ({
  layoutRects,
  activeIndex,
  overIndex,
  index: index2
}) => {
  const newRects = arrayMove(layoutRects, overIndex, activeIndex);
  const oldRect = layoutRects[index2];
  const newRect = newRects[index2];
  if (!newRect || !oldRect) {
    return null;
  }
  return {
    x: newRect.offsetLeft - oldRect.offsetLeft,
    y: newRect.offsetTop - oldRect.offsetTop,
    scaleX: newRect.width / oldRect.width,
    scaleY: newRect.height / oldRect.height
  };
};
const defaultScale$1 = {
  scaleX: 1,
  scaleY: 1
};
const verticalListSortingStrategy = ({
  activeIndex,
  activeNodeRect: fallbackActiveRect,
  index: index2,
  layoutRects,
  overIndex
}) => {
  var _layoutRects$activeIn;
  const activeNodeRect = (_layoutRects$activeIn = layoutRects[activeIndex]) != null ? _layoutRects$activeIn : fallbackActiveRect;
  if (!activeNodeRect) {
    return null;
  }
  if (index2 === activeIndex) {
    const overIndexRect = layoutRects[overIndex];
    if (!overIndexRect) {
      return null;
    }
    return {
      x: 0,
      y: activeIndex < overIndex ? overIndexRect.offsetTop + overIndexRect.height - (activeNodeRect.offsetTop + activeNodeRect.height) : overIndexRect.offsetTop - activeNodeRect.offsetTop,
      ...defaultScale$1
    };
  }
  const itemGap = getItemGap$1(layoutRects, index2, activeIndex);
  if (index2 > activeIndex && index2 <= overIndex) {
    return {
      x: 0,
      y: -activeNodeRect.height - itemGap,
      ...defaultScale$1
    };
  }
  if (index2 < activeIndex && index2 >= overIndex) {
    return {
      x: 0,
      y: activeNodeRect.height + itemGap,
      ...defaultScale$1
    };
  }
  return {
    x: 0,
    y: 0,
    ...defaultScale$1
  };
};
function getItemGap$1(layoutRects, index2, activeIndex) {
  const currentRect = layoutRects[index2];
  const previousRect = layoutRects[index2 - 1];
  const nextRect = layoutRects[index2 + 1];
  if (!currentRect) {
    return 0;
  }
  if (activeIndex < index2) {
    return previousRect ? currentRect.offsetTop - (previousRect.offsetTop + previousRect.height) : nextRect ? nextRect.offsetTop - (currentRect.offsetTop + currentRect.height) : 0;
  }
  return nextRect ? nextRect.offsetTop - (currentRect.offsetTop + currentRect.height) : previousRect ? currentRect.offsetTop - (previousRect.offsetTop + previousRect.height) : 0;
}
const ID_PREFIX = "Sortable";
const Context = /* @__PURE__ */ e$3.createContext({
  activeIndex: -1,
  containerId: ID_PREFIX,
  disableTransforms: false,
  items: [],
  overIndex: -1,
  useDragOverlay: false,
  sortedRects: [],
  strategy: rectSortingStrategy,
  wasDragging: {
    current: false
  }
});
function SortableContext({
  children,
  id: id2,
  items: userDefinedItems,
  strategy = rectSortingStrategy
}) {
  const {
    active,
    dragOverlay,
    droppableRects,
    over,
    recomputeLayouts,
    willRecomputeLayouts
  } = useDndContext();
  const containerId = useUniqueId(ID_PREFIX, id2);
  const useDragOverlay = Boolean(dragOverlay.rect !== null);
  const items = react.exports.useMemo(() => userDefinedItems.map((item2) => typeof item2 === "string" ? item2 : item2.id), [userDefinedItems]);
  const isDragging = active != null;
  const wasDragging = react.exports.useRef(false);
  const activeIndex = active ? items.indexOf(active.id) : -1;
  const isSorting = activeIndex !== -1;
  const overIndex = over ? items.indexOf(over.id) : -1;
  const previousItemsRef = react.exports.useRef(items);
  const sortedRects = getSortedRects(items, droppableRects);
  const itemsHaveChanged = !isEqual$1(items, previousItemsRef.current);
  const disableTransforms = overIndex !== -1 && activeIndex === -1 || itemsHaveChanged;
  useIsomorphicLayoutEffect$3(() => {
    if (itemsHaveChanged && isSorting && !willRecomputeLayouts) {
      recomputeLayouts();
    }
  }, [itemsHaveChanged, isSorting, recomputeLayouts, willRecomputeLayouts]);
  react.exports.useEffect(() => {
    previousItemsRef.current = items;
  }, [items]);
  react.exports.useEffect(() => {
    const timeoutId = setTimeout(() => {
      wasDragging.current = isDragging;
    }, 100);
    return () => clearTimeout(timeoutId);
  }, [isDragging]);
  const contextValue = react.exports.useMemo(() => ({
    activeIndex,
    containerId,
    disableTransforms,
    items,
    overIndex,
    useDragOverlay,
    sortedRects,
    strategy,
    wasDragging
  }), [activeIndex, containerId, disableTransforms, items, overIndex, sortedRects, useDragOverlay, strategy, wasDragging]);
  return /* @__PURE__ */ jsx(Context.Provider, {
    value: contextValue,
    children
  });
}
function isEqual$1(arr1, arr2) {
  return arr1.join() === arr2.join();
}
const defaultNewIndexGetter = ({
  id: id2,
  items,
  activeIndex,
  overIndex
}) => arrayMove(items, activeIndex, overIndex).indexOf(id2);
const defaultAnimateLayoutChanges = ({
  containerId,
  isSorting,
  wasDragging,
  index: index2,
  items,
  newIndex: newIndex2,
  previousItems,
  previousContainerId,
  transition
}) => {
  if (!transition || !wasDragging) {
    return false;
  }
  if (previousItems !== items && index2 === newIndex2) {
    return false;
  }
  if (isSorting) {
    return true;
  }
  return newIndex2 !== index2 && containerId === previousContainerId;
};
const defaultTransition = {
  duration: 200,
  easing: "ease"
};
const transitionProperty = "transform";
const disabledTransition = /* @__PURE__ */ CSS.Transition.toString({
  property: transitionProperty,
  duration: 0,
  easing: "linear"
});
const defaultAttributes = {
  roleDescription: "sortable"
};
function useDerivedTransform({
  disabled,
  index: index2,
  node: node2,
  rect
}) {
  const [derivedTransform, setDerivedtransform] = react.exports.useState(null);
  const previousIndex = react.exports.useRef(index2);
  useIsomorphicLayoutEffect$3(() => {
    if (!disabled && index2 !== previousIndex.current && node2.current) {
      const initial = rect.current;
      if (initial) {
        const current = getBoundingClientRect$1(node2.current);
        const delta = {
          x: initial.offsetLeft - current.offsetLeft,
          y: initial.offsetTop - current.offsetTop,
          scaleX: initial.width / current.width,
          scaleY: initial.height / current.height
        };
        if (delta.x || delta.y) {
          setDerivedtransform(delta);
        }
      }
    }
    if (index2 !== previousIndex.current) {
      previousIndex.current = index2;
    }
  }, [disabled, index2, node2, rect]);
  react.exports.useEffect(() => {
    if (derivedTransform) {
      requestAnimationFrame(() => {
        setDerivedtransform(null);
      });
    }
  }, [derivedTransform]);
  return derivedTransform;
}
function useSortable({
  animateLayoutChanges = defaultAnimateLayoutChanges,
  attributes: userDefinedAttributes,
  disabled,
  data: customData,
  getNewIndex = defaultNewIndexGetter,
  id: id2,
  strategy: localStrategy,
  transition = defaultTransition
}) {
  const {
    items,
    containerId,
    activeIndex,
    disableTransforms,
    sortedRects,
    overIndex,
    useDragOverlay,
    strategy: globalStrategy,
    wasDragging
  } = react.exports.useContext(Context);
  const index2 = items.indexOf(id2);
  const data = react.exports.useMemo(() => ({
    sortable: {
      containerId,
      index: index2,
      items
    },
    ...customData
  }), [containerId, customData, index2, items]);
  const {
    rect,
    node: node2,
    setNodeRef: setDroppableNodeRef
  } = useDroppable({
    id: id2,
    data
  });
  const {
    active,
    activeNodeRect,
    activatorEvent,
    attributes,
    setNodeRef: setDraggableNodeRef,
    listeners,
    isDragging,
    over,
    transform
  } = useDraggable({
    id: id2,
    data,
    attributes: {
      ...defaultAttributes,
      ...userDefinedAttributes
    },
    disabled
  });
  const setNodeRef = useCombinedRefs(setDroppableNodeRef, setDraggableNodeRef);
  const isSorting = Boolean(active);
  const displaceItem = isSorting && wasDragging.current && !disableTransforms && isValidIndex(activeIndex) && isValidIndex(overIndex);
  const shouldDisplaceDragSource = !useDragOverlay && isDragging;
  const dragSourceDisplacement = shouldDisplaceDragSource && displaceItem ? transform : null;
  const strategy = localStrategy != null ? localStrategy : globalStrategy;
  const finalTransform = displaceItem ? dragSourceDisplacement != null ? dragSourceDisplacement : strategy({
    layoutRects: sortedRects,
    activeNodeRect,
    activeIndex,
    overIndex,
    index: index2
  }) : null;
  const newIndex2 = isValidIndex(activeIndex) && isValidIndex(overIndex) ? getNewIndex({
    id: id2,
    items,
    activeIndex,
    overIndex
  }) : index2;
  const prevItems = react.exports.useRef(items);
  const itemsHaveChanged = items !== prevItems.current;
  const prevNewIndex = react.exports.useRef(newIndex2);
  const previousContainerId = react.exports.useRef(containerId);
  const shouldAnimateLayoutChanges = animateLayoutChanges({
    active,
    containerId,
    isDragging,
    isSorting,
    id: id2,
    index: index2,
    items,
    newIndex: prevNewIndex.current,
    previousItems: prevItems.current,
    previousContainerId: previousContainerId.current,
    transition,
    wasDragging: wasDragging.current
  });
  const derivedTransform = useDerivedTransform({
    disabled: !shouldAnimateLayoutChanges,
    index: index2,
    node: node2,
    rect
  });
  react.exports.useEffect(() => {
    if (isSorting && prevNewIndex.current !== newIndex2) {
      prevNewIndex.current = newIndex2;
    }
    if (containerId !== previousContainerId.current) {
      previousContainerId.current = containerId;
    }
    if (items !== prevItems.current) {
      prevItems.current = items;
    }
  }, [isSorting, newIndex2, containerId, items]);
  return {
    active,
    attributes,
    activatorEvent,
    rect,
    index: index2,
    isSorting,
    isDragging,
    listeners,
    node: node2,
    overIndex,
    over,
    setNodeRef,
    setDroppableNodeRef,
    setDraggableNodeRef,
    transform: derivedTransform != null ? derivedTransform : finalTransform,
    transition: getTransition()
  };
  function getTransition() {
    if (derivedTransform || itemsHaveChanged && prevNewIndex.current === index2) {
      return disabledTransition;
    }
    if (shouldDisplaceDragSource || !transition) {
      return void 0;
    }
    if (isSorting || shouldAnimateLayoutChanges) {
      return CSS.Transition.toString({
        ...transition,
        property: transitionProperty
      });
    }
    return void 0;
  }
}
const directions = [KeyboardCode.Down, KeyboardCode.Right, KeyboardCode.Up, KeyboardCode.Left];
const sortableKeyboardCoordinates = (event, {
  context: {
    active,
    droppableContainers,
    translatedRect,
    scrollableAncestors
  }
}) => {
  if (directions.includes(event.code)) {
    event.preventDefault();
    if (!active || !translatedRect) {
      return;
    }
    const filteredContainers = [];
    droppableContainers.getEnabled().forEach((entry) => {
      if (!entry || (entry == null ? void 0 : entry.disabled)) {
        return;
      }
      const node2 = entry == null ? void 0 : entry.node.current;
      if (!node2) {
        return;
      }
      const rect = getViewRect(node2);
      const container = {
        ...entry,
        rect: {
          current: rect
        }
      };
      switch (event.code) {
        case KeyboardCode.Down:
          if (translatedRect.top + translatedRect.height <= rect.top) {
            filteredContainers.push(container);
          }
          break;
        case KeyboardCode.Up:
          if (translatedRect.top >= rect.top + rect.height) {
            filteredContainers.push(container);
          }
          break;
        case KeyboardCode.Left:
          if (translatedRect.left >= rect.left + rect.width) {
            filteredContainers.push(container);
          }
          break;
        case KeyboardCode.Right:
          if (translatedRect.left + translatedRect.width <= rect.left) {
            filteredContainers.push(container);
          }
          break;
      }
    });
    const closestId = closestCorners({
      active,
      collisionRect: translatedRect,
      droppableContainers: filteredContainers
    });
    if (closestId) {
      var _droppableContainers$;
      const newNode = (_droppableContainers$ = droppableContainers.get(closestId)) == null ? void 0 : _droppableContainers$.node.current;
      if (newNode) {
        const newScrollAncestors = getScrollableAncestors(newNode);
        const hasDifferentScrollAncestors = newScrollAncestors.some((element, index2) => scrollableAncestors[index2] !== element);
        const newRect = getViewRect(newNode);
        const offset2 = hasDifferentScrollAncestors ? {
          x: 0,
          y: 0
        } : {
          x: translatedRect.width - newRect.width,
          y: translatedRect.height - newRect.height
        };
        const newCoordinates = {
          x: newRect.left - offset2.x,
          y: newRect.top - offset2.y
        };
        return newCoordinates;
      }
    }
  }
  return void 0;
};
function Button$1({
  children,
  icon: IconElement,
  size = "default",
  secondary = false,
  outline = false,
  ...props
}) {
  return /* @__PURE__ */ jsxs(BaseButton, {
    css: [secondary && Secondary, size === "small" && Small, outline && Outline, "", ""],
    ...props,
    children: [IconElement && /* @__PURE__ */ jsx(IconElement, {
      size: 20
    }), children]
  });
}
const BaseButton = /* @__PURE__ */ createStyled("button", {
  target: "e1koncuq0"
})({
  name: "cagk2s",
  styles: "outline:none;display:flex;align-items:center;gap:0.5em;font-weight:700;background-color:var(--contrast);border:none;color:#fff;align-self:flex-end;font-size:0.9rem;height:48px;padding:0 1em;line-height:1.25rem;cursor:pointer;border-radius:4px;transition:background-color 0.3s;&:hover, &:focus{background-color:var(--color-dark);}"
});
const Secondary = {
  backgroundColor: "transparent",
  color: "var(--contrast)",
  "&:hover, &:focus": {
    backgroundColor: "var(--color-light)"
  }
};
const Small = {
  height: 40
};
const Outline = {
  border: "solid 1px var(--contrast)",
  background: "transparent",
  color: "var(--contrast)",
  "&:hover, &:focus": {
    backgroundColor: "var(--contrast)",
    color: "#FFF"
  }
};
const UnstyledButton = /* @__PURE__ */ createStyled("button", {
  target: "e1dg9xmc0"
})({
  name: "ctsem8",
  styles: "background-color:transparent;border:none;padding:0;margin:0;color:inherit"
});
var top = "top";
var bottom = "bottom";
var right = "right";
var left = "left";
var auto = "auto";
var basePlacements = [top, bottom, right, left];
var start = "start";
var end = "end";
var clippingParents = "clippingParents";
var viewport = "viewport";
var popper = "popper";
var reference = "reference";
var variationPlacements = /* @__PURE__ */ basePlacements.reduce(function(acc, placement) {
  return acc.concat([placement + "-" + start, placement + "-" + end]);
}, []);
var placements = /* @__PURE__ */ [].concat(basePlacements, [auto]).reduce(function(acc, placement) {
  return acc.concat([placement, placement + "-" + start, placement + "-" + end]);
}, []);
var beforeRead = "beforeRead";
var read = "read";
var afterRead = "afterRead";
var beforeMain = "beforeMain";
var main = "main";
var afterMain = "afterMain";
var beforeWrite = "beforeWrite";
var write = "write";
var afterWrite = "afterWrite";
var modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];
function getNodeName(element) {
  return element ? (element.nodeName || "").toLowerCase() : null;
}
function getWindow(node2) {
  if (node2 == null) {
    return window;
  }
  if (node2.toString() !== "[object Window]") {
    var ownerDocument = node2.ownerDocument;
    return ownerDocument ? ownerDocument.defaultView || window : window;
  }
  return node2;
}
function isElement$1(node2) {
  var OwnElement = getWindow(node2).Element;
  return node2 instanceof OwnElement || node2 instanceof Element;
}
function isHTMLElement(node2) {
  var OwnElement = getWindow(node2).HTMLElement;
  return node2 instanceof OwnElement || node2 instanceof HTMLElement;
}
function isShadowRoot(node2) {
  if (typeof ShadowRoot === "undefined") {
    return false;
  }
  var OwnElement = getWindow(node2).ShadowRoot;
  return node2 instanceof OwnElement || node2 instanceof ShadowRoot;
}
function applyStyles(_ref2) {
  var state = _ref2.state;
  Object.keys(state.elements).forEach(function(name) {
    var style2 = state.styles[name] || {};
    var attributes = state.attributes[name] || {};
    var element = state.elements[name];
    if (!isHTMLElement(element) || !getNodeName(element)) {
      return;
    }
    Object.assign(element.style, style2);
    Object.keys(attributes).forEach(function(name2) {
      var value = attributes[name2];
      if (value === false) {
        element.removeAttribute(name2);
      } else {
        element.setAttribute(name2, value === true ? "" : value);
      }
    });
  });
}
function effect$2(_ref2) {
  var state = _ref2.state;
  var initialStyles = {
    popper: {
      position: state.options.strategy,
      left: "0",
      top: "0",
      margin: "0"
    },
    arrow: {
      position: "absolute"
    },
    reference: {}
  };
  Object.assign(state.elements.popper.style, initialStyles.popper);
  state.styles = initialStyles;
  if (state.elements.arrow) {
    Object.assign(state.elements.arrow.style, initialStyles.arrow);
  }
  return function() {
    Object.keys(state.elements).forEach(function(name) {
      var element = state.elements[name];
      var attributes = state.attributes[name] || {};
      var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]);
      var style2 = styleProperties.reduce(function(style3, property) {
        style3[property] = "";
        return style3;
      }, {});
      if (!isHTMLElement(element) || !getNodeName(element)) {
        return;
      }
      Object.assign(element.style, style2);
      Object.keys(attributes).forEach(function(attribute) {
        element.removeAttribute(attribute);
      });
    });
  };
}
var applyStyles$1 = {
  name: "applyStyles",
  enabled: true,
  phase: "write",
  fn: applyStyles,
  effect: effect$2,
  requires: ["computeStyles"]
};
function getBasePlacement$1(placement) {
  return placement.split("-")[0];
}
var max$1 = Math.max;
var min$1 = Math.min;
var round = Math.round;
function getUAString() {
  var uaData = navigator.userAgentData;
  if (uaData != null && uaData.brands) {
    return uaData.brands.map(function(item2) {
      return item2.brand + "/" + item2.version;
    }).join(" ");
  }
  return navigator.userAgent;
}
function isLayoutViewport() {
  return !/^((?!chrome|android).)*safari/i.test(getUAString());
}
function getBoundingClientRect(element, includeScale, isFixedStrategy) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  var clientRect2 = element.getBoundingClientRect();
  var scaleX2 = 1;
  var scaleY2 = 1;
  if (includeScale && isHTMLElement(element)) {
    scaleX2 = element.offsetWidth > 0 ? round(clientRect2.width) / element.offsetWidth || 1 : 1;
    scaleY2 = element.offsetHeight > 0 ? round(clientRect2.height) / element.offsetHeight || 1 : 1;
  }
  var _ref2 = isElement$1(element) ? getWindow(element) : window, visualViewport = _ref2.visualViewport;
  var addVisualOffsets = !isLayoutViewport() && isFixedStrategy;
  var x3 = (clientRect2.left + (addVisualOffsets && visualViewport ? visualViewport.offsetLeft : 0)) / scaleX2;
  var y4 = (clientRect2.top + (addVisualOffsets && visualViewport ? visualViewport.offsetTop : 0)) / scaleY2;
  var width = clientRect2.width / scaleX2;
  var height = clientRect2.height / scaleY2;
  return {
    width,
    height,
    top: y4,
    right: x3 + width,
    bottom: y4 + height,
    left: x3,
    x: x3,
    y: y4
  };
}
function getLayoutRect(element) {
  var clientRect2 = getBoundingClientRect(element);
  var width = element.offsetWidth;
  var height = element.offsetHeight;
  if (Math.abs(clientRect2.width - width) <= 1) {
    width = clientRect2.width;
  }
  if (Math.abs(clientRect2.height - height) <= 1) {
    height = clientRect2.height;
  }
  return {
    x: element.offsetLeft,
    y: element.offsetTop,
    width,
    height
  };
}
function contains(parent, child) {
  var rootNode = child.getRootNode && child.getRootNode();
  if (parent.contains(child)) {
    return true;
  } else if (rootNode && isShadowRoot(rootNode)) {
    var next2 = child;
    do {
      if (next2 && parent.isSameNode(next2)) {
        return true;
      }
      next2 = next2.parentNode || next2.host;
    } while (next2);
  }
  return false;
}
function getComputedStyle$1(element) {
  return getWindow(element).getComputedStyle(element);
}
function isTableElement(element) {
  return ["table", "td", "th"].indexOf(getNodeName(element)) >= 0;
}
function getDocumentElement(element) {
  return ((isElement$1(element) ? element.ownerDocument : element.document) || window.document).documentElement;
}
function getParentNode(element) {
  if (getNodeName(element) === "html") {
    return element;
  }
  return element.assignedSlot || element.parentNode || (isShadowRoot(element) ? element.host : null) || getDocumentElement(element);
}
function getTrueOffsetParent(element) {
  if (!isHTMLElement(element) || getComputedStyle$1(element).position === "fixed") {
    return null;
  }
  return element.offsetParent;
}
function getContainingBlock(element) {
  var isFirefox = /firefox/i.test(getUAString());
  var isIE = /Trident/i.test(getUAString());
  if (isIE && isHTMLElement(element)) {
    var elementCss = getComputedStyle$1(element);
    if (elementCss.position === "fixed") {
      return null;
    }
  }
  var currentNode = getParentNode(element);
  if (isShadowRoot(currentNode)) {
    currentNode = currentNode.host;
  }
  while (isHTMLElement(currentNode) && ["html", "body"].indexOf(getNodeName(currentNode)) < 0) {
    var css2 = getComputedStyle$1(currentNode);
    if (css2.transform !== "none" || css2.perspective !== "none" || css2.contain === "paint" || ["transform", "perspective"].indexOf(css2.willChange) !== -1 || isFirefox && css2.willChange === "filter" || isFirefox && css2.filter && css2.filter !== "none") {
      return currentNode;
    } else {
      currentNode = currentNode.parentNode;
    }
  }
  return null;
}
function getOffsetParent(element) {
  var window2 = getWindow(element);
  var offsetParent = getTrueOffsetParent(element);
  while (offsetParent && isTableElement(offsetParent) && getComputedStyle$1(offsetParent).position === "static") {
    offsetParent = getTrueOffsetParent(offsetParent);
  }
  if (offsetParent && (getNodeName(offsetParent) === "html" || getNodeName(offsetParent) === "body" && getComputedStyle$1(offsetParent).position === "static")) {
    return window2;
  }
  return offsetParent || getContainingBlock(element) || window2;
}
function getMainAxisFromPlacement(placement) {
  return ["top", "bottom"].indexOf(placement) >= 0 ? "x" : "y";
}
function within(min2, value, max2) {
  return max$1(min2, min$1(value, max2));
}
function withinMaxClamp(min2, value, max2) {
  var v2 = within(min2, value, max2);
  return v2 > max2 ? max2 : v2;
}
function getFreshSideObject() {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  };
}
function mergePaddingObject(paddingObject) {
  return Object.assign({}, getFreshSideObject(), paddingObject);
}
function expandToHashMap(value, keys2) {
  return keys2.reduce(function(hashMap, key) {
    hashMap[key] = value;
    return hashMap;
  }, {});
}
var toPaddingObject = function toPaddingObject2(padding, state) {
  padding = typeof padding === "function" ? padding(Object.assign({}, state.rects, {
    placement: state.placement
  })) : padding;
  return mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
};
function arrow(_ref2) {
  var _state$modifiersData$;
  var state = _ref2.state, name = _ref2.name, options = _ref2.options;
  var arrowElement = state.elements.arrow;
  var popperOffsets2 = state.modifiersData.popperOffsets;
  var basePlacement = getBasePlacement$1(state.placement);
  var axis = getMainAxisFromPlacement(basePlacement);
  var isVertical = [left, right].indexOf(basePlacement) >= 0;
  var len = isVertical ? "height" : "width";
  if (!arrowElement || !popperOffsets2) {
    return;
  }
  var paddingObject = toPaddingObject(options.padding, state);
  var arrowRect = getLayoutRect(arrowElement);
  var minProp = axis === "y" ? top : left;
  var maxProp = axis === "y" ? bottom : right;
  var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets2[axis] - state.rects.popper[len];
  var startDiff = popperOffsets2[axis] - state.rects.reference[axis];
  var arrowOffsetParent = getOffsetParent(arrowElement);
  var clientSize = arrowOffsetParent ? axis === "y" ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
  var centerToReference = endDiff / 2 - startDiff / 2;
  var min2 = paddingObject[minProp];
  var max2 = clientSize - arrowRect[len] - paddingObject[maxProp];
  var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
  var offset2 = within(min2, center, max2);
  var axisProp = axis;
  state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset2, _state$modifiersData$.centerOffset = offset2 - center, _state$modifiersData$);
}
function effect$1(_ref2) {
  var state = _ref2.state, options = _ref2.options;
  var _options$element = options.element, arrowElement = _options$element === void 0 ? "[data-popper-arrow]" : _options$element;
  if (arrowElement == null) {
    return;
  }
  if (typeof arrowElement === "string") {
    arrowElement = state.elements.popper.querySelector(arrowElement);
    if (!arrowElement) {
      return;
    }
  }
  if (!contains(state.elements.popper, arrowElement)) {
    return;
  }
  state.elements.arrow = arrowElement;
}
var arrow$1 = {
  name: "arrow",
  enabled: true,
  phase: "main",
  fn: arrow,
  effect: effect$1,
  requires: ["popperOffsets"],
  requiresIfExists: ["preventOverflow"]
};
function getVariation(placement) {
  return placement.split("-")[1];
}
var unsetSides = {
  top: "auto",
  right: "auto",
  bottom: "auto",
  left: "auto"
};
function roundOffsetsByDPR(_ref2) {
  var x3 = _ref2.x, y4 = _ref2.y;
  var win = window;
  var dpr = win.devicePixelRatio || 1;
  return {
    x: round(x3 * dpr) / dpr || 0,
    y: round(y4 * dpr) / dpr || 0
  };
}
function mapToStyles(_ref2) {
  var _Object$assign2;
  var popper2 = _ref2.popper, popperRect = _ref2.popperRect, placement = _ref2.placement, variation = _ref2.variation, offsets = _ref2.offsets, position2 = _ref2.position, gpuAcceleration = _ref2.gpuAcceleration, adaptive = _ref2.adaptive, roundOffsets = _ref2.roundOffsets, isFixed2 = _ref2.isFixed;
  var _offsets$x = offsets.x, x3 = _offsets$x === void 0 ? 0 : _offsets$x, _offsets$y = offsets.y, y4 = _offsets$y === void 0 ? 0 : _offsets$y;
  var _ref3 = typeof roundOffsets === "function" ? roundOffsets({
    x: x3,
    y: y4
  }) : {
    x: x3,
    y: y4
  };
  x3 = _ref3.x;
  y4 = _ref3.y;
  var hasX = offsets.hasOwnProperty("x");
  var hasY = offsets.hasOwnProperty("y");
  var sideX = left;
  var sideY = top;
  var win = window;
  if (adaptive) {
    var offsetParent = getOffsetParent(popper2);
    var heightProp = "clientHeight";
    var widthProp = "clientWidth";
    if (offsetParent === getWindow(popper2)) {
      offsetParent = getDocumentElement(popper2);
      if (getComputedStyle$1(offsetParent).position !== "static" && position2 === "absolute") {
        heightProp = "scrollHeight";
        widthProp = "scrollWidth";
      }
    }
    offsetParent = offsetParent;
    if (placement === top || (placement === left || placement === right) && variation === end) {
      sideY = bottom;
      var offsetY = isFixed2 && offsetParent === win && win.visualViewport ? win.visualViewport.height : offsetParent[heightProp];
      y4 -= offsetY - popperRect.height;
      y4 *= gpuAcceleration ? 1 : -1;
    }
    if (placement === left || (placement === top || placement === bottom) && variation === end) {
      sideX = right;
      var offsetX = isFixed2 && offsetParent === win && win.visualViewport ? win.visualViewport.width : offsetParent[widthProp];
      x3 -= offsetX - popperRect.width;
      x3 *= gpuAcceleration ? 1 : -1;
    }
  }
  var commonStyles = Object.assign({
    position: position2
  }, adaptive && unsetSides);
  var _ref4 = roundOffsets === true ? roundOffsetsByDPR({
    x: x3,
    y: y4
  }) : {
    x: x3,
    y: y4
  };
  x3 = _ref4.x;
  y4 = _ref4.y;
  if (gpuAcceleration) {
    var _Object$assign;
    return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? "0" : "", _Object$assign[sideX] = hasX ? "0" : "", _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? "translate(" + x3 + "px, " + y4 + "px)" : "translate3d(" + x3 + "px, " + y4 + "px, 0)", _Object$assign));
  }
  return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y4 + "px" : "", _Object$assign2[sideX] = hasX ? x3 + "px" : "", _Object$assign2.transform = "", _Object$assign2));
}
function computeStyles(_ref5) {
  var state = _ref5.state, options = _ref5.options;
  var _options$gpuAccelerat = options.gpuAcceleration, gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat, _options$adaptive = options.adaptive, adaptive = _options$adaptive === void 0 ? true : _options$adaptive, _options$roundOffsets = options.roundOffsets, roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;
  var commonStyles = {
    placement: getBasePlacement$1(state.placement),
    variation: getVariation(state.placement),
    popper: state.elements.popper,
    popperRect: state.rects.popper,
    gpuAcceleration,
    isFixed: state.options.strategy === "fixed"
  };
  if (state.modifiersData.popperOffsets != null) {
    state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.popperOffsets,
      position: state.options.strategy,
      adaptive,
      roundOffsets
    })));
  }
  if (state.modifiersData.arrow != null) {
    state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.arrow,
      position: "absolute",
      adaptive: false,
      roundOffsets
    })));
  }
  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    "data-popper-placement": state.placement
  });
}
var computeStyles$1 = {
  name: "computeStyles",
  enabled: true,
  phase: "beforeWrite",
  fn: computeStyles,
  data: {}
};
var passive = {
  passive: true
};
function effect(_ref2) {
  var state = _ref2.state, instance = _ref2.instance, options = _ref2.options;
  var _options$scroll = options.scroll, scroll = _options$scroll === void 0 ? true : _options$scroll, _options$resize = options.resize, resize = _options$resize === void 0 ? true : _options$resize;
  var window2 = getWindow(state.elements.popper);
  var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);
  if (scroll) {
    scrollParents.forEach(function(scrollParent) {
      scrollParent.addEventListener("scroll", instance.update, passive);
    });
  }
  if (resize) {
    window2.addEventListener("resize", instance.update, passive);
  }
  return function() {
    if (scroll) {
      scrollParents.forEach(function(scrollParent) {
        scrollParent.removeEventListener("scroll", instance.update, passive);
      });
    }
    if (resize) {
      window2.removeEventListener("resize", instance.update, passive);
    }
  };
}
var eventListeners = {
  name: "eventListeners",
  enabled: true,
  phase: "write",
  fn: function fn() {
  },
  effect,
  data: {}
};
var hash$1 = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, function(matched) {
    return hash$1[matched];
  });
}
var hash = {
  start: "end",
  end: "start"
};
function getOppositeVariationPlacement(placement) {
  return placement.replace(/start|end/g, function(matched) {
    return hash[matched];
  });
}
function getWindowScroll(node2) {
  var win = getWindow(node2);
  var scrollLeft = win.pageXOffset;
  var scrollTop = win.pageYOffset;
  return {
    scrollLeft,
    scrollTop
  };
}
function getWindowScrollBarX(element) {
  return getBoundingClientRect(getDocumentElement(element)).left + getWindowScroll(element).scrollLeft;
}
function getViewportRect(element, strategy) {
  var win = getWindow(element);
  var html = getDocumentElement(element);
  var visualViewport = win.visualViewport;
  var width = html.clientWidth;
  var height = html.clientHeight;
  var x3 = 0;
  var y4 = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    var layoutViewport = isLayoutViewport();
    if (layoutViewport || !layoutViewport && strategy === "fixed") {
      x3 = visualViewport.offsetLeft;
      y4 = visualViewport.offsetTop;
    }
  }
  return {
    width,
    height,
    x: x3 + getWindowScrollBarX(element),
    y: y4
  };
}
function getDocumentRect(element) {
  var _element$ownerDocumen;
  var html = getDocumentElement(element);
  var winScroll = getWindowScroll(element);
  var body2 = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
  var width = max$1(html.scrollWidth, html.clientWidth, body2 ? body2.scrollWidth : 0, body2 ? body2.clientWidth : 0);
  var height = max$1(html.scrollHeight, html.clientHeight, body2 ? body2.scrollHeight : 0, body2 ? body2.clientHeight : 0);
  var x3 = -winScroll.scrollLeft + getWindowScrollBarX(element);
  var y4 = -winScroll.scrollTop;
  if (getComputedStyle$1(body2 || html).direction === "rtl") {
    x3 += max$1(html.clientWidth, body2 ? body2.clientWidth : 0) - width;
  }
  return {
    width,
    height,
    x: x3,
    y: y4
  };
}
function isScrollParent(element) {
  var _getComputedStyle = getComputedStyle$1(element), overflow = _getComputedStyle.overflow, overflowX = _getComputedStyle.overflowX, overflowY = _getComputedStyle.overflowY;
  return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
}
function getScrollParent(node2) {
  if (["html", "body", "#document"].indexOf(getNodeName(node2)) >= 0) {
    return node2.ownerDocument.body;
  }
  if (isHTMLElement(node2) && isScrollParent(node2)) {
    return node2;
  }
  return getScrollParent(getParentNode(node2));
}
function listScrollParents(element, list) {
  var _element$ownerDocumen;
  if (list === void 0) {
    list = [];
  }
  var scrollParent = getScrollParent(element);
  var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);
  var win = getWindow(scrollParent);
  var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;
  var updatedList = list.concat(target);
  return isBody ? updatedList : updatedList.concat(listScrollParents(getParentNode(target)));
}
function rectToClientRect(rect) {
  return Object.assign({}, rect, {
    left: rect.x,
    top: rect.y,
    right: rect.x + rect.width,
    bottom: rect.y + rect.height
  });
}
function getInnerBoundingClientRect(element, strategy) {
  var rect = getBoundingClientRect(element, false, strategy === "fixed");
  rect.top = rect.top + element.clientTop;
  rect.left = rect.left + element.clientLeft;
  rect.bottom = rect.top + element.clientHeight;
  rect.right = rect.left + element.clientWidth;
  rect.width = element.clientWidth;
  rect.height = element.clientHeight;
  rect.x = rect.left;
  rect.y = rect.top;
  return rect;
}
function getClientRectFromMixedType(element, clippingParent, strategy) {
  return clippingParent === viewport ? rectToClientRect(getViewportRect(element, strategy)) : isElement$1(clippingParent) ? getInnerBoundingClientRect(clippingParent, strategy) : rectToClientRect(getDocumentRect(getDocumentElement(element)));
}
function getClippingParents(element) {
  var clippingParents2 = listScrollParents(getParentNode(element));
  var canEscapeClipping = ["absolute", "fixed"].indexOf(getComputedStyle$1(element).position) >= 0;
  var clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;
  if (!isElement$1(clipperElement)) {
    return [];
  }
  return clippingParents2.filter(function(clippingParent) {
    return isElement$1(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== "body";
  });
}
function getClippingRect(element, boundary, rootBoundary, strategy) {
  var mainClippingParents = boundary === "clippingParents" ? getClippingParents(element) : [].concat(boundary);
  var clippingParents2 = [].concat(mainClippingParents, [rootBoundary]);
  var firstClippingParent = clippingParents2[0];
  var clippingRect = clippingParents2.reduce(function(accRect, clippingParent) {
    var rect = getClientRectFromMixedType(element, clippingParent, strategy);
    accRect.top = max$1(rect.top, accRect.top);
    accRect.right = min$1(rect.right, accRect.right);
    accRect.bottom = min$1(rect.bottom, accRect.bottom);
    accRect.left = max$1(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromMixedType(element, firstClippingParent, strategy));
  clippingRect.width = clippingRect.right - clippingRect.left;
  clippingRect.height = clippingRect.bottom - clippingRect.top;
  clippingRect.x = clippingRect.left;
  clippingRect.y = clippingRect.top;
  return clippingRect;
}
function computeOffsets(_ref2) {
  var reference2 = _ref2.reference, element = _ref2.element, placement = _ref2.placement;
  var basePlacement = placement ? getBasePlacement$1(placement) : null;
  var variation = placement ? getVariation(placement) : null;
  var commonX = reference2.x + reference2.width / 2 - element.width / 2;
  var commonY = reference2.y + reference2.height / 2 - element.height / 2;
  var offsets;
  switch (basePlacement) {
    case top:
      offsets = {
        x: commonX,
        y: reference2.y - element.height
      };
      break;
    case bottom:
      offsets = {
        x: commonX,
        y: reference2.y + reference2.height
      };
      break;
    case right:
      offsets = {
        x: reference2.x + reference2.width,
        y: commonY
      };
      break;
    case left:
      offsets = {
        x: reference2.x - element.width,
        y: commonY
      };
      break;
    default:
      offsets = {
        x: reference2.x,
        y: reference2.y
      };
  }
  var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;
  if (mainAxis != null) {
    var len = mainAxis === "y" ? "height" : "width";
    switch (variation) {
      case start:
        offsets[mainAxis] = offsets[mainAxis] - (reference2[len] / 2 - element[len] / 2);
        break;
      case end:
        offsets[mainAxis] = offsets[mainAxis] + (reference2[len] / 2 - element[len] / 2);
        break;
    }
  }
  return offsets;
}
function detectOverflow(state, options) {
  if (options === void 0) {
    options = {};
  }
  var _options = options, _options$placement = _options.placement, placement = _options$placement === void 0 ? state.placement : _options$placement, _options$strategy = _options.strategy, strategy = _options$strategy === void 0 ? state.strategy : _options$strategy, _options$boundary = _options.boundary, boundary = _options$boundary === void 0 ? clippingParents : _options$boundary, _options$rootBoundary = _options.rootBoundary, rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary, _options$elementConte = _options.elementContext, elementContext = _options$elementConte === void 0 ? popper : _options$elementConte, _options$altBoundary = _options.altBoundary, altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary, _options$padding = _options.padding, padding = _options$padding === void 0 ? 0 : _options$padding;
  var paddingObject = mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
  var altContext = elementContext === popper ? reference : popper;
  var popperRect = state.rects.popper;
  var element = state.elements[altBoundary ? altContext : elementContext];
  var clippingClientRect = getClippingRect(isElement$1(element) ? element : element.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary, strategy);
  var referenceClientRect = getBoundingClientRect(state.elements.reference);
  var popperOffsets2 = computeOffsets({
    reference: referenceClientRect,
    element: popperRect,
    strategy: "absolute",
    placement
  });
  var popperClientRect = rectToClientRect(Object.assign({}, popperRect, popperOffsets2));
  var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect;
  var overflowOffsets = {
    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
    bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
    right: elementClientRect.right - clippingClientRect.right + paddingObject.right
  };
  var offsetData = state.modifiersData.offset;
  if (elementContext === popper && offsetData) {
    var offset2 = offsetData[placement];
    Object.keys(overflowOffsets).forEach(function(key) {
      var multiply2 = [right, bottom].indexOf(key) >= 0 ? 1 : -1;
      var axis = [top, bottom].indexOf(key) >= 0 ? "y" : "x";
      overflowOffsets[key] += offset2[axis] * multiply2;
    });
  }
  return overflowOffsets;
}
function computeAutoPlacement(state, options) {
  if (options === void 0) {
    options = {};
  }
  var _options = options, placement = _options.placement, boundary = _options.boundary, rootBoundary = _options.rootBoundary, padding = _options.padding, flipVariations = _options.flipVariations, _options$allowedAutoP = _options.allowedAutoPlacements, allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements : _options$allowedAutoP;
  var variation = getVariation(placement);
  var placements$1 = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function(placement2) {
    return getVariation(placement2) === variation;
  }) : basePlacements;
  var allowedPlacements = placements$1.filter(function(placement2) {
    return allowedAutoPlacements.indexOf(placement2) >= 0;
  });
  if (allowedPlacements.length === 0) {
    allowedPlacements = placements$1;
  }
  var overflows = allowedPlacements.reduce(function(acc, placement2) {
    acc[placement2] = detectOverflow(state, {
      placement: placement2,
      boundary,
      rootBoundary,
      padding
    })[getBasePlacement$1(placement2)];
    return acc;
  }, {});
  return Object.keys(overflows).sort(function(a4, b3) {
    return overflows[a4] - overflows[b3];
  });
}
function getExpandedFallbackPlacements(placement) {
  if (getBasePlacement$1(placement) === auto) {
    return [];
  }
  var oppositePlacement = getOppositePlacement(placement);
  return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];
}
function flip(_ref2) {
  var state = _ref2.state, options = _ref2.options, name = _ref2.name;
  if (state.modifiersData[name]._skip) {
    return;
  }
  var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis, specifiedFallbackPlacements = options.fallbackPlacements, padding = options.padding, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, _options$flipVariatio = options.flipVariations, flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio, allowedAutoPlacements = options.allowedAutoPlacements;
  var preferredPlacement = state.options.placement;
  var basePlacement = getBasePlacement$1(preferredPlacement);
  var isBasePlacement = basePlacement === preferredPlacement;
  var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));
  var placements2 = [preferredPlacement].concat(fallbackPlacements).reduce(function(acc, placement2) {
    return acc.concat(getBasePlacement$1(placement2) === auto ? computeAutoPlacement(state, {
      placement: placement2,
      boundary,
      rootBoundary,
      padding,
      flipVariations,
      allowedAutoPlacements
    }) : placement2);
  }, []);
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var checksMap = /* @__PURE__ */ new Map();
  var makeFallbackChecks = true;
  var firstFittingPlacement = placements2[0];
  for (var i3 = 0; i3 < placements2.length; i3++) {
    var placement = placements2[i3];
    var _basePlacement = getBasePlacement$1(placement);
    var isStartVariation = getVariation(placement) === start;
    var isVertical = [top, bottom].indexOf(_basePlacement) >= 0;
    var len = isVertical ? "width" : "height";
    var overflow = detectOverflow(state, {
      placement,
      boundary,
      rootBoundary,
      altBoundary,
      padding
    });
    var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;
    if (referenceRect[len] > popperRect[len]) {
      mainVariationSide = getOppositePlacement(mainVariationSide);
    }
    var altVariationSide = getOppositePlacement(mainVariationSide);
    var checks = [];
    if (checkMainAxis) {
      checks.push(overflow[_basePlacement] <= 0);
    }
    if (checkAltAxis) {
      checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);
    }
    if (checks.every(function(check2) {
      return check2;
    })) {
      firstFittingPlacement = placement;
      makeFallbackChecks = false;
      break;
    }
    checksMap.set(placement, checks);
  }
  if (makeFallbackChecks) {
    var numberOfChecks = flipVariations ? 3 : 1;
    var _loop = function _loop2(_i2) {
      var fittingPlacement = placements2.find(function(placement2) {
        var checks2 = checksMap.get(placement2);
        if (checks2) {
          return checks2.slice(0, _i2).every(function(check2) {
            return check2;
          });
        }
      });
      if (fittingPlacement) {
        firstFittingPlacement = fittingPlacement;
        return "break";
      }
    };
    for (var _i = numberOfChecks; _i > 0; _i--) {
      var _ret = _loop(_i);
      if (_ret === "break")
        break;
    }
  }
  if (state.placement !== firstFittingPlacement) {
    state.modifiersData[name]._skip = true;
    state.placement = firstFittingPlacement;
    state.reset = true;
  }
}
var flip$1 = {
  name: "flip",
  enabled: true,
  phase: "main",
  fn: flip,
  requiresIfExists: ["offset"],
  data: {
    _skip: false
  }
};
function getSideOffsets(overflow, rect, preventedOffsets) {
  if (preventedOffsets === void 0) {
    preventedOffsets = {
      x: 0,
      y: 0
    };
  }
  return {
    top: overflow.top - rect.height - preventedOffsets.y,
    right: overflow.right - rect.width + preventedOffsets.x,
    bottom: overflow.bottom - rect.height + preventedOffsets.y,
    left: overflow.left - rect.width - preventedOffsets.x
  };
}
function isAnySideFullyClipped(overflow) {
  return [top, right, bottom, left].some(function(side) {
    return overflow[side] >= 0;
  });
}
function hide(_ref2) {
  var state = _ref2.state, name = _ref2.name;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var preventedOffsets = state.modifiersData.preventOverflow;
  var referenceOverflow = detectOverflow(state, {
    elementContext: "reference"
  });
  var popperAltOverflow = detectOverflow(state, {
    altBoundary: true
  });
  var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);
  var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);
  var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);
  var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
  state.modifiersData[name] = {
    referenceClippingOffsets,
    popperEscapeOffsets,
    isReferenceHidden,
    hasPopperEscaped
  };
  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    "data-popper-reference-hidden": isReferenceHidden,
    "data-popper-escaped": hasPopperEscaped
  });
}
var hide$1 = {
  name: "hide",
  enabled: true,
  phase: "main",
  requiresIfExists: ["preventOverflow"],
  fn: hide
};
function distanceAndSkiddingToXY(placement, rects, offset2) {
  var basePlacement = getBasePlacement$1(placement);
  var invertDistance = [left, top].indexOf(basePlacement) >= 0 ? -1 : 1;
  var _ref2 = typeof offset2 === "function" ? offset2(Object.assign({}, rects, {
    placement
  })) : offset2, skidding = _ref2[0], distance = _ref2[1];
  skidding = skidding || 0;
  distance = (distance || 0) * invertDistance;
  return [left, right].indexOf(basePlacement) >= 0 ? {
    x: distance,
    y: skidding
  } : {
    x: skidding,
    y: distance
  };
}
function offset(_ref2) {
  var state = _ref2.state, options = _ref2.options, name = _ref2.name;
  var _options$offset = options.offset, offset2 = _options$offset === void 0 ? [0, 0] : _options$offset;
  var data = placements.reduce(function(acc, placement) {
    acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset2);
    return acc;
  }, {});
  var _data$state$placement = data[state.placement], x3 = _data$state$placement.x, y4 = _data$state$placement.y;
  if (state.modifiersData.popperOffsets != null) {
    state.modifiersData.popperOffsets.x += x3;
    state.modifiersData.popperOffsets.y += y4;
  }
  state.modifiersData[name] = data;
}
var offset$1 = {
  name: "offset",
  enabled: true,
  phase: "main",
  requires: ["popperOffsets"],
  fn: offset
};
function popperOffsets(_ref2) {
  var state = _ref2.state, name = _ref2.name;
  state.modifiersData[name] = computeOffsets({
    reference: state.rects.reference,
    element: state.rects.popper,
    strategy: "absolute",
    placement: state.placement
  });
}
var popperOffsets$1 = {
  name: "popperOffsets",
  enabled: true,
  phase: "read",
  fn: popperOffsets,
  data: {}
};
function getAltAxis(axis) {
  return axis === "x" ? "y" : "x";
}
function preventOverflow(_ref2) {
  var state = _ref2.state, options = _ref2.options, name = _ref2.name;
  var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, padding = options.padding, _options$tether = options.tether, tether = _options$tether === void 0 ? true : _options$tether, _options$tetherOffset = options.tetherOffset, tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
  var overflow = detectOverflow(state, {
    boundary,
    rootBoundary,
    padding,
    altBoundary
  });
  var basePlacement = getBasePlacement$1(state.placement);
  var variation = getVariation(state.placement);
  var isBasePlacement = !variation;
  var mainAxis = getMainAxisFromPlacement(basePlacement);
  var altAxis = getAltAxis(mainAxis);
  var popperOffsets2 = state.modifiersData.popperOffsets;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var tetherOffsetValue = typeof tetherOffset === "function" ? tetherOffset(Object.assign({}, state.rects, {
    placement: state.placement
  })) : tetherOffset;
  var normalizedTetherOffsetValue = typeof tetherOffsetValue === "number" ? {
    mainAxis: tetherOffsetValue,
    altAxis: tetherOffsetValue
  } : Object.assign({
    mainAxis: 0,
    altAxis: 0
  }, tetherOffsetValue);
  var offsetModifierState = state.modifiersData.offset ? state.modifiersData.offset[state.placement] : null;
  var data = {
    x: 0,
    y: 0
  };
  if (!popperOffsets2) {
    return;
  }
  if (checkMainAxis) {
    var _offsetModifierState$;
    var mainSide = mainAxis === "y" ? top : left;
    var altSide = mainAxis === "y" ? bottom : right;
    var len = mainAxis === "y" ? "height" : "width";
    var offset2 = popperOffsets2[mainAxis];
    var min2 = offset2 + overflow[mainSide];
    var max2 = offset2 - overflow[altSide];
    var additive = tether ? -popperRect[len] / 2 : 0;
    var minLen = variation === start ? referenceRect[len] : popperRect[len];
    var maxLen = variation === start ? -popperRect[len] : -referenceRect[len];
    var arrowElement = state.elements.arrow;
    var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {
      width: 0,
      height: 0
    };
    var arrowPaddingObject = state.modifiersData["arrow#persistent"] ? state.modifiersData["arrow#persistent"].padding : getFreshSideObject();
    var arrowPaddingMin = arrowPaddingObject[mainSide];
    var arrowPaddingMax = arrowPaddingObject[altSide];
    var arrowLen = within(0, referenceRect[len], arrowRect[len]);
    var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;
    var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;
    var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);
    var clientOffset = arrowOffsetParent ? mainAxis === "y" ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
    var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;
    var tetherMin = offset2 + minOffset - offsetModifierValue - clientOffset;
    var tetherMax = offset2 + maxOffset - offsetModifierValue;
    var preventedOffset = within(tether ? min$1(min2, tetherMin) : min2, offset2, tether ? max$1(max2, tetherMax) : max2);
    popperOffsets2[mainAxis] = preventedOffset;
    data[mainAxis] = preventedOffset - offset2;
  }
  if (checkAltAxis) {
    var _offsetModifierState$2;
    var _mainSide = mainAxis === "x" ? top : left;
    var _altSide = mainAxis === "x" ? bottom : right;
    var _offset = popperOffsets2[altAxis];
    var _len = altAxis === "y" ? "height" : "width";
    var _min = _offset + overflow[_mainSide];
    var _max = _offset - overflow[_altSide];
    var isOriginSide = [top, left].indexOf(basePlacement) !== -1;
    var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;
    var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;
    var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;
    var _preventedOffset = tether && isOriginSide ? withinMaxClamp(_tetherMin, _offset, _tetherMax) : within(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);
    popperOffsets2[altAxis] = _preventedOffset;
    data[altAxis] = _preventedOffset - _offset;
  }
  state.modifiersData[name] = data;
}
var preventOverflow$1 = {
  name: "preventOverflow",
  enabled: true,
  phase: "main",
  fn: preventOverflow,
  requiresIfExists: ["offset"]
};
function getHTMLElementScroll(element) {
  return {
    scrollLeft: element.scrollLeft,
    scrollTop: element.scrollTop
  };
}
function getNodeScroll(node2) {
  if (node2 === getWindow(node2) || !isHTMLElement(node2)) {
    return getWindowScroll(node2);
  } else {
    return getHTMLElementScroll(node2);
  }
}
function isElementScaled(element) {
  var rect = element.getBoundingClientRect();
  var scaleX2 = round(rect.width) / element.offsetWidth || 1;
  var scaleY2 = round(rect.height) / element.offsetHeight || 1;
  return scaleX2 !== 1 || scaleY2 !== 1;
}
function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed2) {
  if (isFixed2 === void 0) {
    isFixed2 = false;
  }
  var isOffsetParentAnElement = isHTMLElement(offsetParent);
  var offsetParentIsScaled = isHTMLElement(offsetParent) && isElementScaled(offsetParent);
  var documentElement = getDocumentElement(offsetParent);
  var rect = getBoundingClientRect(elementOrVirtualElement, offsetParentIsScaled, isFixed2);
  var scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  var offsets = {
    x: 0,
    y: 0
  };
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed2) {
    if (getNodeName(offsetParent) !== "body" || isScrollParent(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      offsets = getBoundingClientRect(offsetParent, true);
      offsets.x += offsetParent.clientLeft;
      offsets.y += offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }
  return {
    x: rect.left + scroll.scrollLeft - offsets.x,
    y: rect.top + scroll.scrollTop - offsets.y,
    width: rect.width,
    height: rect.height
  };
}
function order(modifiers2) {
  var map2 = /* @__PURE__ */ new Map();
  var visited = /* @__PURE__ */ new Set();
  var result = [];
  modifiers2.forEach(function(modifier) {
    map2.set(modifier.name, modifier);
  });
  function sort2(modifier) {
    visited.add(modifier.name);
    var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
    requires.forEach(function(dep) {
      if (!visited.has(dep)) {
        var depModifier = map2.get(dep);
        if (depModifier) {
          sort2(depModifier);
        }
      }
    });
    result.push(modifier);
  }
  modifiers2.forEach(function(modifier) {
    if (!visited.has(modifier.name)) {
      sort2(modifier);
    }
  });
  return result;
}
function orderModifiers(modifiers2) {
  var orderedModifiers = order(modifiers2);
  return modifierPhases.reduce(function(acc, phase) {
    return acc.concat(orderedModifiers.filter(function(modifier) {
      return modifier.phase === phase;
    }));
  }, []);
}
function debounce$4(fn3) {
  var pending;
  return function() {
    if (!pending) {
      pending = new Promise(function(resolve2) {
        Promise.resolve().then(function() {
          pending = void 0;
          resolve2(fn3());
        });
      });
    }
    return pending;
  };
}
function mergeByName(modifiers2) {
  var merged = modifiers2.reduce(function(merged2, current) {
    var existing = merged2[current.name];
    merged2[current.name] = existing ? Object.assign({}, existing, current, {
      options: Object.assign({}, existing.options, current.options),
      data: Object.assign({}, existing.data, current.data)
    }) : current;
    return merged2;
  }, {});
  return Object.keys(merged).map(function(key) {
    return merged[key];
  });
}
var DEFAULT_OPTIONS = {
  placement: "bottom",
  modifiers: [],
  strategy: "absolute"
};
function areValidElements() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  return !args.some(function(element) {
    return !(element && typeof element.getBoundingClientRect === "function");
  });
}
function popperGenerator(generatorOptions) {
  if (generatorOptions === void 0) {
    generatorOptions = {};
  }
  var _generatorOptions = generatorOptions, _generatorOptions$def = _generatorOptions.defaultModifiers, defaultModifiers2 = _generatorOptions$def === void 0 ? [] : _generatorOptions$def, _generatorOptions$def2 = _generatorOptions.defaultOptions, defaultOptions2 = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;
  return function createPopper2(reference2, popper2, options) {
    if (options === void 0) {
      options = defaultOptions2;
    }
    var state = {
      placement: "bottom",
      orderedModifiers: [],
      options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions2),
      modifiersData: {},
      elements: {
        reference: reference2,
        popper: popper2
      },
      attributes: {},
      styles: {}
    };
    var effectCleanupFns = [];
    var isDestroyed = false;
    var instance = {
      state,
      setOptions: function setOptions(setOptionsAction) {
        var options2 = typeof setOptionsAction === "function" ? setOptionsAction(state.options) : setOptionsAction;
        cleanupModifierEffects();
        state.options = Object.assign({}, defaultOptions2, state.options, options2);
        state.scrollParents = {
          reference: isElement$1(reference2) ? listScrollParents(reference2) : reference2.contextElement ? listScrollParents(reference2.contextElement) : [],
          popper: listScrollParents(popper2)
        };
        var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers2, state.options.modifiers)));
        state.orderedModifiers = orderedModifiers.filter(function(m4) {
          return m4.enabled;
        });
        runModifierEffects();
        return instance.update();
      },
      forceUpdate: function forceUpdate() {
        if (isDestroyed) {
          return;
        }
        var _state$elements = state.elements, reference3 = _state$elements.reference, popper3 = _state$elements.popper;
        if (!areValidElements(reference3, popper3)) {
          return;
        }
        state.rects = {
          reference: getCompositeRect(reference3, getOffsetParent(popper3), state.options.strategy === "fixed"),
          popper: getLayoutRect(popper3)
        };
        state.reset = false;
        state.placement = state.options.placement;
        state.orderedModifiers.forEach(function(modifier) {
          return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);
        });
        for (var index2 = 0; index2 < state.orderedModifiers.length; index2++) {
          if (state.reset === true) {
            state.reset = false;
            index2 = -1;
            continue;
          }
          var _state$orderedModifie = state.orderedModifiers[index2], fn3 = _state$orderedModifie.fn, _state$orderedModifie2 = _state$orderedModifie.options, _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2, name = _state$orderedModifie.name;
          if (typeof fn3 === "function") {
            state = fn3({
              state,
              options: _options,
              name,
              instance
            }) || state;
          }
        }
      },
      update: debounce$4(function() {
        return new Promise(function(resolve2) {
          instance.forceUpdate();
          resolve2(state);
        });
      }),
      destroy: function destroy2() {
        cleanupModifierEffects();
        isDestroyed = true;
      }
    };
    if (!areValidElements(reference2, popper2)) {
      return instance;
    }
    instance.setOptions(options).then(function(state2) {
      if (!isDestroyed && options.onFirstUpdate) {
        options.onFirstUpdate(state2);
      }
    });
    function runModifierEffects() {
      state.orderedModifiers.forEach(function(_ref3) {
        var name = _ref3.name, _ref3$options = _ref3.options, options2 = _ref3$options === void 0 ? {} : _ref3$options, effect3 = _ref3.effect;
        if (typeof effect3 === "function") {
          var cleanupFn = effect3({
            state,
            name,
            instance,
            options: options2
          });
          var noopFn = function noopFn2() {
          };
          effectCleanupFns.push(cleanupFn || noopFn);
        }
      });
    }
    function cleanupModifierEffects() {
      effectCleanupFns.forEach(function(fn3) {
        return fn3();
      });
      effectCleanupFns = [];
    }
    return instance;
  };
}
var defaultModifiers = [eventListeners, popperOffsets$1, computeStyles$1, applyStyles$1, offset$1, flip$1, preventOverflow$1, arrow$1, hide$1];
var createPopper = /* @__PURE__ */ popperGenerator({
  defaultModifiers
});
var BOX_CLASS = "tippy-box";
var CONTENT_CLASS = "tippy-content";
var BACKDROP_CLASS = "tippy-backdrop";
var ARROW_CLASS = "tippy-arrow";
var SVG_ARROW_CLASS = "tippy-svg-arrow";
var TOUCH_OPTIONS = {
  passive: true,
  capture: true
};
var TIPPY_DEFAULT_APPEND_TO = function TIPPY_DEFAULT_APPEND_TO2() {
  return document.body;
};
function getValueAtIndexOrReturn(value, index2, defaultValue2) {
  if (Array.isArray(value)) {
    var v2 = value[index2];
    return v2 == null ? Array.isArray(defaultValue2) ? defaultValue2[index2] : defaultValue2 : v2;
  }
  return value;
}
function isType(value, type) {
  var str = {}.toString.call(value);
  return str.indexOf("[object") === 0 && str.indexOf(type + "]") > -1;
}
function invokeWithArgsOrReturn(value, args) {
  return typeof value === "function" ? value.apply(void 0, args) : value;
}
function debounce$3(fn3, ms) {
  if (ms === 0) {
    return fn3;
  }
  var timeout;
  return function(arg) {
    clearTimeout(timeout);
    timeout = setTimeout(function() {
      fn3(arg);
    }, ms);
  };
}
function splitBySpaces(value) {
  return value.split(/\s+/).filter(Boolean);
}
function normalizeToArray(value) {
  return [].concat(value);
}
function pushIfUnique(arr, value) {
  if (arr.indexOf(value) === -1) {
    arr.push(value);
  }
}
function unique(arr) {
  return arr.filter(function(item2, index2) {
    return arr.indexOf(item2) === index2;
  });
}
function getBasePlacement(placement) {
  return placement.split("-")[0];
}
function arrayFrom(value) {
  return [].slice.call(value);
}
function removeUndefinedProps(obj) {
  return Object.keys(obj).reduce(function(acc, key) {
    if (obj[key] !== void 0) {
      acc[key] = obj[key];
    }
    return acc;
  }, {});
}
function div() {
  return document.createElement("div");
}
function isElement(value) {
  return ["Element", "Fragment"].some(function(type) {
    return isType(value, type);
  });
}
function isNodeList(value) {
  return isType(value, "NodeList");
}
function isMouseEvent(value) {
  return isType(value, "MouseEvent");
}
function isReferenceElement(value) {
  return !!(value && value._tippy && value._tippy.reference === value);
}
function getArrayOfElements(value) {
  if (isElement(value)) {
    return [value];
  }
  if (isNodeList(value)) {
    return arrayFrom(value);
  }
  if (Array.isArray(value)) {
    return value;
  }
  return arrayFrom(document.querySelectorAll(value));
}
function setTransitionDuration(els, value) {
  els.forEach(function(el2) {
    if (el2) {
      el2.style.transitionDuration = value + "ms";
    }
  });
}
function setVisibilityState(els, state) {
  els.forEach(function(el2) {
    if (el2) {
      el2.setAttribute("data-state", state);
    }
  });
}
function getOwnerDocument(elementOrElements) {
  var _element$ownerDocumen;
  var _normalizeToArray = normalizeToArray(elementOrElements), element = _normalizeToArray[0];
  return element != null && (_element$ownerDocumen = element.ownerDocument) != null && _element$ownerDocumen.body ? element.ownerDocument : document;
}
function isCursorOutsideInteractiveBorder(popperTreeData, event) {
  var clientX = event.clientX, clientY = event.clientY;
  return popperTreeData.every(function(_ref2) {
    var popperRect = _ref2.popperRect, popperState = _ref2.popperState, props = _ref2.props;
    var interactiveBorder = props.interactiveBorder;
    var basePlacement = getBasePlacement(popperState.placement);
    var offsetData = popperState.modifiersData.offset;
    if (!offsetData) {
      return true;
    }
    var topDistance = basePlacement === "bottom" ? offsetData.top.y : 0;
    var bottomDistance = basePlacement === "top" ? offsetData.bottom.y : 0;
    var leftDistance = basePlacement === "right" ? offsetData.left.x : 0;
    var rightDistance = basePlacement === "left" ? offsetData.right.x : 0;
    var exceedsTop = popperRect.top - clientY + topDistance > interactiveBorder;
    var exceedsBottom = clientY - popperRect.bottom - bottomDistance > interactiveBorder;
    var exceedsLeft = popperRect.left - clientX + leftDistance > interactiveBorder;
    var exceedsRight = clientX - popperRect.right - rightDistance > interactiveBorder;
    return exceedsTop || exceedsBottom || exceedsLeft || exceedsRight;
  });
}
function updateTransitionEndListener(box, action, listener) {
  var method = action + "EventListener";
  ["transitionend", "webkitTransitionEnd"].forEach(function(event) {
    box[method](event, listener);
  });
}
function actualContains(parent, child) {
  var target = child;
  while (target) {
    var _target$getRootNode;
    if (parent.contains(target)) {
      return true;
    }
    target = target.getRootNode == null ? void 0 : (_target$getRootNode = target.getRootNode()) == null ? void 0 : _target$getRootNode.host;
  }
  return false;
}
var currentInput = {
  isTouch: false
};
var lastMouseMoveTime = 0;
function onDocumentTouchStart() {
  if (currentInput.isTouch) {
    return;
  }
  currentInput.isTouch = true;
  if (window.performance) {
    document.addEventListener("mousemove", onDocumentMouseMove);
  }
}
function onDocumentMouseMove() {
  var now2 = performance.now();
  if (now2 - lastMouseMoveTime < 20) {
    currentInput.isTouch = false;
    document.removeEventListener("mousemove", onDocumentMouseMove);
  }
  lastMouseMoveTime = now2;
}
function onWindowBlur() {
  var activeElement = document.activeElement;
  if (isReferenceElement(activeElement)) {
    var instance = activeElement._tippy;
    if (activeElement.blur && !instance.state.isVisible) {
      activeElement.blur();
    }
  }
}
function bindGlobalEventListeners() {
  document.addEventListener("touchstart", onDocumentTouchStart, TOUCH_OPTIONS);
  window.addEventListener("blur", onWindowBlur);
}
var isBrowser$2 = typeof window !== "undefined" && typeof document !== "undefined";
var isIE11 = isBrowser$2 ? !!window.msCrypto : false;
var pluginProps = {
  animateFill: false,
  followCursor: false,
  inlinePositioning: false,
  sticky: false
};
var renderProps = {
  allowHTML: false,
  animation: "fade",
  arrow: true,
  content: "",
  inertia: false,
  maxWidth: 350,
  role: "tooltip",
  theme: "",
  zIndex: 9999
};
var defaultProps = Object.assign({
  appendTo: TIPPY_DEFAULT_APPEND_TO,
  aria: {
    content: "auto",
    expanded: "auto"
  },
  delay: 0,
  duration: [300, 250],
  getReferenceClientRect: null,
  hideOnClick: true,
  ignoreAttributes: false,
  interactive: false,
  interactiveBorder: 2,
  interactiveDebounce: 0,
  moveTransition: "",
  offset: [0, 10],
  onAfterUpdate: function onAfterUpdate() {
  },
  onBeforeUpdate: function onBeforeUpdate() {
  },
  onCreate: function onCreate() {
  },
  onDestroy: function onDestroy() {
  },
  onHidden: function onHidden() {
  },
  onHide: function onHide() {
  },
  onMount: function onMount() {
  },
  onShow: function onShow() {
  },
  onShown: function onShown() {
  },
  onTrigger: function onTrigger() {
  },
  onUntrigger: function onUntrigger() {
  },
  onClickOutside: function onClickOutside() {
  },
  placement: "top",
  plugins: [],
  popperOptions: {},
  render: null,
  showOnCreate: false,
  touch: true,
  trigger: "mouseenter focus",
  triggerTarget: null
}, pluginProps, renderProps);
var defaultKeys = Object.keys(defaultProps);
var setDefaultProps = function setDefaultProps2(partialProps) {
  var keys2 = Object.keys(partialProps);
  keys2.forEach(function(key) {
    defaultProps[key] = partialProps[key];
  });
};
function getExtendedPassedProps(passedProps) {
  var plugins2 = passedProps.plugins || [];
  var pluginProps2 = plugins2.reduce(function(acc, plugin) {
    var name = plugin.name, defaultValue2 = plugin.defaultValue;
    if (name) {
      var _name;
      acc[name] = passedProps[name] !== void 0 ? passedProps[name] : (_name = defaultProps[name]) != null ? _name : defaultValue2;
    }
    return acc;
  }, {});
  return Object.assign({}, passedProps, pluginProps2);
}
function getDataAttributeProps(reference2, plugins2) {
  var propKeys = plugins2 ? Object.keys(getExtendedPassedProps(Object.assign({}, defaultProps, {
    plugins: plugins2
  }))) : defaultKeys;
  var props = propKeys.reduce(function(acc, key) {
    var valueAsString = (reference2.getAttribute("data-tippy-" + key) || "").trim();
    if (!valueAsString) {
      return acc;
    }
    if (key === "content") {
      acc[key] = valueAsString;
    } else {
      try {
        acc[key] = JSON.parse(valueAsString);
      } catch (e3) {
        acc[key] = valueAsString;
      }
    }
    return acc;
  }, {});
  return props;
}
function evaluateProps(reference2, props) {
  var out = Object.assign({}, props, {
    content: invokeWithArgsOrReturn(props.content, [reference2])
  }, props.ignoreAttributes ? {} : getDataAttributeProps(reference2, props.plugins));
  out.aria = Object.assign({}, defaultProps.aria, out.aria);
  out.aria = {
    expanded: out.aria.expanded === "auto" ? props.interactive : out.aria.expanded,
    content: out.aria.content === "auto" ? props.interactive ? null : "describedby" : out.aria.content
  };
  return out;
}
var innerHTML = function innerHTML2() {
  return "innerHTML";
};
function dangerouslySetInnerHTML(element, html) {
  element[innerHTML()] = html;
}
function createArrowElement(value) {
  var arrow2 = div();
  if (value === true) {
    arrow2.className = ARROW_CLASS;
  } else {
    arrow2.className = SVG_ARROW_CLASS;
    if (isElement(value)) {
      arrow2.appendChild(value);
    } else {
      dangerouslySetInnerHTML(arrow2, value);
    }
  }
  return arrow2;
}
function setContent$1(content, props) {
  if (isElement(props.content)) {
    dangerouslySetInnerHTML(content, "");
    content.appendChild(props.content);
  } else if (typeof props.content !== "function") {
    if (props.allowHTML) {
      dangerouslySetInnerHTML(content, props.content);
    } else {
      content.textContent = props.content;
    }
  }
}
function getChildren(popper2) {
  var box = popper2.firstElementChild;
  var boxChildren = arrayFrom(box.children);
  return {
    box,
    content: boxChildren.find(function(node2) {
      return node2.classList.contains(CONTENT_CLASS);
    }),
    arrow: boxChildren.find(function(node2) {
      return node2.classList.contains(ARROW_CLASS) || node2.classList.contains(SVG_ARROW_CLASS);
    }),
    backdrop: boxChildren.find(function(node2) {
      return node2.classList.contains(BACKDROP_CLASS);
    })
  };
}
function render(instance) {
  var popper2 = div();
  var box = div();
  box.className = BOX_CLASS;
  box.setAttribute("data-state", "hidden");
  box.setAttribute("tabindex", "-1");
  var content = div();
  content.className = CONTENT_CLASS;
  content.setAttribute("data-state", "hidden");
  setContent$1(content, instance.props);
  popper2.appendChild(box);
  box.appendChild(content);
  onUpdate(instance.props, instance.props);
  function onUpdate(prevProps, nextProps) {
    var _getChildren = getChildren(popper2), box2 = _getChildren.box, content2 = _getChildren.content, arrow2 = _getChildren.arrow;
    if (nextProps.theme) {
      box2.setAttribute("data-theme", nextProps.theme);
    } else {
      box2.removeAttribute("data-theme");
    }
    if (typeof nextProps.animation === "string") {
      box2.setAttribute("data-animation", nextProps.animation);
    } else {
      box2.removeAttribute("data-animation");
    }
    if (nextProps.inertia) {
      box2.setAttribute("data-inertia", "");
    } else {
      box2.removeAttribute("data-inertia");
    }
    box2.style.maxWidth = typeof nextProps.maxWidth === "number" ? nextProps.maxWidth + "px" : nextProps.maxWidth;
    if (nextProps.role) {
      box2.setAttribute("role", nextProps.role);
    } else {
      box2.removeAttribute("role");
    }
    if (prevProps.content !== nextProps.content || prevProps.allowHTML !== nextProps.allowHTML) {
      setContent$1(content2, instance.props);
    }
    if (nextProps.arrow) {
      if (!arrow2) {
        box2.appendChild(createArrowElement(nextProps.arrow));
      } else if (prevProps.arrow !== nextProps.arrow) {
        box2.removeChild(arrow2);
        box2.appendChild(createArrowElement(nextProps.arrow));
      }
    } else if (arrow2) {
      box2.removeChild(arrow2);
    }
  }
  return {
    popper: popper2,
    onUpdate
  };
}
render.$$tippy = true;
var idCounter$1 = 1;
var mouseMoveListeners = [];
var mountedInstances = [];
function createTippy(reference2, passedProps) {
  var props = evaluateProps(reference2, Object.assign({}, defaultProps, getExtendedPassedProps(removeUndefinedProps(passedProps))));
  var showTimeout;
  var hideTimeout;
  var scheduleHideAnimationFrame;
  var isVisibleFromClick = false;
  var didHideDueToDocumentMouseDown = false;
  var didTouchMove = false;
  var ignoreOnFirstUpdate = false;
  var lastTriggerEvent;
  var currentTransitionEndListener;
  var onFirstUpdate;
  var listeners = [];
  var debouncedOnMouseMove = debounce$3(onMouseMove, props.interactiveDebounce);
  var currentTarget;
  var id2 = idCounter$1++;
  var popperInstance = null;
  var plugins2 = unique(props.plugins);
  var state = {
    isEnabled: true,
    isVisible: false,
    isDestroyed: false,
    isMounted: false,
    isShown: false
  };
  var instance = {
    id: id2,
    reference: reference2,
    popper: div(),
    popperInstance,
    props,
    state,
    plugins: plugins2,
    clearDelayTimeouts,
    setProps,
    setContent: setContent2,
    show,
    hide: hide2,
    hideWithInteractivity,
    enable,
    disable,
    unmount,
    destroy: destroy2
  };
  if (!props.render) {
    return instance;
  }
  var _props$render = props.render(instance), popper2 = _props$render.popper, onUpdate = _props$render.onUpdate;
  popper2.setAttribute("data-tippy-root", "");
  popper2.id = "tippy-" + instance.id;
  instance.popper = popper2;
  reference2._tippy = instance;
  popper2._tippy = instance;
  var pluginsHooks = plugins2.map(function(plugin) {
    return plugin.fn(instance);
  });
  var hasAriaExpanded = reference2.hasAttribute("aria-expanded");
  addListeners();
  handleAriaExpandedAttribute();
  handleStyles();
  invokeHook("onCreate", [instance]);
  if (props.showOnCreate) {
    scheduleShow();
  }
  popper2.addEventListener("mouseenter", function() {
    if (instance.props.interactive && instance.state.isVisible) {
      instance.clearDelayTimeouts();
    }
  });
  popper2.addEventListener("mouseleave", function() {
    if (instance.props.interactive && instance.props.trigger.indexOf("mouseenter") >= 0) {
      getDocument().addEventListener("mousemove", debouncedOnMouseMove);
    }
  });
  return instance;
  function getNormalizedTouchSettings() {
    var touch = instance.props.touch;
    return Array.isArray(touch) ? touch : [touch, 0];
  }
  function getIsCustomTouchBehavior() {
    return getNormalizedTouchSettings()[0] === "hold";
  }
  function getIsDefaultRenderFn() {
    var _instance$props$rende;
    return !!((_instance$props$rende = instance.props.render) != null && _instance$props$rende.$$tippy);
  }
  function getCurrentTarget() {
    return currentTarget || reference2;
  }
  function getDocument() {
    var parent = getCurrentTarget().parentNode;
    return parent ? getOwnerDocument(parent) : document;
  }
  function getDefaultTemplateChildren() {
    return getChildren(popper2);
  }
  function getDelay(isShow) {
    if (instance.state.isMounted && !instance.state.isVisible || currentInput.isTouch || lastTriggerEvent && lastTriggerEvent.type === "focus") {
      return 0;
    }
    return getValueAtIndexOrReturn(instance.props.delay, isShow ? 0 : 1, defaultProps.delay);
  }
  function handleStyles(fromHide) {
    if (fromHide === void 0) {
      fromHide = false;
    }
    popper2.style.pointerEvents = instance.props.interactive && !fromHide ? "" : "none";
    popper2.style.zIndex = "" + instance.props.zIndex;
  }
  function invokeHook(hook, args, shouldInvokePropsHook) {
    if (shouldInvokePropsHook === void 0) {
      shouldInvokePropsHook = true;
    }
    pluginsHooks.forEach(function(pluginHooks) {
      if (pluginHooks[hook]) {
        pluginHooks[hook].apply(pluginHooks, args);
      }
    });
    if (shouldInvokePropsHook) {
      var _instance$props;
      (_instance$props = instance.props)[hook].apply(_instance$props, args);
    }
  }
  function handleAriaContentAttribute() {
    var aria = instance.props.aria;
    if (!aria.content) {
      return;
    }
    var attr = "aria-" + aria.content;
    var id3 = popper2.id;
    var nodes = normalizeToArray(instance.props.triggerTarget || reference2);
    nodes.forEach(function(node2) {
      var currentValue = node2.getAttribute(attr);
      if (instance.state.isVisible) {
        node2.setAttribute(attr, currentValue ? currentValue + " " + id3 : id3);
      } else {
        var nextValue = currentValue && currentValue.replace(id3, "").trim();
        if (nextValue) {
          node2.setAttribute(attr, nextValue);
        } else {
          node2.removeAttribute(attr);
        }
      }
    });
  }
  function handleAriaExpandedAttribute() {
    if (hasAriaExpanded || !instance.props.aria.expanded) {
      return;
    }
    var nodes = normalizeToArray(instance.props.triggerTarget || reference2);
    nodes.forEach(function(node2) {
      if (instance.props.interactive) {
        node2.setAttribute("aria-expanded", instance.state.isVisible && node2 === getCurrentTarget() ? "true" : "false");
      } else {
        node2.removeAttribute("aria-expanded");
      }
    });
  }
  function cleanupInteractiveMouseListeners() {
    getDocument().removeEventListener("mousemove", debouncedOnMouseMove);
    mouseMoveListeners = mouseMoveListeners.filter(function(listener) {
      return listener !== debouncedOnMouseMove;
    });
  }
  function onDocumentPress(event) {
    if (currentInput.isTouch) {
      if (didTouchMove || event.type === "mousedown") {
        return;
      }
    }
    var actualTarget = event.composedPath && event.composedPath()[0] || event.target;
    if (instance.props.interactive && actualContains(popper2, actualTarget)) {
      return;
    }
    if (normalizeToArray(instance.props.triggerTarget || reference2).some(function(el2) {
      return actualContains(el2, actualTarget);
    })) {
      if (currentInput.isTouch) {
        return;
      }
      if (instance.state.isVisible && instance.props.trigger.indexOf("click") >= 0) {
        return;
      }
    } else {
      invokeHook("onClickOutside", [instance, event]);
    }
    if (instance.props.hideOnClick === true) {
      instance.clearDelayTimeouts();
      instance.hide();
      didHideDueToDocumentMouseDown = true;
      setTimeout(function() {
        didHideDueToDocumentMouseDown = false;
      });
      if (!instance.state.isMounted) {
        removeDocumentPress();
      }
    }
  }
  function onTouchMove() {
    didTouchMove = true;
  }
  function onTouchStart() {
    didTouchMove = false;
  }
  function addDocumentPress() {
    var doc2 = getDocument();
    doc2.addEventListener("mousedown", onDocumentPress, true);
    doc2.addEventListener("touchend", onDocumentPress, TOUCH_OPTIONS);
    doc2.addEventListener("touchstart", onTouchStart, TOUCH_OPTIONS);
    doc2.addEventListener("touchmove", onTouchMove, TOUCH_OPTIONS);
  }
  function removeDocumentPress() {
    var doc2 = getDocument();
    doc2.removeEventListener("mousedown", onDocumentPress, true);
    doc2.removeEventListener("touchend", onDocumentPress, TOUCH_OPTIONS);
    doc2.removeEventListener("touchstart", onTouchStart, TOUCH_OPTIONS);
    doc2.removeEventListener("touchmove", onTouchMove, TOUCH_OPTIONS);
  }
  function onTransitionedOut(duration2, callback) {
    onTransitionEnd(duration2, function() {
      if (!instance.state.isVisible && popper2.parentNode && popper2.parentNode.contains(popper2)) {
        callback();
      }
    });
  }
  function onTransitionedIn(duration2, callback) {
    onTransitionEnd(duration2, callback);
  }
  function onTransitionEnd(duration2, callback) {
    var box = getDefaultTemplateChildren().box;
    function listener(event) {
      if (event.target === box) {
        updateTransitionEndListener(box, "remove", listener);
        callback();
      }
    }
    if (duration2 === 0) {
      return callback();
    }
    updateTransitionEndListener(box, "remove", currentTransitionEndListener);
    updateTransitionEndListener(box, "add", listener);
    currentTransitionEndListener = listener;
  }
  function on2(eventType, handler, options) {
    if (options === void 0) {
      options = false;
    }
    var nodes = normalizeToArray(instance.props.triggerTarget || reference2);
    nodes.forEach(function(node2) {
      node2.addEventListener(eventType, handler, options);
      listeners.push({
        node: node2,
        eventType,
        handler,
        options
      });
    });
  }
  function addListeners() {
    if (getIsCustomTouchBehavior()) {
      on2("touchstart", onTrigger2, {
        passive: true
      });
      on2("touchend", onMouseLeave, {
        passive: true
      });
    }
    splitBySpaces(instance.props.trigger).forEach(function(eventType) {
      if (eventType === "manual") {
        return;
      }
      on2(eventType, onTrigger2);
      switch (eventType) {
        case "mouseenter":
          on2("mouseleave", onMouseLeave);
          break;
        case "focus":
          on2(isIE11 ? "focusout" : "blur", onBlurOrFocusOut);
          break;
        case "focusin":
          on2("focusout", onBlurOrFocusOut);
          break;
      }
    });
  }
  function removeListeners() {
    listeners.forEach(function(_ref2) {
      var node2 = _ref2.node, eventType = _ref2.eventType, handler = _ref2.handler, options = _ref2.options;
      node2.removeEventListener(eventType, handler, options);
    });
    listeners = [];
  }
  function onTrigger2(event) {
    var _lastTriggerEvent;
    var shouldScheduleClickHide = false;
    if (!instance.state.isEnabled || isEventListenerStopped(event) || didHideDueToDocumentMouseDown) {
      return;
    }
    var wasFocused = ((_lastTriggerEvent = lastTriggerEvent) == null ? void 0 : _lastTriggerEvent.type) === "focus";
    lastTriggerEvent = event;
    currentTarget = event.currentTarget;
    handleAriaExpandedAttribute();
    if (!instance.state.isVisible && isMouseEvent(event)) {
      mouseMoveListeners.forEach(function(listener) {
        return listener(event);
      });
    }
    if (event.type === "click" && (instance.props.trigger.indexOf("mouseenter") < 0 || isVisibleFromClick) && instance.props.hideOnClick !== false && instance.state.isVisible) {
      shouldScheduleClickHide = true;
    } else {
      scheduleShow(event);
    }
    if (event.type === "click") {
      isVisibleFromClick = !shouldScheduleClickHide;
    }
    if (shouldScheduleClickHide && !wasFocused) {
      scheduleHide(event);
    }
  }
  function onMouseMove(event) {
    var target = event.target;
    var isCursorOverReferenceOrPopper = getCurrentTarget().contains(target) || popper2.contains(target);
    if (event.type === "mousemove" && isCursorOverReferenceOrPopper) {
      return;
    }
    var popperTreeData = getNestedPopperTree().concat(popper2).map(function(popper3) {
      var _instance$popperInsta;
      var instance2 = popper3._tippy;
      var state2 = (_instance$popperInsta = instance2.popperInstance) == null ? void 0 : _instance$popperInsta.state;
      if (state2) {
        return {
          popperRect: popper3.getBoundingClientRect(),
          popperState: state2,
          props
        };
      }
      return null;
    }).filter(Boolean);
    if (isCursorOutsideInteractiveBorder(popperTreeData, event)) {
      cleanupInteractiveMouseListeners();
      scheduleHide(event);
    }
  }
  function onMouseLeave(event) {
    var shouldBail = isEventListenerStopped(event) || instance.props.trigger.indexOf("click") >= 0 && isVisibleFromClick;
    if (shouldBail) {
      return;
    }
    if (instance.props.interactive) {
      instance.hideWithInteractivity(event);
      return;
    }
    scheduleHide(event);
  }
  function onBlurOrFocusOut(event) {
    if (instance.props.trigger.indexOf("focusin") < 0 && event.target !== getCurrentTarget()) {
      return;
    }
    if (instance.props.interactive && event.relatedTarget && popper2.contains(event.relatedTarget)) {
      return;
    }
    scheduleHide(event);
  }
  function isEventListenerStopped(event) {
    return currentInput.isTouch ? getIsCustomTouchBehavior() !== event.type.indexOf("touch") >= 0 : false;
  }
  function createPopperInstance() {
    destroyPopperInstance();
    var _instance$props2 = instance.props, popperOptions = _instance$props2.popperOptions, placement = _instance$props2.placement, offset2 = _instance$props2.offset, getReferenceClientRect = _instance$props2.getReferenceClientRect, moveTransition = _instance$props2.moveTransition;
    var arrow2 = getIsDefaultRenderFn() ? getChildren(popper2).arrow : null;
    var computedReference = getReferenceClientRect ? {
      getBoundingClientRect: getReferenceClientRect,
      contextElement: getReferenceClientRect.contextElement || getCurrentTarget()
    } : reference2;
    var tippyModifier = {
      name: "$$tippy",
      enabled: true,
      phase: "beforeWrite",
      requires: ["computeStyles"],
      fn: function fn3(_ref2) {
        var state2 = _ref2.state;
        if (getIsDefaultRenderFn()) {
          var _getDefaultTemplateCh = getDefaultTemplateChildren(), box = _getDefaultTemplateCh.box;
          ["placement", "reference-hidden", "escaped"].forEach(function(attr) {
            if (attr === "placement") {
              box.setAttribute("data-placement", state2.placement);
            } else {
              if (state2.attributes.popper["data-popper-" + attr]) {
                box.setAttribute("data-" + attr, "");
              } else {
                box.removeAttribute("data-" + attr);
              }
            }
          });
          state2.attributes.popper = {};
        }
      }
    };
    var modifiers2 = [{
      name: "offset",
      options: {
        offset: offset2
      }
    }, {
      name: "preventOverflow",
      options: {
        padding: {
          top: 2,
          bottom: 2,
          left: 5,
          right: 5
        }
      }
    }, {
      name: "flip",
      options: {
        padding: 5
      }
    }, {
      name: "computeStyles",
      options: {
        adaptive: !moveTransition
      }
    }, tippyModifier];
    if (getIsDefaultRenderFn() && arrow2) {
      modifiers2.push({
        name: "arrow",
        options: {
          element: arrow2,
          padding: 3
        }
      });
    }
    modifiers2.push.apply(modifiers2, (popperOptions == null ? void 0 : popperOptions.modifiers) || []);
    instance.popperInstance = createPopper(computedReference, popper2, Object.assign({}, popperOptions, {
      placement,
      onFirstUpdate,
      modifiers: modifiers2
    }));
  }
  function destroyPopperInstance() {
    if (instance.popperInstance) {
      instance.popperInstance.destroy();
      instance.popperInstance = null;
    }
  }
  function mount2() {
    var appendTo = instance.props.appendTo;
    var parentNode2;
    var node2 = getCurrentTarget();
    if (instance.props.interactive && appendTo === TIPPY_DEFAULT_APPEND_TO || appendTo === "parent") {
      parentNode2 = node2.parentNode;
    } else {
      parentNode2 = invokeWithArgsOrReturn(appendTo, [node2]);
    }
    if (!parentNode2.contains(popper2)) {
      parentNode2.appendChild(popper2);
    }
    instance.state.isMounted = true;
    createPopperInstance();
  }
  function getNestedPopperTree() {
    return arrayFrom(popper2.querySelectorAll("[data-tippy-root]"));
  }
  function scheduleShow(event) {
    instance.clearDelayTimeouts();
    if (event) {
      invokeHook("onTrigger", [instance, event]);
    }
    addDocumentPress();
    var delay = getDelay(true);
    var _getNormalizedTouchSe = getNormalizedTouchSettings(), touchValue = _getNormalizedTouchSe[0], touchDelay = _getNormalizedTouchSe[1];
    if (currentInput.isTouch && touchValue === "hold" && touchDelay) {
      delay = touchDelay;
    }
    if (delay) {
      showTimeout = setTimeout(function() {
        instance.show();
      }, delay);
    } else {
      instance.show();
    }
  }
  function scheduleHide(event) {
    instance.clearDelayTimeouts();
    invokeHook("onUntrigger", [instance, event]);
    if (!instance.state.isVisible) {
      removeDocumentPress();
      return;
    }
    if (instance.props.trigger.indexOf("mouseenter") >= 0 && instance.props.trigger.indexOf("click") >= 0 && ["mouseleave", "mousemove"].indexOf(event.type) >= 0 && isVisibleFromClick) {
      return;
    }
    var delay = getDelay(false);
    if (delay) {
      hideTimeout = setTimeout(function() {
        if (instance.state.isVisible) {
          instance.hide();
        }
      }, delay);
    } else {
      scheduleHideAnimationFrame = requestAnimationFrame(function() {
        instance.hide();
      });
    }
  }
  function enable() {
    instance.state.isEnabled = true;
  }
  function disable() {
    instance.hide();
    instance.state.isEnabled = false;
  }
  function clearDelayTimeouts() {
    clearTimeout(showTimeout);
    clearTimeout(hideTimeout);
    cancelAnimationFrame(scheduleHideAnimationFrame);
  }
  function setProps(partialProps) {
    if (instance.state.isDestroyed) {
      return;
    }
    invokeHook("onBeforeUpdate", [instance, partialProps]);
    removeListeners();
    var prevProps = instance.props;
    var nextProps = evaluateProps(reference2, Object.assign({}, prevProps, removeUndefinedProps(partialProps), {
      ignoreAttributes: true
    }));
    instance.props = nextProps;
    addListeners();
    if (prevProps.interactiveDebounce !== nextProps.interactiveDebounce) {
      cleanupInteractiveMouseListeners();
      debouncedOnMouseMove = debounce$3(onMouseMove, nextProps.interactiveDebounce);
    }
    if (prevProps.triggerTarget && !nextProps.triggerTarget) {
      normalizeToArray(prevProps.triggerTarget).forEach(function(node2) {
        node2.removeAttribute("aria-expanded");
      });
    } else if (nextProps.triggerTarget) {
      reference2.removeAttribute("aria-expanded");
    }
    handleAriaExpandedAttribute();
    handleStyles();
    if (onUpdate) {
      onUpdate(prevProps, nextProps);
    }
    if (instance.popperInstance) {
      createPopperInstance();
      getNestedPopperTree().forEach(function(nestedPopper) {
        requestAnimationFrame(nestedPopper._tippy.popperInstance.forceUpdate);
      });
    }
    invokeHook("onAfterUpdate", [instance, partialProps]);
  }
  function setContent2(content) {
    instance.setProps({
      content
    });
  }
  function show() {
    var isAlreadyVisible = instance.state.isVisible;
    var isDestroyed = instance.state.isDestroyed;
    var isDisabled = !instance.state.isEnabled;
    var isTouchAndTouchDisabled = currentInput.isTouch && !instance.props.touch;
    var duration2 = getValueAtIndexOrReturn(instance.props.duration, 0, defaultProps.duration);
    if (isAlreadyVisible || isDestroyed || isDisabled || isTouchAndTouchDisabled) {
      return;
    }
    if (getCurrentTarget().hasAttribute("disabled")) {
      return;
    }
    invokeHook("onShow", [instance], false);
    if (instance.props.onShow(instance) === false) {
      return;
    }
    instance.state.isVisible = true;
    if (getIsDefaultRenderFn()) {
      popper2.style.visibility = "visible";
    }
    handleStyles();
    addDocumentPress();
    if (!instance.state.isMounted) {
      popper2.style.transition = "none";
    }
    if (getIsDefaultRenderFn()) {
      var _getDefaultTemplateCh2 = getDefaultTemplateChildren(), box = _getDefaultTemplateCh2.box, content = _getDefaultTemplateCh2.content;
      setTransitionDuration([box, content], 0);
    }
    onFirstUpdate = function onFirstUpdate2() {
      var _instance$popperInsta2;
      if (!instance.state.isVisible || ignoreOnFirstUpdate) {
        return;
      }
      ignoreOnFirstUpdate = true;
      void popper2.offsetHeight;
      popper2.style.transition = instance.props.moveTransition;
      if (getIsDefaultRenderFn() && instance.props.animation) {
        var _getDefaultTemplateCh3 = getDefaultTemplateChildren(), _box = _getDefaultTemplateCh3.box, _content = _getDefaultTemplateCh3.content;
        setTransitionDuration([_box, _content], duration2);
        setVisibilityState([_box, _content], "visible");
      }
      handleAriaContentAttribute();
      handleAriaExpandedAttribute();
      pushIfUnique(mountedInstances, instance);
      (_instance$popperInsta2 = instance.popperInstance) == null ? void 0 : _instance$popperInsta2.forceUpdate();
      invokeHook("onMount", [instance]);
      if (instance.props.animation && getIsDefaultRenderFn()) {
        onTransitionedIn(duration2, function() {
          instance.state.isShown = true;
          invokeHook("onShown", [instance]);
        });
      }
    };
    mount2();
  }
  function hide2() {
    var isAlreadyHidden = !instance.state.isVisible;
    var isDestroyed = instance.state.isDestroyed;
    var isDisabled = !instance.state.isEnabled;
    var duration2 = getValueAtIndexOrReturn(instance.props.duration, 1, defaultProps.duration);
    if (isAlreadyHidden || isDestroyed || isDisabled) {
      return;
    }
    invokeHook("onHide", [instance], false);
    if (instance.props.onHide(instance) === false) {
      return;
    }
    instance.state.isVisible = false;
    instance.state.isShown = false;
    ignoreOnFirstUpdate = false;
    isVisibleFromClick = false;
    if (getIsDefaultRenderFn()) {
      popper2.style.visibility = "hidden";
    }
    cleanupInteractiveMouseListeners();
    removeDocumentPress();
    handleStyles(true);
    if (getIsDefaultRenderFn()) {
      var _getDefaultTemplateCh4 = getDefaultTemplateChildren(), box = _getDefaultTemplateCh4.box, content = _getDefaultTemplateCh4.content;
      if (instance.props.animation) {
        setTransitionDuration([box, content], duration2);
        setVisibilityState([box, content], "hidden");
      }
    }
    handleAriaContentAttribute();
    handleAriaExpandedAttribute();
    if (instance.props.animation) {
      if (getIsDefaultRenderFn()) {
        onTransitionedOut(duration2, instance.unmount);
      }
    } else {
      instance.unmount();
    }
  }
  function hideWithInteractivity(event) {
    getDocument().addEventListener("mousemove", debouncedOnMouseMove);
    pushIfUnique(mouseMoveListeners, debouncedOnMouseMove);
    debouncedOnMouseMove(event);
  }
  function unmount() {
    if (instance.state.isVisible) {
      instance.hide();
    }
    if (!instance.state.isMounted) {
      return;
    }
    destroyPopperInstance();
    getNestedPopperTree().forEach(function(nestedPopper) {
      nestedPopper._tippy.unmount();
    });
    if (popper2.parentNode) {
      popper2.parentNode.removeChild(popper2);
    }
    mountedInstances = mountedInstances.filter(function(i3) {
      return i3 !== instance;
    });
    instance.state.isMounted = false;
    invokeHook("onHidden", [instance]);
  }
  function destroy2() {
    if (instance.state.isDestroyed) {
      return;
    }
    instance.clearDelayTimeouts();
    instance.unmount();
    removeListeners();
    delete reference2._tippy;
    instance.state.isDestroyed = true;
    invokeHook("onDestroy", [instance]);
  }
}
function tippy(targets, optionalProps) {
  if (optionalProps === void 0) {
    optionalProps = {};
  }
  var plugins2 = defaultProps.plugins.concat(optionalProps.plugins || []);
  bindGlobalEventListeners();
  var passedProps = Object.assign({}, optionalProps, {
    plugins: plugins2
  });
  var elements = getArrayOfElements(targets);
  var instances = elements.reduce(function(acc, reference2) {
    var instance = reference2 && createTippy(reference2, passedProps);
    if (instance) {
      acc.push(instance);
    }
    return acc;
  }, []);
  return isElement(targets) ? instances[0] : instances;
}
tippy.defaultProps = defaultProps;
tippy.setDefaultProps = setDefaultProps;
tippy.currentInput = currentInput;
Object.assign({}, applyStyles$1, {
  effect: function effect2(_ref2) {
    var state = _ref2.state;
    var initialStyles = {
      popper: {
        position: state.options.strategy,
        left: "0",
        top: "0",
        margin: "0"
      },
      arrow: {
        position: "absolute"
      },
      reference: {}
    };
    Object.assign(state.elements.popper.style, initialStyles.popper);
    state.styles = initialStyles;
    if (state.elements.arrow) {
      Object.assign(state.elements.arrow.style, initialStyles.arrow);
    }
  }
});
tippy.setDefaultProps({
  render
});
function _objectWithoutPropertiesLoose$2(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i3;
  for (i3 = 0; i3 < sourceKeys.length; i3++) {
    key = sourceKeys[i3];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
var isBrowser$1 = typeof window !== "undefined" && typeof document !== "undefined";
function preserveRef(ref, node2) {
  if (ref) {
    if (typeof ref === "function") {
      ref(node2);
    }
    if ({}.hasOwnProperty.call(ref, "current")) {
      ref.current = node2;
    }
  }
}
function ssrSafeCreateDiv() {
  return isBrowser$1 && document.createElement("div");
}
function toDataAttributes(attrs) {
  var dataAttrs = {
    "data-placement": attrs.placement
  };
  if (attrs.referenceHidden) {
    dataAttrs["data-reference-hidden"] = "";
  }
  if (attrs.escaped) {
    dataAttrs["data-escaped"] = "";
  }
  return dataAttrs;
}
function deepEqual(x3, y4) {
  if (x3 === y4) {
    return true;
  } else if (typeof x3 === "object" && x3 != null && typeof y4 === "object" && y4 != null) {
    if (Object.keys(x3).length !== Object.keys(y4).length) {
      return false;
    }
    for (var prop in x3) {
      if (y4.hasOwnProperty(prop)) {
        if (!deepEqual(x3[prop], y4[prop])) {
          return false;
        }
      } else {
        return false;
      }
    }
    return true;
  } else {
    return false;
  }
}
function uniqueByShape(arr) {
  var output = [];
  arr.forEach(function(item2) {
    if (!output.find(function(outputItem) {
      return deepEqual(item2, outputItem);
    })) {
      output.push(item2);
    }
  });
  return output;
}
function deepPreserveProps(instanceProps, componentProps) {
  var _instanceProps$popper, _componentProps$poppe;
  return Object.assign({}, componentProps, {
    popperOptions: Object.assign({}, instanceProps.popperOptions, componentProps.popperOptions, {
      modifiers: uniqueByShape([].concat(((_instanceProps$popper = instanceProps.popperOptions) == null ? void 0 : _instanceProps$popper.modifiers) || [], ((_componentProps$poppe = componentProps.popperOptions) == null ? void 0 : _componentProps$poppe.modifiers) || []))
    })
  });
}
var useIsomorphicLayoutEffect$2 = isBrowser$1 ? react.exports.useLayoutEffect : react.exports.useEffect;
function useMutableBox(initialValue) {
  var ref = react.exports.useRef();
  if (!ref.current) {
    ref.current = typeof initialValue === "function" ? initialValue() : initialValue;
  }
  return ref.current;
}
function updateClassName(box, action, classNames) {
  classNames.split(/\s+/).forEach(function(name) {
    if (name) {
      box.classList[action](name);
    }
  });
}
var classNamePlugin = {
  name: "className",
  defaultValue: "",
  fn: function fn2(instance) {
    var box = instance.popper.firstElementChild;
    var isDefaultRenderFn = function isDefaultRenderFn2() {
      var _instance$props$rende;
      return !!((_instance$props$rende = instance.props.render) == null ? void 0 : _instance$props$rende.$$tippy);
    };
    function add2() {
      if (instance.props.className && !isDefaultRenderFn()) {
        return;
      }
      updateClassName(box, "add", instance.props.className);
    }
    function remove() {
      if (isDefaultRenderFn()) {
        updateClassName(box, "remove", instance.props.className);
      }
    }
    return {
      onCreate: add2,
      onBeforeUpdate: remove,
      onAfterUpdate: add2
    };
  }
};
function TippyGenerator(tippy2) {
  function Tippy2(_ref2) {
    var children = _ref2.children, content = _ref2.content, visible = _ref2.visible, singleton = _ref2.singleton, render2 = _ref2.render, reference2 = _ref2.reference, _ref$disabled = _ref2.disabled, disabled = _ref$disabled === void 0 ? false : _ref$disabled, _ref$ignoreAttributes = _ref2.ignoreAttributes, ignoreAttributes = _ref$ignoreAttributes === void 0 ? true : _ref$ignoreAttributes;
    _ref2.__source;
    _ref2.__self;
    var restOfNativeProps = _objectWithoutPropertiesLoose$2(_ref2, ["children", "content", "visible", "singleton", "render", "reference", "disabled", "ignoreAttributes", "__source", "__self"]);
    var isControlledMode = visible !== void 0;
    var isSingletonMode = singleton !== void 0;
    var _useState = react.exports.useState(false), mounted = _useState[0], setMounted = _useState[1];
    var _useState2 = react.exports.useState({}), attrs = _useState2[0], setAttrs = _useState2[1];
    var _useState3 = react.exports.useState(), singletonContent = _useState3[0], setSingletonContent = _useState3[1];
    var mutableBox = useMutableBox(function() {
      return {
        container: ssrSafeCreateDiv(),
        renders: 1
      };
    });
    var props = Object.assign({
      ignoreAttributes
    }, restOfNativeProps, {
      content: mutableBox.container
    });
    if (isControlledMode) {
      props.trigger = "manual";
      props.hideOnClick = false;
    }
    if (isSingletonMode) {
      disabled = true;
    }
    var computedProps = props;
    var plugins2 = props.plugins || [];
    if (render2) {
      computedProps = Object.assign({}, props, {
        plugins: isSingletonMode && singleton.data != null ? [].concat(plugins2, [{
          fn: function fn3() {
            return {
              onTrigger: function onTrigger2(instance, event) {
                var node2 = singleton.data.children.find(function(_ref22) {
                  var instance2 = _ref22.instance;
                  return instance2.reference === event.currentTarget;
                });
                instance.state.$$activeSingletonInstance = node2.instance;
                setSingletonContent(node2.content);
              }
            };
          }
        }]) : plugins2,
        render: function render3() {
          return {
            popper: mutableBox.container
          };
        }
      });
    }
    var deps = [reference2].concat(children ? [children.type] : []);
    useIsomorphicLayoutEffect$2(function() {
      var element = reference2;
      if (reference2 && reference2.hasOwnProperty("current")) {
        element = reference2.current;
      }
      var instance = tippy2(element || mutableBox.ref || ssrSafeCreateDiv(), Object.assign({}, computedProps, {
        plugins: [classNamePlugin].concat(props.plugins || [])
      }));
      mutableBox.instance = instance;
      if (disabled) {
        instance.disable();
      }
      if (visible) {
        instance.show();
      }
      if (isSingletonMode) {
        singleton.hook({
          instance,
          content,
          props: computedProps,
          setSingletonContent
        });
      }
      setMounted(true);
      return function() {
        instance.destroy();
        singleton == null ? void 0 : singleton.cleanup(instance);
      };
    }, deps);
    useIsomorphicLayoutEffect$2(function() {
      var _instance$popperInsta;
      if (mutableBox.renders === 1) {
        mutableBox.renders++;
        return;
      }
      var instance = mutableBox.instance;
      instance.setProps(deepPreserveProps(instance.props, computedProps));
      (_instance$popperInsta = instance.popperInstance) == null ? void 0 : _instance$popperInsta.forceUpdate();
      if (disabled) {
        instance.disable();
      } else {
        instance.enable();
      }
      if (isControlledMode) {
        if (visible) {
          instance.show();
        } else {
          instance.hide();
        }
      }
      if (isSingletonMode) {
        singleton.hook({
          instance,
          content,
          props: computedProps,
          setSingletonContent
        });
      }
    });
    useIsomorphicLayoutEffect$2(function() {
      var _instance$props$poppe;
      if (!render2) {
        return;
      }
      var instance = mutableBox.instance;
      instance.setProps({
        popperOptions: Object.assign({}, instance.props.popperOptions, {
          modifiers: [].concat((((_instance$props$poppe = instance.props.popperOptions) == null ? void 0 : _instance$props$poppe.modifiers) || []).filter(function(_ref3) {
            var name = _ref3.name;
            return name !== "$$tippyReact";
          }), [{
            name: "$$tippyReact",
            enabled: true,
            phase: "beforeWrite",
            requires: ["computeStyles"],
            fn: function fn3(_ref4) {
              var _state$modifiersData;
              var state = _ref4.state;
              var hideData = (_state$modifiersData = state.modifiersData) == null ? void 0 : _state$modifiersData.hide;
              if (attrs.placement !== state.placement || attrs.referenceHidden !== (hideData == null ? void 0 : hideData.isReferenceHidden) || attrs.escaped !== (hideData == null ? void 0 : hideData.hasPopperEscaped)) {
                setAttrs({
                  placement: state.placement,
                  referenceHidden: hideData == null ? void 0 : hideData.isReferenceHidden,
                  escaped: hideData == null ? void 0 : hideData.hasPopperEscaped
                });
              }
              state.attributes.popper = {};
            }
          }])
        })
      });
    }, [attrs.placement, attrs.referenceHidden, attrs.escaped].concat(deps));
    return /* @__PURE__ */ jsxs(Fragment$1, {
      children: [children ? /* @__PURE__ */ react.exports.cloneElement(children, {
        ref: function ref(node2) {
          mutableBox.ref = node2;
          preserveRef(children.ref, node2);
        }
      }) : null, mounted && /* @__PURE__ */ reactDom.exports.createPortal(render2 ? render2(toDataAttributes(attrs), singletonContent, mutableBox.instance) : content, mutableBox.container)]
    });
  }
  return Tippy2;
}
var forwardRef = function(Tippy2, defaultProps2) {
  return /* @__PURE__ */ react.exports.forwardRef(function TippyWrapper(_ref2, _ref22) {
    var children = _ref2.children, props = _objectWithoutPropertiesLoose$2(_ref2, ["children"]);
    return /* @__PURE__ */ jsx(Tippy2, {
      ...Object.assign({}, defaultProps2, props),
      children: children ? /* @__PURE__ */ react.exports.cloneElement(children, {
        ref: function ref(node2) {
          preserveRef(_ref22, node2);
          preserveRef(children.ref, node2);
        }
      }) : null
    });
  });
};
var index$1 = /* @__PURE__ */ forwardRef(/* @__PURE__ */ TippyGenerator(tippy));
var Tippy = index$1;
function Tooltip({
  content,
  children,
  visible,
  trigger
}) {
  const tippyProps = {};
  if (trigger === "click") {
    tippyProps.trigger = trigger;
    tippyProps.hideOnClick = true;
    tippyProps.interactive = true;
  }
  return /* @__PURE__ */ jsx(StyledTippy, {
    content,
    visible,
    ...tippyProps,
    children
  });
}
const StyledTippy = /* @__PURE__ */ createStyled(Tippy, {
  target: "e1mzuann0"
})({
  name: "t3ueh3",
  styles: 'background-color:#202227;color:#FFF;padding:.2em .5em;position:relative;border-radius:4px;font-size:.75em;line-height:1.4;box-shadow:rgba(0, 0, 0, 0.1) 0 10px 15px -3px, rgba(0, 0, 0, 0.05) 0 4px 6px -2px;outline:0;transition-property:transform, visibility, opacity;&[data-animation=fade][data-state=hidden]{transform:translateY(-5px);opacity:0;}&[data-placement^=top] > .tippy-arrow{bottom:0;}& .tippy-arrow{width:16px;height:16px;color:#202227;}&[data-placement^=top] > .tippy-arrow::before{bottom:-7px;left:0;border-width:8px 8px 0;border-top-color:initial;transform-origin:center top;}& .tippy-arrow::before{content:"";position:absolute;border-color:transparent;border-style:solid;}&[data-placement^=bottom] > .tippy-arrow::before{top:-19px;left:0;border-width:8px 8px 0;border-top-color:initial;transform:rotate(180deg);transform-origin:center top;}'
});
const button__icon = "_button__icon_1t9xz_1";
const danger = "_danger_1t9xz_20";
const success = "_success_1t9xz_27";
var Style$a = {
  button__icon,
  danger,
  success
};
function ButtonIcon({
  danger: danger2,
  success: success2,
  rotate,
  title: title2,
  additionalStyle,
  ...props
}) {
  const style2 = rotate ? {
    transform: `rotate(${rotate}deg)`,
    ...additionalStyle
  } : additionalStyle;
  const button2 = /* @__PURE__ */ jsx("button", {
    ...props,
    className: `${Style$a["button__icon"]} ${danger2 && Style$a.danger} ${success2 && Style$a.success}`,
    "aria-label": title2,
    style: style2
  });
  if (title2) {
    return /* @__PURE__ */ jsx(Tooltip, {
      content: title2,
      trigger: "focus",
      children: button2
    });
  }
  return button2;
}
const DragHandle = /* @__PURE__ */ createStyled("div", {
  target: "emmre300"
})({
  name: "2ozjl7",
  styles: "width:10px;position:absolute;top:.5rem;left:3px;bottom:.5rem;cursor:move;background:radial-gradient(rgba(0,0,0,0.1), rgba(0,0,0,0.1) 30%, rgba(0,0,0,0) 31%, rgba(0,0,0,0.0)) left top / 5px 5px repeat"
});
var __create$1 = Object.create;
var __defProp$1 = Object.defineProperty;
var __getOwnPropDesc$1 = Object.getOwnPropertyDescriptor;
var __getOwnPropNames$1 = Object.getOwnPropertyNames;
var __getProtoOf$1 = Object.getPrototypeOf;
var __hasOwnProp$1 = Object.prototype.hasOwnProperty;
var __defNormalProp2 = (obj, key, value) => key in obj ? __defProp$1(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __esm$1 = (fn3, res) => function __init() {
  return fn3 && (res = (0, fn3[__getOwnPropNames$1(fn3)[0]])(fn3 = 0)), res;
};
var __commonJS$1 = (cb2, mod) => function __require() {
  return mod || (0, cb2[__getOwnPropNames$1(cb2)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __copyProps$1 = (to, from3, except, desc) => {
  if (from3 && typeof from3 === "object" || typeof from3 === "function") {
    for (let key of __getOwnPropNames$1(from3))
      if (!__hasOwnProp$1.call(to, key) && key !== except)
        __defProp$1(to, key, { get: () => from3[key], enumerable: !(desc = __getOwnPropDesc$1(from3, key)) || desc.enumerable });
  }
  return to;
};
var __toESM$1 = (mod, isNodeMode, target) => (target = mod != null ? __create$1(__getProtoOf$1(mod)) : {}, __copyProps$1(
  isNodeMode || !mod || !mod.__esModule ? __defProp$1(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __publicField2 = (obj, key, value) => {
  __defNormalProp2(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var init_react_shim$1 = __esm$1({
  "react-shim.js"() {
  }
});
var require_turbolinks$1 = __commonJS$1({
  "node_modules/turbolinks/dist/turbolinks.js"(exports, module) {
    init_react_shim$1();
    (function() {
      var t3 = this;
      (function() {
        (function() {
          this.Turbolinks = { supported: function() {
            return null != window.history.pushState && null != window.requestAnimationFrame && null != window.addEventListener;
          }(), visit: function(t22, r2) {
            return e3.controller.visit(t22, r2);
          }, clearCache: function() {
            return e3.controller.clearCache();
          }, setProgressBarDelay: function(t22) {
            return e3.controller.setProgressBarDelay(t22);
          } };
        }).call(this);
      }).call(t3);
      var e3 = t3.Turbolinks;
      (function() {
        (function() {
          var t22, r2, n2, o2 = [].slice;
          e3.copyObject = function(t32) {
            var e22, r22, n22;
            r22 = {};
            for (e22 in t32)
              n22 = t32[e22], r22[e22] = n22;
            return r22;
          }, e3.closest = function(e22, r22) {
            return t22.call(e22, r22);
          }, t22 = function() {
            var t32, e22;
            return t32 = document.documentElement, null != (e22 = t32.closest) ? e22 : function(t4) {
              var e32;
              for (e32 = this; e32; ) {
                if (e32.nodeType === Node.ELEMENT_NODE && r2.call(e32, t4))
                  return e32;
                e32 = e32.parentNode;
              }
            };
          }(), e3.defer = function(t32) {
            return setTimeout(t32, 1);
          }, e3.throttle = function(t32) {
            var e22;
            return e22 = null, function() {
              var r22;
              return r22 = 1 <= arguments.length ? o2.call(arguments, 0) : [], null != e22 ? e22 : e22 = requestAnimationFrame(function(n22) {
                return function() {
                  return e22 = null, t32.apply(n22, r22);
                };
              }(this));
            };
          }, e3.dispatch = function(t32, e22) {
            var r22, o22, i3, s4, a4, u3;
            return a4 = null != e22 ? e22 : {}, u3 = a4.target, r22 = a4.cancelable, o22 = a4.data, i3 = document.createEvent("Events"), i3.initEvent(t32, true, r22 === true), i3.data = null != o22 ? o22 : {}, i3.cancelable && !n2 && (s4 = i3.preventDefault, i3.preventDefault = function() {
              return this.defaultPrevented || Object.defineProperty(this, "defaultPrevented", { get: function() {
                return true;
              } }), s4.call(this);
            }), (null != u3 ? u3 : document).dispatchEvent(i3), i3;
          }, n2 = function() {
            var t32;
            return t32 = document.createEvent("Events"), t32.initEvent("test", true, true), t32.preventDefault(), t32.defaultPrevented;
          }(), e3.match = function(t32, e22) {
            return r2.call(t32, e22);
          }, r2 = function() {
            var t32, e22, r22, n22;
            return t32 = document.documentElement, null != (e22 = null != (r22 = null != (n22 = t32.matchesSelector) ? n22 : t32.webkitMatchesSelector) ? r22 : t32.msMatchesSelector) ? e22 : t32.mozMatchesSelector;
          }(), e3.uuid = function() {
            var t32, e22, r22;
            for (r22 = "", t32 = e22 = 1; 36 >= e22; t32 = ++e22)
              r22 += 9 === t32 || 14 === t32 || 19 === t32 || 24 === t32 ? "-" : 15 === t32 ? "4" : 20 === t32 ? (Math.floor(4 * Math.random()) + 8).toString(16) : Math.floor(15 * Math.random()).toString(16);
            return r22;
          };
        }).call(this), function() {
          e3.Location = function() {
            function t22(t32) {
              var e32, r22;
              null == t32 && (t32 = ""), r22 = document.createElement("a"), r22.href = t32.toString(), this.absoluteURL = r22.href, e32 = r22.hash.length, 2 > e32 ? this.requestURL = this.absoluteURL : (this.requestURL = this.absoluteURL.slice(0, -e32), this.anchor = r22.hash.slice(1));
            }
            var e22, r2, n2, o2;
            return t22.wrap = function(t32) {
              return t32 instanceof this ? t32 : new this(t32);
            }, t22.prototype.getOrigin = function() {
              return this.absoluteURL.split("/", 3).join("/");
            }, t22.prototype.getPath = function() {
              var t32, e32;
              return null != (t32 = null != (e32 = this.requestURL.match(/\/\/[^\/]*(\/[^?;]*)/)) ? e32[1] : void 0) ? t32 : "/";
            }, t22.prototype.getPathComponents = function() {
              return this.getPath().split("/").slice(1);
            }, t22.prototype.getLastPathComponent = function() {
              return this.getPathComponents().slice(-1)[0];
            }, t22.prototype.getExtension = function() {
              var t32, e32;
              return null != (t32 = null != (e32 = this.getLastPathComponent().match(/\.[^.]*$/)) ? e32[0] : void 0) ? t32 : "";
            }, t22.prototype.isHTML = function() {
              return this.getExtension().match(/^(?:|\.(?:htm|html|xhtml))$/);
            }, t22.prototype.isPrefixedBy = function(t32) {
              var e32;
              return e32 = r2(t32), this.isEqualTo(t32) || o2(this.absoluteURL, e32);
            }, t22.prototype.isEqualTo = function(t32) {
              return this.absoluteURL === (null != t32 ? t32.absoluteURL : void 0);
            }, t22.prototype.toCacheKey = function() {
              return this.requestURL;
            }, t22.prototype.toJSON = function() {
              return this.absoluteURL;
            }, t22.prototype.toString = function() {
              return this.absoluteURL;
            }, t22.prototype.valueOf = function() {
              return this.absoluteURL;
            }, r2 = function(t32) {
              return e22(t32.getOrigin() + t32.getPath());
            }, e22 = function(t32) {
              return n2(t32, "/") ? t32 : t32 + "/";
            }, o2 = function(t32, e32) {
              return t32.slice(0, e32.length) === e32;
            }, n2 = function(t32, e32) {
              return t32.slice(-e32.length) === e32;
            }, t22;
          }();
        }.call(this), function() {
          var t22 = function(t32, e22) {
            return function() {
              return t32.apply(e22, arguments);
            };
          };
          e3.HttpRequest = function() {
            function r2(r22, n2, o2) {
              this.delegate = r22, this.requestCanceled = t22(this.requestCanceled, this), this.requestTimedOut = t22(this.requestTimedOut, this), this.requestFailed = t22(this.requestFailed, this), this.requestLoaded = t22(this.requestLoaded, this), this.requestProgressed = t22(this.requestProgressed, this), this.url = e3.Location.wrap(n2).requestURL, this.referrer = e3.Location.wrap(o2).absoluteURL, this.createXHR();
            }
            return r2.NETWORK_FAILURE = 0, r2.TIMEOUT_FAILURE = -1, r2.timeout = 60, r2.prototype.send = function() {
              var t32;
              return this.xhr && !this.sent ? (this.notifyApplicationBeforeRequestStart(), this.setProgress(0), this.xhr.send(), this.sent = true, "function" == typeof (t32 = this.delegate).requestStarted ? t32.requestStarted() : void 0) : void 0;
            }, r2.prototype.cancel = function() {
              return this.xhr && this.sent ? this.xhr.abort() : void 0;
            }, r2.prototype.requestProgressed = function(t32) {
              return t32.lengthComputable ? this.setProgress(t32.loaded / t32.total) : void 0;
            }, r2.prototype.requestLoaded = function() {
              return this.endRequest(function(t32) {
                return function() {
                  var e22;
                  return 200 <= (e22 = t32.xhr.status) && 300 > e22 ? t32.delegate.requestCompletedWithResponse(t32.xhr.responseText, t32.xhr.getResponseHeader("Turbolinks-Location")) : (t32.failed = true, t32.delegate.requestFailedWithStatusCode(t32.xhr.status, t32.xhr.responseText));
                };
              }(this));
            }, r2.prototype.requestFailed = function() {
              return this.endRequest(function(t32) {
                return function() {
                  return t32.failed = true, t32.delegate.requestFailedWithStatusCode(t32.constructor.NETWORK_FAILURE);
                };
              }(this));
            }, r2.prototype.requestTimedOut = function() {
              return this.endRequest(function(t32) {
                return function() {
                  return t32.failed = true, t32.delegate.requestFailedWithStatusCode(t32.constructor.TIMEOUT_FAILURE);
                };
              }(this));
            }, r2.prototype.requestCanceled = function() {
              return this.endRequest();
            }, r2.prototype.notifyApplicationBeforeRequestStart = function() {
              return e3.dispatch("turbolinks:request-start", { data: { url: this.url, xhr: this.xhr } });
            }, r2.prototype.notifyApplicationAfterRequestEnd = function() {
              return e3.dispatch("turbolinks:request-end", { data: { url: this.url, xhr: this.xhr } });
            }, r2.prototype.createXHR = function() {
              return this.xhr = new XMLHttpRequest(), this.xhr.open("GET", this.url, true), this.xhr.timeout = 1e3 * this.constructor.timeout, this.xhr.setRequestHeader("Accept", "text/html, application/xhtml+xml"), this.xhr.setRequestHeader("Turbolinks-Referrer", this.referrer), this.xhr.onprogress = this.requestProgressed, this.xhr.onload = this.requestLoaded, this.xhr.onerror = this.requestFailed, this.xhr.ontimeout = this.requestTimedOut, this.xhr.onabort = this.requestCanceled;
            }, r2.prototype.endRequest = function(t32) {
              return this.xhr ? (this.notifyApplicationAfterRequestEnd(), null != t32 && t32.call(this), this.destroy()) : void 0;
            }, r2.prototype.setProgress = function(t32) {
              var e22;
              return this.progress = t32, "function" == typeof (e22 = this.delegate).requestProgressed ? e22.requestProgressed(this.progress) : void 0;
            }, r2.prototype.destroy = function() {
              var t32;
              return this.setProgress(1), "function" == typeof (t32 = this.delegate).requestFinished && t32.requestFinished(), this.delegate = null, this.xhr = null;
            }, r2;
          }();
        }.call(this), function() {
          var t22 = function(t32, e22) {
            return function() {
              return t32.apply(e22, arguments);
            };
          };
          e3.ProgressBar = function() {
            function e22() {
              this.trickle = t22(this.trickle, this), this.stylesheetElement = this.createStylesheetElement(), this.progressElement = this.createProgressElement();
            }
            var r2;
            return r2 = 300, e22.defaultCSS = ".turbolinks-progress-bar {\n  position: fixed;\n  display: block;\n  top: 0;\n  left: 0;\n  height: 3px;\n  background: #0076ff;\n  z-index: 9999;\n  transition: width " + r2 + "ms ease-out, opacity " + r2 / 2 + "ms " + r2 / 2 + "ms ease-in;\n  transform: translate3d(0, 0, 0);\n}", e22.prototype.show = function() {
              return this.visible ? void 0 : (this.visible = true, this.installStylesheetElement(), this.installProgressElement(), this.startTrickling());
            }, e22.prototype.hide = function() {
              return this.visible && !this.hiding ? (this.hiding = true, this.fadeProgressElement(function(t32) {
                return function() {
                  return t32.uninstallProgressElement(), t32.stopTrickling(), t32.visible = false, t32.hiding = false;
                };
              }(this))) : void 0;
            }, e22.prototype.setValue = function(t32) {
              return this.value = t32, this.refresh();
            }, e22.prototype.installStylesheetElement = function() {
              return document.head.insertBefore(this.stylesheetElement, document.head.firstChild);
            }, e22.prototype.installProgressElement = function() {
              return this.progressElement.style.width = 0, this.progressElement.style.opacity = 1, document.documentElement.insertBefore(this.progressElement, document.body), this.refresh();
            }, e22.prototype.fadeProgressElement = function(t32) {
              return this.progressElement.style.opacity = 0, setTimeout(t32, 1.5 * r2);
            }, e22.prototype.uninstallProgressElement = function() {
              return this.progressElement.parentNode ? document.documentElement.removeChild(this.progressElement) : void 0;
            }, e22.prototype.startTrickling = function() {
              return null != this.trickleInterval ? this.trickleInterval : this.trickleInterval = setInterval(this.trickle, r2);
            }, e22.prototype.stopTrickling = function() {
              return clearInterval(this.trickleInterval), this.trickleInterval = null;
            }, e22.prototype.trickle = function() {
              return this.setValue(this.value + Math.random() / 100);
            }, e22.prototype.refresh = function() {
              return requestAnimationFrame(function(t32) {
                return function() {
                  return t32.progressElement.style.width = 10 + 90 * t32.value + "%";
                };
              }(this));
            }, e22.prototype.createStylesheetElement = function() {
              var t32;
              return t32 = document.createElement("style"), t32.type = "text/css", t32.textContent = this.constructor.defaultCSS, t32;
            }, e22.prototype.createProgressElement = function() {
              var t32;
              return t32 = document.createElement("div"), t32.className = "turbolinks-progress-bar", t32;
            }, e22;
          }();
        }.call(this), function() {
          var t22 = function(t32, e22) {
            return function() {
              return t32.apply(e22, arguments);
            };
          };
          e3.BrowserAdapter = function() {
            function r2(r22) {
              this.controller = r22, this.showProgressBar = t22(this.showProgressBar, this), this.progressBar = new e3.ProgressBar();
            }
            var n2, o2, i3;
            return i3 = e3.HttpRequest, n2 = i3.NETWORK_FAILURE, o2 = i3.TIMEOUT_FAILURE, r2.prototype.visitProposedToLocationWithAction = function(t32, e22) {
              return this.controller.startVisitToLocationWithAction(t32, e22);
            }, r2.prototype.visitStarted = function(t32) {
              return t32.issueRequest(), t32.changeHistory(), t32.loadCachedSnapshot();
            }, r2.prototype.visitRequestStarted = function(t32) {
              return this.progressBar.setValue(0), t32.hasCachedSnapshot() || "restore" !== t32.action ? this.showProgressBarAfterDelay() : this.showProgressBar();
            }, r2.prototype.visitRequestProgressed = function(t32) {
              return this.progressBar.setValue(t32.progress);
            }, r2.prototype.visitRequestCompleted = function(t32) {
              return t32.loadResponse();
            }, r2.prototype.visitRequestFailedWithStatusCode = function(t32, e22) {
              switch (e22) {
                case n2:
                case o2:
                  return this.reload();
                default:
                  return t32.loadResponse();
              }
            }, r2.prototype.visitRequestFinished = function(t32) {
              return this.hideProgressBar();
            }, r2.prototype.visitCompleted = function(t32) {
              return t32.followRedirect();
            }, r2.prototype.pageInvalidated = function() {
              return this.reload();
            }, r2.prototype.showProgressBarAfterDelay = function() {
              return this.progressBarTimeout = setTimeout(this.showProgressBar, this.controller.progressBarDelay);
            }, r2.prototype.showProgressBar = function() {
              return this.progressBar.show();
            }, r2.prototype.hideProgressBar = function() {
              return this.progressBar.hide(), clearTimeout(this.progressBarTimeout);
            }, r2.prototype.reload = function() {
              return window.location.reload();
            }, r2;
          }();
        }.call(this), function() {
          var t22 = function(t32, e22) {
            return function() {
              return t32.apply(e22, arguments);
            };
          };
          e3.History = function() {
            function r2(e22) {
              this.delegate = e22, this.onPageLoad = t22(this.onPageLoad, this), this.onPopState = t22(this.onPopState, this);
            }
            return r2.prototype.start = function() {
              return this.started ? void 0 : (addEventListener("popstate", this.onPopState, false), addEventListener("load", this.onPageLoad, false), this.started = true);
            }, r2.prototype.stop = function() {
              return this.started ? (removeEventListener("popstate", this.onPopState, false), removeEventListener("load", this.onPageLoad, false), this.started = false) : void 0;
            }, r2.prototype.push = function(t32, r22) {
              return t32 = e3.Location.wrap(t32), this.update("push", t32, r22);
            }, r2.prototype.replace = function(t32, r22) {
              return t32 = e3.Location.wrap(t32), this.update("replace", t32, r22);
            }, r2.prototype.onPopState = function(t32) {
              var r22, n2, o2, i3;
              return this.shouldHandlePopState() && (i3 = null != (n2 = t32.state) ? n2.turbolinks : void 0) ? (r22 = e3.Location.wrap(window.location), o2 = i3.restorationIdentifier, this.delegate.historyPoppedToLocationWithRestorationIdentifier(r22, o2)) : void 0;
            }, r2.prototype.onPageLoad = function(t32) {
              return e3.defer(function(t4) {
                return function() {
                  return t4.pageLoaded = true;
                };
              }(this));
            }, r2.prototype.shouldHandlePopState = function() {
              return this.pageIsLoaded();
            }, r2.prototype.pageIsLoaded = function() {
              return this.pageLoaded || "complete" === document.readyState;
            }, r2.prototype.update = function(t32, e22, r22) {
              var n2;
              return n2 = { turbolinks: { restorationIdentifier: r22 } }, history[t32 + "State"](n2, null, e22);
            }, r2;
          }();
        }.call(this), function() {
          e3.HeadDetails = function() {
            function t22(t32) {
              var e32, r22, n22, s4, a4, u3;
              for (this.elements = {}, n22 = 0, a4 = t32.length; a4 > n22; n22++)
                u3 = t32[n22], u3.nodeType === Node.ELEMENT_NODE && (s4 = u3.outerHTML, r22 = null != (e32 = this.elements)[s4] ? e32[s4] : e32[s4] = { type: i3(u3), tracked: o2(u3), elements: [] }, r22.elements.push(u3));
            }
            var e22, r2, n2, o2, i3;
            return t22.fromHeadElement = function(t32) {
              var e32;
              return new this(null != (e32 = null != t32 ? t32.childNodes : void 0) ? e32 : []);
            }, t22.prototype.hasElementWithKey = function(t32) {
              return t32 in this.elements;
            }, t22.prototype.getTrackedElementSignature = function() {
              var t32, e32;
              return function() {
                var r22, n22;
                r22 = this.elements, n22 = [];
                for (t32 in r22)
                  e32 = r22[t32].tracked, e32 && n22.push(t32);
                return n22;
              }.call(this).join("");
            }, t22.prototype.getScriptElementsNotInDetails = function(t32) {
              return this.getElementsMatchingTypeNotInDetails("script", t32);
            }, t22.prototype.getStylesheetElementsNotInDetails = function(t32) {
              return this.getElementsMatchingTypeNotInDetails("stylesheet", t32);
            }, t22.prototype.getElementsMatchingTypeNotInDetails = function(t32, e32) {
              var r22, n22, o22, i22, s4, a4;
              o22 = this.elements, s4 = [];
              for (n22 in o22)
                i22 = o22[n22], a4 = i22.type, r22 = i22.elements, a4 !== t32 || e32.hasElementWithKey(n22) || s4.push(r22[0]);
              return s4;
            }, t22.prototype.getProvisionalElements = function() {
              var t32, e32, r22, n22, o22, i22, s4;
              r22 = [], n22 = this.elements;
              for (e32 in n22)
                o22 = n22[e32], s4 = o22.type, i22 = o22.tracked, t32 = o22.elements, null != s4 || i22 ? t32.length > 1 && r22.push.apply(r22, t32.slice(1)) : r22.push.apply(r22, t32);
              return r22;
            }, t22.prototype.getMetaValue = function(t32) {
              var e32;
              return null != (e32 = this.findMetaElementByName(t32)) ? e32.getAttribute("content") : void 0;
            }, t22.prototype.findMetaElementByName = function(t32) {
              var r22, n22, o22, i22;
              r22 = void 0, i22 = this.elements;
              for (o22 in i22)
                n22 = i22[o22].elements, e22(n22[0], t32) && (r22 = n22[0]);
              return r22;
            }, i3 = function(t32) {
              return r2(t32) ? "script" : n2(t32) ? "stylesheet" : void 0;
            }, o2 = function(t32) {
              return "reload" === t32.getAttribute("data-turbolinks-track");
            }, r2 = function(t32) {
              var e32;
              return e32 = t32.tagName.toLowerCase(), "script" === e32;
            }, n2 = function(t32) {
              var e32;
              return e32 = t32.tagName.toLowerCase(), "style" === e32 || "link" === e32 && "stylesheet" === t32.getAttribute("rel");
            }, e22 = function(t32, e32) {
              var r22;
              return r22 = t32.tagName.toLowerCase(), "meta" === r22 && t32.getAttribute("name") === e32;
            }, t22;
          }();
        }.call(this), function() {
          e3.Snapshot = function() {
            function t22(t32, e22) {
              this.headDetails = t32, this.bodyElement = e22;
            }
            return t22.wrap = function(t32) {
              return t32 instanceof this ? t32 : "string" == typeof t32 ? this.fromHTMLString(t32) : this.fromHTMLElement(t32);
            }, t22.fromHTMLString = function(t32) {
              var e22;
              return e22 = document.createElement("html"), e22.innerHTML = t32, this.fromHTMLElement(e22);
            }, t22.fromHTMLElement = function(t32) {
              var r2, n2, o2, i3;
              return o2 = t32.querySelector("head"), r2 = null != (i3 = t32.querySelector("body")) ? i3 : document.createElement("body"), n2 = e3.HeadDetails.fromHeadElement(o2), new this(n2, r2);
            }, t22.prototype.clone = function() {
              return new this.constructor(this.headDetails, this.bodyElement.cloneNode(true));
            }, t22.prototype.getRootLocation = function() {
              var t32, r2;
              return r2 = null != (t32 = this.getSetting("root")) ? t32 : "/", new e3.Location(r2);
            }, t22.prototype.getCacheControlValue = function() {
              return this.getSetting("cache-control");
            }, t22.prototype.getElementForAnchor = function(t32) {
              try {
                return this.bodyElement.querySelector("[id='" + t32 + "'], a[name='" + t32 + "']");
              } catch (e22) {
              }
            }, t22.prototype.getPermanentElements = function() {
              return this.bodyElement.querySelectorAll("[id][data-turbolinks-permanent]");
            }, t22.prototype.getPermanentElementById = function(t32) {
              return this.bodyElement.querySelector("#" + t32 + "[data-turbolinks-permanent]");
            }, t22.prototype.getPermanentElementsPresentInSnapshot = function(t32) {
              var e22, r2, n2, o2, i3;
              for (o2 = this.getPermanentElements(), i3 = [], r2 = 0, n2 = o2.length; n2 > r2; r2++)
                e22 = o2[r2], t32.getPermanentElementById(e22.id) && i3.push(e22);
              return i3;
            }, t22.prototype.findFirstAutofocusableElement = function() {
              return this.bodyElement.querySelector("[autofocus]");
            }, t22.prototype.hasAnchor = function(t32) {
              return null != this.getElementForAnchor(t32);
            }, t22.prototype.isPreviewable = function() {
              return "no-preview" !== this.getCacheControlValue();
            }, t22.prototype.isCacheable = function() {
              return "no-cache" !== this.getCacheControlValue();
            }, t22.prototype.isVisitable = function() {
              return "reload" !== this.getSetting("visit-control");
            }, t22.prototype.getSetting = function(t32) {
              return this.headDetails.getMetaValue("turbolinks-" + t32);
            }, t22;
          }();
        }.call(this), function() {
          var t22 = [].slice;
          e3.Renderer = function() {
            function e22() {
            }
            var r2;
            return e22.render = function() {
              var e32, r22, n2, o2;
              return n2 = arguments[0], r22 = arguments[1], e32 = 3 <= arguments.length ? t22.call(arguments, 2) : [], o2 = function(t32, e4, r3) {
                r3.prototype = t32.prototype;
                var n22 = new r3(), o22 = t32.apply(n22, e4);
                return Object(o22) === o22 ? o22 : n22;
              }(this, e32, function() {
              }), o2.delegate = n2, o2.render(r22), o2;
            }, e22.prototype.renderView = function(t32) {
              return this.delegate.viewWillRender(this.newBody), t32(), this.delegate.viewRendered(this.newBody);
            }, e22.prototype.invalidateView = function() {
              return this.delegate.viewInvalidated();
            }, e22.prototype.createScriptElement = function(t32) {
              var e32;
              return "false" === t32.getAttribute("data-turbolinks-eval") ? t32 : (e32 = document.createElement("script"), e32.textContent = t32.textContent, e32.async = false, r2(e32, t32), e32);
            }, r2 = function(t32, e32) {
              var r22, n2, o2, i3, s4, a4, u3;
              for (i3 = e32.attributes, a4 = [], r22 = 0, n2 = i3.length; n2 > r22; r22++)
                s4 = i3[r22], o2 = s4.name, u3 = s4.value, a4.push(t32.setAttribute(o2, u3));
              return a4;
            }, e22;
          }();
        }.call(this), function() {
          var t22, r2, n2 = function(t32, e22) {
            function r22() {
              this.constructor = t32;
            }
            for (var n22 in e22)
              o2.call(e22, n22) && (t32[n22] = e22[n22]);
            return r22.prototype = e22.prototype, t32.prototype = new r22(), t32.__super__ = e22.prototype, t32;
          }, o2 = {}.hasOwnProperty;
          e3.SnapshotRenderer = function(e22) {
            function o22(t32, e32, r22) {
              this.currentSnapshot = t32, this.newSnapshot = e32, this.isPreview = r22, this.currentHeadDetails = this.currentSnapshot.headDetails, this.newHeadDetails = this.newSnapshot.headDetails, this.currentBody = this.currentSnapshot.bodyElement, this.newBody = this.newSnapshot.bodyElement;
            }
            return n2(o22, e22), o22.prototype.render = function(t32) {
              return this.shouldRender() ? (this.mergeHead(), this.renderView(function(e32) {
                return function() {
                  return e32.replaceBody(), e32.isPreview || e32.focusFirstAutofocusableElement(), t32();
                };
              }(this))) : this.invalidateView();
            }, o22.prototype.mergeHead = function() {
              return this.copyNewHeadStylesheetElements(), this.copyNewHeadScriptElements(), this.removeCurrentHeadProvisionalElements(), this.copyNewHeadProvisionalElements();
            }, o22.prototype.replaceBody = function() {
              var t32;
              return t32 = this.relocateCurrentBodyPermanentElements(), this.activateNewBodyScriptElements(), this.assignNewBody(), this.replacePlaceholderElementsWithClonedPermanentElements(t32);
            }, o22.prototype.shouldRender = function() {
              return this.newSnapshot.isVisitable() && this.trackedElementsAreIdentical();
            }, o22.prototype.trackedElementsAreIdentical = function() {
              return this.currentHeadDetails.getTrackedElementSignature() === this.newHeadDetails.getTrackedElementSignature();
            }, o22.prototype.copyNewHeadStylesheetElements = function() {
              var t32, e32, r22, n22, o3;
              for (n22 = this.getNewHeadStylesheetElements(), o3 = [], e32 = 0, r22 = n22.length; r22 > e32; e32++)
                t32 = n22[e32], o3.push(document.head.appendChild(t32));
              return o3;
            }, o22.prototype.copyNewHeadScriptElements = function() {
              var t32, e32, r22, n22, o3;
              for (n22 = this.getNewHeadScriptElements(), o3 = [], e32 = 0, r22 = n22.length; r22 > e32; e32++)
                t32 = n22[e32], o3.push(document.head.appendChild(this.createScriptElement(t32)));
              return o3;
            }, o22.prototype.removeCurrentHeadProvisionalElements = function() {
              var t32, e32, r22, n22, o3;
              for (n22 = this.getCurrentHeadProvisionalElements(), o3 = [], e32 = 0, r22 = n22.length; r22 > e32; e32++)
                t32 = n22[e32], o3.push(document.head.removeChild(t32));
              return o3;
            }, o22.prototype.copyNewHeadProvisionalElements = function() {
              var t32, e32, r22, n22, o3;
              for (n22 = this.getNewHeadProvisionalElements(), o3 = [], e32 = 0, r22 = n22.length; r22 > e32; e32++)
                t32 = n22[e32], o3.push(document.head.appendChild(t32));
              return o3;
            }, o22.prototype.relocateCurrentBodyPermanentElements = function() {
              var e32, n22, o3, i3, s4, a4, u3;
              for (a4 = this.getCurrentBodyPermanentElements(), u3 = [], e32 = 0, n22 = a4.length; n22 > e32; e32++)
                i3 = a4[e32], s4 = t22(i3), o3 = this.newSnapshot.getPermanentElementById(i3.id), r2(i3, s4.element), r2(o3, i3), u3.push(s4);
              return u3;
            }, o22.prototype.replacePlaceholderElementsWithClonedPermanentElements = function(t32) {
              var e32, n22, o3, i3, s4, a4, u3;
              for (u3 = [], o3 = 0, i3 = t32.length; i3 > o3; o3++)
                a4 = t32[o3], n22 = a4.element, s4 = a4.permanentElement, e32 = s4.cloneNode(true), u3.push(r2(n22, e32));
              return u3;
            }, o22.prototype.activateNewBodyScriptElements = function() {
              var t32, e32, n22, o3, i3, s4;
              for (i3 = this.getNewBodyScriptElements(), s4 = [], e32 = 0, o3 = i3.length; o3 > e32; e32++)
                n22 = i3[e32], t32 = this.createScriptElement(n22), s4.push(r2(n22, t32));
              return s4;
            }, o22.prototype.assignNewBody = function() {
              return document.body = this.newBody;
            }, o22.prototype.focusFirstAutofocusableElement = function() {
              var t32;
              return null != (t32 = this.newSnapshot.findFirstAutofocusableElement()) ? t32.focus() : void 0;
            }, o22.prototype.getNewHeadStylesheetElements = function() {
              return this.newHeadDetails.getStylesheetElementsNotInDetails(this.currentHeadDetails);
            }, o22.prototype.getNewHeadScriptElements = function() {
              return this.newHeadDetails.getScriptElementsNotInDetails(this.currentHeadDetails);
            }, o22.prototype.getCurrentHeadProvisionalElements = function() {
              return this.currentHeadDetails.getProvisionalElements();
            }, o22.prototype.getNewHeadProvisionalElements = function() {
              return this.newHeadDetails.getProvisionalElements();
            }, o22.prototype.getCurrentBodyPermanentElements = function() {
              return this.currentSnapshot.getPermanentElementsPresentInSnapshot(this.newSnapshot);
            }, o22.prototype.getNewBodyScriptElements = function() {
              return this.newBody.querySelectorAll("script");
            }, o22;
          }(e3.Renderer), t22 = function(t32) {
            var e22;
            return e22 = document.createElement("meta"), e22.setAttribute("name", "turbolinks-permanent-placeholder"), e22.setAttribute("content", t32.id), { element: e22, permanentElement: t32 };
          }, r2 = function(t32, e22) {
            var r22;
            return (r22 = t32.parentNode) ? r22.replaceChild(e22, t32) : void 0;
          };
        }.call(this), function() {
          var t22 = function(t32, e22) {
            function n2() {
              this.constructor = t32;
            }
            for (var o2 in e22)
              r2.call(e22, o2) && (t32[o2] = e22[o2]);
            return n2.prototype = e22.prototype, t32.prototype = new n2(), t32.__super__ = e22.prototype, t32;
          }, r2 = {}.hasOwnProperty;
          e3.ErrorRenderer = function(e22) {
            function r22(t32) {
              var e32;
              e32 = document.createElement("html"), e32.innerHTML = t32, this.newHead = e32.querySelector("head"), this.newBody = e32.querySelector("body");
            }
            return t22(r22, e22), r22.prototype.render = function(t32) {
              return this.renderView(function(e32) {
                return function() {
                  return e32.replaceHeadAndBody(), e32.activateBodyScriptElements(), t32();
                };
              }(this));
            }, r22.prototype.replaceHeadAndBody = function() {
              var t32, e32;
              return e32 = document.head, t32 = document.body, e32.parentNode.replaceChild(this.newHead, e32), t32.parentNode.replaceChild(this.newBody, t32);
            }, r22.prototype.activateBodyScriptElements = function() {
              var t32, e32, r3, n2, o2, i3;
              for (n2 = this.getScriptElements(), i3 = [], e32 = 0, r3 = n2.length; r3 > e32; e32++)
                o2 = n2[e32], t32 = this.createScriptElement(o2), i3.push(o2.parentNode.replaceChild(t32, o2));
              return i3;
            }, r22.prototype.getScriptElements = function() {
              return document.documentElement.querySelectorAll("script");
            }, r22;
          }(e3.Renderer);
        }.call(this), function() {
          e3.View = function() {
            function t22(t32) {
              this.delegate = t32, this.htmlElement = document.documentElement;
            }
            return t22.prototype.getRootLocation = function() {
              return this.getSnapshot().getRootLocation();
            }, t22.prototype.getElementForAnchor = function(t32) {
              return this.getSnapshot().getElementForAnchor(t32);
            }, t22.prototype.getSnapshot = function() {
              return e3.Snapshot.fromHTMLElement(this.htmlElement);
            }, t22.prototype.render = function(t32, e22) {
              var r2, n2, o2;
              return o2 = t32.snapshot, r2 = t32.error, n2 = t32.isPreview, this.markAsPreview(n2), null != o2 ? this.renderSnapshot(o2, n2, e22) : this.renderError(r2, e22);
            }, t22.prototype.markAsPreview = function(t32) {
              return t32 ? this.htmlElement.setAttribute("data-turbolinks-preview", "") : this.htmlElement.removeAttribute("data-turbolinks-preview");
            }, t22.prototype.renderSnapshot = function(t32, r2, n2) {
              return e3.SnapshotRenderer.render(this.delegate, n2, this.getSnapshot(), e3.Snapshot.wrap(t32), r2);
            }, t22.prototype.renderError = function(t32, r2) {
              return e3.ErrorRenderer.render(this.delegate, r2, t32);
            }, t22;
          }();
        }.call(this), function() {
          var t22 = function(t32, e22) {
            return function() {
              return t32.apply(e22, arguments);
            };
          };
          e3.ScrollManager = function() {
            function r2(r22) {
              this.delegate = r22, this.onScroll = t22(this.onScroll, this), this.onScroll = e3.throttle(this.onScroll);
            }
            return r2.prototype.start = function() {
              return this.started ? void 0 : (addEventListener("scroll", this.onScroll, false), this.onScroll(), this.started = true);
            }, r2.prototype.stop = function() {
              return this.started ? (removeEventListener("scroll", this.onScroll, false), this.started = false) : void 0;
            }, r2.prototype.scrollToElement = function(t32) {
              return t32.scrollIntoView();
            }, r2.prototype.scrollToPosition = function(t32) {
              var e22, r22;
              return e22 = t32.x, r22 = t32.y, window.scrollTo(e22, r22);
            }, r2.prototype.onScroll = function(t32) {
              return this.updatePosition({ x: window.pageXOffset, y: window.pageYOffset });
            }, r2.prototype.updatePosition = function(t32) {
              var e22;
              return this.position = t32, null != (e22 = this.delegate) ? e22.scrollPositionChanged(this.position) : void 0;
            }, r2;
          }();
        }.call(this), function() {
          e3.SnapshotCache = function() {
            function t22(t32) {
              this.size = t32, this.keys = [], this.snapshots = {};
            }
            var r2;
            return t22.prototype.has = function(t32) {
              var e22;
              return e22 = r2(t32), e22 in this.snapshots;
            }, t22.prototype.get = function(t32) {
              var e22;
              if (this.has(t32))
                return e22 = this.read(t32), this.touch(t32), e22;
            }, t22.prototype.put = function(t32, e22) {
              return this.write(t32, e22), this.touch(t32), e22;
            }, t22.prototype.read = function(t32) {
              var e22;
              return e22 = r2(t32), this.snapshots[e22];
            }, t22.prototype.write = function(t32, e22) {
              var n2;
              return n2 = r2(t32), this.snapshots[n2] = e22;
            }, t22.prototype.touch = function(t32) {
              var e22, n2;
              return n2 = r2(t32), e22 = this.keys.indexOf(n2), e22 > -1 && this.keys.splice(e22, 1), this.keys.unshift(n2), this.trim();
            }, t22.prototype.trim = function() {
              var t32, e22, r22, n2, o2;
              for (n2 = this.keys.splice(this.size), o2 = [], t32 = 0, r22 = n2.length; r22 > t32; t32++)
                e22 = n2[t32], o2.push(delete this.snapshots[e22]);
              return o2;
            }, r2 = function(t32) {
              return e3.Location.wrap(t32).toCacheKey();
            }, t22;
          }();
        }.call(this), function() {
          var t22 = function(t32, e22) {
            return function() {
              return t32.apply(e22, arguments);
            };
          };
          e3.Visit = function() {
            function r2(r22, n22, o2) {
              this.controller = r22, this.action = o2, this.performScroll = t22(this.performScroll, this), this.identifier = e3.uuid(), this.location = e3.Location.wrap(n22), this.adapter = this.controller.adapter, this.state = "initialized", this.timingMetrics = {};
            }
            var n2;
            return r2.prototype.start = function() {
              return "initialized" === this.state ? (this.recordTimingMetric("visitStart"), this.state = "started", this.adapter.visitStarted(this)) : void 0;
            }, r2.prototype.cancel = function() {
              var t32;
              return "started" === this.state ? (null != (t32 = this.request) && t32.cancel(), this.cancelRender(), this.state = "canceled") : void 0;
            }, r2.prototype.complete = function() {
              var t32;
              return "started" === this.state ? (this.recordTimingMetric("visitEnd"), this.state = "completed", "function" == typeof (t32 = this.adapter).visitCompleted && t32.visitCompleted(this), this.controller.visitCompleted(this)) : void 0;
            }, r2.prototype.fail = function() {
              var t32;
              return "started" === this.state ? (this.state = "failed", "function" == typeof (t32 = this.adapter).visitFailed ? t32.visitFailed(this) : void 0) : void 0;
            }, r2.prototype.changeHistory = function() {
              var t32, e22;
              return this.historyChanged ? void 0 : (t32 = this.location.isEqualTo(this.referrer) ? "replace" : this.action, e22 = n2(t32), this.controller[e22](this.location, this.restorationIdentifier), this.historyChanged = true);
            }, r2.prototype.issueRequest = function() {
              return this.shouldIssueRequest() && null == this.request ? (this.progress = 0, this.request = new e3.HttpRequest(this, this.location, this.referrer), this.request.send()) : void 0;
            }, r2.prototype.getCachedSnapshot = function() {
              var t32;
              return !(t32 = this.controller.getCachedSnapshotForLocation(this.location)) || null != this.location.anchor && !t32.hasAnchor(this.location.anchor) || "restore" !== this.action && !t32.isPreviewable() ? void 0 : t32;
            }, r2.prototype.hasCachedSnapshot = function() {
              return null != this.getCachedSnapshot();
            }, r2.prototype.loadCachedSnapshot = function() {
              var t32, e22;
              return (e22 = this.getCachedSnapshot()) ? (t32 = this.shouldIssueRequest(), this.render(function() {
                var r22;
                return this.cacheSnapshot(), this.controller.render({ snapshot: e22, isPreview: t32 }, this.performScroll), "function" == typeof (r22 = this.adapter).visitRendered && r22.visitRendered(this), t32 ? void 0 : this.complete();
              })) : void 0;
            }, r2.prototype.loadResponse = function() {
              return null != this.response ? this.render(function() {
                var t32, e22;
                return this.cacheSnapshot(), this.request.failed ? (this.controller.render({ error: this.response }, this.performScroll), "function" == typeof (t32 = this.adapter).visitRendered && t32.visitRendered(this), this.fail()) : (this.controller.render({ snapshot: this.response }, this.performScroll), "function" == typeof (e22 = this.adapter).visitRendered && e22.visitRendered(this), this.complete());
              }) : void 0;
            }, r2.prototype.followRedirect = function() {
              return this.redirectedToLocation && !this.followedRedirect ? (this.location = this.redirectedToLocation, this.controller.replaceHistoryWithLocationAndRestorationIdentifier(this.redirectedToLocation, this.restorationIdentifier), this.followedRedirect = true) : void 0;
            }, r2.prototype.requestStarted = function() {
              var t32;
              return this.recordTimingMetric("requestStart"), "function" == typeof (t32 = this.adapter).visitRequestStarted ? t32.visitRequestStarted(this) : void 0;
            }, r2.prototype.requestProgressed = function(t32) {
              var e22;
              return this.progress = t32, "function" == typeof (e22 = this.adapter).visitRequestProgressed ? e22.visitRequestProgressed(this) : void 0;
            }, r2.prototype.requestCompletedWithResponse = function(t32, r22) {
              return this.response = t32, null != r22 && (this.redirectedToLocation = e3.Location.wrap(r22)), this.adapter.visitRequestCompleted(this);
            }, r2.prototype.requestFailedWithStatusCode = function(t32, e22) {
              return this.response = e22, this.adapter.visitRequestFailedWithStatusCode(this, t32);
            }, r2.prototype.requestFinished = function() {
              var t32;
              return this.recordTimingMetric("requestEnd"), "function" == typeof (t32 = this.adapter).visitRequestFinished ? t32.visitRequestFinished(this) : void 0;
            }, r2.prototype.performScroll = function() {
              return this.scrolled ? void 0 : ("restore" === this.action ? this.scrollToRestoredPosition() || this.scrollToTop() : this.scrollToAnchor() || this.scrollToTop(), this.scrolled = true);
            }, r2.prototype.scrollToRestoredPosition = function() {
              var t32, e22;
              return t32 = null != (e22 = this.restorationData) ? e22.scrollPosition : void 0, null != t32 ? (this.controller.scrollToPosition(t32), true) : void 0;
            }, r2.prototype.scrollToAnchor = function() {
              return null != this.location.anchor ? (this.controller.scrollToAnchor(this.location.anchor), true) : void 0;
            }, r2.prototype.scrollToTop = function() {
              return this.controller.scrollToPosition({ x: 0, y: 0 });
            }, r2.prototype.recordTimingMetric = function(t32) {
              var e22;
              return null != (e22 = this.timingMetrics)[t32] ? e22[t32] : e22[t32] = new Date().getTime();
            }, r2.prototype.getTimingMetrics = function() {
              return e3.copyObject(this.timingMetrics);
            }, n2 = function(t32) {
              switch (t32) {
                case "replace":
                  return "replaceHistoryWithLocationAndRestorationIdentifier";
                case "advance":
                case "restore":
                  return "pushHistoryWithLocationAndRestorationIdentifier";
              }
            }, r2.prototype.shouldIssueRequest = function() {
              return "restore" === this.action ? !this.hasCachedSnapshot() : true;
            }, r2.prototype.cacheSnapshot = function() {
              return this.snapshotCached ? void 0 : (this.controller.cacheSnapshot(), this.snapshotCached = true);
            }, r2.prototype.render = function(t32) {
              return this.cancelRender(), this.frame = requestAnimationFrame(function(e22) {
                return function() {
                  return e22.frame = null, t32.call(e22);
                };
              }(this));
            }, r2.prototype.cancelRender = function() {
              return this.frame ? cancelAnimationFrame(this.frame) : void 0;
            }, r2;
          }();
        }.call(this), function() {
          var t22 = function(t32, e22) {
            return function() {
              return t32.apply(e22, arguments);
            };
          };
          e3.Controller = function() {
            function r2() {
              this.clickBubbled = t22(this.clickBubbled, this), this.clickCaptured = t22(this.clickCaptured, this), this.pageLoaded = t22(this.pageLoaded, this), this.history = new e3.History(this), this.view = new e3.View(this), this.scrollManager = new e3.ScrollManager(this), this.restorationData = {}, this.clearCache(), this.setProgressBarDelay(500);
            }
            return r2.prototype.start = function() {
              return e3.supported && !this.started ? (addEventListener("click", this.clickCaptured, true), addEventListener("DOMContentLoaded", this.pageLoaded, false), this.scrollManager.start(), this.startHistory(), this.started = true, this.enabled = true) : void 0;
            }, r2.prototype.disable = function() {
              return this.enabled = false;
            }, r2.prototype.stop = function() {
              return this.started ? (removeEventListener("click", this.clickCaptured, true), removeEventListener("DOMContentLoaded", this.pageLoaded, false), this.scrollManager.stop(), this.stopHistory(), this.started = false) : void 0;
            }, r2.prototype.clearCache = function() {
              return this.cache = new e3.SnapshotCache(10);
            }, r2.prototype.visit = function(t32, r22) {
              var n2, o2;
              return null == r22 && (r22 = {}), t32 = e3.Location.wrap(t32), this.applicationAllowsVisitingLocation(t32) ? this.locationIsVisitable(t32) ? (n2 = null != (o2 = r22.action) ? o2 : "advance", this.adapter.visitProposedToLocationWithAction(t32, n2)) : window.location = t32 : void 0;
            }, r2.prototype.startVisitToLocationWithAction = function(t32, r22, n2) {
              var o2;
              return e3.supported ? (o2 = this.getRestorationDataForIdentifier(n2), this.startVisit(t32, r22, { restorationData: o2 })) : window.location = t32;
            }, r2.prototype.setProgressBarDelay = function(t32) {
              return this.progressBarDelay = t32;
            }, r2.prototype.startHistory = function() {
              return this.location = e3.Location.wrap(window.location), this.restorationIdentifier = e3.uuid(), this.history.start(), this.history.replace(this.location, this.restorationIdentifier);
            }, r2.prototype.stopHistory = function() {
              return this.history.stop();
            }, r2.prototype.pushHistoryWithLocationAndRestorationIdentifier = function(t32, r22) {
              return this.restorationIdentifier = r22, this.location = e3.Location.wrap(t32), this.history.push(this.location, this.restorationIdentifier);
            }, r2.prototype.replaceHistoryWithLocationAndRestorationIdentifier = function(t32, r22) {
              return this.restorationIdentifier = r22, this.location = e3.Location.wrap(t32), this.history.replace(this.location, this.restorationIdentifier);
            }, r2.prototype.historyPoppedToLocationWithRestorationIdentifier = function(t32, r22) {
              var n2;
              return this.restorationIdentifier = r22, this.enabled ? (n2 = this.getRestorationDataForIdentifier(this.restorationIdentifier), this.startVisit(t32, "restore", { restorationIdentifier: this.restorationIdentifier, restorationData: n2, historyChanged: true }), this.location = e3.Location.wrap(t32)) : this.adapter.pageInvalidated();
            }, r2.prototype.getCachedSnapshotForLocation = function(t32) {
              var e22;
              return null != (e22 = this.cache.get(t32)) ? e22.clone() : void 0;
            }, r2.prototype.shouldCacheSnapshot = function() {
              return this.view.getSnapshot().isCacheable();
            }, r2.prototype.cacheSnapshot = function() {
              var t32, r22;
              return this.shouldCacheSnapshot() ? (this.notifyApplicationBeforeCachingSnapshot(), r22 = this.view.getSnapshot(), t32 = this.lastRenderedLocation, e3.defer(function(e22) {
                return function() {
                  return e22.cache.put(t32, r22.clone());
                };
              }(this))) : void 0;
            }, r2.prototype.scrollToAnchor = function(t32) {
              var e22;
              return (e22 = this.view.getElementForAnchor(t32)) ? this.scrollToElement(e22) : this.scrollToPosition({ x: 0, y: 0 });
            }, r2.prototype.scrollToElement = function(t32) {
              return this.scrollManager.scrollToElement(t32);
            }, r2.prototype.scrollToPosition = function(t32) {
              return this.scrollManager.scrollToPosition(t32);
            }, r2.prototype.scrollPositionChanged = function(t32) {
              var e22;
              return e22 = this.getCurrentRestorationData(), e22.scrollPosition = t32;
            }, r2.prototype.render = function(t32, e22) {
              return this.view.render(t32, e22);
            }, r2.prototype.viewInvalidated = function() {
              return this.adapter.pageInvalidated();
            }, r2.prototype.viewWillRender = function(t32) {
              return this.notifyApplicationBeforeRender(t32);
            }, r2.prototype.viewRendered = function() {
              return this.lastRenderedLocation = this.currentVisit.location, this.notifyApplicationAfterRender();
            }, r2.prototype.pageLoaded = function() {
              return this.lastRenderedLocation = this.location, this.notifyApplicationAfterPageLoad();
            }, r2.prototype.clickCaptured = function() {
              return removeEventListener("click", this.clickBubbled, false), addEventListener("click", this.clickBubbled, false);
            }, r2.prototype.clickBubbled = function(t32) {
              var e22, r22, n2;
              return this.enabled && this.clickEventIsSignificant(t32) && (r22 = this.getVisitableLinkForNode(t32.target)) && (n2 = this.getVisitableLocationForLink(r22)) && this.applicationAllowsFollowingLinkToLocation(r22, n2) ? (t32.preventDefault(), e22 = this.getActionForLink(r22), this.visit(n2, { action: e22 })) : void 0;
            }, r2.prototype.applicationAllowsFollowingLinkToLocation = function(t32, e22) {
              var r22;
              return r22 = this.notifyApplicationAfterClickingLinkToLocation(t32, e22), !r22.defaultPrevented;
            }, r2.prototype.applicationAllowsVisitingLocation = function(t32) {
              var e22;
              return e22 = this.notifyApplicationBeforeVisitingLocation(t32), !e22.defaultPrevented;
            }, r2.prototype.notifyApplicationAfterClickingLinkToLocation = function(t32, r22) {
              return e3.dispatch("turbolinks:click", { target: t32, data: { url: r22.absoluteURL }, cancelable: true });
            }, r2.prototype.notifyApplicationBeforeVisitingLocation = function(t32) {
              return e3.dispatch("turbolinks:before-visit", { data: { url: t32.absoluteURL }, cancelable: true });
            }, r2.prototype.notifyApplicationAfterVisitingLocation = function(t32) {
              return e3.dispatch("turbolinks:visit", { data: { url: t32.absoluteURL } });
            }, r2.prototype.notifyApplicationBeforeCachingSnapshot = function() {
              return e3.dispatch("turbolinks:before-cache");
            }, r2.prototype.notifyApplicationBeforeRender = function(t32) {
              return e3.dispatch("turbolinks:before-render", { data: { newBody: t32 } });
            }, r2.prototype.notifyApplicationAfterRender = function() {
              return e3.dispatch("turbolinks:render");
            }, r2.prototype.notifyApplicationAfterPageLoad = function(t32) {
              return null == t32 && (t32 = {}), e3.dispatch("turbolinks:load", { data: { url: this.location.absoluteURL, timing: t32 } });
            }, r2.prototype.startVisit = function(t32, e22, r22) {
              var n2;
              return null != (n2 = this.currentVisit) && n2.cancel(), this.currentVisit = this.createVisit(t32, e22, r22), this.currentVisit.start(), this.notifyApplicationAfterVisitingLocation(t32);
            }, r2.prototype.createVisit = function(t32, r22, n2) {
              var o2, i3, s4, a4, u3;
              return i3 = null != n2 ? n2 : {}, a4 = i3.restorationIdentifier, s4 = i3.restorationData, o2 = i3.historyChanged, u3 = new e3.Visit(this, t32, r22), u3.restorationIdentifier = null != a4 ? a4 : e3.uuid(), u3.restorationData = e3.copyObject(s4), u3.historyChanged = o2, u3.referrer = this.location, u3;
            }, r2.prototype.visitCompleted = function(t32) {
              return this.notifyApplicationAfterPageLoad(t32.getTimingMetrics());
            }, r2.prototype.clickEventIsSignificant = function(t32) {
              return !(t32.defaultPrevented || t32.target.isContentEditable || t32.which > 1 || t32.altKey || t32.ctrlKey || t32.metaKey || t32.shiftKey);
            }, r2.prototype.getVisitableLinkForNode = function(t32) {
              return this.nodeIsVisitable(t32) ? e3.closest(t32, "a[href]:not([target]):not([download])") : void 0;
            }, r2.prototype.getVisitableLocationForLink = function(t32) {
              var r22;
              return r22 = new e3.Location(t32.getAttribute("href")), this.locationIsVisitable(r22) ? r22 : void 0;
            }, r2.prototype.getActionForLink = function(t32) {
              var e22;
              return null != (e22 = t32.getAttribute("data-turbolinks-action")) ? e22 : "advance";
            }, r2.prototype.nodeIsVisitable = function(t32) {
              var r22;
              return (r22 = e3.closest(t32, "[data-turbolinks]")) ? "false" !== r22.getAttribute("data-turbolinks") : true;
            }, r2.prototype.locationIsVisitable = function(t32) {
              return t32.isPrefixedBy(this.view.getRootLocation()) && t32.isHTML();
            }, r2.prototype.getCurrentRestorationData = function() {
              return this.getRestorationDataForIdentifier(this.restorationIdentifier);
            }, r2.prototype.getRestorationDataForIdentifier = function(t32) {
              var e22;
              return null != (e22 = this.restorationData)[t32] ? e22[t32] : e22[t32] = {};
            }, r2;
          }();
        }.call(this), function() {
          !function() {
            var t22, e22;
            if ((t22 = e22 = document.currentScript) && !e22.hasAttribute("data-turbolinks-suppress-warning")) {
              for (; t22 = t22.parentNode; )
                if (t22 === document.body)
                  return console.warn("You are loading Turbolinks from a <script> element inside the <body> element. This is probably not what you meant to do!\n\nLoad your application\u2019s JavaScript bundle inside the <head> element instead. <script> elements in <body> are evaluated with each page change.\n\nFor more information, see: https://github.com/turbolinks/turbolinks#working-with-script-elements\n\n\u2014\u2014\nSuppress this warning by adding a `data-turbolinks-suppress-warning` attribute to: %s", e22.outerHTML);
            }
          }();
        }.call(this), function() {
          var t22, r2, n2;
          e3.start = function() {
            return r2() ? (null == e3.controller && (e3.controller = t22()), e3.controller.start()) : void 0;
          }, r2 = function() {
            return null == window.Turbolinks && (window.Turbolinks = e3), n2();
          }, t22 = function() {
            var t32;
            return t32 = new e3.Controller(), t32.adapter = new e3.BrowserAdapter(t32), t32;
          }, n2 = function() {
            return window.Turbolinks === e3;
          }, n2() && e3.start();
        }.call(this);
      }).call(this), "object" == typeof module && module.exports ? module.exports = e3 : "function" == typeof define && define.amd && define(e3);
    }).call(exports);
  }
});
init_react_shim$1();
init_react_shim$1();
init_react_shim$1();
init_react_shim$1();
function index_module_default$1(n2) {
  for (var l2, e3, s4 = arguments, t3 = 1, r2 = "", u3 = "", a4 = [0], c3 = function(n22) {
    1 === t3 && (n22 || (r2 = r2.replace(/^\s*\n\s*|\s*\n\s*$/g, ""))) ? a4.push(n22 ? s4[n22] : r2) : 3 === t3 && (n22 || r2) ? (a4[1] = n22 ? s4[n22] : r2, t3 = 2) : 2 === t3 && "..." === r2 && n22 ? a4[2] = Object.assign(a4[2] || {}, s4[n22]) : 2 === t3 && r2 && !n22 ? (a4[2] = a4[2] || {})[r2] = true : t3 >= 5 && (5 === t3 ? ((a4[2] = a4[2] || {})[e3] = n22 ? r2 ? r2 + s4[n22] : s4[n22] : r2, t3 = 6) : (n22 || r2) && (a4[2][e3] += n22 ? r2 + s4[n22] : r2)), r2 = "";
  }, h4 = 0; h4 < n2.length; h4++) {
    h4 && (1 === t3 && c3(), c3(h4));
    for (var i3 = 0; i3 < n2[h4].length; i3++)
      l2 = n2[h4][i3], 1 === t3 ? "<" === l2 ? (c3(), a4 = [a4, "", null], t3 = 3) : r2 += l2 : 4 === t3 ? "--" === r2 && ">" === l2 ? (t3 = 1, r2 = "") : r2 = l2 + r2[0] : u3 ? l2 === u3 ? u3 = "" : r2 += l2 : '"' === l2 || "'" === l2 ? u3 = l2 : ">" === l2 ? (c3(), t3 = 1) : t3 && ("=" === l2 ? (t3 = 5, e3 = r2, r2 = "") : "/" === l2 && (t3 < 5 || ">" === n2[h4][i3 + 1]) ? (c3(), 3 === t3 && (a4 = a4[0]), t3 = a4, (a4 = a4[0]).push(this.apply(null, t3.slice(1))), t3 = 0) : " " === l2 || "	" === l2 || "\n" === l2 || "\r" === l2 ? (c3(), t3 = 2) : r2 += l2), 3 === t3 && "!--" === r2 && (t3 = 4, a4 = a4[0]);
  }
  return c3(), a4.length > 2 ? a4.slice(1) : a4[1];
}
function createElement$2(tagName, attributes = {}, ...children) {
  if (typeof tagName === "function") {
    return tagName(attributes);
  }
  const svgTags = ["svg", "use", "path", "circle", "g"];
  const e3 = !svgTags.includes(tagName) ? document.createElement(tagName) : document.createElementNS("http://www.w3.org/2000/svg", tagName);
  for (let k3 of Object.keys(attributes || {})) {
    if (typeof k3 === "number") {
      k3 = k3.toString();
    }
    if (typeof attributes[k3] === "function" && k3.startsWith("on")) {
      e3.addEventListener(k3.substr(2).toLowerCase(), attributes[k3]);
    } else if (k3 === "xlink:href") {
      e3.setAttributeNS("http://www.w3.org/1999/xlink", "href", attributes[k3]);
    } else {
      e3.setAttribute(k3, attributes[k3]);
    }
  }
  children = children.reduce((acc, child) => {
    return Array.isArray(child) ? [...acc, ...child] : [...acc, child];
  }, []);
  for (const child of children) {
    if (typeof child === "string") {
      e3.appendChild(document.createTextNode(child));
    } else if (child instanceof HTMLElement || child instanceof SVGElement) {
      e3.appendChild(child);
    } else {
      console.error("Impossible d'ajouter l'\xE9l\xE9ment", child, typeof child);
    }
  }
  return e3;
}
index_module_default$1.bind(createElement$2);
init_react_shim$1();
var uuid$1 = new Date().getTime().toString();
if (localStorage) {
  localStorage.setItem("windowId", uuid$1);
  window.addEventListener("focus", function() {
    localStorage.setItem("windowId", uuid$1);
  });
}
function slideUp(element, duration2 = 500) {
  return new Promise((resolve2) => {
    element.style.height = `${element.offsetHeight}px`;
    element.style.transitionProperty = "height, margin, padding";
    element.style.transitionDuration = `${duration2}ms`;
    element.offsetHeight;
    element.style.overflow = "hidden";
    element.style.height = "0";
    element.style.paddingTop = "0";
    element.style.paddingBottom = "0";
    element.style.marginTop = "0";
    element.style.marginBottom = "0";
    window.setTimeout(() => {
      element.style.display = "none";
      element.style.removeProperty("height");
      element.style.removeProperty("padding-top");
      element.style.removeProperty("padding-bottom");
      element.style.removeProperty("margin-top");
      element.style.removeProperty("margin-bottom");
      element.style.removeProperty("overflow");
      element.style.removeProperty("transition-duration");
      element.style.removeProperty("transition-property");
      resolve2(element);
    }, duration2);
  });
}
init_react_shim$1();
async function jsonFetch(url, params = {}) {
  if (params.body instanceof FormData) {
    params.body = Object.fromEntries(params.body);
  }
  if (params.body && typeof params.body === "object") {
    params.body = JSON.stringify(params.body);
  }
  params = {
    headers: {
      "Content-Type": "application/json",
      Accept: "application/json",
      "X-Requested-With": "XMLHttpRequest"
    },
    ...params
  };
  const response = await fetch(url, params);
  if (response.status === 204) {
    return null;
  }
  const data = await response.json();
  if (response.ok) {
    return data;
  }
  throw new ApiError(data, response.status);
}
var ApiError = class {
  constructor(data, status) {
    __publicField2(this, "data");
    __publicField2(this, "status");
    this.data = data;
    this.status = status;
  }
  violationsFor(field) {
    return this.data.violations.filter((v2) => v2.propertyPath === field).map((v2) => v2.message);
  }
  get name() {
    return `${this.data.title} ${this.data.detail || ""}`;
  }
  get violations() {
    if (!this.data.violations) {
      return {
        main: `${this.data.title} ${this.data.detail || ""}`
      };
    }
    return this.data.violations.reduce(
      (acc, violation) => {
        if (acc[violation.propertyPath]) {
          acc[violation.propertyPath].push(violation.message);
        } else {
          acc[violation.propertyPath] = [violation.message];
        }
        return acc;
      },
      {}
    );
  }
};
init_react_shim$1();
init_react_shim$1();
init_react_shim$1();
function useAutofocus(ref, focus2) {
  react.exports.useEffect(() => {
    if (focus2 && ref.current) {
      const input = ref.current.querySelector("input, textarea");
      if (input) {
        input.focus();
      }
    }
  }, [focus2, ref]);
}
init_react_shim$1();
init_react_shim$1();
init_react_shim$1();
var import_turbolinks = __toESM$1(require_turbolinks$1(), 1);
function redirect(url) {
  return new Promise((resolve2) => {
    const onLoad = function() {
      resolve2(true);
      document.removeEventListener("turbolinks:load", onLoad);
    };
    document.addEventListener("turbolinks:load", onLoad);
    import_turbolinks.default.visit(url);
  });
}
var HOOKS = [
  "onChange",
  "onClose",
  "onDayCreate",
  "onDestroy",
  "onKeyDown",
  "onMonthChange",
  "onOpen",
  "onParseConfig",
  "onReady",
  "onValueUpdate",
  "onYearChange",
  "onPreCalendarPosition"
];
var defaults$3 = {
  _disable: [],
  allowInput: false,
  allowInvalidPreload: false,
  altFormat: "F j, Y",
  altInput: false,
  altInputClass: "form-control input",
  animate: typeof window === "object" && window.navigator.userAgent.indexOf("MSIE") === -1,
  ariaDateFormat: "F j, Y",
  autoFillDefaultTime: true,
  clickOpens: true,
  closeOnSelect: true,
  conjunction: ", ",
  dateFormat: "Y-m-d",
  defaultHour: 12,
  defaultMinute: 0,
  defaultSeconds: 0,
  disable: [],
  disableMobile: false,
  enableSeconds: false,
  enableTime: false,
  errorHandler: function(err) {
    return typeof console !== "undefined" && console.warn(err);
  },
  getWeek: function(givenDate) {
    var date = new Date(givenDate.getTime());
    date.setHours(0, 0, 0, 0);
    date.setDate(date.getDate() + 3 - (date.getDay() + 6) % 7);
    var week1 = new Date(date.getFullYear(), 0, 4);
    return 1 + Math.round(((date.getTime() - week1.getTime()) / 864e5 - 3 + (week1.getDay() + 6) % 7) / 7);
  },
  hourIncrement: 1,
  ignoredFocusElements: [],
  inline: false,
  locale: "default",
  minuteIncrement: 5,
  mode: "single",
  monthSelectorType: "dropdown",
  nextArrow: "<svg version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' viewBox='0 0 17 17'><g></g><path d='M13.207 8.472l-7.854 7.854-0.707-0.707 7.146-7.146-7.146-7.148 0.707-0.707 7.854 7.854z' /></svg>",
  noCalendar: false,
  now: new Date(),
  onChange: [],
  onClose: [],
  onDayCreate: [],
  onDestroy: [],
  onKeyDown: [],
  onMonthChange: [],
  onOpen: [],
  onParseConfig: [],
  onReady: [],
  onValueUpdate: [],
  onYearChange: [],
  onPreCalendarPosition: [],
  plugins: [],
  position: "auto",
  positionElement: void 0,
  prevArrow: "<svg version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' viewBox='0 0 17 17'><g></g><path d='M5.207 8.471l7.146 7.147-0.707 0.707-7.853-7.854 7.854-7.853 0.707 0.707-7.147 7.146z' /></svg>",
  shorthandCurrentMonth: false,
  showMonths: 1,
  static: false,
  time_24hr: false,
  weekNumbers: false,
  wrap: false
};
var english = {
  weekdays: {
    shorthand: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
    longhand: [
      "Sunday",
      "Monday",
      "Tuesday",
      "Wednesday",
      "Thursday",
      "Friday",
      "Saturday"
    ]
  },
  months: {
    shorthand: [
      "Jan",
      "Feb",
      "Mar",
      "Apr",
      "May",
      "Jun",
      "Jul",
      "Aug",
      "Sep",
      "Oct",
      "Nov",
      "Dec"
    ],
    longhand: [
      "January",
      "February",
      "March",
      "April",
      "May",
      "June",
      "July",
      "August",
      "September",
      "October",
      "November",
      "December"
    ]
  },
  daysInMonth: [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31],
  firstDayOfWeek: 0,
  ordinal: function(nth) {
    var s4 = nth % 100;
    if (s4 > 3 && s4 < 21)
      return "th";
    switch (s4 % 10) {
      case 1:
        return "st";
      case 2:
        return "nd";
      case 3:
        return "rd";
      default:
        return "th";
    }
  },
  rangeSeparator: " to ",
  weekAbbreviation: "Wk",
  scrollTitle: "Scroll to increment",
  toggleTitle: "Click to toggle",
  amPM: ["AM", "PM"],
  yearAriaLabel: "Year",
  monthAriaLabel: "Month",
  hourAriaLabel: "Hour",
  minuteAriaLabel: "Minute",
  time_24hr: false
};
var pad = function(number, length2) {
  if (length2 === void 0) {
    length2 = 2;
  }
  return ("000" + number).slice(length2 * -1);
};
var int = function(bool) {
  return bool === true ? 1 : 0;
};
function debounce$2(fn3, wait) {
  var t3;
  return function() {
    var _this = this;
    var args = arguments;
    clearTimeout(t3);
    t3 = setTimeout(function() {
      return fn3.apply(_this, args);
    }, wait);
  };
}
var arrayify = function(obj) {
  return obj instanceof Array ? obj : [obj];
};
function toggleClass$1(elem, className, bool) {
  if (bool === true)
    return elem.classList.add(className);
  elem.classList.remove(className);
}
function createElement$1(tag, className, content) {
  var e3 = window.document.createElement(tag);
  className = className || "";
  content = content || "";
  e3.className = className;
  if (content !== void 0)
    e3.textContent = content;
  return e3;
}
function clearNode(node2) {
  while (node2.firstChild)
    node2.removeChild(node2.firstChild);
}
function findParent(node2, condition) {
  if (condition(node2))
    return node2;
  else if (node2.parentNode)
    return findParent(node2.parentNode, condition);
  return void 0;
}
function createNumberInput(inputClassName, opts) {
  var wrapper = createElement$1("div", "numInputWrapper"), numInput = createElement$1("input", "numInput " + inputClassName), arrowUp = createElement$1("span", "arrowUp"), arrowDown = createElement$1("span", "arrowDown");
  if (navigator.userAgent.indexOf("MSIE 9.0") === -1) {
    numInput.type = "number";
  } else {
    numInput.type = "text";
    numInput.pattern = "\\d*";
  }
  if (opts !== void 0)
    for (var key in opts)
      numInput.setAttribute(key, opts[key]);
  wrapper.appendChild(numInput);
  wrapper.appendChild(arrowUp);
  wrapper.appendChild(arrowDown);
  return wrapper;
}
function getEventTarget(event) {
  try {
    if (typeof event.composedPath === "function") {
      var path = event.composedPath();
      return path[0];
    }
    return event.target;
  } catch (error) {
    return event.target;
  }
}
var doNothing = function() {
  return void 0;
};
var monthToStr = function(monthNumber, shorthand, locale2) {
  return locale2.months[shorthand ? "shorthand" : "longhand"][monthNumber];
};
var revFormat = {
  D: doNothing,
  F: function(dateObj, monthName, locale2) {
    dateObj.setMonth(locale2.months.longhand.indexOf(monthName));
  },
  G: function(dateObj, hour) {
    dateObj.setHours((dateObj.getHours() >= 12 ? 12 : 0) + parseFloat(hour));
  },
  H: function(dateObj, hour) {
    dateObj.setHours(parseFloat(hour));
  },
  J: function(dateObj, day) {
    dateObj.setDate(parseFloat(day));
  },
  K: function(dateObj, amPM, locale2) {
    dateObj.setHours(dateObj.getHours() % 12 + 12 * int(new RegExp(locale2.amPM[1], "i").test(amPM)));
  },
  M: function(dateObj, shortMonth, locale2) {
    dateObj.setMonth(locale2.months.shorthand.indexOf(shortMonth));
  },
  S: function(dateObj, seconds) {
    dateObj.setSeconds(parseFloat(seconds));
  },
  U: function(_2, unixSeconds) {
    return new Date(parseFloat(unixSeconds) * 1e3);
  },
  W: function(dateObj, weekNum, locale2) {
    var weekNumber = parseInt(weekNum);
    var date = new Date(dateObj.getFullYear(), 0, 2 + (weekNumber - 1) * 7, 0, 0, 0, 0);
    date.setDate(date.getDate() - date.getDay() + locale2.firstDayOfWeek);
    return date;
  },
  Y: function(dateObj, year) {
    dateObj.setFullYear(parseFloat(year));
  },
  Z: function(_2, ISODate) {
    return new Date(ISODate);
  },
  d: function(dateObj, day) {
    dateObj.setDate(parseFloat(day));
  },
  h: function(dateObj, hour) {
    dateObj.setHours((dateObj.getHours() >= 12 ? 12 : 0) + parseFloat(hour));
  },
  i: function(dateObj, minutes) {
    dateObj.setMinutes(parseFloat(minutes));
  },
  j: function(dateObj, day) {
    dateObj.setDate(parseFloat(day));
  },
  l: doNothing,
  m: function(dateObj, month) {
    dateObj.setMonth(parseFloat(month) - 1);
  },
  n: function(dateObj, month) {
    dateObj.setMonth(parseFloat(month) - 1);
  },
  s: function(dateObj, seconds) {
    dateObj.setSeconds(parseFloat(seconds));
  },
  u: function(_2, unixMillSeconds) {
    return new Date(parseFloat(unixMillSeconds));
  },
  w: doNothing,
  y: function(dateObj, year) {
    dateObj.setFullYear(2e3 + parseFloat(year));
  }
};
var tokenRegex = {
  D: "",
  F: "",
  G: "(\\d\\d|\\d)",
  H: "(\\d\\d|\\d)",
  J: "(\\d\\d|\\d)\\w+",
  K: "",
  M: "",
  S: "(\\d\\d|\\d)",
  U: "(.+)",
  W: "(\\d\\d|\\d)",
  Y: "(\\d{4})",
  Z: "(.+)",
  d: "(\\d\\d|\\d)",
  h: "(\\d\\d|\\d)",
  i: "(\\d\\d|\\d)",
  j: "(\\d\\d|\\d)",
  l: "",
  m: "(\\d\\d|\\d)",
  n: "(\\d\\d|\\d)",
  s: "(\\d\\d|\\d)",
  u: "(.+)",
  w: "(\\d\\d|\\d)",
  y: "(\\d{2})"
};
var formats = {
  Z: function(date) {
    return date.toISOString();
  },
  D: function(date, locale2, options) {
    return locale2.weekdays.shorthand[formats.w(date, locale2, options)];
  },
  F: function(date, locale2, options) {
    return monthToStr(formats.n(date, locale2, options) - 1, false, locale2);
  },
  G: function(date, locale2, options) {
    return pad(formats.h(date, locale2, options));
  },
  H: function(date) {
    return pad(date.getHours());
  },
  J: function(date, locale2) {
    return locale2.ordinal !== void 0 ? date.getDate() + locale2.ordinal(date.getDate()) : date.getDate();
  },
  K: function(date, locale2) {
    return locale2.amPM[int(date.getHours() > 11)];
  },
  M: function(date, locale2) {
    return monthToStr(date.getMonth(), true, locale2);
  },
  S: function(date) {
    return pad(date.getSeconds());
  },
  U: function(date) {
    return date.getTime() / 1e3;
  },
  W: function(date, _2, options) {
    return options.getWeek(date);
  },
  Y: function(date) {
    return pad(date.getFullYear(), 4);
  },
  d: function(date) {
    return pad(date.getDate());
  },
  h: function(date) {
    return date.getHours() % 12 ? date.getHours() % 12 : 12;
  },
  i: function(date) {
    return pad(date.getMinutes());
  },
  j: function(date) {
    return date.getDate();
  },
  l: function(date, locale2) {
    return locale2.weekdays.longhand[date.getDay()];
  },
  m: function(date) {
    return pad(date.getMonth() + 1);
  },
  n: function(date) {
    return date.getMonth() + 1;
  },
  s: function(date) {
    return date.getSeconds();
  },
  u: function(date) {
    return date.getTime();
  },
  w: function(date) {
    return date.getDay();
  },
  y: function(date) {
    return String(date.getFullYear()).substring(2);
  }
};
var createDateFormatter = function(_a) {
  var _b = _a.config, config = _b === void 0 ? defaults$3 : _b, _c = _a.l10n, l10n = _c === void 0 ? english : _c, _d = _a.isMobile, isMobile = _d === void 0 ? false : _d;
  return function(dateObj, frmt, overrideLocale) {
    var locale2 = overrideLocale || l10n;
    if (config.formatDate !== void 0 && !isMobile) {
      return config.formatDate(dateObj, frmt, locale2);
    }
    return frmt.split("").map(function(c3, i3, arr) {
      return formats[c3] && arr[i3 - 1] !== "\\" ? formats[c3](dateObj, locale2, config) : c3 !== "\\" ? c3 : "";
    }).join("");
  };
};
var createDateParser = function(_a) {
  var _b = _a.config, config = _b === void 0 ? defaults$3 : _b, _c = _a.l10n, l10n = _c === void 0 ? english : _c;
  return function(date, givenFormat, timeless, customLocale) {
    if (date !== 0 && !date)
      return void 0;
    var locale2 = customLocale || l10n;
    var parsedDate;
    var dateOrig = date;
    if (date instanceof Date)
      parsedDate = new Date(date.getTime());
    else if (typeof date !== "string" && date.toFixed !== void 0)
      parsedDate = new Date(date);
    else if (typeof date === "string") {
      var format2 = givenFormat || (config || defaults$3).dateFormat;
      var datestr = String(date).trim();
      if (datestr === "today") {
        parsedDate = new Date();
        timeless = true;
      } else if (config && config.parseDate) {
        parsedDate = config.parseDate(date, format2);
      } else if (/Z$/.test(datestr) || /GMT$/.test(datestr)) {
        parsedDate = new Date(date);
      } else {
        var matched = void 0, ops = [];
        for (var i3 = 0, matchIndex = 0, regexStr = ""; i3 < format2.length; i3++) {
          var token2 = format2[i3];
          var isBackSlash = token2 === "\\";
          var escaped = format2[i3 - 1] === "\\" || isBackSlash;
          if (tokenRegex[token2] && !escaped) {
            regexStr += tokenRegex[token2];
            var match2 = new RegExp(regexStr).exec(date);
            if (match2 && (matched = true)) {
              ops[token2 !== "Y" ? "push" : "unshift"]({
                fn: revFormat[token2],
                val: match2[++matchIndex]
              });
            }
          } else if (!isBackSlash)
            regexStr += ".";
        }
        parsedDate = !config || !config.noCalendar ? new Date(new Date().getFullYear(), 0, 1, 0, 0, 0, 0) : new Date(new Date().setHours(0, 0, 0, 0));
        ops.forEach(function(_a2) {
          var fn3 = _a2.fn, val = _a2.val;
          return parsedDate = fn3(parsedDate, val, locale2) || parsedDate;
        });
        parsedDate = matched ? parsedDate : void 0;
      }
    }
    if (!(parsedDate instanceof Date && !isNaN(parsedDate.getTime()))) {
      config.errorHandler(new Error("Invalid date provided: " + dateOrig));
      return void 0;
    }
    if (timeless === true)
      parsedDate.setHours(0, 0, 0, 0);
    return parsedDate;
  };
};
function compareDates(date1, date2, timeless) {
  if (timeless === void 0) {
    timeless = true;
  }
  if (timeless !== false) {
    return new Date(date1.getTime()).setHours(0, 0, 0, 0) - new Date(date2.getTime()).setHours(0, 0, 0, 0);
  }
  return date1.getTime() - date2.getTime();
}
var isBetween = function(ts, ts1, ts2) {
  return ts > Math.min(ts1, ts2) && ts < Math.max(ts1, ts2);
};
var calculateSecondsSinceMidnight = function(hours, minutes, seconds) {
  return hours * 3600 + minutes * 60 + seconds;
};
var parseSeconds = function(secondsSinceMidnight) {
  var hours = Math.floor(secondsSinceMidnight / 3600), minutes = (secondsSinceMidnight - hours * 3600) / 60;
  return [hours, minutes, secondsSinceMidnight - hours * 3600 - minutes * 60];
};
var duration = {
  DAY: 864e5
};
function getDefaultHours(config) {
  var hours = config.defaultHour;
  var minutes = config.defaultMinute;
  var seconds = config.defaultSeconds;
  if (config.minDate !== void 0) {
    var minHour = config.minDate.getHours();
    var minMinutes = config.minDate.getMinutes();
    var minSeconds = config.minDate.getSeconds();
    if (hours < minHour) {
      hours = minHour;
    }
    if (hours === minHour && minutes < minMinutes) {
      minutes = minMinutes;
    }
    if (hours === minHour && minutes === minMinutes && seconds < minSeconds)
      seconds = config.minDate.getSeconds();
  }
  if (config.maxDate !== void 0) {
    var maxHr = config.maxDate.getHours();
    var maxMinutes = config.maxDate.getMinutes();
    hours = Math.min(hours, maxHr);
    if (hours === maxHr)
      minutes = Math.min(maxMinutes, minutes);
    if (hours === maxHr && minutes === maxMinutes)
      seconds = config.maxDate.getSeconds();
  }
  return { hours, minutes, seconds };
}
if (typeof Object.assign !== "function") {
  Object.assign = function(target) {
    var args = [];
    for (var _i = 1; _i < arguments.length; _i++) {
      args[_i - 1] = arguments[_i];
    }
    if (!target) {
      throw TypeError("Cannot convert undefined or null to object");
    }
    var _loop_1 = function(source2) {
      if (source2) {
        Object.keys(source2).forEach(function(key) {
          return target[key] = source2[key];
        });
      }
    };
    for (var _a = 0, args_1 = args; _a < args_1.length; _a++) {
      var source = args_1[_a];
      _loop_1(source);
    }
    return target;
  };
}
var __assign$1 = globalThis && globalThis.__assign || function() {
  __assign$1 = Object.assign || function(t3) {
    for (var s4, i3 = 1, n2 = arguments.length; i3 < n2; i3++) {
      s4 = arguments[i3];
      for (var p2 in s4)
        if (Object.prototype.hasOwnProperty.call(s4, p2))
          t3[p2] = s4[p2];
    }
    return t3;
  };
  return __assign$1.apply(this, arguments);
};
var __spreadArrays = globalThis && globalThis.__spreadArrays || function() {
  for (var s4 = 0, i3 = 0, il2 = arguments.length; i3 < il2; i3++)
    s4 += arguments[i3].length;
  for (var r2 = Array(s4), k3 = 0, i3 = 0; i3 < il2; i3++)
    for (var a4 = arguments[i3], j2 = 0, jl2 = a4.length; j2 < jl2; j2++, k3++)
      r2[k3] = a4[j2];
  return r2;
};
var DEBOUNCED_CHANGE_MS = 300;
function FlatpickrInstance(element, instanceConfig) {
  var self2 = {
    config: __assign$1(__assign$1({}, defaults$3), flatpickr.defaultConfig),
    l10n: english
  };
  self2.parseDate = createDateParser({ config: self2.config, l10n: self2.l10n });
  self2._handlers = [];
  self2.pluginElements = [];
  self2.loadedPlugins = [];
  self2._bind = bind2;
  self2._setHoursFromDate = setHoursFromDate;
  self2._positionCalendar = positionCalendar;
  self2.changeMonth = changeMonth;
  self2.changeYear = changeYear;
  self2.clear = clear;
  self2.close = close2;
  self2.onMouseOver = onMouseOver;
  self2._createElement = createElement$1;
  self2.createDay = createDay;
  self2.destroy = destroy2;
  self2.isEnabled = isEnabled;
  self2.jumpToDate = jumpToDate;
  self2.updateValue = updateValue;
  self2.open = open;
  self2.redraw = redraw;
  self2.set = set2;
  self2.setDate = setDate;
  self2.toggle = toggle;
  function setupHelperFunctions() {
    self2.utils = {
      getDaysInMonth: function(month, yr) {
        if (month === void 0) {
          month = self2.currentMonth;
        }
        if (yr === void 0) {
          yr = self2.currentYear;
        }
        if (month === 1 && (yr % 4 === 0 && yr % 100 !== 0 || yr % 400 === 0))
          return 29;
        return self2.l10n.daysInMonth[month];
      }
    };
  }
  function init2() {
    self2.element = self2.input = element;
    self2.isOpen = false;
    parseConfig();
    setupLocale();
    setupInputs();
    setupDates();
    setupHelperFunctions();
    if (!self2.isMobile)
      build();
    bindEvents();
    if (self2.selectedDates.length || self2.config.noCalendar) {
      if (self2.config.enableTime) {
        setHoursFromDate(self2.config.noCalendar ? self2.latestSelectedDateObj : void 0);
      }
      updateValue(false);
    }
    setCalendarWidth();
    var isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
    if (!self2.isMobile && isSafari) {
      positionCalendar();
    }
    triggerEvent2("onReady");
  }
  function getClosestActiveElement() {
    var _a;
    return ((_a = self2.calendarContainer) === null || _a === void 0 ? void 0 : _a.getRootNode()).activeElement || document.activeElement;
  }
  function bindToInstance(fn3) {
    return fn3.bind(self2);
  }
  function setCalendarWidth() {
    var config = self2.config;
    if (config.weekNumbers === false && config.showMonths === 1) {
      return;
    } else if (config.noCalendar !== true) {
      window.requestAnimationFrame(function() {
        if (self2.calendarContainer !== void 0) {
          self2.calendarContainer.style.visibility = "hidden";
          self2.calendarContainer.style.display = "block";
        }
        if (self2.daysContainer !== void 0) {
          var daysWidth = (self2.days.offsetWidth + 1) * config.showMonths;
          self2.daysContainer.style.width = daysWidth + "px";
          self2.calendarContainer.style.width = daysWidth + (self2.weekWrapper !== void 0 ? self2.weekWrapper.offsetWidth : 0) + "px";
          self2.calendarContainer.style.removeProperty("visibility");
          self2.calendarContainer.style.removeProperty("display");
        }
      });
    }
  }
  function updateTime(e3) {
    if (self2.selectedDates.length === 0) {
      var defaultDate = self2.config.minDate === void 0 || compareDates(new Date(), self2.config.minDate) >= 0 ? new Date() : new Date(self2.config.minDate.getTime());
      var defaults2 = getDefaultHours(self2.config);
      defaultDate.setHours(defaults2.hours, defaults2.minutes, defaults2.seconds, defaultDate.getMilliseconds());
      self2.selectedDates = [defaultDate];
      self2.latestSelectedDateObj = defaultDate;
    }
    if (e3 !== void 0 && e3.type !== "blur") {
      timeWrapper(e3);
    }
    var prevValue = self2._input.value;
    setHoursFromInputs();
    updateValue();
    if (self2._input.value !== prevValue) {
      self2._debouncedChange();
    }
  }
  function ampm2military(hour, amPM) {
    return hour % 12 + 12 * int(amPM === self2.l10n.amPM[1]);
  }
  function military2ampm(hour) {
    switch (hour % 24) {
      case 0:
      case 12:
        return 12;
      default:
        return hour % 12;
    }
  }
  function setHoursFromInputs() {
    if (self2.hourElement === void 0 || self2.minuteElement === void 0)
      return;
    var hours = (parseInt(self2.hourElement.value.slice(-2), 10) || 0) % 24, minutes = (parseInt(self2.minuteElement.value, 10) || 0) % 60, seconds = self2.secondElement !== void 0 ? (parseInt(self2.secondElement.value, 10) || 0) % 60 : 0;
    if (self2.amPM !== void 0) {
      hours = ampm2military(hours, self2.amPM.textContent);
    }
    var limitMinHours = self2.config.minTime !== void 0 || self2.config.minDate && self2.minDateHasTime && self2.latestSelectedDateObj && compareDates(self2.latestSelectedDateObj, self2.config.minDate, true) === 0;
    var limitMaxHours = self2.config.maxTime !== void 0 || self2.config.maxDate && self2.maxDateHasTime && self2.latestSelectedDateObj && compareDates(self2.latestSelectedDateObj, self2.config.maxDate, true) === 0;
    if (self2.config.maxTime !== void 0 && self2.config.minTime !== void 0 && self2.config.minTime > self2.config.maxTime) {
      var minBound = calculateSecondsSinceMidnight(self2.config.minTime.getHours(), self2.config.minTime.getMinutes(), self2.config.minTime.getSeconds());
      var maxBound = calculateSecondsSinceMidnight(self2.config.maxTime.getHours(), self2.config.maxTime.getMinutes(), self2.config.maxTime.getSeconds());
      var currentTime = calculateSecondsSinceMidnight(hours, minutes, seconds);
      if (currentTime > maxBound && currentTime < minBound) {
        var result = parseSeconds(minBound);
        hours = result[0];
        minutes = result[1];
        seconds = result[2];
      }
    } else {
      if (limitMaxHours) {
        var maxTime = self2.config.maxTime !== void 0 ? self2.config.maxTime : self2.config.maxDate;
        hours = Math.min(hours, maxTime.getHours());
        if (hours === maxTime.getHours())
          minutes = Math.min(minutes, maxTime.getMinutes());
        if (minutes === maxTime.getMinutes())
          seconds = Math.min(seconds, maxTime.getSeconds());
      }
      if (limitMinHours) {
        var minTime = self2.config.minTime !== void 0 ? self2.config.minTime : self2.config.minDate;
        hours = Math.max(hours, minTime.getHours());
        if (hours === minTime.getHours() && minutes < minTime.getMinutes())
          minutes = minTime.getMinutes();
        if (minutes === minTime.getMinutes())
          seconds = Math.max(seconds, minTime.getSeconds());
      }
    }
    setHours2(hours, minutes, seconds);
  }
  function setHoursFromDate(dateObj) {
    var date = dateObj || self2.latestSelectedDateObj;
    if (date && date instanceof Date) {
      setHours2(date.getHours(), date.getMinutes(), date.getSeconds());
    }
  }
  function setHours2(hours, minutes, seconds) {
    if (self2.latestSelectedDateObj !== void 0) {
      self2.latestSelectedDateObj.setHours(hours % 24, minutes, seconds || 0, 0);
    }
    if (!self2.hourElement || !self2.minuteElement || self2.isMobile)
      return;
    self2.hourElement.value = pad(!self2.config.time_24hr ? (12 + hours) % 12 + 12 * int(hours % 12 === 0) : hours);
    self2.minuteElement.value = pad(minutes);
    if (self2.amPM !== void 0)
      self2.amPM.textContent = self2.l10n.amPM[int(hours >= 12)];
    if (self2.secondElement !== void 0)
      self2.secondElement.value = pad(seconds);
  }
  function onYearInput(event) {
    var eventTarget = getEventTarget(event);
    var year = parseInt(eventTarget.value) + (event.delta || 0);
    if (year / 1e3 > 1 || event.key === "Enter" && !/[^\d]/.test(year.toString())) {
      changeYear(year);
    }
  }
  function bind2(element2, event, handler, options) {
    if (event instanceof Array)
      return event.forEach(function(ev) {
        return bind2(element2, ev, handler, options);
      });
    if (element2 instanceof Array)
      return element2.forEach(function(el2) {
        return bind2(el2, event, handler, options);
      });
    element2.addEventListener(event, handler, options);
    self2._handlers.push({
      remove: function() {
        return element2.removeEventListener(event, handler, options);
      }
    });
  }
  function triggerChange() {
    triggerEvent2("onChange");
  }
  function bindEvents() {
    if (self2.config.wrap) {
      ["open", "close", "toggle", "clear"].forEach(function(evt) {
        Array.prototype.forEach.call(self2.element.querySelectorAll("[data-" + evt + "]"), function(el2) {
          return bind2(el2, "click", self2[evt]);
        });
      });
    }
    if (self2.isMobile) {
      setupMobile();
      return;
    }
    var debouncedResize = debounce$2(onResize, 50);
    self2._debouncedChange = debounce$2(triggerChange, DEBOUNCED_CHANGE_MS);
    if (self2.daysContainer && !/iPhone|iPad|iPod/i.test(navigator.userAgent))
      bind2(self2.daysContainer, "mouseover", function(e3) {
        if (self2.config.mode === "range")
          onMouseOver(getEventTarget(e3));
      });
    bind2(self2._input, "keydown", onKeyDown);
    if (self2.calendarContainer !== void 0) {
      bind2(self2.calendarContainer, "keydown", onKeyDown);
    }
    if (!self2.config.inline && !self2.config.static)
      bind2(window, "resize", debouncedResize);
    if (window.ontouchstart !== void 0)
      bind2(window.document, "touchstart", documentClick);
    else
      bind2(window.document, "mousedown", documentClick);
    bind2(window.document, "focus", documentClick, { capture: true });
    if (self2.config.clickOpens === true) {
      bind2(self2._input, "focus", self2.open);
      bind2(self2._input, "click", self2.open);
    }
    if (self2.daysContainer !== void 0) {
      bind2(self2.monthNav, "click", onMonthNavClick);
      bind2(self2.monthNav, ["keyup", "increment"], onYearInput);
      bind2(self2.daysContainer, "click", selectDate);
    }
    if (self2.timeContainer !== void 0 && self2.minuteElement !== void 0 && self2.hourElement !== void 0) {
      var selText = function(e3) {
        return getEventTarget(e3).select();
      };
      bind2(self2.timeContainer, ["increment"], updateTime);
      bind2(self2.timeContainer, "blur", updateTime, { capture: true });
      bind2(self2.timeContainer, "click", timeIncrement);
      bind2([self2.hourElement, self2.minuteElement], ["focus", "click"], selText);
      if (self2.secondElement !== void 0)
        bind2(self2.secondElement, "focus", function() {
          return self2.secondElement && self2.secondElement.select();
        });
      if (self2.amPM !== void 0) {
        bind2(self2.amPM, "click", function(e3) {
          updateTime(e3);
        });
      }
    }
    if (self2.config.allowInput) {
      bind2(self2._input, "blur", onBlur);
    }
  }
  function jumpToDate(jumpDate, triggerChange2) {
    var jumpTo = jumpDate !== void 0 ? self2.parseDate(jumpDate) : self2.latestSelectedDateObj || (self2.config.minDate && self2.config.minDate > self2.now ? self2.config.minDate : self2.config.maxDate && self2.config.maxDate < self2.now ? self2.config.maxDate : self2.now);
    var oldYear = self2.currentYear;
    var oldMonth = self2.currentMonth;
    try {
      if (jumpTo !== void 0) {
        self2.currentYear = jumpTo.getFullYear();
        self2.currentMonth = jumpTo.getMonth();
      }
    } catch (e3) {
      e3.message = "Invalid date supplied: " + jumpTo;
      self2.config.errorHandler(e3);
    }
    if (triggerChange2 && self2.currentYear !== oldYear) {
      triggerEvent2("onYearChange");
      buildMonthSwitch();
    }
    if (triggerChange2 && (self2.currentYear !== oldYear || self2.currentMonth !== oldMonth)) {
      triggerEvent2("onMonthChange");
    }
    self2.redraw();
  }
  function timeIncrement(e3) {
    var eventTarget = getEventTarget(e3);
    if (~eventTarget.className.indexOf("arrow"))
      incrementNumInput(e3, eventTarget.classList.contains("arrowUp") ? 1 : -1);
  }
  function incrementNumInput(e3, delta, inputElem) {
    var target = e3 && getEventTarget(e3);
    var input = inputElem || target && target.parentNode && target.parentNode.firstChild;
    var event = createEvent("increment");
    event.delta = delta;
    input && input.dispatchEvent(event);
  }
  function build() {
    var fragment = window.document.createDocumentFragment();
    self2.calendarContainer = createElement$1("div", "flatpickr-calendar");
    self2.calendarContainer.tabIndex = -1;
    if (!self2.config.noCalendar) {
      fragment.appendChild(buildMonthNav());
      self2.innerContainer = createElement$1("div", "flatpickr-innerContainer");
      if (self2.config.weekNumbers) {
        var _a = buildWeeks(), weekWrapper = _a.weekWrapper, weekNumbers = _a.weekNumbers;
        self2.innerContainer.appendChild(weekWrapper);
        self2.weekNumbers = weekNumbers;
        self2.weekWrapper = weekWrapper;
      }
      self2.rContainer = createElement$1("div", "flatpickr-rContainer");
      self2.rContainer.appendChild(buildWeekdays());
      if (!self2.daysContainer) {
        self2.daysContainer = createElement$1("div", "flatpickr-days");
        self2.daysContainer.tabIndex = -1;
      }
      buildDays();
      self2.rContainer.appendChild(self2.daysContainer);
      self2.innerContainer.appendChild(self2.rContainer);
      fragment.appendChild(self2.innerContainer);
    }
    if (self2.config.enableTime) {
      fragment.appendChild(buildTime());
    }
    toggleClass$1(self2.calendarContainer, "rangeMode", self2.config.mode === "range");
    toggleClass$1(self2.calendarContainer, "animate", self2.config.animate === true);
    toggleClass$1(self2.calendarContainer, "multiMonth", self2.config.showMonths > 1);
    self2.calendarContainer.appendChild(fragment);
    var customAppend = self2.config.appendTo !== void 0 && self2.config.appendTo.nodeType !== void 0;
    if (self2.config.inline || self2.config.static) {
      self2.calendarContainer.classList.add(self2.config.inline ? "inline" : "static");
      if (self2.config.inline) {
        if (!customAppend && self2.element.parentNode)
          self2.element.parentNode.insertBefore(self2.calendarContainer, self2._input.nextSibling);
        else if (self2.config.appendTo !== void 0)
          self2.config.appendTo.appendChild(self2.calendarContainer);
      }
      if (self2.config.static) {
        var wrapper = createElement$1("div", "flatpickr-wrapper");
        if (self2.element.parentNode)
          self2.element.parentNode.insertBefore(wrapper, self2.element);
        wrapper.appendChild(self2.element);
        if (self2.altInput)
          wrapper.appendChild(self2.altInput);
        wrapper.appendChild(self2.calendarContainer);
      }
    }
    if (!self2.config.static && !self2.config.inline)
      (self2.config.appendTo !== void 0 ? self2.config.appendTo : window.document.body).appendChild(self2.calendarContainer);
  }
  function createDay(className, date, _dayNumber, i3) {
    var dateIsEnabled = isEnabled(date, true), dayElement = createElement$1("span", className, date.getDate().toString());
    dayElement.dateObj = date;
    dayElement.$i = i3;
    dayElement.setAttribute("aria-label", self2.formatDate(date, self2.config.ariaDateFormat));
    if (className.indexOf("hidden") === -1 && compareDates(date, self2.now) === 0) {
      self2.todayDateElem = dayElement;
      dayElement.classList.add("today");
      dayElement.setAttribute("aria-current", "date");
    }
    if (dateIsEnabled) {
      dayElement.tabIndex = -1;
      if (isDateSelected(date)) {
        dayElement.classList.add("selected");
        self2.selectedDateElem = dayElement;
        if (self2.config.mode === "range") {
          toggleClass$1(dayElement, "startRange", self2.selectedDates[0] && compareDates(date, self2.selectedDates[0], true) === 0);
          toggleClass$1(dayElement, "endRange", self2.selectedDates[1] && compareDates(date, self2.selectedDates[1], true) === 0);
          if (className === "nextMonthDay")
            dayElement.classList.add("inRange");
        }
      }
    } else {
      dayElement.classList.add("flatpickr-disabled");
    }
    if (self2.config.mode === "range") {
      if (isDateInRange(date) && !isDateSelected(date))
        dayElement.classList.add("inRange");
    }
    if (self2.weekNumbers && self2.config.showMonths === 1 && className !== "prevMonthDay" && i3 % 7 === 6) {
      self2.weekNumbers.insertAdjacentHTML("beforeend", "<span class='flatpickr-day'>" + self2.config.getWeek(date) + "</span>");
    }
    triggerEvent2("onDayCreate", dayElement);
    return dayElement;
  }
  function focusOnDayElem(targetNode) {
    targetNode.focus();
    if (self2.config.mode === "range")
      onMouseOver(targetNode);
  }
  function getFirstAvailableDay(delta) {
    var startMonth = delta > 0 ? 0 : self2.config.showMonths - 1;
    var endMonth = delta > 0 ? self2.config.showMonths : -1;
    for (var m4 = startMonth; m4 != endMonth; m4 += delta) {
      var month = self2.daysContainer.children[m4];
      var startIndex2 = delta > 0 ? 0 : month.children.length - 1;
      var endIndex2 = delta > 0 ? month.children.length : -1;
      for (var i3 = startIndex2; i3 != endIndex2; i3 += delta) {
        var c3 = month.children[i3];
        if (c3.className.indexOf("hidden") === -1 && isEnabled(c3.dateObj))
          return c3;
      }
    }
    return void 0;
  }
  function getNextAvailableDay(current, delta) {
    var givenMonth = current.className.indexOf("Month") === -1 ? current.dateObj.getMonth() : self2.currentMonth;
    var endMonth = delta > 0 ? self2.config.showMonths : -1;
    var loopDelta = delta > 0 ? 1 : -1;
    for (var m4 = givenMonth - self2.currentMonth; m4 != endMonth; m4 += loopDelta) {
      var month = self2.daysContainer.children[m4];
      var startIndex2 = givenMonth - self2.currentMonth === m4 ? current.$i + delta : delta < 0 ? month.children.length - 1 : 0;
      var numMonthDays = month.children.length;
      for (var i3 = startIndex2; i3 >= 0 && i3 < numMonthDays && i3 != (delta > 0 ? numMonthDays : -1); i3 += loopDelta) {
        var c3 = month.children[i3];
        if (c3.className.indexOf("hidden") === -1 && isEnabled(c3.dateObj) && Math.abs(current.$i - i3) >= Math.abs(delta))
          return focusOnDayElem(c3);
      }
    }
    self2.changeMonth(loopDelta);
    focusOnDay(getFirstAvailableDay(loopDelta), 0);
    return void 0;
  }
  function focusOnDay(current, offset2) {
    var activeElement = getClosestActiveElement();
    var dayFocused = isInView(activeElement || document.body);
    var startElem = current !== void 0 ? current : dayFocused ? activeElement : self2.selectedDateElem !== void 0 && isInView(self2.selectedDateElem) ? self2.selectedDateElem : self2.todayDateElem !== void 0 && isInView(self2.todayDateElem) ? self2.todayDateElem : getFirstAvailableDay(offset2 > 0 ? 1 : -1);
    if (startElem === void 0) {
      self2._input.focus();
    } else if (!dayFocused) {
      focusOnDayElem(startElem);
    } else {
      getNextAvailableDay(startElem, offset2);
    }
  }
  function buildMonthDays(year, month) {
    var firstOfMonth = (new Date(year, month, 1).getDay() - self2.l10n.firstDayOfWeek + 7) % 7;
    var prevMonthDays = self2.utils.getDaysInMonth((month - 1 + 12) % 12, year);
    var daysInMonth = self2.utils.getDaysInMonth(month, year), days = window.document.createDocumentFragment(), isMultiMonth = self2.config.showMonths > 1, prevMonthDayClass = isMultiMonth ? "prevMonthDay hidden" : "prevMonthDay", nextMonthDayClass = isMultiMonth ? "nextMonthDay hidden" : "nextMonthDay";
    var dayNumber = prevMonthDays + 1 - firstOfMonth, dayIndex = 0;
    for (; dayNumber <= prevMonthDays; dayNumber++, dayIndex++) {
      days.appendChild(createDay("flatpickr-day " + prevMonthDayClass, new Date(year, month - 1, dayNumber), dayNumber, dayIndex));
    }
    for (dayNumber = 1; dayNumber <= daysInMonth; dayNumber++, dayIndex++) {
      days.appendChild(createDay("flatpickr-day", new Date(year, month, dayNumber), dayNumber, dayIndex));
    }
    for (var dayNum = daysInMonth + 1; dayNum <= 42 - firstOfMonth && (self2.config.showMonths === 1 || dayIndex % 7 !== 0); dayNum++, dayIndex++) {
      days.appendChild(createDay("flatpickr-day " + nextMonthDayClass, new Date(year, month + 1, dayNum % daysInMonth), dayNum, dayIndex));
    }
    var dayContainer = createElement$1("div", "dayContainer");
    dayContainer.appendChild(days);
    return dayContainer;
  }
  function buildDays() {
    if (self2.daysContainer === void 0) {
      return;
    }
    clearNode(self2.daysContainer);
    if (self2.weekNumbers)
      clearNode(self2.weekNumbers);
    var frag = document.createDocumentFragment();
    for (var i3 = 0; i3 < self2.config.showMonths; i3++) {
      var d4 = new Date(self2.currentYear, self2.currentMonth, 1);
      d4.setMonth(self2.currentMonth + i3);
      frag.appendChild(buildMonthDays(d4.getFullYear(), d4.getMonth()));
    }
    self2.daysContainer.appendChild(frag);
    self2.days = self2.daysContainer.firstChild;
    if (self2.config.mode === "range" && self2.selectedDates.length === 1) {
      onMouseOver();
    }
  }
  function buildMonthSwitch() {
    if (self2.config.showMonths > 1 || self2.config.monthSelectorType !== "dropdown")
      return;
    var shouldBuildMonth = function(month2) {
      if (self2.config.minDate !== void 0 && self2.currentYear === self2.config.minDate.getFullYear() && month2 < self2.config.minDate.getMonth()) {
        return false;
      }
      return !(self2.config.maxDate !== void 0 && self2.currentYear === self2.config.maxDate.getFullYear() && month2 > self2.config.maxDate.getMonth());
    };
    self2.monthsDropdownContainer.tabIndex = -1;
    self2.monthsDropdownContainer.innerHTML = "";
    for (var i3 = 0; i3 < 12; i3++) {
      if (!shouldBuildMonth(i3))
        continue;
      var month = createElement$1("option", "flatpickr-monthDropdown-month");
      month.value = new Date(self2.currentYear, i3).getMonth().toString();
      month.textContent = monthToStr(i3, self2.config.shorthandCurrentMonth, self2.l10n);
      month.tabIndex = -1;
      if (self2.currentMonth === i3) {
        month.selected = true;
      }
      self2.monthsDropdownContainer.appendChild(month);
    }
  }
  function buildMonth() {
    var container = createElement$1("div", "flatpickr-month");
    var monthNavFragment = window.document.createDocumentFragment();
    var monthElement;
    if (self2.config.showMonths > 1 || self2.config.monthSelectorType === "static") {
      monthElement = createElement$1("span", "cur-month");
    } else {
      self2.monthsDropdownContainer = createElement$1("select", "flatpickr-monthDropdown-months");
      self2.monthsDropdownContainer.setAttribute("aria-label", self2.l10n.monthAriaLabel);
      bind2(self2.monthsDropdownContainer, "change", function(e3) {
        var target = getEventTarget(e3);
        var selectedMonth = parseInt(target.value, 10);
        self2.changeMonth(selectedMonth - self2.currentMonth);
        triggerEvent2("onMonthChange");
      });
      buildMonthSwitch();
      monthElement = self2.monthsDropdownContainer;
    }
    var yearInput = createNumberInput("cur-year", { tabindex: "-1" });
    var yearElement = yearInput.getElementsByTagName("input")[0];
    yearElement.setAttribute("aria-label", self2.l10n.yearAriaLabel);
    if (self2.config.minDate) {
      yearElement.setAttribute("min", self2.config.minDate.getFullYear().toString());
    }
    if (self2.config.maxDate) {
      yearElement.setAttribute("max", self2.config.maxDate.getFullYear().toString());
      yearElement.disabled = !!self2.config.minDate && self2.config.minDate.getFullYear() === self2.config.maxDate.getFullYear();
    }
    var currentMonth = createElement$1("div", "flatpickr-current-month");
    currentMonth.appendChild(monthElement);
    currentMonth.appendChild(yearInput);
    monthNavFragment.appendChild(currentMonth);
    container.appendChild(monthNavFragment);
    return {
      container,
      yearElement,
      monthElement
    };
  }
  function buildMonths() {
    clearNode(self2.monthNav);
    self2.monthNav.appendChild(self2.prevMonthNav);
    if (self2.config.showMonths) {
      self2.yearElements = [];
      self2.monthElements = [];
    }
    for (var m4 = self2.config.showMonths; m4--; ) {
      var month = buildMonth();
      self2.yearElements.push(month.yearElement);
      self2.monthElements.push(month.monthElement);
      self2.monthNav.appendChild(month.container);
    }
    self2.monthNav.appendChild(self2.nextMonthNav);
  }
  function buildMonthNav() {
    self2.monthNav = createElement$1("div", "flatpickr-months");
    self2.yearElements = [];
    self2.monthElements = [];
    self2.prevMonthNav = createElement$1("span", "flatpickr-prev-month");
    self2.prevMonthNav.innerHTML = self2.config.prevArrow;
    self2.nextMonthNav = createElement$1("span", "flatpickr-next-month");
    self2.nextMonthNav.innerHTML = self2.config.nextArrow;
    buildMonths();
    Object.defineProperty(self2, "_hidePrevMonthArrow", {
      get: function() {
        return self2.__hidePrevMonthArrow;
      },
      set: function(bool) {
        if (self2.__hidePrevMonthArrow !== bool) {
          toggleClass$1(self2.prevMonthNav, "flatpickr-disabled", bool);
          self2.__hidePrevMonthArrow = bool;
        }
      }
    });
    Object.defineProperty(self2, "_hideNextMonthArrow", {
      get: function() {
        return self2.__hideNextMonthArrow;
      },
      set: function(bool) {
        if (self2.__hideNextMonthArrow !== bool) {
          toggleClass$1(self2.nextMonthNav, "flatpickr-disabled", bool);
          self2.__hideNextMonthArrow = bool;
        }
      }
    });
    self2.currentYearElement = self2.yearElements[0];
    updateNavigationCurrentMonth();
    return self2.monthNav;
  }
  function buildTime() {
    self2.calendarContainer.classList.add("hasTime");
    if (self2.config.noCalendar)
      self2.calendarContainer.classList.add("noCalendar");
    var defaults2 = getDefaultHours(self2.config);
    self2.timeContainer = createElement$1("div", "flatpickr-time");
    self2.timeContainer.tabIndex = -1;
    var separator = createElement$1("span", "flatpickr-time-separator", ":");
    var hourInput = createNumberInput("flatpickr-hour", {
      "aria-label": self2.l10n.hourAriaLabel
    });
    self2.hourElement = hourInput.getElementsByTagName("input")[0];
    var minuteInput = createNumberInput("flatpickr-minute", {
      "aria-label": self2.l10n.minuteAriaLabel
    });
    self2.minuteElement = minuteInput.getElementsByTagName("input")[0];
    self2.hourElement.tabIndex = self2.minuteElement.tabIndex = -1;
    self2.hourElement.value = pad(self2.latestSelectedDateObj ? self2.latestSelectedDateObj.getHours() : self2.config.time_24hr ? defaults2.hours : military2ampm(defaults2.hours));
    self2.minuteElement.value = pad(self2.latestSelectedDateObj ? self2.latestSelectedDateObj.getMinutes() : defaults2.minutes);
    self2.hourElement.setAttribute("step", self2.config.hourIncrement.toString());
    self2.minuteElement.setAttribute("step", self2.config.minuteIncrement.toString());
    self2.hourElement.setAttribute("min", self2.config.time_24hr ? "0" : "1");
    self2.hourElement.setAttribute("max", self2.config.time_24hr ? "23" : "12");
    self2.hourElement.setAttribute("maxlength", "2");
    self2.minuteElement.setAttribute("min", "0");
    self2.minuteElement.setAttribute("max", "59");
    self2.minuteElement.setAttribute("maxlength", "2");
    self2.timeContainer.appendChild(hourInput);
    self2.timeContainer.appendChild(separator);
    self2.timeContainer.appendChild(minuteInput);
    if (self2.config.time_24hr)
      self2.timeContainer.classList.add("time24hr");
    if (self2.config.enableSeconds) {
      self2.timeContainer.classList.add("hasSeconds");
      var secondInput = createNumberInput("flatpickr-second");
      self2.secondElement = secondInput.getElementsByTagName("input")[0];
      self2.secondElement.value = pad(self2.latestSelectedDateObj ? self2.latestSelectedDateObj.getSeconds() : defaults2.seconds);
      self2.secondElement.setAttribute("step", self2.minuteElement.getAttribute("step"));
      self2.secondElement.setAttribute("min", "0");
      self2.secondElement.setAttribute("max", "59");
      self2.secondElement.setAttribute("maxlength", "2");
      self2.timeContainer.appendChild(createElement$1("span", "flatpickr-time-separator", ":"));
      self2.timeContainer.appendChild(secondInput);
    }
    if (!self2.config.time_24hr) {
      self2.amPM = createElement$1("span", "flatpickr-am-pm", self2.l10n.amPM[int((self2.latestSelectedDateObj ? self2.hourElement.value : self2.config.defaultHour) > 11)]);
      self2.amPM.title = self2.l10n.toggleTitle;
      self2.amPM.tabIndex = -1;
      self2.timeContainer.appendChild(self2.amPM);
    }
    return self2.timeContainer;
  }
  function buildWeekdays() {
    if (!self2.weekdayContainer)
      self2.weekdayContainer = createElement$1("div", "flatpickr-weekdays");
    else
      clearNode(self2.weekdayContainer);
    for (var i3 = self2.config.showMonths; i3--; ) {
      var container = createElement$1("div", "flatpickr-weekdaycontainer");
      self2.weekdayContainer.appendChild(container);
    }
    updateWeekdays();
    return self2.weekdayContainer;
  }
  function updateWeekdays() {
    if (!self2.weekdayContainer) {
      return;
    }
    var firstDayOfWeek = self2.l10n.firstDayOfWeek;
    var weekdays = __spreadArrays(self2.l10n.weekdays.shorthand);
    if (firstDayOfWeek > 0 && firstDayOfWeek < weekdays.length) {
      weekdays = __spreadArrays(weekdays.splice(firstDayOfWeek, weekdays.length), weekdays.splice(0, firstDayOfWeek));
    }
    for (var i3 = self2.config.showMonths; i3--; ) {
      self2.weekdayContainer.children[i3].innerHTML = "\n      <span class='flatpickr-weekday'>\n        " + weekdays.join("</span><span class='flatpickr-weekday'>") + "\n      </span>\n      ";
    }
  }
  function buildWeeks() {
    self2.calendarContainer.classList.add("hasWeeks");
    var weekWrapper = createElement$1("div", "flatpickr-weekwrapper");
    weekWrapper.appendChild(createElement$1("span", "flatpickr-weekday", self2.l10n.weekAbbreviation));
    var weekNumbers = createElement$1("div", "flatpickr-weeks");
    weekWrapper.appendChild(weekNumbers);
    return {
      weekWrapper,
      weekNumbers
    };
  }
  function changeMonth(value, isOffset) {
    if (isOffset === void 0) {
      isOffset = true;
    }
    var delta = isOffset ? value : value - self2.currentMonth;
    if (delta < 0 && self2._hidePrevMonthArrow === true || delta > 0 && self2._hideNextMonthArrow === true)
      return;
    self2.currentMonth += delta;
    if (self2.currentMonth < 0 || self2.currentMonth > 11) {
      self2.currentYear += self2.currentMonth > 11 ? 1 : -1;
      self2.currentMonth = (self2.currentMonth + 12) % 12;
      triggerEvent2("onYearChange");
      buildMonthSwitch();
    }
    buildDays();
    triggerEvent2("onMonthChange");
    updateNavigationCurrentMonth();
  }
  function clear(triggerChangeEvent, toInitial) {
    if (triggerChangeEvent === void 0) {
      triggerChangeEvent = true;
    }
    if (toInitial === void 0) {
      toInitial = true;
    }
    self2.input.value = "";
    if (self2.altInput !== void 0)
      self2.altInput.value = "";
    if (self2.mobileInput !== void 0)
      self2.mobileInput.value = "";
    self2.selectedDates = [];
    self2.latestSelectedDateObj = void 0;
    if (toInitial === true) {
      self2.currentYear = self2._initialDate.getFullYear();
      self2.currentMonth = self2._initialDate.getMonth();
    }
    if (self2.config.enableTime === true) {
      var _a = getDefaultHours(self2.config), hours = _a.hours, minutes = _a.minutes, seconds = _a.seconds;
      setHours2(hours, minutes, seconds);
    }
    self2.redraw();
    if (triggerChangeEvent)
      triggerEvent2("onChange");
  }
  function close2() {
    self2.isOpen = false;
    if (!self2.isMobile) {
      if (self2.calendarContainer !== void 0) {
        self2.calendarContainer.classList.remove("open");
      }
      if (self2._input !== void 0) {
        self2._input.classList.remove("active");
      }
    }
    triggerEvent2("onClose");
  }
  function destroy2() {
    if (self2.config !== void 0)
      triggerEvent2("onDestroy");
    for (var i3 = self2._handlers.length; i3--; ) {
      self2._handlers[i3].remove();
    }
    self2._handlers = [];
    if (self2.mobileInput) {
      if (self2.mobileInput.parentNode)
        self2.mobileInput.parentNode.removeChild(self2.mobileInput);
      self2.mobileInput = void 0;
    } else if (self2.calendarContainer && self2.calendarContainer.parentNode) {
      if (self2.config.static && self2.calendarContainer.parentNode) {
        var wrapper = self2.calendarContainer.parentNode;
        wrapper.lastChild && wrapper.removeChild(wrapper.lastChild);
        if (wrapper.parentNode) {
          while (wrapper.firstChild)
            wrapper.parentNode.insertBefore(wrapper.firstChild, wrapper);
          wrapper.parentNode.removeChild(wrapper);
        }
      } else
        self2.calendarContainer.parentNode.removeChild(self2.calendarContainer);
    }
    if (self2.altInput) {
      self2.input.type = "text";
      if (self2.altInput.parentNode)
        self2.altInput.parentNode.removeChild(self2.altInput);
      delete self2.altInput;
    }
    if (self2.input) {
      self2.input.type = self2.input._type;
      self2.input.classList.remove("flatpickr-input");
      self2.input.removeAttribute("readonly");
    }
    [
      "_showTimeInput",
      "latestSelectedDateObj",
      "_hideNextMonthArrow",
      "_hidePrevMonthArrow",
      "__hideNextMonthArrow",
      "__hidePrevMonthArrow",
      "isMobile",
      "isOpen",
      "selectedDateElem",
      "minDateHasTime",
      "maxDateHasTime",
      "days",
      "daysContainer",
      "_input",
      "_positionElement",
      "innerContainer",
      "rContainer",
      "monthNav",
      "todayDateElem",
      "calendarContainer",
      "weekdayContainer",
      "prevMonthNav",
      "nextMonthNav",
      "monthsDropdownContainer",
      "currentMonthElement",
      "currentYearElement",
      "navigationCurrentMonth",
      "selectedDateElem",
      "config"
    ].forEach(function(k3) {
      try {
        delete self2[k3];
      } catch (_2) {
      }
    });
  }
  function isCalendarElem(elem) {
    return self2.calendarContainer.contains(elem);
  }
  function documentClick(e3) {
    if (self2.isOpen && !self2.config.inline) {
      var eventTarget_1 = getEventTarget(e3);
      var isCalendarElement = isCalendarElem(eventTarget_1);
      var isInput = eventTarget_1 === self2.input || eventTarget_1 === self2.altInput || self2.element.contains(eventTarget_1) || e3.path && e3.path.indexOf && (~e3.path.indexOf(self2.input) || ~e3.path.indexOf(self2.altInput));
      var lostFocus = !isInput && !isCalendarElement && !isCalendarElem(e3.relatedTarget);
      var isIgnored = !self2.config.ignoredFocusElements.some(function(elem) {
        return elem.contains(eventTarget_1);
      });
      if (lostFocus && isIgnored) {
        if (self2.config.allowInput) {
          self2.setDate(self2._input.value, false, self2.config.altInput ? self2.config.altFormat : self2.config.dateFormat);
        }
        if (self2.timeContainer !== void 0 && self2.minuteElement !== void 0 && self2.hourElement !== void 0 && self2.input.value !== "" && self2.input.value !== void 0) {
          updateTime();
        }
        self2.close();
        if (self2.config && self2.config.mode === "range" && self2.selectedDates.length === 1)
          self2.clear(false);
      }
    }
  }
  function changeYear(newYear) {
    if (!newYear || self2.config.minDate && newYear < self2.config.minDate.getFullYear() || self2.config.maxDate && newYear > self2.config.maxDate.getFullYear())
      return;
    var newYearNum = newYear, isNewYear = self2.currentYear !== newYearNum;
    self2.currentYear = newYearNum || self2.currentYear;
    if (self2.config.maxDate && self2.currentYear === self2.config.maxDate.getFullYear()) {
      self2.currentMonth = Math.min(self2.config.maxDate.getMonth(), self2.currentMonth);
    } else if (self2.config.minDate && self2.currentYear === self2.config.minDate.getFullYear()) {
      self2.currentMonth = Math.max(self2.config.minDate.getMonth(), self2.currentMonth);
    }
    if (isNewYear) {
      self2.redraw();
      triggerEvent2("onYearChange");
      buildMonthSwitch();
    }
  }
  function isEnabled(date, timeless) {
    var _a;
    if (timeless === void 0) {
      timeless = true;
    }
    var dateToCheck = self2.parseDate(date, void 0, timeless);
    if (self2.config.minDate && dateToCheck && compareDates(dateToCheck, self2.config.minDate, timeless !== void 0 ? timeless : !self2.minDateHasTime) < 0 || self2.config.maxDate && dateToCheck && compareDates(dateToCheck, self2.config.maxDate, timeless !== void 0 ? timeless : !self2.maxDateHasTime) > 0)
      return false;
    if (!self2.config.enable && self2.config.disable.length === 0)
      return true;
    if (dateToCheck === void 0)
      return false;
    var bool = !!self2.config.enable, array = (_a = self2.config.enable) !== null && _a !== void 0 ? _a : self2.config.disable;
    for (var i3 = 0, d4 = void 0; i3 < array.length; i3++) {
      d4 = array[i3];
      if (typeof d4 === "function" && d4(dateToCheck))
        return bool;
      else if (d4 instanceof Date && dateToCheck !== void 0 && d4.getTime() === dateToCheck.getTime())
        return bool;
      else if (typeof d4 === "string") {
        var parsed = self2.parseDate(d4, void 0, true);
        return parsed && parsed.getTime() === dateToCheck.getTime() ? bool : !bool;
      } else if (typeof d4 === "object" && dateToCheck !== void 0 && d4.from && d4.to && dateToCheck.getTime() >= d4.from.getTime() && dateToCheck.getTime() <= d4.to.getTime())
        return bool;
    }
    return !bool;
  }
  function isInView(elem) {
    if (self2.daysContainer !== void 0)
      return elem.className.indexOf("hidden") === -1 && elem.className.indexOf("flatpickr-disabled") === -1 && self2.daysContainer.contains(elem);
    return false;
  }
  function onBlur(e3) {
    var isInput = e3.target === self2._input;
    var valueChanged = self2._input.value.trimEnd() !== getDateStr();
    if (isInput && valueChanged && !(e3.relatedTarget && isCalendarElem(e3.relatedTarget))) {
      self2.setDate(self2._input.value, true, e3.target === self2.altInput ? self2.config.altFormat : self2.config.dateFormat);
    }
  }
  function onKeyDown(e3) {
    var eventTarget = getEventTarget(e3);
    var isInput = self2.config.wrap ? element.contains(eventTarget) : eventTarget === self2._input;
    var allowInput = self2.config.allowInput;
    var allowKeydown = self2.isOpen && (!allowInput || !isInput);
    var allowInlineKeydown = self2.config.inline && isInput && !allowInput;
    if (e3.keyCode === 13 && isInput) {
      if (allowInput) {
        self2.setDate(self2._input.value, true, eventTarget === self2.altInput ? self2.config.altFormat : self2.config.dateFormat);
        self2.close();
        return eventTarget.blur();
      } else {
        self2.open();
      }
    } else if (isCalendarElem(eventTarget) || allowKeydown || allowInlineKeydown) {
      var isTimeObj = !!self2.timeContainer && self2.timeContainer.contains(eventTarget);
      switch (e3.keyCode) {
        case 13:
          if (isTimeObj) {
            e3.preventDefault();
            updateTime();
            focusAndClose();
          } else
            selectDate(e3);
          break;
        case 27:
          e3.preventDefault();
          focusAndClose();
          break;
        case 8:
        case 46:
          if (isInput && !self2.config.allowInput) {
            e3.preventDefault();
            self2.clear();
          }
          break;
        case 37:
        case 39:
          if (!isTimeObj && !isInput) {
            e3.preventDefault();
            var activeElement = getClosestActiveElement();
            if (self2.daysContainer !== void 0 && (allowInput === false || activeElement && isInView(activeElement))) {
              var delta_1 = e3.keyCode === 39 ? 1 : -1;
              if (!e3.ctrlKey)
                focusOnDay(void 0, delta_1);
              else {
                e3.stopPropagation();
                changeMonth(delta_1);
                focusOnDay(getFirstAvailableDay(1), 0);
              }
            }
          } else if (self2.hourElement)
            self2.hourElement.focus();
          break;
        case 38:
        case 40:
          e3.preventDefault();
          var delta = e3.keyCode === 40 ? 1 : -1;
          if (self2.daysContainer && eventTarget.$i !== void 0 || eventTarget === self2.input || eventTarget === self2.altInput) {
            if (e3.ctrlKey) {
              e3.stopPropagation();
              changeYear(self2.currentYear - delta);
              focusOnDay(getFirstAvailableDay(1), 0);
            } else if (!isTimeObj)
              focusOnDay(void 0, delta * 7);
          } else if (eventTarget === self2.currentYearElement) {
            changeYear(self2.currentYear - delta);
          } else if (self2.config.enableTime) {
            if (!isTimeObj && self2.hourElement)
              self2.hourElement.focus();
            updateTime(e3);
            self2._debouncedChange();
          }
          break;
        case 9:
          if (isTimeObj) {
            var elems = [
              self2.hourElement,
              self2.minuteElement,
              self2.secondElement,
              self2.amPM
            ].concat(self2.pluginElements).filter(function(x3) {
              return x3;
            });
            var i3 = elems.indexOf(eventTarget);
            if (i3 !== -1) {
              var target = elems[i3 + (e3.shiftKey ? -1 : 1)];
              e3.preventDefault();
              (target || self2._input).focus();
            }
          } else if (!self2.config.noCalendar && self2.daysContainer && self2.daysContainer.contains(eventTarget) && e3.shiftKey) {
            e3.preventDefault();
            self2._input.focus();
          }
          break;
      }
    }
    if (self2.amPM !== void 0 && eventTarget === self2.amPM) {
      switch (e3.key) {
        case self2.l10n.amPM[0].charAt(0):
        case self2.l10n.amPM[0].charAt(0).toLowerCase():
          self2.amPM.textContent = self2.l10n.amPM[0];
          setHoursFromInputs();
          updateValue();
          break;
        case self2.l10n.amPM[1].charAt(0):
        case self2.l10n.amPM[1].charAt(0).toLowerCase():
          self2.amPM.textContent = self2.l10n.amPM[1];
          setHoursFromInputs();
          updateValue();
          break;
      }
    }
    if (isInput || isCalendarElem(eventTarget)) {
      triggerEvent2("onKeyDown", e3);
    }
  }
  function onMouseOver(elem, cellClass) {
    if (cellClass === void 0) {
      cellClass = "flatpickr-day";
    }
    if (self2.selectedDates.length !== 1 || elem && (!elem.classList.contains(cellClass) || elem.classList.contains("flatpickr-disabled")))
      return;
    var hoverDate = elem ? elem.dateObj.getTime() : self2.days.firstElementChild.dateObj.getTime(), initialDate = self2.parseDate(self2.selectedDates[0], void 0, true).getTime(), rangeStartDate = Math.min(hoverDate, self2.selectedDates[0].getTime()), rangeEndDate = Math.max(hoverDate, self2.selectedDates[0].getTime());
    var containsDisabled = false;
    var minRange = 0, maxRange = 0;
    for (var t3 = rangeStartDate; t3 < rangeEndDate; t3 += duration.DAY) {
      if (!isEnabled(new Date(t3), true)) {
        containsDisabled = containsDisabled || t3 > rangeStartDate && t3 < rangeEndDate;
        if (t3 < initialDate && (!minRange || t3 > minRange))
          minRange = t3;
        else if (t3 > initialDate && (!maxRange || t3 < maxRange))
          maxRange = t3;
      }
    }
    var hoverableCells = Array.from(self2.rContainer.querySelectorAll("*:nth-child(-n+" + self2.config.showMonths + ") > ." + cellClass));
    hoverableCells.forEach(function(dayElem) {
      var date = dayElem.dateObj;
      var timestamp = date.getTime();
      var outOfRange = minRange > 0 && timestamp < minRange || maxRange > 0 && timestamp > maxRange;
      if (outOfRange) {
        dayElem.classList.add("notAllowed");
        ["inRange", "startRange", "endRange"].forEach(function(c3) {
          dayElem.classList.remove(c3);
        });
        return;
      } else if (containsDisabled && !outOfRange)
        return;
      ["startRange", "inRange", "endRange", "notAllowed"].forEach(function(c3) {
        dayElem.classList.remove(c3);
      });
      if (elem !== void 0) {
        elem.classList.add(hoverDate <= self2.selectedDates[0].getTime() ? "startRange" : "endRange");
        if (initialDate < hoverDate && timestamp === initialDate)
          dayElem.classList.add("startRange");
        else if (initialDate > hoverDate && timestamp === initialDate)
          dayElem.classList.add("endRange");
        if (timestamp >= minRange && (maxRange === 0 || timestamp <= maxRange) && isBetween(timestamp, initialDate, hoverDate))
          dayElem.classList.add("inRange");
      }
    });
  }
  function onResize() {
    if (self2.isOpen && !self2.config.static && !self2.config.inline)
      positionCalendar();
  }
  function open(e3, positionElement) {
    if (positionElement === void 0) {
      positionElement = self2._positionElement;
    }
    if (self2.isMobile === true) {
      if (e3) {
        e3.preventDefault();
        var eventTarget = getEventTarget(e3);
        if (eventTarget) {
          eventTarget.blur();
        }
      }
      if (self2.mobileInput !== void 0) {
        self2.mobileInput.focus();
        self2.mobileInput.click();
      }
      triggerEvent2("onOpen");
      return;
    } else if (self2._input.disabled || self2.config.inline) {
      return;
    }
    var wasOpen = self2.isOpen;
    self2.isOpen = true;
    if (!wasOpen) {
      self2.calendarContainer.classList.add("open");
      self2._input.classList.add("active");
      triggerEvent2("onOpen");
      positionCalendar(positionElement);
    }
    if (self2.config.enableTime === true && self2.config.noCalendar === true) {
      if (self2.config.allowInput === false && (e3 === void 0 || !self2.timeContainer.contains(e3.relatedTarget))) {
        setTimeout(function() {
          return self2.hourElement.select();
        }, 50);
      }
    }
  }
  function minMaxDateSetter(type) {
    return function(date) {
      var dateObj = self2.config["_" + type + "Date"] = self2.parseDate(date, self2.config.dateFormat);
      var inverseDateObj = self2.config["_" + (type === "min" ? "max" : "min") + "Date"];
      if (dateObj !== void 0) {
        self2[type === "min" ? "minDateHasTime" : "maxDateHasTime"] = dateObj.getHours() > 0 || dateObj.getMinutes() > 0 || dateObj.getSeconds() > 0;
      }
      if (self2.selectedDates) {
        self2.selectedDates = self2.selectedDates.filter(function(d4) {
          return isEnabled(d4);
        });
        if (!self2.selectedDates.length && type === "min")
          setHoursFromDate(dateObj);
        updateValue();
      }
      if (self2.daysContainer) {
        redraw();
        if (dateObj !== void 0)
          self2.currentYearElement[type] = dateObj.getFullYear().toString();
        else
          self2.currentYearElement.removeAttribute(type);
        self2.currentYearElement.disabled = !!inverseDateObj && dateObj !== void 0 && inverseDateObj.getFullYear() === dateObj.getFullYear();
      }
    };
  }
  function parseConfig() {
    var boolOpts = [
      "wrap",
      "weekNumbers",
      "allowInput",
      "allowInvalidPreload",
      "clickOpens",
      "time_24hr",
      "enableTime",
      "noCalendar",
      "altInput",
      "shorthandCurrentMonth",
      "inline",
      "static",
      "enableSeconds",
      "disableMobile"
    ];
    var userConfig = __assign$1(__assign$1({}, JSON.parse(JSON.stringify(element.dataset || {}))), instanceConfig);
    var formats2 = {};
    self2.config.parseDate = userConfig.parseDate;
    self2.config.formatDate = userConfig.formatDate;
    Object.defineProperty(self2.config, "enable", {
      get: function() {
        return self2.config._enable;
      },
      set: function(dates) {
        self2.config._enable = parseDateRules(dates);
      }
    });
    Object.defineProperty(self2.config, "disable", {
      get: function() {
        return self2.config._disable;
      },
      set: function(dates) {
        self2.config._disable = parseDateRules(dates);
      }
    });
    var timeMode = userConfig.mode === "time";
    if (!userConfig.dateFormat && (userConfig.enableTime || timeMode)) {
      var defaultDateFormat = flatpickr.defaultConfig.dateFormat || defaults$3.dateFormat;
      formats2.dateFormat = userConfig.noCalendar || timeMode ? "H:i" + (userConfig.enableSeconds ? ":S" : "") : defaultDateFormat + " H:i" + (userConfig.enableSeconds ? ":S" : "");
    }
    if (userConfig.altInput && (userConfig.enableTime || timeMode) && !userConfig.altFormat) {
      var defaultAltFormat = flatpickr.defaultConfig.altFormat || defaults$3.altFormat;
      formats2.altFormat = userConfig.noCalendar || timeMode ? "h:i" + (userConfig.enableSeconds ? ":S K" : " K") : defaultAltFormat + (" h:i" + (userConfig.enableSeconds ? ":S" : "") + " K");
    }
    Object.defineProperty(self2.config, "minDate", {
      get: function() {
        return self2.config._minDate;
      },
      set: minMaxDateSetter("min")
    });
    Object.defineProperty(self2.config, "maxDate", {
      get: function() {
        return self2.config._maxDate;
      },
      set: minMaxDateSetter("max")
    });
    var minMaxTimeSetter = function(type) {
      return function(val) {
        self2.config[type === "min" ? "_minTime" : "_maxTime"] = self2.parseDate(val, "H:i:S");
      };
    };
    Object.defineProperty(self2.config, "minTime", {
      get: function() {
        return self2.config._minTime;
      },
      set: minMaxTimeSetter("min")
    });
    Object.defineProperty(self2.config, "maxTime", {
      get: function() {
        return self2.config._maxTime;
      },
      set: minMaxTimeSetter("max")
    });
    if (userConfig.mode === "time") {
      self2.config.noCalendar = true;
      self2.config.enableTime = true;
    }
    Object.assign(self2.config, formats2, userConfig);
    for (var i3 = 0; i3 < boolOpts.length; i3++)
      self2.config[boolOpts[i3]] = self2.config[boolOpts[i3]] === true || self2.config[boolOpts[i3]] === "true";
    HOOKS.filter(function(hook) {
      return self2.config[hook] !== void 0;
    }).forEach(function(hook) {
      self2.config[hook] = arrayify(self2.config[hook] || []).map(bindToInstance);
    });
    self2.isMobile = !self2.config.disableMobile && !self2.config.inline && self2.config.mode === "single" && !self2.config.disable.length && !self2.config.enable && !self2.config.weekNumbers && /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
    for (var i3 = 0; i3 < self2.config.plugins.length; i3++) {
      var pluginConf = self2.config.plugins[i3](self2) || {};
      for (var key in pluginConf) {
        if (HOOKS.indexOf(key) > -1) {
          self2.config[key] = arrayify(pluginConf[key]).map(bindToInstance).concat(self2.config[key]);
        } else if (typeof userConfig[key] === "undefined")
          self2.config[key] = pluginConf[key];
      }
    }
    if (!userConfig.altInputClass) {
      self2.config.altInputClass = getInputElem().className + " " + self2.config.altInputClass;
    }
    triggerEvent2("onParseConfig");
  }
  function getInputElem() {
    return self2.config.wrap ? element.querySelector("[data-input]") : element;
  }
  function setupLocale() {
    if (typeof self2.config.locale !== "object" && typeof flatpickr.l10ns[self2.config.locale] === "undefined")
      self2.config.errorHandler(new Error("flatpickr: invalid locale " + self2.config.locale));
    self2.l10n = __assign$1(__assign$1({}, flatpickr.l10ns.default), typeof self2.config.locale === "object" ? self2.config.locale : self2.config.locale !== "default" ? flatpickr.l10ns[self2.config.locale] : void 0);
    tokenRegex.D = "(" + self2.l10n.weekdays.shorthand.join("|") + ")";
    tokenRegex.l = "(" + self2.l10n.weekdays.longhand.join("|") + ")";
    tokenRegex.M = "(" + self2.l10n.months.shorthand.join("|") + ")";
    tokenRegex.F = "(" + self2.l10n.months.longhand.join("|") + ")";
    tokenRegex.K = "(" + self2.l10n.amPM[0] + "|" + self2.l10n.amPM[1] + "|" + self2.l10n.amPM[0].toLowerCase() + "|" + self2.l10n.amPM[1].toLowerCase() + ")";
    var userConfig = __assign$1(__assign$1({}, instanceConfig), JSON.parse(JSON.stringify(element.dataset || {})));
    if (userConfig.time_24hr === void 0 && flatpickr.defaultConfig.time_24hr === void 0) {
      self2.config.time_24hr = self2.l10n.time_24hr;
    }
    self2.formatDate = createDateFormatter(self2);
    self2.parseDate = createDateParser({ config: self2.config, l10n: self2.l10n });
  }
  function positionCalendar(customPositionElement) {
    if (typeof self2.config.position === "function") {
      return void self2.config.position(self2, customPositionElement);
    }
    if (self2.calendarContainer === void 0)
      return;
    triggerEvent2("onPreCalendarPosition");
    var positionElement = customPositionElement || self2._positionElement;
    var calendarHeight = Array.prototype.reduce.call(self2.calendarContainer.children, function(acc, child) {
      return acc + child.offsetHeight;
    }, 0), calendarWidth = self2.calendarContainer.offsetWidth, configPos = self2.config.position.split(" "), configPosVertical = configPos[0], configPosHorizontal = configPos.length > 1 ? configPos[1] : null, inputBounds = positionElement.getBoundingClientRect(), distanceFromBottom = window.innerHeight - inputBounds.bottom, showOnTop = configPosVertical === "above" || configPosVertical !== "below" && distanceFromBottom < calendarHeight && inputBounds.top > calendarHeight;
    var top2 = window.pageYOffset + inputBounds.top + (!showOnTop ? positionElement.offsetHeight + 2 : -calendarHeight - 2);
    toggleClass$1(self2.calendarContainer, "arrowTop", !showOnTop);
    toggleClass$1(self2.calendarContainer, "arrowBottom", showOnTop);
    if (self2.config.inline)
      return;
    var left2 = window.pageXOffset + inputBounds.left;
    var isCenter = false;
    var isRight = false;
    if (configPosHorizontal === "center") {
      left2 -= (calendarWidth - inputBounds.width) / 2;
      isCenter = true;
    } else if (configPosHorizontal === "right") {
      left2 -= calendarWidth - inputBounds.width;
      isRight = true;
    }
    toggleClass$1(self2.calendarContainer, "arrowLeft", !isCenter && !isRight);
    toggleClass$1(self2.calendarContainer, "arrowCenter", isCenter);
    toggleClass$1(self2.calendarContainer, "arrowRight", isRight);
    var right2 = window.document.body.offsetWidth - (window.pageXOffset + inputBounds.right);
    var rightMost = left2 + calendarWidth > window.document.body.offsetWidth;
    var centerMost = right2 + calendarWidth > window.document.body.offsetWidth;
    toggleClass$1(self2.calendarContainer, "rightMost", rightMost);
    if (self2.config.static)
      return;
    self2.calendarContainer.style.top = top2 + "px";
    if (!rightMost) {
      self2.calendarContainer.style.left = left2 + "px";
      self2.calendarContainer.style.right = "auto";
    } else if (!centerMost) {
      self2.calendarContainer.style.left = "auto";
      self2.calendarContainer.style.right = right2 + "px";
    } else {
      var doc2 = getDocumentStyleSheet();
      if (doc2 === void 0)
        return;
      var bodyWidth = window.document.body.offsetWidth;
      var centerLeft = Math.max(0, bodyWidth / 2 - calendarWidth / 2);
      var centerBefore = ".flatpickr-calendar.centerMost:before";
      var centerAfter = ".flatpickr-calendar.centerMost:after";
      var centerIndex = doc2.cssRules.length;
      var centerStyle = "{left:" + inputBounds.left + "px;right:auto;}";
      toggleClass$1(self2.calendarContainer, "rightMost", false);
      toggleClass$1(self2.calendarContainer, "centerMost", true);
      doc2.insertRule(centerBefore + "," + centerAfter + centerStyle, centerIndex);
      self2.calendarContainer.style.left = centerLeft + "px";
      self2.calendarContainer.style.right = "auto";
    }
  }
  function getDocumentStyleSheet() {
    var editableSheet = null;
    for (var i3 = 0; i3 < document.styleSheets.length; i3++) {
      var sheet = document.styleSheets[i3];
      if (!sheet.cssRules)
        continue;
      try {
        sheet.cssRules;
      } catch (err) {
        continue;
      }
      editableSheet = sheet;
      break;
    }
    return editableSheet != null ? editableSheet : createStyleSheet();
  }
  function createStyleSheet() {
    var style2 = document.createElement("style");
    document.head.appendChild(style2);
    return style2.sheet;
  }
  function redraw() {
    if (self2.config.noCalendar || self2.isMobile)
      return;
    buildMonthSwitch();
    updateNavigationCurrentMonth();
    buildDays();
  }
  function focusAndClose() {
    self2._input.focus();
    if (window.navigator.userAgent.indexOf("MSIE") !== -1 || navigator.msMaxTouchPoints !== void 0) {
      setTimeout(self2.close, 0);
    } else {
      self2.close();
    }
  }
  function selectDate(e3) {
    e3.preventDefault();
    e3.stopPropagation();
    var isSelectable = function(day) {
      return day.classList && day.classList.contains("flatpickr-day") && !day.classList.contains("flatpickr-disabled") && !day.classList.contains("notAllowed");
    };
    var t3 = findParent(getEventTarget(e3), isSelectable);
    if (t3 === void 0)
      return;
    var target = t3;
    var selectedDate = self2.latestSelectedDateObj = new Date(target.dateObj.getTime());
    var shouldChangeMonth = (selectedDate.getMonth() < self2.currentMonth || selectedDate.getMonth() > self2.currentMonth + self2.config.showMonths - 1) && self2.config.mode !== "range";
    self2.selectedDateElem = target;
    if (self2.config.mode === "single")
      self2.selectedDates = [selectedDate];
    else if (self2.config.mode === "multiple") {
      var selectedIndex = isDateSelected(selectedDate);
      if (selectedIndex)
        self2.selectedDates.splice(parseInt(selectedIndex), 1);
      else
        self2.selectedDates.push(selectedDate);
    } else if (self2.config.mode === "range") {
      if (self2.selectedDates.length === 2) {
        self2.clear(false, false);
      }
      self2.latestSelectedDateObj = selectedDate;
      self2.selectedDates.push(selectedDate);
      if (compareDates(selectedDate, self2.selectedDates[0], true) !== 0)
        self2.selectedDates.sort(function(a4, b3) {
          return a4.getTime() - b3.getTime();
        });
    }
    setHoursFromInputs();
    if (shouldChangeMonth) {
      var isNewYear = self2.currentYear !== selectedDate.getFullYear();
      self2.currentYear = selectedDate.getFullYear();
      self2.currentMonth = selectedDate.getMonth();
      if (isNewYear) {
        triggerEvent2("onYearChange");
        buildMonthSwitch();
      }
      triggerEvent2("onMonthChange");
    }
    updateNavigationCurrentMonth();
    buildDays();
    updateValue();
    if (!shouldChangeMonth && self2.config.mode !== "range" && self2.config.showMonths === 1)
      focusOnDayElem(target);
    else if (self2.selectedDateElem !== void 0 && self2.hourElement === void 0) {
      self2.selectedDateElem && self2.selectedDateElem.focus();
    }
    if (self2.hourElement !== void 0)
      self2.hourElement !== void 0 && self2.hourElement.focus();
    if (self2.config.closeOnSelect) {
      var single = self2.config.mode === "single" && !self2.config.enableTime;
      var range2 = self2.config.mode === "range" && self2.selectedDates.length === 2 && !self2.config.enableTime;
      if (single || range2) {
        focusAndClose();
      }
    }
    triggerChange();
  }
  var CALLBACKS = {
    locale: [setupLocale, updateWeekdays],
    showMonths: [buildMonths, setCalendarWidth, buildWeekdays],
    minDate: [jumpToDate],
    maxDate: [jumpToDate],
    positionElement: [updatePositionElement],
    clickOpens: [
      function() {
        if (self2.config.clickOpens === true) {
          bind2(self2._input, "focus", self2.open);
          bind2(self2._input, "click", self2.open);
        } else {
          self2._input.removeEventListener("focus", self2.open);
          self2._input.removeEventListener("click", self2.open);
        }
      }
    ]
  };
  function set2(option2, value) {
    if (option2 !== null && typeof option2 === "object") {
      Object.assign(self2.config, option2);
      for (var key in option2) {
        if (CALLBACKS[key] !== void 0)
          CALLBACKS[key].forEach(function(x3) {
            return x3();
          });
      }
    } else {
      self2.config[option2] = value;
      if (CALLBACKS[option2] !== void 0)
        CALLBACKS[option2].forEach(function(x3) {
          return x3();
        });
      else if (HOOKS.indexOf(option2) > -1)
        self2.config[option2] = arrayify(value);
    }
    self2.redraw();
    updateValue(true);
  }
  function setSelectedDate(inputDate, format2) {
    var dates = [];
    if (inputDate instanceof Array)
      dates = inputDate.map(function(d4) {
        return self2.parseDate(d4, format2);
      });
    else if (inputDate instanceof Date || typeof inputDate === "number")
      dates = [self2.parseDate(inputDate, format2)];
    else if (typeof inputDate === "string") {
      switch (self2.config.mode) {
        case "single":
        case "time":
          dates = [self2.parseDate(inputDate, format2)];
          break;
        case "multiple":
          dates = inputDate.split(self2.config.conjunction).map(function(date) {
            return self2.parseDate(date, format2);
          });
          break;
        case "range":
          dates = inputDate.split(self2.l10n.rangeSeparator).map(function(date) {
            return self2.parseDate(date, format2);
          });
          break;
      }
    } else
      self2.config.errorHandler(new Error("Invalid date supplied: " + JSON.stringify(inputDate)));
    self2.selectedDates = self2.config.allowInvalidPreload ? dates : dates.filter(function(d4) {
      return d4 instanceof Date && isEnabled(d4, false);
    });
    if (self2.config.mode === "range")
      self2.selectedDates.sort(function(a4, b3) {
        return a4.getTime() - b3.getTime();
      });
  }
  function setDate(date, triggerChange2, format2) {
    if (triggerChange2 === void 0) {
      triggerChange2 = false;
    }
    if (format2 === void 0) {
      format2 = self2.config.dateFormat;
    }
    if (date !== 0 && !date || date instanceof Array && date.length === 0)
      return self2.clear(triggerChange2);
    setSelectedDate(date, format2);
    self2.latestSelectedDateObj = self2.selectedDates[self2.selectedDates.length - 1];
    self2.redraw();
    jumpToDate(void 0, triggerChange2);
    setHoursFromDate();
    if (self2.selectedDates.length === 0) {
      self2.clear(false);
    }
    updateValue(triggerChange2);
    if (triggerChange2)
      triggerEvent2("onChange");
  }
  function parseDateRules(arr) {
    return arr.slice().map(function(rule) {
      if (typeof rule === "string" || typeof rule === "number" || rule instanceof Date) {
        return self2.parseDate(rule, void 0, true);
      } else if (rule && typeof rule === "object" && rule.from && rule.to)
        return {
          from: self2.parseDate(rule.from, void 0),
          to: self2.parseDate(rule.to, void 0)
        };
      return rule;
    }).filter(function(x3) {
      return x3;
    });
  }
  function setupDates() {
    self2.selectedDates = [];
    self2.now = self2.parseDate(self2.config.now) || new Date();
    var preloadedDate = self2.config.defaultDate || ((self2.input.nodeName === "INPUT" || self2.input.nodeName === "TEXTAREA") && self2.input.placeholder && self2.input.value === self2.input.placeholder ? null : self2.input.value);
    if (preloadedDate)
      setSelectedDate(preloadedDate, self2.config.dateFormat);
    self2._initialDate = self2.selectedDates.length > 0 ? self2.selectedDates[0] : self2.config.minDate && self2.config.minDate.getTime() > self2.now.getTime() ? self2.config.minDate : self2.config.maxDate && self2.config.maxDate.getTime() < self2.now.getTime() ? self2.config.maxDate : self2.now;
    self2.currentYear = self2._initialDate.getFullYear();
    self2.currentMonth = self2._initialDate.getMonth();
    if (self2.selectedDates.length > 0)
      self2.latestSelectedDateObj = self2.selectedDates[0];
    if (self2.config.minTime !== void 0)
      self2.config.minTime = self2.parseDate(self2.config.minTime, "H:i");
    if (self2.config.maxTime !== void 0)
      self2.config.maxTime = self2.parseDate(self2.config.maxTime, "H:i");
    self2.minDateHasTime = !!self2.config.minDate && (self2.config.minDate.getHours() > 0 || self2.config.minDate.getMinutes() > 0 || self2.config.minDate.getSeconds() > 0);
    self2.maxDateHasTime = !!self2.config.maxDate && (self2.config.maxDate.getHours() > 0 || self2.config.maxDate.getMinutes() > 0 || self2.config.maxDate.getSeconds() > 0);
  }
  function setupInputs() {
    self2.input = getInputElem();
    if (!self2.input) {
      self2.config.errorHandler(new Error("Invalid input element specified"));
      return;
    }
    self2.input._type = self2.input.type;
    self2.input.type = "text";
    self2.input.classList.add("flatpickr-input");
    self2._input = self2.input;
    if (self2.config.altInput) {
      self2.altInput = createElement$1(self2.input.nodeName, self2.config.altInputClass);
      self2._input = self2.altInput;
      self2.altInput.placeholder = self2.input.placeholder;
      self2.altInput.disabled = self2.input.disabled;
      self2.altInput.required = self2.input.required;
      self2.altInput.tabIndex = self2.input.tabIndex;
      self2.altInput.type = "text";
      self2.input.setAttribute("type", "hidden");
      if (!self2.config.static && self2.input.parentNode)
        self2.input.parentNode.insertBefore(self2.altInput, self2.input.nextSibling);
    }
    if (!self2.config.allowInput)
      self2._input.setAttribute("readonly", "readonly");
    updatePositionElement();
  }
  function updatePositionElement() {
    self2._positionElement = self2.config.positionElement || self2._input;
  }
  function setupMobile() {
    var inputType = self2.config.enableTime ? self2.config.noCalendar ? "time" : "datetime-local" : "date";
    self2.mobileInput = createElement$1("input", self2.input.className + " flatpickr-mobile");
    self2.mobileInput.tabIndex = 1;
    self2.mobileInput.type = inputType;
    self2.mobileInput.disabled = self2.input.disabled;
    self2.mobileInput.required = self2.input.required;
    self2.mobileInput.placeholder = self2.input.placeholder;
    self2.mobileFormatStr = inputType === "datetime-local" ? "Y-m-d\\TH:i:S" : inputType === "date" ? "Y-m-d" : "H:i:S";
    if (self2.selectedDates.length > 0) {
      self2.mobileInput.defaultValue = self2.mobileInput.value = self2.formatDate(self2.selectedDates[0], self2.mobileFormatStr);
    }
    if (self2.config.minDate)
      self2.mobileInput.min = self2.formatDate(self2.config.minDate, "Y-m-d");
    if (self2.config.maxDate)
      self2.mobileInput.max = self2.formatDate(self2.config.maxDate, "Y-m-d");
    if (self2.input.getAttribute("step"))
      self2.mobileInput.step = String(self2.input.getAttribute("step"));
    self2.input.type = "hidden";
    if (self2.altInput !== void 0)
      self2.altInput.type = "hidden";
    try {
      if (self2.input.parentNode)
        self2.input.parentNode.insertBefore(self2.mobileInput, self2.input.nextSibling);
    } catch (_a) {
    }
    bind2(self2.mobileInput, "change", function(e3) {
      self2.setDate(getEventTarget(e3).value, false, self2.mobileFormatStr);
      triggerEvent2("onChange");
      triggerEvent2("onClose");
    });
  }
  function toggle(e3) {
    if (self2.isOpen === true)
      return self2.close();
    self2.open(e3);
  }
  function triggerEvent2(event, data) {
    if (self2.config === void 0)
      return;
    var hooks = self2.config[event];
    if (hooks !== void 0 && hooks.length > 0) {
      for (var i3 = 0; hooks[i3] && i3 < hooks.length; i3++)
        hooks[i3](self2.selectedDates, self2.input.value, self2, data);
    }
    if (event === "onChange") {
      self2.input.dispatchEvent(createEvent("change"));
      self2.input.dispatchEvent(createEvent("input"));
    }
  }
  function createEvent(name) {
    var e3 = document.createEvent("Event");
    e3.initEvent(name, true, true);
    return e3;
  }
  function isDateSelected(date) {
    for (var i3 = 0; i3 < self2.selectedDates.length; i3++) {
      var selectedDate = self2.selectedDates[i3];
      if (selectedDate instanceof Date && compareDates(selectedDate, date) === 0)
        return "" + i3;
    }
    return false;
  }
  function isDateInRange(date) {
    if (self2.config.mode !== "range" || self2.selectedDates.length < 2)
      return false;
    return compareDates(date, self2.selectedDates[0]) >= 0 && compareDates(date, self2.selectedDates[1]) <= 0;
  }
  function updateNavigationCurrentMonth() {
    if (self2.config.noCalendar || self2.isMobile || !self2.monthNav)
      return;
    self2.yearElements.forEach(function(yearElement, i3) {
      var d4 = new Date(self2.currentYear, self2.currentMonth, 1);
      d4.setMonth(self2.currentMonth + i3);
      if (self2.config.showMonths > 1 || self2.config.monthSelectorType === "static") {
        self2.monthElements[i3].textContent = monthToStr(d4.getMonth(), self2.config.shorthandCurrentMonth, self2.l10n) + " ";
      } else {
        self2.monthsDropdownContainer.value = d4.getMonth().toString();
      }
      yearElement.value = d4.getFullYear().toString();
    });
    self2._hidePrevMonthArrow = self2.config.minDate !== void 0 && (self2.currentYear === self2.config.minDate.getFullYear() ? self2.currentMonth <= self2.config.minDate.getMonth() : self2.currentYear < self2.config.minDate.getFullYear());
    self2._hideNextMonthArrow = self2.config.maxDate !== void 0 && (self2.currentYear === self2.config.maxDate.getFullYear() ? self2.currentMonth + 1 > self2.config.maxDate.getMonth() : self2.currentYear > self2.config.maxDate.getFullYear());
  }
  function getDateStr(specificFormat) {
    var format2 = specificFormat || (self2.config.altInput ? self2.config.altFormat : self2.config.dateFormat);
    return self2.selectedDates.map(function(dObj) {
      return self2.formatDate(dObj, format2);
    }).filter(function(d4, i3, arr) {
      return self2.config.mode !== "range" || self2.config.enableTime || arr.indexOf(d4) === i3;
    }).join(self2.config.mode !== "range" ? self2.config.conjunction : self2.l10n.rangeSeparator);
  }
  function updateValue(triggerChange2) {
    if (triggerChange2 === void 0) {
      triggerChange2 = true;
    }
    if (self2.mobileInput !== void 0 && self2.mobileFormatStr) {
      self2.mobileInput.value = self2.latestSelectedDateObj !== void 0 ? self2.formatDate(self2.latestSelectedDateObj, self2.mobileFormatStr) : "";
    }
    self2.input.value = getDateStr(self2.config.dateFormat);
    if (self2.altInput !== void 0) {
      self2.altInput.value = getDateStr(self2.config.altFormat);
    }
    if (triggerChange2 !== false)
      triggerEvent2("onValueUpdate");
  }
  function onMonthNavClick(e3) {
    var eventTarget = getEventTarget(e3);
    var isPrevMonth = self2.prevMonthNav.contains(eventTarget);
    var isNextMonth = self2.nextMonthNav.contains(eventTarget);
    if (isPrevMonth || isNextMonth) {
      changeMonth(isPrevMonth ? -1 : 1);
    } else if (self2.yearElements.indexOf(eventTarget) >= 0) {
      eventTarget.select();
    } else if (eventTarget.classList.contains("arrowUp")) {
      self2.changeYear(self2.currentYear + 1);
    } else if (eventTarget.classList.contains("arrowDown")) {
      self2.changeYear(self2.currentYear - 1);
    }
  }
  function timeWrapper(e3) {
    e3.preventDefault();
    var isKeyDown2 = e3.type === "keydown", eventTarget = getEventTarget(e3), input = eventTarget;
    if (self2.amPM !== void 0 && eventTarget === self2.amPM) {
      self2.amPM.textContent = self2.l10n.amPM[int(self2.amPM.textContent === self2.l10n.amPM[0])];
    }
    var min2 = parseFloat(input.getAttribute("min")), max2 = parseFloat(input.getAttribute("max")), step = parseFloat(input.getAttribute("step")), curValue = parseInt(input.value, 10), delta = e3.delta || (isKeyDown2 ? e3.which === 38 ? 1 : -1 : 0);
    var newValue = curValue + step * delta;
    if (typeof input.value !== "undefined" && input.value.length === 2) {
      var isHourElem = input === self2.hourElement, isMinuteElem = input === self2.minuteElement;
      if (newValue < min2) {
        newValue = max2 + newValue + int(!isHourElem) + (int(isHourElem) && int(!self2.amPM));
        if (isMinuteElem)
          incrementNumInput(void 0, -1, self2.hourElement);
      } else if (newValue > max2) {
        newValue = input === self2.hourElement ? newValue - max2 - int(!self2.amPM) : min2;
        if (isMinuteElem)
          incrementNumInput(void 0, 1, self2.hourElement);
      }
      if (self2.amPM && isHourElem && (step === 1 ? newValue + curValue === 23 : Math.abs(newValue - curValue) > step)) {
        self2.amPM.textContent = self2.l10n.amPM[int(self2.amPM.textContent === self2.l10n.amPM[0])];
      }
      input.value = pad(newValue);
    }
  }
  init2();
  return self2;
}
function _flatpickr(nodeList, config) {
  var nodes = Array.prototype.slice.call(nodeList).filter(function(x3) {
    return x3 instanceof HTMLElement;
  });
  var instances = [];
  for (var i3 = 0; i3 < nodes.length; i3++) {
    var node2 = nodes[i3];
    try {
      if (node2.getAttribute("data-fp-omit") !== null)
        continue;
      if (node2._flatpickr !== void 0) {
        node2._flatpickr.destroy();
        node2._flatpickr = void 0;
      }
      node2._flatpickr = FlatpickrInstance(node2, config || {});
      instances.push(node2._flatpickr);
    } catch (e3) {
      console.error(e3);
    }
  }
  return instances.length === 1 ? instances[0] : instances;
}
if (typeof HTMLElement !== "undefined" && typeof HTMLCollection !== "undefined" && typeof NodeList !== "undefined") {
  HTMLCollection.prototype.flatpickr = NodeList.prototype.flatpickr = function(config) {
    return _flatpickr(this, config);
  };
  HTMLElement.prototype.flatpickr = function(config) {
    return _flatpickr([this], config);
  };
}
var flatpickr = function(selector, config) {
  if (typeof selector === "string") {
    return _flatpickr(window.document.querySelectorAll(selector), config);
  } else if (selector instanceof Node) {
    return _flatpickr([selector], config);
  } else {
    return _flatpickr(selector, config);
  }
};
flatpickr.defaultConfig = {};
flatpickr.l10ns = {
  en: __assign$1({}, english),
  default: __assign$1({}, english)
};
flatpickr.localize = function(l10n) {
  flatpickr.l10ns.default = __assign$1(__assign$1({}, flatpickr.l10ns.default), l10n);
};
flatpickr.setDefaults = function(config) {
  flatpickr.defaultConfig = __assign$1(__assign$1({}, flatpickr.defaultConfig), config);
};
flatpickr.parseDate = createDateParser({});
flatpickr.formatDate = createDateFormatter({});
flatpickr.compareDates = compareDates;
if (typeof jQuery !== "undefined" && typeof jQuery.fn !== "undefined") {
  jQuery.fn.flatpickr = function(config) {
    return _flatpickr(this, config);
  };
}
Date.prototype.fp_incr = function(days) {
  return new Date(this.getFullYear(), this.getMonth(), this.getDate() + (typeof days === "string" ? parseInt(days, 10) : days));
};
if (typeof window !== "undefined") {
  window.flatpickr = flatpickr;
}
var flatpickr_min = "";
function forEvents(events2, callback) {
  events2.split(/\s+/).forEach((event) => {
    callback(event);
  });
}
class MicroEvent {
  constructor() {
    this._events = void 0;
    this._events = {};
  }
  on(events2, fct) {
    forEvents(events2, (event) => {
      const event_array = this._events[event] || [];
      event_array.push(fct);
      this._events[event] = event_array;
    });
  }
  off(events2, fct) {
    var n2 = arguments.length;
    if (n2 === 0) {
      this._events = {};
      return;
    }
    forEvents(events2, (event) => {
      if (n2 === 1) {
        delete this._events[event];
        return;
      }
      const event_array = this._events[event];
      if (event_array === void 0)
        return;
      event_array.splice(event_array.indexOf(fct), 1);
      this._events[event] = event_array;
    });
  }
  trigger(events2, ...args) {
    var self2 = this;
    forEvents(events2, (event) => {
      const event_array = self2._events[event];
      if (event_array === void 0)
        return;
      event_array.forEach((fct) => {
        fct.apply(self2, args);
      });
    });
  }
}
function MicroPlugin(Interface) {
  Interface.plugins = {};
  return class extends Interface {
    constructor(...args) {
      super(...args);
      this.plugins = {
        names: [],
        settings: {},
        requested: {},
        loaded: {}
      };
    }
    static define(name, fn3) {
      Interface.plugins[name] = {
        "name": name,
        "fn": fn3
      };
    }
    initializePlugins(plugins2) {
      var key, name;
      const self2 = this;
      const queue = [];
      if (Array.isArray(plugins2)) {
        plugins2.forEach((plugin) => {
          if (typeof plugin === "string") {
            queue.push(plugin);
          } else {
            self2.plugins.settings[plugin.name] = plugin.options;
            queue.push(plugin.name);
          }
        });
      } else if (plugins2) {
        for (key in plugins2) {
          if (plugins2.hasOwnProperty(key)) {
            self2.plugins.settings[key] = plugins2[key];
            queue.push(key);
          }
        }
      }
      while (name = queue.shift()) {
        self2.require(name);
      }
    }
    loadPlugin(name) {
      var self2 = this;
      var plugins2 = self2.plugins;
      var plugin = Interface.plugins[name];
      if (!Interface.plugins.hasOwnProperty(name)) {
        throw new Error('Unable to find "' + name + '" plugin');
      }
      plugins2.requested[name] = true;
      plugins2.loaded[name] = plugin.fn.apply(self2, [self2.plugins.settings[name] || {}]);
      plugins2.names.push(name);
    }
    require(name) {
      var self2 = this;
      var plugins2 = self2.plugins;
      if (!self2.plugins.loaded.hasOwnProperty(name)) {
        if (plugins2.requested[name]) {
          throw new Error('Plugin has circular dependency ("' + name + '")');
        }
        self2.loadPlugin(name);
      }
      return plugins2.loaded[name];
    }
  };
}
/*! @orchidjs/unicode-variants | https://github.com/orchidjs/unicode-variants | Apache License (v2) */
const arrayToPattern = (chars) => {
  chars = chars.filter(Boolean);
  if (chars.length < 2) {
    return chars[0] || "";
  }
  return maxValueLength(chars) == 1 ? "[" + chars.join("") + "]" : "(?:" + chars.join("|") + ")";
};
const sequencePattern = (array) => {
  if (!hasDuplicates(array)) {
    return array.join("");
  }
  let pattern = "";
  let prev_char_count = 0;
  const prev_pattern = () => {
    if (prev_char_count > 1) {
      pattern += "{" + prev_char_count + "}";
    }
  };
  array.forEach((char2, i3) => {
    if (char2 === array[i3 - 1]) {
      prev_char_count++;
      return;
    }
    prev_pattern();
    pattern += char2;
    prev_char_count = 1;
  });
  prev_pattern();
  return pattern;
};
const setToPattern = (chars) => {
  let array = toArray(chars);
  return arrayToPattern(array);
};
const hasDuplicates = (array) => {
  return new Set(array).size !== array.length;
};
const escape_regex = (str) => {
  return (str + "").replace(/([\$\(\)\*\+\.\?\[\]\^\{\|\}\\])/gu, "\\$1");
};
const maxValueLength = (array) => {
  return array.reduce((longest, value) => Math.max(longest, unicodeLength(value)), 0);
};
const unicodeLength = (str) => {
  return toArray(str).length;
};
const toArray = (p2) => Array.from(p2);
/*! @orchidjs/unicode-variants | https://github.com/orchidjs/unicode-variants | Apache License (v2) */
const allSubstrings = (input) => {
  if (input.length === 1)
    return [[input]];
  let result = [];
  const start2 = input.substring(1);
  const suba = allSubstrings(start2);
  suba.forEach(function(subresult) {
    let tmp = subresult.slice(0);
    tmp[0] = input.charAt(0) + tmp[0];
    result.push(tmp);
    tmp = subresult.slice(0);
    tmp.unshift(input.charAt(0));
    result.push(tmp);
  });
  return result;
};
/*! @orchidjs/unicode-variants | https://github.com/orchidjs/unicode-variants | Apache License (v2) */
const code_points = [[0, 65535]];
const accent_pat = "[\u0300-\u036F\xB7\u02BE\u02BC]";
let unicode_map;
let multi_char_reg;
const max_char_length = 3;
const latin_convert = {};
const latin_condensed = {
  "/": "\u2044\u2215",
  "0": "\u07C0",
  "a": "\u2C65\u0250\u0251",
  "aa": "\uA733",
  "ae": "\xE6\u01FD\u01E3",
  "ao": "\uA735",
  "au": "\uA737",
  "av": "\uA739\uA73B",
  "ay": "\uA73D",
  "b": "\u0180\u0253\u0183",
  "c": "\uA73F\u0188\u023C\u2184",
  "d": "\u0111\u0257\u0256\u1D05\u018C\uABB7\u0501\u0266",
  "e": "\u025B\u01DD\u1D07\u0247",
  "f": "\uA77C\u0192",
  "g": "\u01E5\u0260\uA7A1\u1D79\uA77F\u0262",
  "h": "\u0127\u2C68\u2C76\u0265",
  "i": "\u0268\u0131",
  "j": "\u0249\u0237",
  "k": "\u0199\u2C6A\uA741\uA743\uA745\uA7A3",
  "l": "\u0142\u019A\u026B\u2C61\uA749\uA747\uA781\u026D",
  "m": "\u0271\u026F\u03FB",
  "n": "\uA7A5\u019E\u0272\uA791\u1D0E\u043B\u0509",
  "o": "\xF8\u01FF\u0254\u0275\uA74B\uA74D\u1D11",
  "oe": "\u0153",
  "oi": "\u01A3",
  "oo": "\uA74F",
  "ou": "\u0223",
  "p": "\u01A5\u1D7D\uA751\uA753\uA755\u03C1",
  "q": "\uA757\uA759\u024B",
  "r": "\u024D\u027D\uA75B\uA7A7\uA783",
  "s": "\xDF\u023F\uA7A9\uA785\u0282",
  "t": "\u0167\u01AD\u0288\u2C66\uA787",
  "th": "\xFE",
  "tz": "\uA729",
  "u": "\u0289",
  "v": "\u028B\uA75F\u028C",
  "vy": "\uA761",
  "w": "\u2C73",
  "y": "\u01B4\u024F\u1EFF",
  "z": "\u01B6\u0225\u0240\u2C6C\uA763",
  "hv": "\u0195"
};
for (let latin in latin_condensed) {
  let unicode = latin_condensed[latin] || "";
  for (let i3 = 0; i3 < unicode.length; i3++) {
    let char2 = unicode.substring(i3, i3 + 1);
    latin_convert[char2] = latin;
  }
}
const convert_pat = new RegExp(Object.keys(latin_convert).join("|") + "|" + accent_pat, "gu");
const initialize = (_code_points) => {
  if (unicode_map !== void 0)
    return;
  unicode_map = generateMap(_code_points || code_points);
};
const normalize$1 = (str, form = "NFKD") => str.normalize(form);
const asciifold = (str) => {
  return toArray(str).reduce(
    (result, char2) => {
      return result + _asciifold(char2);
    },
    ""
  );
};
const _asciifold = (str) => {
  str = normalize$1(str).toLowerCase().replace(convert_pat, (char2) => {
    return latin_convert[char2] || "";
  });
  return normalize$1(str, "NFC");
};
function* generator(code_points2) {
  for (const [code_point_min, code_point_max] of code_points2) {
    for (let i3 = code_point_min; i3 <= code_point_max; i3++) {
      let composed = String.fromCharCode(i3);
      let folded = asciifold(composed);
      if (folded == composed.toLowerCase()) {
        continue;
      }
      if (folded.length > max_char_length) {
        continue;
      }
      if (folded.length == 0) {
        continue;
      }
      yield {
        folded,
        composed,
        code_point: i3
      };
    }
  }
}
const generateSets = (code_points2) => {
  const unicode_sets = {};
  const addMatching = (folded, to_add) => {
    const folded_set = unicode_sets[folded] || /* @__PURE__ */ new Set();
    const patt = new RegExp("^" + setToPattern(folded_set) + "$", "iu");
    if (to_add.match(patt)) {
      return;
    }
    folded_set.add(escape_regex(to_add));
    unicode_sets[folded] = folded_set;
  };
  for (let value of generator(code_points2)) {
    addMatching(value.folded, value.folded);
    addMatching(value.folded, value.composed);
  }
  return unicode_sets;
};
const generateMap = (code_points2) => {
  const unicode_sets = generateSets(code_points2);
  const unicode_map2 = {};
  let multi_char = [];
  for (let folded in unicode_sets) {
    let set2 = unicode_sets[folded];
    if (set2) {
      unicode_map2[folded] = setToPattern(set2);
    }
    if (folded.length > 1) {
      multi_char.push(escape_regex(folded));
    }
  }
  multi_char.sort((a4, b3) => b3.length - a4.length);
  const multi_char_patt = arrayToPattern(multi_char);
  multi_char_reg = new RegExp("^" + multi_char_patt, "u");
  return unicode_map2;
};
const mapSequence = (strings, min_replacement = 1) => {
  let chars_replaced = 0;
  strings = strings.map((str) => {
    if (unicode_map[str]) {
      chars_replaced += str.length;
    }
    return unicode_map[str] || str;
  });
  if (chars_replaced >= min_replacement) {
    return sequencePattern(strings);
  }
  return "";
};
const substringsToPattern = (str, min_replacement = 1) => {
  min_replacement = Math.max(min_replacement, str.length - 1);
  return arrayToPattern(allSubstrings(str).map((sub_pat) => {
    return mapSequence(sub_pat, min_replacement);
  }));
};
const sequencesToPattern = (sequences, all = true) => {
  let min_replacement = sequences.length > 1 ? 1 : 0;
  return arrayToPattern(sequences.map((sequence) => {
    let seq = [];
    const len = all ? sequence.length() : sequence.length() - 1;
    for (let j2 = 0; j2 < len; j2++) {
      seq.push(substringsToPattern(sequence.substrs[j2] || "", min_replacement));
    }
    return sequencePattern(seq);
  }));
};
const inSequences = (needle_seq, sequences) => {
  for (const seq of sequences) {
    if (seq.start != needle_seq.start || seq.end != needle_seq.end) {
      continue;
    }
    if (seq.substrs.join("") !== needle_seq.substrs.join("")) {
      continue;
    }
    let needle_parts = needle_seq.parts;
    const filter = (part) => {
      for (const needle_part of needle_parts) {
        if (needle_part.start === part.start && needle_part.substr === part.substr) {
          return false;
        }
        if (part.length == 1 || needle_part.length == 1) {
          continue;
        }
        if (part.start < needle_part.start && part.end > needle_part.start) {
          return true;
        }
        if (needle_part.start < part.start && needle_part.end > part.start) {
          return true;
        }
      }
      return false;
    };
    let filtered = seq.parts.filter(filter);
    if (filtered.length > 0) {
      continue;
    }
    return true;
  }
  return false;
};
class Sequence {
  constructor() {
    this.parts = [];
    this.substrs = [];
    this.start = 0;
    this.end = 0;
  }
  add(part) {
    if (part) {
      this.parts.push(part);
      this.substrs.push(part.substr);
      this.start = Math.min(part.start, this.start);
      this.end = Math.max(part.end, this.end);
    }
  }
  last() {
    return this.parts[this.parts.length - 1];
  }
  length() {
    return this.parts.length;
  }
  clone(position2, last_piece) {
    let clone2 = new Sequence();
    let parts = JSON.parse(JSON.stringify(this.parts));
    let last_part = parts.pop();
    for (const part of parts) {
      clone2.add(part);
    }
    let last_substr = last_piece.substr.substring(0, position2 - last_part.start);
    let clone_last_len = last_substr.length;
    clone2.add({
      start: last_part.start,
      end: last_part.start + clone_last_len,
      length: clone_last_len,
      substr: last_substr
    });
    return clone2;
  }
}
const getPattern = (str) => {
  initialize();
  str = asciifold(str);
  let pattern = "";
  let sequences = [new Sequence()];
  for (let i3 = 0; i3 < str.length; i3++) {
    let substr2 = str.substring(i3);
    let match2 = substr2.match(multi_char_reg);
    const char2 = str.substring(i3, i3 + 1);
    const match_str = match2 ? match2[0] : null;
    let overlapping = [];
    let added_types = /* @__PURE__ */ new Set();
    for (const sequence of sequences) {
      const last_piece = sequence.last();
      if (!last_piece || last_piece.length == 1 || last_piece.end <= i3) {
        if (match_str) {
          const len = match_str.length;
          sequence.add({
            start: i3,
            end: i3 + len,
            length: len,
            substr: match_str
          });
          added_types.add("1");
        } else {
          sequence.add({
            start: i3,
            end: i3 + 1,
            length: 1,
            substr: char2
          });
          added_types.add("2");
        }
      } else if (match_str) {
        let clone2 = sequence.clone(i3, last_piece);
        const len = match_str.length;
        clone2.add({
          start: i3,
          end: i3 + len,
          length: len,
          substr: match_str
        });
        overlapping.push(clone2);
      } else {
        added_types.add("3");
      }
    }
    if (overlapping.length > 0) {
      overlapping = overlapping.sort((a4, b3) => {
        return a4.length() - b3.length();
      });
      for (let clone2 of overlapping) {
        if (inSequences(clone2, sequences)) {
          continue;
        }
        sequences.push(clone2);
      }
      continue;
    }
    if (i3 > 0 && added_types.size == 1 && !added_types.has("3")) {
      pattern += sequencesToPattern(sequences, false);
      let new_seq = new Sequence();
      const old_seq = sequences[0];
      if (old_seq) {
        new_seq.add(old_seq.last());
      }
      sequences = [new_seq];
    }
  }
  pattern += sequencesToPattern(sequences, true);
  return pattern;
};
/*! sifter.js | https://github.com/orchidjs/sifter.js | Apache License (v2) */
const getAttr = (obj, name) => {
  if (!obj)
    return;
  return obj[name];
};
const getAttrNesting = (obj, name) => {
  if (!obj)
    return;
  var part, names = name.split(".");
  while ((part = names.shift()) && (obj = obj[part]))
    ;
  return obj;
};
const scoreValue = (value, token2, weight) => {
  var score, pos;
  if (!value)
    return 0;
  value = value + "";
  if (token2.regex == null)
    return 0;
  pos = value.search(token2.regex);
  if (pos === -1)
    return 0;
  score = token2.string.length / value.length;
  if (pos === 0)
    score += 0.5;
  return score * weight;
};
const propToArray = (obj, key) => {
  var value = obj[key];
  if (typeof value == "function")
    return value;
  if (value && !Array.isArray(value)) {
    obj[key] = [value];
  }
};
const iterate$1 = (object, callback) => {
  if (Array.isArray(object)) {
    object.forEach(callback);
  } else {
    for (var key in object) {
      if (object.hasOwnProperty(key)) {
        callback(object[key], key);
      }
    }
  }
};
const cmp$1 = (a4, b3) => {
  if (typeof a4 === "number" && typeof b3 === "number") {
    return a4 > b3 ? 1 : a4 < b3 ? -1 : 0;
  }
  a4 = asciifold(a4 + "").toLowerCase();
  b3 = asciifold(b3 + "").toLowerCase();
  if (a4 > b3)
    return 1;
  if (b3 > a4)
    return -1;
  return 0;
};
/*! sifter.js | https://github.com/orchidjs/sifter.js | Apache License (v2) */
class Sifter {
  constructor(items, settings) {
    this.items = void 0;
    this.settings = void 0;
    this.items = items;
    this.settings = settings || {
      diacritics: true
    };
  }
  tokenize(query, respect_word_boundaries, weights) {
    if (!query || !query.length)
      return [];
    const tokens = [];
    const words = query.split(/\s+/);
    var field_regex;
    if (weights) {
      field_regex = new RegExp("^(" + Object.keys(weights).map(escape_regex).join("|") + "):(.*)$");
    }
    words.forEach((word) => {
      let field_match;
      let field = null;
      let regex = null;
      if (field_regex && (field_match = word.match(field_regex))) {
        field = field_match[1];
        word = field_match[2];
      }
      if (word.length > 0) {
        if (this.settings.diacritics) {
          regex = getPattern(word) || null;
        } else {
          regex = escape_regex(word);
        }
        if (regex && respect_word_boundaries)
          regex = "\\b" + regex;
      }
      tokens.push({
        string: word,
        regex: regex ? new RegExp(regex, "iu") : null,
        field
      });
    });
    return tokens;
  }
  getScoreFunction(query, options) {
    var search = this.prepareSearch(query, options);
    return this._getScoreFunction(search);
  }
  _getScoreFunction(search) {
    const tokens = search.tokens, token_count = tokens.length;
    if (!token_count) {
      return function() {
        return 0;
      };
    }
    const fields = search.options.fields, weights = search.weights, field_count = fields.length, getAttrFn = search.getAttrFn;
    if (!field_count) {
      return function() {
        return 1;
      };
    }
    const scoreObject = function() {
      if (field_count === 1) {
        return function(token2, data) {
          const field = fields[0].field;
          return scoreValue(getAttrFn(data, field), token2, weights[field] || 1);
        };
      }
      return function(token2, data) {
        var sum = 0;
        if (token2.field) {
          const value = getAttrFn(data, token2.field);
          if (!token2.regex && value) {
            sum += 1 / field_count;
          } else {
            sum += scoreValue(value, token2, 1);
          }
        } else {
          iterate$1(weights, (weight, field) => {
            sum += scoreValue(getAttrFn(data, field), token2, weight);
          });
        }
        return sum / field_count;
      };
    }();
    if (token_count === 1) {
      return function(data) {
        return scoreObject(tokens[0], data);
      };
    }
    if (search.options.conjunction === "and") {
      return function(data) {
        var score, sum = 0;
        for (let token2 of tokens) {
          score = scoreObject(token2, data);
          if (score <= 0)
            return 0;
          sum += score;
        }
        return sum / token_count;
      };
    } else {
      return function(data) {
        var sum = 0;
        iterate$1(tokens, (token2) => {
          sum += scoreObject(token2, data);
        });
        return sum / token_count;
      };
    }
  }
  getSortFunction(query, options) {
    var search = this.prepareSearch(query, options);
    return this._getSortFunction(search);
  }
  _getSortFunction(search) {
    var implicit_score, sort_flds = [];
    const self2 = this, options = search.options, sort2 = !search.query && options.sort_empty ? options.sort_empty : options.sort;
    if (typeof sort2 == "function") {
      return sort2.bind(this);
    }
    const get_field = function get_field2(name, result) {
      if (name === "$score")
        return result.score;
      return search.getAttrFn(self2.items[result.id], name);
    };
    if (sort2) {
      for (let s4 of sort2) {
        if (search.query || s4.field !== "$score") {
          sort_flds.push(s4);
        }
      }
    }
    if (search.query) {
      implicit_score = true;
      for (let fld of sort_flds) {
        if (fld.field === "$score") {
          implicit_score = false;
          break;
        }
      }
      if (implicit_score) {
        sort_flds.unshift({
          field: "$score",
          direction: "desc"
        });
      }
    } else {
      sort_flds = sort_flds.filter((fld) => fld.field !== "$score");
    }
    const sort_flds_count = sort_flds.length;
    if (!sort_flds_count) {
      return null;
    }
    return function(a4, b3) {
      var result, field;
      for (let sort_fld of sort_flds) {
        field = sort_fld.field;
        let multiplier = sort_fld.direction === "desc" ? -1 : 1;
        result = multiplier * cmp$1(get_field(field, a4), get_field(field, b3));
        if (result)
          return result;
      }
      return 0;
    };
  }
  prepareSearch(query, optsUser) {
    const weights = {};
    var options = Object.assign({}, optsUser);
    propToArray(options, "sort");
    propToArray(options, "sort_empty");
    if (options.fields) {
      propToArray(options, "fields");
      const fields = [];
      options.fields.forEach((field) => {
        if (typeof field == "string") {
          field = {
            field,
            weight: 1
          };
        }
        fields.push(field);
        weights[field.field] = "weight" in field ? field.weight : 1;
      });
      options.fields = fields;
    }
    return {
      options,
      query: query.toLowerCase().trim(),
      tokens: this.tokenize(query, options.respect_word_boundaries, weights),
      total: 0,
      items: [],
      weights,
      getAttrFn: options.nesting ? getAttrNesting : getAttr
    };
  }
  search(query, options) {
    var self2 = this, score, search;
    search = this.prepareSearch(query, options);
    options = search.options;
    query = search.query;
    const fn_score = options.score || self2._getScoreFunction(search);
    if (query.length) {
      iterate$1(self2.items, (item2, id2) => {
        score = fn_score(item2);
        if (options.filter === false || score > 0) {
          search.items.push({
            "score": score,
            "id": id2
          });
        }
      });
    } else {
      iterate$1(self2.items, (_2, id2) => {
        search.items.push({
          "score": 1,
          "id": id2
        });
      });
    }
    const fn_sort = self2._getSortFunction(search);
    if (fn_sort)
      search.items.sort(fn_sort);
    search.total = search.items.length;
    if (typeof options.limit === "number") {
      search.items = search.items.slice(0, options.limit);
    }
    return search;
  }
}
const iterate = (object, callback) => {
  if (Array.isArray(object)) {
    object.forEach(callback);
  } else {
    for (var key in object) {
      if (object.hasOwnProperty(key)) {
        callback(object[key], key);
      }
    }
  }
};
const getDom = (query) => {
  if (query.jquery) {
    return query[0];
  }
  if (query instanceof HTMLElement) {
    return query;
  }
  if (isHtmlString(query)) {
    var tpl = document.createElement("template");
    tpl.innerHTML = query.trim();
    return tpl.content.firstChild;
  }
  return document.querySelector(query);
};
const isHtmlString = (arg) => {
  if (typeof arg === "string" && arg.indexOf("<") > -1) {
    return true;
  }
  return false;
};
const escapeQuery = (query) => {
  return query.replace(/['"\\]/g, "\\$&");
};
const triggerEvent = (dom_el, event_name) => {
  var event = document.createEvent("HTMLEvents");
  event.initEvent(event_name, true, false);
  dom_el.dispatchEvent(event);
};
const applyCSS = (dom_el, css2) => {
  Object.assign(dom_el.style, css2);
};
const addClasses = (elmts, ...classes) => {
  var norm_classes = classesArray(classes);
  elmts = castAsArray(elmts);
  elmts.map((el2) => {
    norm_classes.map((cls) => {
      el2.classList.add(cls);
    });
  });
};
const removeClasses = (elmts, ...classes) => {
  var norm_classes = classesArray(classes);
  elmts = castAsArray(elmts);
  elmts.map((el2) => {
    norm_classes.map((cls) => {
      el2.classList.remove(cls);
    });
  });
};
const classesArray = (args) => {
  var classes = [];
  iterate(args, (_classes) => {
    if (typeof _classes === "string") {
      _classes = _classes.trim().split(/[\11\12\14\15\40]/);
    }
    if (Array.isArray(_classes)) {
      classes = classes.concat(_classes);
    }
  });
  return classes.filter(Boolean);
};
const castAsArray = (arg) => {
  if (!Array.isArray(arg)) {
    arg = [arg];
  }
  return arg;
};
const parentMatch = (target, selector, wrapper) => {
  if (wrapper && !wrapper.contains(target)) {
    return;
  }
  while (target && target.matches) {
    if (target.matches(selector)) {
      return target;
    }
    target = target.parentNode;
  }
};
const getTail = (list, direction = 0) => {
  if (direction > 0) {
    return list[list.length - 1];
  }
  return list[0];
};
const isEmptyObject$1 = (obj) => {
  return Object.keys(obj).length === 0;
};
const nodeIndex = (el2, amongst) => {
  if (!el2)
    return -1;
  amongst = amongst || el2.nodeName;
  var i3 = 0;
  while (el2 = el2.previousElementSibling) {
    if (el2.matches(amongst)) {
      i3++;
    }
  }
  return i3;
};
const setAttr = (el2, attrs) => {
  iterate(attrs, (val, attr) => {
    if (val == null) {
      el2.removeAttribute(attr);
    } else {
      el2.setAttribute(attr, "" + val);
    }
  });
};
const replaceNode = (existing, replacement) => {
  if (existing.parentNode)
    existing.parentNode.replaceChild(replacement, existing);
};
const highlight = (element, regex) => {
  if (regex === null)
    return;
  if (typeof regex === "string") {
    if (!regex.length)
      return;
    regex = new RegExp(regex, "i");
  }
  const highlightText = (node2) => {
    var match2 = node2.data.match(regex);
    if (match2 && node2.data.length > 0) {
      var spannode = document.createElement("span");
      spannode.className = "highlight";
      var middlebit = node2.splitText(match2.index);
      middlebit.splitText(match2[0].length);
      var middleclone = middlebit.cloneNode(true);
      spannode.appendChild(middleclone);
      replaceNode(middlebit, spannode);
      return 1;
    }
    return 0;
  };
  const highlightChildren = (node2) => {
    if (node2.nodeType === 1 && node2.childNodes && !/(script|style)/i.test(node2.tagName) && (node2.className !== "highlight" || node2.tagName !== "SPAN")) {
      Array.from(node2.childNodes).forEach((element2) => {
        highlightRecursive(element2);
      });
    }
  };
  const highlightRecursive = (node2) => {
    if (node2.nodeType === 3) {
      return highlightText(node2);
    }
    highlightChildren(node2);
    return 0;
  };
  highlightRecursive(element);
};
const removeHighlight = (el2) => {
  var elements = el2.querySelectorAll("span.highlight");
  Array.prototype.forEach.call(elements, function(el3) {
    var parent = el3.parentNode;
    parent.replaceChild(el3.firstChild, el3);
    parent.normalize();
  });
};
const KEY_A = 65;
const KEY_RETURN = 13;
const KEY_ESC = 27;
const KEY_LEFT = 37;
const KEY_UP = 38;
const KEY_RIGHT = 39;
const KEY_DOWN = 40;
const KEY_BACKSPACE = 8;
const KEY_DELETE = 46;
const KEY_TAB = 9;
const IS_MAC = typeof navigator === "undefined" ? false : /Mac/.test(navigator.userAgent);
const KEY_SHORTCUT = IS_MAC ? "metaKey" : "ctrlKey";
var defaults$2 = {
  options: [],
  optgroups: [],
  plugins: [],
  delimiter: ",",
  splitOn: null,
  persist: true,
  diacritics: true,
  create: null,
  createOnBlur: false,
  createFilter: null,
  highlight: true,
  openOnFocus: true,
  shouldOpen: null,
  maxOptions: 50,
  maxItems: null,
  hideSelected: null,
  duplicates: false,
  addPrecedence: false,
  selectOnTab: false,
  preload: null,
  allowEmptyOption: false,
  loadThrottle: 300,
  loadingClass: "loading",
  dataAttr: null,
  optgroupField: "optgroup",
  valueField: "value",
  labelField: "text",
  disabledField: "disabled",
  optgroupLabelField: "label",
  optgroupValueField: "value",
  lockOptgroupOrder: false,
  sortField: "$order",
  searchField: ["text"],
  searchConjunction: "and",
  mode: null,
  wrapperClass: "ts-wrapper",
  controlClass: "ts-control",
  dropdownClass: "ts-dropdown",
  dropdownContentClass: "ts-dropdown-content",
  itemClass: "item",
  optionClass: "option",
  dropdownParent: null,
  controlInput: '<input type="text" autocomplete="off" size="1" />',
  copyClassesToDropdown: false,
  placeholder: null,
  hidePlaceholder: null,
  shouldLoad: function(query) {
    return query.length > 0;
  },
  render: {}
};
const hash_key = (value) => {
  if (typeof value === "undefined" || value === null)
    return null;
  return get_hash(value);
};
const get_hash = (value) => {
  if (typeof value === "boolean")
    return value ? "1" : "0";
  return value + "";
};
const escape_html = (str) => {
  return (str + "").replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;");
};
const loadDebounce = (fn3, delay) => {
  var timeout;
  return function(value, callback) {
    var self2 = this;
    if (timeout) {
      self2.loading = Math.max(self2.loading - 1, 0);
      clearTimeout(timeout);
    }
    timeout = setTimeout(function() {
      timeout = null;
      self2.loadedSearches[value] = true;
      fn3.call(self2, value, callback);
    }, delay);
  };
};
const debounce_events = (self2, types, fn3) => {
  var type;
  var trigger = self2.trigger;
  var event_args = {};
  self2.trigger = function() {
    var type2 = arguments[0];
    if (types.indexOf(type2) !== -1) {
      event_args[type2] = arguments;
    } else {
      return trigger.apply(self2, arguments);
    }
  };
  fn3.apply(self2, []);
  self2.trigger = trigger;
  for (type of types) {
    if (type in event_args) {
      trigger.apply(self2, event_args[type]);
    }
  }
};
const getSelection$1 = (input) => {
  return {
    start: input.selectionStart || 0,
    length: (input.selectionEnd || 0) - (input.selectionStart || 0)
  };
};
const preventDefault = (evt, stop = false) => {
  if (evt) {
    evt.preventDefault();
    if (stop) {
      evt.stopPropagation();
    }
  }
};
const addEvent = (target, type, callback, options) => {
  target.addEventListener(type, callback, options);
};
const isKeyDown = (key_name, evt) => {
  if (!evt) {
    return false;
  }
  if (!evt[key_name]) {
    return false;
  }
  var count = (evt.altKey ? 1 : 0) + (evt.ctrlKey ? 1 : 0) + (evt.shiftKey ? 1 : 0) + (evt.metaKey ? 1 : 0);
  if (count === 1) {
    return true;
  }
  return false;
};
const getId = (el2, id2) => {
  const existing_id = el2.getAttribute("id");
  if (existing_id) {
    return existing_id;
  }
  el2.setAttribute("id", id2);
  return id2;
};
const addSlashes = (str) => {
  return str.replace(/[\\"']/g, "\\$&");
};
const append = (parent, node2) => {
  if (node2)
    parent.append(node2);
};
function getSettings(input, settings_user) {
  var settings = Object.assign({}, defaults$2, settings_user);
  var attr_data = settings.dataAttr;
  var field_label = settings.labelField;
  var field_value = settings.valueField;
  var field_disabled = settings.disabledField;
  var field_optgroup = settings.optgroupField;
  var field_optgroup_label = settings.optgroupLabelField;
  var field_optgroup_value = settings.optgroupValueField;
  var tag_name = input.tagName.toLowerCase();
  var placeholder = input.getAttribute("placeholder") || input.getAttribute("data-placeholder");
  if (!placeholder && !settings.allowEmptyOption) {
    let option2 = input.querySelector('option[value=""]');
    if (option2) {
      placeholder = option2.textContent;
    }
  }
  var settings_element = {
    placeholder,
    options: [],
    optgroups: [],
    items: [],
    maxItems: null
  };
  var init_select = () => {
    var tagName;
    var options = settings_element.options;
    var optionsMap = {};
    var group_count = 1;
    var readData = (el2) => {
      var data = Object.assign({}, el2.dataset);
      var json = attr_data && data[attr_data];
      if (typeof json === "string" && json.length) {
        data = Object.assign(data, JSON.parse(json));
      }
      return data;
    };
    var addOption = (option2, group) => {
      var value = hash_key(option2.value);
      if (value == null)
        return;
      if (!value && !settings.allowEmptyOption)
        return;
      if (optionsMap.hasOwnProperty(value)) {
        if (group) {
          var arr = optionsMap[value][field_optgroup];
          if (!arr) {
            optionsMap[value][field_optgroup] = group;
          } else if (!Array.isArray(arr)) {
            optionsMap[value][field_optgroup] = [arr, group];
          } else {
            arr.push(group);
          }
        }
      } else {
        var option_data = readData(option2);
        option_data[field_label] = option_data[field_label] || option2.textContent;
        option_data[field_value] = option_data[field_value] || value;
        option_data[field_disabled] = option_data[field_disabled] || option2.disabled;
        option_data[field_optgroup] = option_data[field_optgroup] || group;
        option_data.$option = option2;
        optionsMap[value] = option_data;
        options.push(option_data);
      }
      if (option2.selected) {
        settings_element.items.push(value);
      }
    };
    var addGroup = (optgroup) => {
      var id2, optgroup_data;
      optgroup_data = readData(optgroup);
      optgroup_data[field_optgroup_label] = optgroup_data[field_optgroup_label] || optgroup.getAttribute("label") || "";
      optgroup_data[field_optgroup_value] = optgroup_data[field_optgroup_value] || group_count++;
      optgroup_data[field_disabled] = optgroup_data[field_disabled] || optgroup.disabled;
      settings_element.optgroups.push(optgroup_data);
      id2 = optgroup_data[field_optgroup_value];
      iterate(optgroup.children, (option2) => {
        addOption(option2, id2);
      });
    };
    settings_element.maxItems = input.hasAttribute("multiple") ? null : 1;
    iterate(input.children, (child) => {
      tagName = child.tagName.toLowerCase();
      if (tagName === "optgroup") {
        addGroup(child);
      } else if (tagName === "option") {
        addOption(child);
      }
    });
  };
  var init_textbox = () => {
    const data_raw = input.getAttribute(attr_data);
    if (!data_raw) {
      var value = input.value.trim() || "";
      if (!settings.allowEmptyOption && !value.length)
        return;
      const values = value.split(settings.delimiter);
      iterate(values, (value2) => {
        const option2 = {};
        option2[field_label] = value2;
        option2[field_value] = value2;
        settings_element.options.push(option2);
      });
      settings_element.items = values;
    } else {
      settings_element.options = JSON.parse(data_raw);
      iterate(settings_element.options, (opt) => {
        settings_element.items.push(opt[field_value]);
      });
    }
  };
  if (tag_name === "select") {
    init_select();
  } else {
    init_textbox();
  }
  return Object.assign({}, defaults$2, settings_element, settings_user);
}
var instance_i = 0;
class TomSelect extends MicroPlugin(MicroEvent) {
  constructor(input_arg, user_settings) {
    super();
    this.control_input = void 0;
    this.wrapper = void 0;
    this.dropdown = void 0;
    this.control = void 0;
    this.dropdown_content = void 0;
    this.focus_node = void 0;
    this.order = 0;
    this.settings = void 0;
    this.input = void 0;
    this.tabIndex = void 0;
    this.is_select_tag = void 0;
    this.rtl = void 0;
    this.inputId = void 0;
    this._destroy = void 0;
    this.sifter = void 0;
    this.isOpen = false;
    this.isDisabled = false;
    this.isRequired = void 0;
    this.isInvalid = false;
    this.isValid = true;
    this.isLocked = false;
    this.isFocused = false;
    this.isInputHidden = false;
    this.isSetup = false;
    this.ignoreFocus = false;
    this.ignoreHover = false;
    this.hasOptions = false;
    this.currentResults = void 0;
    this.lastValue = "";
    this.caretPos = 0;
    this.loading = 0;
    this.loadedSearches = {};
    this.activeOption = null;
    this.activeItems = [];
    this.optgroups = {};
    this.options = {};
    this.userOptions = {};
    this.items = [];
    instance_i++;
    var dir;
    var input = getDom(input_arg);
    if (input.tomselect) {
      throw new Error("Tom Select already initialized on this element");
    }
    input.tomselect = this;
    var computedStyle = window.getComputedStyle && window.getComputedStyle(input, null);
    dir = computedStyle.getPropertyValue("direction");
    const settings = getSettings(input, user_settings);
    this.settings = settings;
    this.input = input;
    this.tabIndex = input.tabIndex || 0;
    this.is_select_tag = input.tagName.toLowerCase() === "select";
    this.rtl = /rtl/i.test(dir);
    this.inputId = getId(input, "tomselect-" + instance_i);
    this.isRequired = input.required;
    this.sifter = new Sifter(this.options, {
      diacritics: settings.diacritics
    });
    settings.mode = settings.mode || (settings.maxItems === 1 ? "single" : "multi");
    if (typeof settings.hideSelected !== "boolean") {
      settings.hideSelected = settings.mode === "multi";
    }
    if (typeof settings.hidePlaceholder !== "boolean") {
      settings.hidePlaceholder = settings.mode !== "multi";
    }
    var filter = settings.createFilter;
    if (typeof filter !== "function") {
      if (typeof filter === "string") {
        filter = new RegExp(filter);
      }
      if (filter instanceof RegExp) {
        settings.createFilter = (input2) => filter.test(input2);
      } else {
        settings.createFilter = (value) => {
          return this.settings.duplicates || !this.options[value];
        };
      }
    }
    this.initializePlugins(settings.plugins);
    this.setupCallbacks();
    this.setupTemplates();
    const wrapper = getDom("<div>");
    const control = getDom("<div>");
    const dropdown = this._render("dropdown");
    const dropdown_content = getDom(`<div role="listbox" tabindex="-1">`);
    const classes = this.input.getAttribute("class") || "";
    const inputMode = settings.mode;
    var control_input;
    addClasses(wrapper, settings.wrapperClass, classes, inputMode);
    addClasses(control, settings.controlClass);
    append(wrapper, control);
    addClasses(dropdown, settings.dropdownClass, inputMode);
    if (settings.copyClassesToDropdown) {
      addClasses(dropdown, classes);
    }
    addClasses(dropdown_content, settings.dropdownContentClass);
    append(dropdown, dropdown_content);
    getDom(settings.dropdownParent || wrapper).appendChild(dropdown);
    if (isHtmlString(settings.controlInput)) {
      control_input = getDom(settings.controlInput);
      var attrs = ["autocorrect", "autocapitalize", "autocomplete"];
      iterate$1(attrs, (attr) => {
        if (input.getAttribute(attr)) {
          setAttr(control_input, {
            [attr]: input.getAttribute(attr)
          });
        }
      });
      control_input.tabIndex = -1;
      control.appendChild(control_input);
      this.focus_node = control_input;
    } else if (settings.controlInput) {
      control_input = getDom(settings.controlInput);
      this.focus_node = control_input;
    } else {
      control_input = getDom("<input/>");
      this.focus_node = control;
    }
    this.wrapper = wrapper;
    this.dropdown = dropdown;
    this.dropdown_content = dropdown_content;
    this.control = control;
    this.control_input = control_input;
    this.setup();
  }
  setup() {
    const self2 = this;
    const settings = self2.settings;
    const control_input = self2.control_input;
    const dropdown = self2.dropdown;
    const dropdown_content = self2.dropdown_content;
    const wrapper = self2.wrapper;
    const control = self2.control;
    const input = self2.input;
    const focus_node = self2.focus_node;
    const passive_event = {
      passive: true
    };
    const listboxId = self2.inputId + "-ts-dropdown";
    setAttr(dropdown_content, {
      id: listboxId
    });
    setAttr(focus_node, {
      role: "combobox",
      "aria-haspopup": "listbox",
      "aria-expanded": "false",
      "aria-controls": listboxId
    });
    const control_id = getId(focus_node, self2.inputId + "-ts-control");
    const query = "label[for='" + escapeQuery(self2.inputId) + "']";
    const label = document.querySelector(query);
    const label_click = self2.focus.bind(self2);
    if (label) {
      addEvent(label, "click", label_click);
      setAttr(label, {
        for: control_id
      });
      const label_id = getId(label, self2.inputId + "-ts-label");
      setAttr(focus_node, {
        "aria-labelledby": label_id
      });
      setAttr(dropdown_content, {
        "aria-labelledby": label_id
      });
    }
    wrapper.style.width = input.style.width;
    if (self2.plugins.names.length) {
      const classes_plugins = "plugin-" + self2.plugins.names.join(" plugin-");
      addClasses([wrapper, dropdown], classes_plugins);
    }
    if ((settings.maxItems === null || settings.maxItems > 1) && self2.is_select_tag) {
      setAttr(input, {
        multiple: "multiple"
      });
    }
    if (settings.placeholder) {
      setAttr(control_input, {
        placeholder: settings.placeholder
      });
    }
    if (!settings.splitOn && settings.delimiter) {
      settings.splitOn = new RegExp("\\s*" + escape_regex(settings.delimiter) + "+\\s*");
    }
    if (settings.load && settings.loadThrottle) {
      settings.load = loadDebounce(settings.load, settings.loadThrottle);
    }
    self2.control_input.type = input.type;
    addEvent(dropdown, "mousemove", () => {
      self2.ignoreHover = false;
    });
    addEvent(dropdown, "mouseenter", (e3) => {
      var target_match = parentMatch(e3.target, "[data-selectable]", dropdown);
      if (target_match)
        self2.onOptionHover(e3, target_match);
    }, {
      capture: true
    });
    addEvent(dropdown, "click", (evt) => {
      const option2 = parentMatch(evt.target, "[data-selectable]");
      if (option2) {
        self2.onOptionSelect(evt, option2);
        preventDefault(evt, true);
      }
    });
    addEvent(control, "click", (evt) => {
      var target_match = parentMatch(evt.target, "[data-ts-item]", control);
      if (target_match && self2.onItemSelect(evt, target_match)) {
        preventDefault(evt, true);
        return;
      }
      if (control_input.value != "") {
        return;
      }
      self2.onClick();
      preventDefault(evt, true);
    });
    addEvent(focus_node, "keydown", (e3) => self2.onKeyDown(e3));
    addEvent(control_input, "keypress", (e3) => self2.onKeyPress(e3));
    addEvent(control_input, "input", (e3) => self2.onInput(e3));
    addEvent(focus_node, "blur", (e3) => self2.onBlur(e3));
    addEvent(focus_node, "focus", (e3) => self2.onFocus(e3));
    addEvent(control_input, "paste", (e3) => self2.onPaste(e3));
    const doc_mousedown = (evt) => {
      const target = evt.composedPath()[0];
      if (!wrapper.contains(target) && !dropdown.contains(target)) {
        if (self2.isFocused) {
          self2.blur();
        }
        self2.inputState();
        return;
      }
      if (target == control_input && self2.isOpen) {
        evt.stopPropagation();
      } else {
        preventDefault(evt, true);
      }
    };
    const win_scroll = () => {
      if (self2.isOpen) {
        self2.positionDropdown();
      }
    };
    addEvent(document, "mousedown", doc_mousedown);
    addEvent(window, "scroll", win_scroll, passive_event);
    addEvent(window, "resize", win_scroll, passive_event);
    this._destroy = () => {
      document.removeEventListener("mousedown", doc_mousedown);
      window.removeEventListener("scroll", win_scroll);
      window.removeEventListener("resize", win_scroll);
      if (label)
        label.removeEventListener("click", label_click);
    };
    this.revertSettings = {
      innerHTML: input.innerHTML,
      tabIndex: input.tabIndex
    };
    input.tabIndex = -1;
    input.insertAdjacentElement("afterend", self2.wrapper);
    self2.sync(false);
    settings.items = [];
    delete settings.optgroups;
    delete settings.options;
    addEvent(input, "invalid", () => {
      if (self2.isValid) {
        self2.isValid = false;
        self2.isInvalid = true;
        self2.refreshState();
      }
    });
    self2.updateOriginalInput();
    self2.refreshItems();
    self2.close(false);
    self2.inputState();
    self2.isSetup = true;
    if (input.disabled) {
      self2.disable();
    } else {
      self2.enable();
    }
    self2.on("change", this.onChange);
    addClasses(input, "tomselected", "ts-hidden-accessible");
    self2.trigger("initialize");
    if (settings.preload === true) {
      self2.preload();
    }
  }
  setupOptions(options = [], optgroups = []) {
    this.addOptions(options);
    iterate$1(optgroups, (optgroup) => {
      this.registerOptionGroup(optgroup);
    });
  }
  setupTemplates() {
    var self2 = this;
    var field_label = self2.settings.labelField;
    var field_optgroup = self2.settings.optgroupLabelField;
    var templates2 = {
      "optgroup": (data) => {
        let optgroup = document.createElement("div");
        optgroup.className = "optgroup";
        optgroup.appendChild(data.options);
        return optgroup;
      },
      "optgroup_header": (data, escape2) => {
        return '<div class="optgroup-header">' + escape2(data[field_optgroup]) + "</div>";
      },
      "option": (data, escape2) => {
        return "<div>" + escape2(data[field_label]) + "</div>";
      },
      "item": (data, escape2) => {
        return "<div>" + escape2(data[field_label]) + "</div>";
      },
      "option_create": (data, escape2) => {
        return '<div class="create">Add <strong>' + escape2(data.input) + "</strong>&hellip;</div>";
      },
      "no_results": () => {
        return '<div class="no-results">No results found</div>';
      },
      "loading": () => {
        return '<div class="spinner"></div>';
      },
      "not_loading": () => {
      },
      "dropdown": () => {
        return "<div></div>";
      }
    };
    self2.settings.render = Object.assign({}, templates2, self2.settings.render);
  }
  setupCallbacks() {
    var key, fn3;
    var callbacks = {
      "initialize": "onInitialize",
      "change": "onChange",
      "item_add": "onItemAdd",
      "item_remove": "onItemRemove",
      "item_select": "onItemSelect",
      "clear": "onClear",
      "option_add": "onOptionAdd",
      "option_remove": "onOptionRemove",
      "option_clear": "onOptionClear",
      "optgroup_add": "onOptionGroupAdd",
      "optgroup_remove": "onOptionGroupRemove",
      "optgroup_clear": "onOptionGroupClear",
      "dropdown_open": "onDropdownOpen",
      "dropdown_close": "onDropdownClose",
      "type": "onType",
      "load": "onLoad",
      "focus": "onFocus",
      "blur": "onBlur"
    };
    for (key in callbacks) {
      fn3 = this.settings[callbacks[key]];
      if (fn3)
        this.on(key, fn3);
    }
  }
  sync(get_settings = true) {
    const self2 = this;
    const settings = get_settings ? getSettings(self2.input, {
      delimiter: self2.settings.delimiter
    }) : self2.settings;
    self2.setupOptions(settings.options, settings.optgroups);
    self2.setValue(settings.items || [], true);
    self2.lastQuery = null;
  }
  onClick() {
    var self2 = this;
    if (self2.activeItems.length > 0) {
      self2.clearActiveItems();
      self2.focus();
      return;
    }
    if (self2.isFocused && self2.isOpen) {
      self2.blur();
    } else {
      self2.focus();
    }
  }
  onMouseDown() {
  }
  onChange() {
    triggerEvent(this.input, "input");
    triggerEvent(this.input, "change");
  }
  onPaste(e3) {
    var self2 = this;
    if (self2.isInputHidden || self2.isLocked) {
      preventDefault(e3);
      return;
    }
    if (!self2.settings.splitOn) {
      return;
    }
    setTimeout(() => {
      var pastedText = self2.inputValue();
      if (!pastedText.match(self2.settings.splitOn)) {
        return;
      }
      var splitInput = pastedText.trim().split(self2.settings.splitOn);
      iterate$1(splitInput, (piece) => {
        const hash2 = hash_key(piece);
        if (hash2) {
          if (this.options[piece]) {
            self2.addItem(piece);
          } else {
            self2.createItem(piece);
          }
        }
      });
    }, 0);
  }
  onKeyPress(e3) {
    var self2 = this;
    if (self2.isLocked) {
      preventDefault(e3);
      return;
    }
    var character2 = String.fromCharCode(e3.keyCode || e3.which);
    if (self2.settings.create && self2.settings.mode === "multi" && character2 === self2.settings.delimiter) {
      self2.createItem();
      preventDefault(e3);
      return;
    }
  }
  onKeyDown(e3) {
    var self2 = this;
    self2.ignoreHover = true;
    if (self2.isLocked) {
      if (e3.keyCode !== KEY_TAB) {
        preventDefault(e3);
      }
      return;
    }
    switch (e3.keyCode) {
      case KEY_A:
        if (isKeyDown(KEY_SHORTCUT, e3)) {
          if (self2.control_input.value == "") {
            preventDefault(e3);
            self2.selectAll();
            return;
          }
        }
        break;
      case KEY_ESC:
        if (self2.isOpen) {
          preventDefault(e3, true);
          self2.close();
        }
        self2.clearActiveItems();
        return;
      case KEY_DOWN:
        if (!self2.isOpen && self2.hasOptions) {
          self2.open();
        } else if (self2.activeOption) {
          let next2 = self2.getAdjacent(self2.activeOption, 1);
          if (next2)
            self2.setActiveOption(next2);
        }
        preventDefault(e3);
        return;
      case KEY_UP:
        if (self2.activeOption) {
          let prev2 = self2.getAdjacent(self2.activeOption, -1);
          if (prev2)
            self2.setActiveOption(prev2);
        }
        preventDefault(e3);
        return;
      case KEY_RETURN:
        if (self2.canSelect(self2.activeOption)) {
          self2.onOptionSelect(e3, self2.activeOption);
          preventDefault(e3);
        } else if (self2.settings.create && self2.createItem()) {
          preventDefault(e3);
        } else if (document.activeElement == self2.control_input && self2.isOpen) {
          preventDefault(e3);
        }
        return;
      case KEY_LEFT:
        self2.advanceSelection(-1, e3);
        return;
      case KEY_RIGHT:
        self2.advanceSelection(1, e3);
        return;
      case KEY_TAB:
        if (self2.settings.selectOnTab) {
          if (self2.canSelect(self2.activeOption)) {
            self2.onOptionSelect(e3, self2.activeOption);
            preventDefault(e3);
          }
          if (self2.settings.create && self2.createItem()) {
            preventDefault(e3);
          }
        }
        return;
      case KEY_BACKSPACE:
      case KEY_DELETE:
        self2.deleteSelection(e3);
        return;
    }
    if (self2.isInputHidden && !isKeyDown(KEY_SHORTCUT, e3)) {
      preventDefault(e3);
    }
  }
  onInput(e3) {
    var self2 = this;
    if (self2.isLocked) {
      return;
    }
    var value = self2.inputValue();
    if (self2.lastValue !== value) {
      self2.lastValue = value;
      if (self2.settings.shouldLoad.call(self2, value)) {
        self2.load(value);
      }
      self2.refreshOptions();
      self2.trigger("type", value);
    }
  }
  onOptionHover(evt, option2) {
    if (this.ignoreHover)
      return;
    this.setActiveOption(option2, false);
  }
  onFocus(e3) {
    var self2 = this;
    var wasFocused = self2.isFocused;
    if (self2.isDisabled) {
      self2.blur();
      preventDefault(e3);
      return;
    }
    if (self2.ignoreFocus)
      return;
    self2.isFocused = true;
    if (self2.settings.preload === "focus")
      self2.preload();
    if (!wasFocused)
      self2.trigger("focus");
    if (!self2.activeItems.length) {
      self2.showInput();
      self2.refreshOptions(!!self2.settings.openOnFocus);
    }
    self2.refreshState();
  }
  onBlur(e3) {
    if (document.hasFocus() === false)
      return;
    var self2 = this;
    if (!self2.isFocused)
      return;
    self2.isFocused = false;
    self2.ignoreFocus = false;
    var deactivate = () => {
      self2.close();
      self2.setActiveItem();
      self2.setCaret(self2.items.length);
      self2.trigger("blur");
    };
    if (self2.settings.create && self2.settings.createOnBlur) {
      self2.createItem(null, deactivate);
    } else {
      deactivate();
    }
  }
  onOptionSelect(evt, option2) {
    var value, self2 = this;
    if (option2.parentElement && option2.parentElement.matches("[data-disabled]")) {
      return;
    }
    if (option2.classList.contains("create")) {
      self2.createItem(null, () => {
        if (self2.settings.closeAfterSelect) {
          self2.close();
        }
      });
    } else {
      value = option2.dataset.value;
      if (typeof value !== "undefined") {
        self2.lastQuery = null;
        self2.addItem(value);
        if (self2.settings.closeAfterSelect) {
          self2.close();
        }
        if (!self2.settings.hideSelected && evt.type && /click/.test(evt.type)) {
          self2.setActiveOption(option2);
        }
      }
    }
  }
  canSelect(option2) {
    if (this.isOpen && option2 && this.dropdown_content.contains(option2)) {
      return true;
    }
    return false;
  }
  onItemSelect(evt, item2) {
    var self2 = this;
    if (!self2.isLocked && self2.settings.mode === "multi") {
      preventDefault(evt);
      self2.setActiveItem(item2, evt);
      return true;
    }
    return false;
  }
  canLoad(value) {
    if (!this.settings.load)
      return false;
    if (this.loadedSearches.hasOwnProperty(value))
      return false;
    return true;
  }
  load(value) {
    const self2 = this;
    if (!self2.canLoad(value))
      return;
    addClasses(self2.wrapper, self2.settings.loadingClass);
    self2.loading++;
    const callback = self2.loadCallback.bind(self2);
    self2.settings.load.call(self2, value, callback);
  }
  loadCallback(options, optgroups) {
    const self2 = this;
    self2.loading = Math.max(self2.loading - 1, 0);
    self2.lastQuery = null;
    self2.clearActiveOption();
    self2.setupOptions(options, optgroups);
    self2.refreshOptions(self2.isFocused && !self2.isInputHidden);
    if (!self2.loading) {
      removeClasses(self2.wrapper, self2.settings.loadingClass);
    }
    self2.trigger("load", options, optgroups);
  }
  preload() {
    var classList = this.wrapper.classList;
    if (classList.contains("preloaded"))
      return;
    classList.add("preloaded");
    this.load("");
  }
  setTextboxValue(value = "") {
    var input = this.control_input;
    var changed = input.value !== value;
    if (changed) {
      input.value = value;
      triggerEvent(input, "update");
      this.lastValue = value;
    }
  }
  getValue() {
    if (this.is_select_tag && this.input.hasAttribute("multiple")) {
      return this.items;
    }
    return this.items.join(this.settings.delimiter);
  }
  setValue(value, silent) {
    var events2 = silent ? [] : ["change"];
    debounce_events(this, events2, () => {
      this.clear(silent);
      this.addItems(value, silent);
    });
  }
  setMaxItems(value) {
    if (value === 0)
      value = null;
    this.settings.maxItems = value;
    this.refreshState();
  }
  setActiveItem(item2, e3) {
    var self2 = this;
    var eventName;
    var i3, begin, end2, swap;
    var last;
    if (self2.settings.mode === "single")
      return;
    if (!item2) {
      self2.clearActiveItems();
      if (self2.isFocused) {
        self2.showInput();
      }
      return;
    }
    eventName = e3 && e3.type.toLowerCase();
    if (eventName === "click" && isKeyDown("shiftKey", e3) && self2.activeItems.length) {
      last = self2.getLastActive();
      begin = Array.prototype.indexOf.call(self2.control.children, last);
      end2 = Array.prototype.indexOf.call(self2.control.children, item2);
      if (begin > end2) {
        swap = begin;
        begin = end2;
        end2 = swap;
      }
      for (i3 = begin; i3 <= end2; i3++) {
        item2 = self2.control.children[i3];
        if (self2.activeItems.indexOf(item2) === -1) {
          self2.setActiveItemClass(item2);
        }
      }
      preventDefault(e3);
    } else if (eventName === "click" && isKeyDown(KEY_SHORTCUT, e3) || eventName === "keydown" && isKeyDown("shiftKey", e3)) {
      if (item2.classList.contains("active")) {
        self2.removeActiveItem(item2);
      } else {
        self2.setActiveItemClass(item2);
      }
    } else {
      self2.clearActiveItems();
      self2.setActiveItemClass(item2);
    }
    self2.hideInput();
    if (!self2.isFocused) {
      self2.focus();
    }
  }
  setActiveItemClass(item2) {
    const self2 = this;
    const last_active = self2.control.querySelector(".last-active");
    if (last_active)
      removeClasses(last_active, "last-active");
    addClasses(item2, "active last-active");
    self2.trigger("item_select", item2);
    if (self2.activeItems.indexOf(item2) == -1) {
      self2.activeItems.push(item2);
    }
  }
  removeActiveItem(item2) {
    var idx = this.activeItems.indexOf(item2);
    this.activeItems.splice(idx, 1);
    removeClasses(item2, "active");
  }
  clearActiveItems() {
    removeClasses(this.activeItems, "active");
    this.activeItems = [];
  }
  setActiveOption(option2, scroll = true) {
    if (option2 === this.activeOption) {
      return;
    }
    this.clearActiveOption();
    if (!option2)
      return;
    this.activeOption = option2;
    setAttr(this.focus_node, {
      "aria-activedescendant": option2.getAttribute("id")
    });
    setAttr(option2, {
      "aria-selected": "true"
    });
    addClasses(option2, "active");
    if (scroll)
      this.scrollToOption(option2);
  }
  scrollToOption(option2, behavior) {
    if (!option2)
      return;
    const content = this.dropdown_content;
    const height_menu = content.clientHeight;
    const scrollTop = content.scrollTop || 0;
    const height_item = option2.offsetHeight;
    const y4 = option2.getBoundingClientRect().top - content.getBoundingClientRect().top + scrollTop;
    if (y4 + height_item > height_menu + scrollTop) {
      this.scroll(y4 - height_menu + height_item, behavior);
    } else if (y4 < scrollTop) {
      this.scroll(y4, behavior);
    }
  }
  scroll(scrollTop, behavior) {
    const content = this.dropdown_content;
    if (behavior) {
      content.style.scrollBehavior = behavior;
    }
    content.scrollTop = scrollTop;
    content.style.scrollBehavior = "";
  }
  clearActiveOption() {
    if (this.activeOption) {
      removeClasses(this.activeOption, "active");
      setAttr(this.activeOption, {
        "aria-selected": null
      });
    }
    this.activeOption = null;
    setAttr(this.focus_node, {
      "aria-activedescendant": null
    });
  }
  selectAll() {
    const self2 = this;
    if (self2.settings.mode === "single")
      return;
    const activeItems = self2.controlChildren();
    if (!activeItems.length)
      return;
    self2.hideInput();
    self2.close();
    self2.activeItems = activeItems;
    iterate$1(activeItems, (item2) => {
      self2.setActiveItemClass(item2);
    });
  }
  inputState() {
    var self2 = this;
    if (!self2.control.contains(self2.control_input))
      return;
    setAttr(self2.control_input, {
      placeholder: self2.settings.placeholder
    });
    if (self2.activeItems.length > 0 || !self2.isFocused && self2.settings.hidePlaceholder && self2.items.length > 0) {
      self2.setTextboxValue();
      self2.isInputHidden = true;
    } else {
      if (self2.settings.hidePlaceholder && self2.items.length > 0) {
        setAttr(self2.control_input, {
          placeholder: ""
        });
      }
      self2.isInputHidden = false;
    }
    self2.wrapper.classList.toggle("input-hidden", self2.isInputHidden);
  }
  hideInput() {
    this.inputState();
  }
  showInput() {
    this.inputState();
  }
  inputValue() {
    return this.control_input.value.trim();
  }
  focus() {
    var self2 = this;
    if (self2.isDisabled)
      return;
    self2.ignoreFocus = true;
    if (self2.control_input.offsetWidth) {
      self2.control_input.focus();
    } else {
      self2.focus_node.focus();
    }
    setTimeout(() => {
      self2.ignoreFocus = false;
      self2.onFocus();
    }, 0);
  }
  blur() {
    this.focus_node.blur();
    this.onBlur();
  }
  getScoreFunction(query) {
    return this.sifter.getScoreFunction(query, this.getSearchOptions());
  }
  getSearchOptions() {
    var settings = this.settings;
    var sort2 = settings.sortField;
    if (typeof settings.sortField === "string") {
      sort2 = [{
        field: settings.sortField
      }];
    }
    return {
      fields: settings.searchField,
      conjunction: settings.searchConjunction,
      sort: sort2,
      nesting: settings.nesting
    };
  }
  search(query) {
    var result, calculateScore;
    var self2 = this;
    var options = this.getSearchOptions();
    if (self2.settings.score) {
      calculateScore = self2.settings.score.call(self2, query);
      if (typeof calculateScore !== "function") {
        throw new Error('Tom Select "score" setting must be a function that returns a function');
      }
    }
    if (query !== self2.lastQuery) {
      self2.lastQuery = query;
      result = self2.sifter.search(query, Object.assign(options, {
        score: calculateScore
      }));
      self2.currentResults = result;
    } else {
      result = Object.assign({}, self2.currentResults);
    }
    if (self2.settings.hideSelected) {
      result.items = result.items.filter((item2) => {
        let hashed = hash_key(item2.id);
        return !(hashed && self2.items.indexOf(hashed) !== -1);
      });
    }
    return result;
  }
  refreshOptions(triggerDropdown = true) {
    var i3, j2, k3, n2, optgroup, optgroups, html, has_create_option, active_group;
    var create2;
    const groups = {};
    const groups_order = [];
    var self2 = this;
    var query = self2.inputValue();
    const same_query = query === self2.lastQuery || query == "" && self2.lastQuery == null;
    var results = self2.search(query);
    var active_option = null;
    var show_dropdown = self2.settings.shouldOpen || false;
    var dropdown_content = self2.dropdown_content;
    if (same_query) {
      active_option = self2.activeOption;
      if (active_option) {
        active_group = active_option.closest("[data-group]");
      }
    }
    n2 = results.items.length;
    if (typeof self2.settings.maxOptions === "number") {
      n2 = Math.min(n2, self2.settings.maxOptions);
    }
    if (n2 > 0) {
      show_dropdown = true;
    }
    for (i3 = 0; i3 < n2; i3++) {
      let item2 = results.items[i3];
      if (!item2)
        continue;
      let opt_value = item2.id;
      let option2 = self2.options[opt_value];
      if (option2 === void 0)
        continue;
      let opt_hash = get_hash(opt_value);
      let option_el = self2.getOption(opt_hash, true);
      if (!self2.settings.hideSelected) {
        option_el.classList.toggle("selected", self2.items.includes(opt_hash));
      }
      optgroup = option2[self2.settings.optgroupField] || "";
      optgroups = Array.isArray(optgroup) ? optgroup : [optgroup];
      for (j2 = 0, k3 = optgroups && optgroups.length; j2 < k3; j2++) {
        optgroup = optgroups[j2];
        if (!self2.optgroups.hasOwnProperty(optgroup)) {
          optgroup = "";
        }
        let group_fragment = groups[optgroup];
        if (group_fragment === void 0) {
          group_fragment = document.createDocumentFragment();
          groups_order.push(optgroup);
        }
        if (j2 > 0) {
          option_el = option_el.cloneNode(true);
          setAttr(option_el, {
            id: option2.$id + "-clone-" + j2,
            "aria-selected": null
          });
          option_el.classList.add("ts-cloned");
          removeClasses(option_el, "active");
          if (self2.activeOption && self2.activeOption.dataset.value == opt_value) {
            if (active_group && active_group.dataset.group === optgroup.toString()) {
              active_option = option_el;
            }
          }
        }
        group_fragment.appendChild(option_el);
        groups[optgroup] = group_fragment;
      }
    }
    if (self2.settings.lockOptgroupOrder) {
      groups_order.sort((a4, b3) => {
        const grp_a = self2.optgroups[a4];
        const grp_b = self2.optgroups[b3];
        const a_order = grp_a && grp_a.$order || 0;
        const b_order = grp_b && grp_b.$order || 0;
        return a_order - b_order;
      });
    }
    html = document.createDocumentFragment();
    iterate$1(groups_order, (optgroup2) => {
      let group_fragment = groups[optgroup2];
      if (!group_fragment || !group_fragment.children.length)
        return;
      let group_heading = self2.optgroups[optgroup2];
      if (group_heading !== void 0) {
        let group_options = document.createDocumentFragment();
        let header = self2.render("optgroup_header", group_heading);
        append(group_options, header);
        append(group_options, group_fragment);
        let group_html = self2.render("optgroup", {
          group: group_heading,
          options: group_options
        });
        append(html, group_html);
      } else {
        append(html, group_fragment);
      }
    });
    dropdown_content.innerHTML = "";
    append(dropdown_content, html);
    if (self2.settings.highlight) {
      removeHighlight(dropdown_content);
      if (results.query.length && results.tokens.length) {
        iterate$1(results.tokens, (tok) => {
          highlight(dropdown_content, tok.regex);
        });
      }
    }
    var add_template = (template) => {
      let content = self2.render(template, {
        input: query
      });
      if (content) {
        show_dropdown = true;
        dropdown_content.insertBefore(content, dropdown_content.firstChild);
      }
      return content;
    };
    if (self2.loading) {
      add_template("loading");
    } else if (!self2.settings.shouldLoad.call(self2, query)) {
      add_template("not_loading");
    } else if (results.items.length === 0) {
      add_template("no_results");
    }
    has_create_option = self2.canCreate(query);
    if (has_create_option) {
      create2 = add_template("option_create");
    }
    self2.hasOptions = results.items.length > 0 || has_create_option;
    if (show_dropdown) {
      if (results.items.length > 0) {
        if (!active_option && self2.settings.mode === "single" && self2.items[0] != void 0) {
          active_option = self2.getOption(self2.items[0]);
        }
        if (!dropdown_content.contains(active_option)) {
          let active_index = 0;
          if (create2 && !self2.settings.addPrecedence) {
            active_index = 1;
          }
          active_option = self2.selectable()[active_index];
        }
      } else if (create2) {
        active_option = create2;
      }
      if (triggerDropdown && !self2.isOpen) {
        self2.open();
        self2.scrollToOption(active_option, "auto");
      }
      self2.setActiveOption(active_option);
    } else {
      self2.clearActiveOption();
      if (triggerDropdown && self2.isOpen) {
        self2.close(false);
      }
    }
  }
  selectable() {
    return this.dropdown_content.querySelectorAll("[data-selectable]");
  }
  addOption(data, user_created = false) {
    const self2 = this;
    if (Array.isArray(data)) {
      self2.addOptions(data, user_created);
      return false;
    }
    const key = hash_key(data[self2.settings.valueField]);
    if (key === null || self2.options.hasOwnProperty(key)) {
      return false;
    }
    data.$order = data.$order || ++self2.order;
    data.$id = self2.inputId + "-opt-" + data.$order;
    self2.options[key] = data;
    self2.lastQuery = null;
    if (user_created) {
      self2.userOptions[key] = user_created;
      self2.trigger("option_add", key, data);
    }
    return key;
  }
  addOptions(data, user_created = false) {
    iterate$1(data, (dat) => {
      this.addOption(dat, user_created);
    });
  }
  registerOption(data) {
    return this.addOption(data);
  }
  registerOptionGroup(data) {
    var key = hash_key(data[this.settings.optgroupValueField]);
    if (key === null)
      return false;
    data.$order = data.$order || ++this.order;
    this.optgroups[key] = data;
    return key;
  }
  addOptionGroup(id2, data) {
    var hashed_id;
    data[this.settings.optgroupValueField] = id2;
    if (hashed_id = this.registerOptionGroup(data)) {
      this.trigger("optgroup_add", hashed_id, data);
    }
  }
  removeOptionGroup(id2) {
    if (this.optgroups.hasOwnProperty(id2)) {
      delete this.optgroups[id2];
      this.clearCache();
      this.trigger("optgroup_remove", id2);
    }
  }
  clearOptionGroups() {
    this.optgroups = {};
    this.clearCache();
    this.trigger("optgroup_clear");
  }
  updateOption(value, data) {
    const self2 = this;
    var item_new;
    var index_item;
    const value_old = hash_key(value);
    const value_new = hash_key(data[self2.settings.valueField]);
    if (value_old === null)
      return;
    const data_old = self2.options[value_old];
    if (data_old == void 0)
      return;
    if (typeof value_new !== "string")
      throw new Error("Value must be set in option data");
    const option2 = self2.getOption(value_old);
    const item2 = self2.getItem(value_old);
    data.$order = data.$order || data_old.$order;
    delete self2.options[value_old];
    self2.uncacheValue(value_new);
    self2.options[value_new] = data;
    if (option2) {
      if (self2.dropdown_content.contains(option2)) {
        const option_new = self2._render("option", data);
        replaceNode(option2, option_new);
        if (self2.activeOption === option2) {
          self2.setActiveOption(option_new);
        }
      }
      option2.remove();
    }
    if (item2) {
      index_item = self2.items.indexOf(value_old);
      if (index_item !== -1) {
        self2.items.splice(index_item, 1, value_new);
      }
      item_new = self2._render("item", data);
      if (item2.classList.contains("active"))
        addClasses(item_new, "active");
      replaceNode(item2, item_new);
    }
    self2.lastQuery = null;
  }
  removeOption(value, silent) {
    const self2 = this;
    value = get_hash(value);
    self2.uncacheValue(value);
    delete self2.userOptions[value];
    delete self2.options[value];
    self2.lastQuery = null;
    self2.trigger("option_remove", value);
    self2.removeItem(value, silent);
  }
  clearOptions(filter) {
    const boundFilter = (filter || this.clearFilter).bind(this);
    this.loadedSearches = {};
    this.userOptions = {};
    this.clearCache();
    const selected = {};
    iterate$1(this.options, (option2, key) => {
      if (boundFilter(option2, key)) {
        selected[key] = option2;
      }
    });
    this.options = this.sifter.items = selected;
    this.lastQuery = null;
    this.trigger("option_clear");
  }
  clearFilter(option2, value) {
    if (this.items.indexOf(value) >= 0) {
      return true;
    }
    return false;
  }
  getOption(value, create2 = false) {
    const hashed = hash_key(value);
    if (hashed === null)
      return null;
    const option2 = this.options[hashed];
    if (option2 != void 0) {
      if (option2.$div) {
        return option2.$div;
      }
      if (create2) {
        return this._render("option", option2);
      }
    }
    return null;
  }
  getAdjacent(option2, direction, type = "option") {
    var self2 = this, all;
    if (!option2) {
      return null;
    }
    if (type == "item") {
      all = self2.controlChildren();
    } else {
      all = self2.dropdown_content.querySelectorAll("[data-selectable]");
    }
    for (let i3 = 0; i3 < all.length; i3++) {
      if (all[i3] != option2) {
        continue;
      }
      if (direction > 0) {
        return all[i3 + 1];
      }
      return all[i3 - 1];
    }
    return null;
  }
  getItem(item2) {
    if (typeof item2 == "object") {
      return item2;
    }
    var value = hash_key(item2);
    return value !== null ? this.control.querySelector(`[data-value="${addSlashes(value)}"]`) : null;
  }
  addItems(values, silent) {
    var self2 = this;
    var items = Array.isArray(values) ? values : [values];
    items = items.filter((x3) => self2.items.indexOf(x3) === -1);
    const last_item = items[items.length - 1];
    items.forEach((item2) => {
      self2.isPending = item2 !== last_item;
      self2.addItem(item2, silent);
    });
  }
  addItem(value, silent) {
    var events2 = silent ? [] : ["change", "dropdown_close"];
    debounce_events(this, events2, () => {
      var item2, wasFull;
      const self2 = this;
      const inputMode = self2.settings.mode;
      const hashed = hash_key(value);
      if (hashed && self2.items.indexOf(hashed) !== -1) {
        if (inputMode === "single") {
          self2.close();
        }
        if (inputMode === "single" || !self2.settings.duplicates) {
          return;
        }
      }
      if (hashed === null || !self2.options.hasOwnProperty(hashed))
        return;
      if (inputMode === "single")
        self2.clear(silent);
      if (inputMode === "multi" && self2.isFull())
        return;
      item2 = self2._render("item", self2.options[hashed]);
      if (self2.control.contains(item2)) {
        item2 = item2.cloneNode(true);
      }
      wasFull = self2.isFull();
      self2.items.splice(self2.caretPos, 0, hashed);
      self2.insertAtCaret(item2);
      if (self2.isSetup) {
        if (!self2.isPending && self2.settings.hideSelected) {
          let option2 = self2.getOption(hashed);
          let next2 = self2.getAdjacent(option2, 1);
          if (next2) {
            self2.setActiveOption(next2);
          }
        }
        if (!self2.isPending && !self2.settings.closeAfterSelect) {
          self2.refreshOptions(self2.isFocused && inputMode !== "single");
        }
        if (self2.settings.closeAfterSelect != false && self2.isFull()) {
          self2.close();
        } else if (!self2.isPending) {
          self2.positionDropdown();
        }
        self2.trigger("item_add", hashed, item2);
        if (!self2.isPending) {
          self2.updateOriginalInput({
            silent
          });
        }
      }
      if (!self2.isPending || !wasFull && self2.isFull()) {
        self2.inputState();
        self2.refreshState();
      }
    });
  }
  removeItem(item2 = null, silent) {
    const self2 = this;
    item2 = self2.getItem(item2);
    if (!item2)
      return;
    var i3, idx;
    const value = item2.dataset.value;
    i3 = nodeIndex(item2);
    item2.remove();
    if (item2.classList.contains("active")) {
      idx = self2.activeItems.indexOf(item2);
      self2.activeItems.splice(idx, 1);
      removeClasses(item2, "active");
    }
    self2.items.splice(i3, 1);
    self2.lastQuery = null;
    if (!self2.settings.persist && self2.userOptions.hasOwnProperty(value)) {
      self2.removeOption(value, silent);
    }
    if (i3 < self2.caretPos) {
      self2.setCaret(self2.caretPos - 1);
    }
    self2.updateOriginalInput({
      silent
    });
    self2.refreshState();
    self2.positionDropdown();
    self2.trigger("item_remove", value, item2);
  }
  createItem(input = null, callback = () => {
  }) {
    if (arguments.length === 3) {
      callback = arguments[2];
    }
    if (typeof callback != "function") {
      callback = () => {
      };
    }
    var self2 = this;
    var caret2 = self2.caretPos;
    var output;
    input = input || self2.inputValue();
    if (!self2.canCreate(input)) {
      callback();
      return false;
    }
    self2.lock();
    var created = false;
    var create2 = (data) => {
      self2.unlock();
      if (!data || typeof data !== "object")
        return callback();
      var value = hash_key(data[self2.settings.valueField]);
      if (typeof value !== "string") {
        return callback();
      }
      self2.setTextboxValue();
      self2.addOption(data, true);
      self2.setCaret(caret2);
      self2.addItem(value);
      callback(data);
      created = true;
    };
    if (typeof self2.settings.create === "function") {
      output = self2.settings.create.call(this, input, create2);
    } else {
      output = {
        [self2.settings.labelField]: input,
        [self2.settings.valueField]: input
      };
    }
    if (!created) {
      create2(output);
    }
    return true;
  }
  refreshItems() {
    var self2 = this;
    self2.lastQuery = null;
    if (self2.isSetup) {
      self2.addItems(self2.items);
    }
    self2.updateOriginalInput();
    self2.refreshState();
  }
  refreshState() {
    const self2 = this;
    self2.refreshValidityState();
    const isFull = self2.isFull();
    const isLocked = self2.isLocked;
    self2.wrapper.classList.toggle("rtl", self2.rtl);
    const wrap_classList = self2.wrapper.classList;
    wrap_classList.toggle("focus", self2.isFocused);
    wrap_classList.toggle("disabled", self2.isDisabled);
    wrap_classList.toggle("required", self2.isRequired);
    wrap_classList.toggle("invalid", !self2.isValid);
    wrap_classList.toggle("locked", isLocked);
    wrap_classList.toggle("full", isFull);
    wrap_classList.toggle("input-active", self2.isFocused && !self2.isInputHidden);
    wrap_classList.toggle("dropdown-active", self2.isOpen);
    wrap_classList.toggle("has-options", isEmptyObject$1(self2.options));
    wrap_classList.toggle("has-items", self2.items.length > 0);
  }
  refreshValidityState() {
    var self2 = this;
    if (!self2.input.validity) {
      return;
    }
    self2.isValid = self2.input.validity.valid;
    self2.isInvalid = !self2.isValid;
  }
  isFull() {
    return this.settings.maxItems !== null && this.items.length >= this.settings.maxItems;
  }
  updateOriginalInput(opts = {}) {
    const self2 = this;
    var option2, label;
    const empty_option = self2.input.querySelector('option[value=""]');
    if (self2.is_select_tag) {
      let AddSelected = function(option_el, value, label2) {
        if (!option_el) {
          option_el = getDom('<option value="' + escape_html(value) + '">' + escape_html(label2) + "</option>");
        }
        if (option_el != empty_option) {
          self2.input.append(option_el);
        }
        selected.push(option_el);
        if (option_el != empty_option || has_selected > 0) {
          option_el.selected = true;
        }
        return option_el;
      };
      const selected = [];
      const has_selected = self2.input.querySelectorAll("option:checked").length;
      self2.input.querySelectorAll("option:checked").forEach((option_el) => {
        option_el.selected = false;
      });
      if (self2.items.length == 0 && self2.settings.mode == "single") {
        AddSelected(empty_option, "", "");
      } else {
        self2.items.forEach((value) => {
          option2 = self2.options[value];
          label = option2[self2.settings.labelField] || "";
          if (selected.includes(option2.$option)) {
            const reuse_opt = self2.input.querySelector(`option[value="${addSlashes(value)}"]:not(:checked)`);
            AddSelected(reuse_opt, value, label);
          } else {
            option2.$option = AddSelected(option2.$option, value, label);
          }
        });
      }
    } else {
      self2.input.value = self2.getValue();
    }
    if (self2.isSetup) {
      if (!opts.silent) {
        self2.trigger("change", self2.getValue());
      }
    }
  }
  open() {
    var self2 = this;
    if (self2.isLocked || self2.isOpen || self2.settings.mode === "multi" && self2.isFull())
      return;
    self2.isOpen = true;
    setAttr(self2.focus_node, {
      "aria-expanded": "true"
    });
    self2.refreshState();
    applyCSS(self2.dropdown, {
      visibility: "hidden",
      display: "block"
    });
    self2.positionDropdown();
    applyCSS(self2.dropdown, {
      visibility: "visible",
      display: "block"
    });
    self2.focus();
    self2.trigger("dropdown_open", self2.dropdown);
  }
  close(setTextboxValue = true) {
    var self2 = this;
    var trigger = self2.isOpen;
    if (setTextboxValue) {
      self2.setTextboxValue();
      if (self2.settings.mode === "single" && self2.items.length) {
        self2.hideInput();
      }
    }
    self2.isOpen = false;
    setAttr(self2.focus_node, {
      "aria-expanded": "false"
    });
    applyCSS(self2.dropdown, {
      display: "none"
    });
    if (self2.settings.hideSelected) {
      self2.clearActiveOption();
    }
    self2.refreshState();
    if (trigger)
      self2.trigger("dropdown_close", self2.dropdown);
  }
  positionDropdown() {
    if (this.settings.dropdownParent !== "body") {
      return;
    }
    var context = this.control;
    var rect = context.getBoundingClientRect();
    var top2 = context.offsetHeight + rect.top + window.scrollY;
    var left2 = rect.left + window.scrollX;
    applyCSS(this.dropdown, {
      width: rect.width + "px",
      top: top2 + "px",
      left: left2 + "px"
    });
  }
  clear(silent) {
    var self2 = this;
    if (!self2.items.length)
      return;
    var items = self2.controlChildren();
    iterate$1(items, (item2) => {
      self2.removeItem(item2, true);
    });
    self2.showInput();
    if (!silent)
      self2.updateOriginalInput();
    self2.trigger("clear");
  }
  insertAtCaret(el2) {
    const self2 = this;
    const caret2 = self2.caretPos;
    const target = self2.control;
    target.insertBefore(el2, target.children[caret2] || null);
    self2.setCaret(caret2 + 1);
  }
  deleteSelection(e3) {
    var direction, selection, caret2, tail;
    var self2 = this;
    direction = e3 && e3.keyCode === KEY_BACKSPACE ? -1 : 1;
    selection = getSelection$1(self2.control_input);
    const rm_items = [];
    if (self2.activeItems.length) {
      tail = getTail(self2.activeItems, direction);
      caret2 = nodeIndex(tail);
      if (direction > 0) {
        caret2++;
      }
      iterate$1(self2.activeItems, (item2) => rm_items.push(item2));
    } else if ((self2.isFocused || self2.settings.mode === "single") && self2.items.length) {
      const items = self2.controlChildren();
      let rm_item;
      if (direction < 0 && selection.start === 0 && selection.length === 0) {
        rm_item = items[self2.caretPos - 1];
      } else if (direction > 0 && selection.start === self2.inputValue().length) {
        rm_item = items[self2.caretPos];
      }
      if (rm_item !== void 0) {
        rm_items.push(rm_item);
      }
    }
    if (!self2.shouldDelete(rm_items, e3)) {
      return false;
    }
    preventDefault(e3, true);
    if (typeof caret2 !== "undefined") {
      self2.setCaret(caret2);
    }
    while (rm_items.length) {
      self2.removeItem(rm_items.pop());
    }
    self2.showInput();
    self2.positionDropdown();
    self2.refreshOptions(false);
    return true;
  }
  shouldDelete(items, evt) {
    const values = items.map((item2) => item2.dataset.value);
    if (!values.length || typeof this.settings.onDelete === "function" && this.settings.onDelete(values, evt) === false) {
      return false;
    }
    return true;
  }
  advanceSelection(direction, e3) {
    var last_active, adjacent, self2 = this;
    if (self2.rtl)
      direction *= -1;
    if (self2.inputValue().length)
      return;
    if (isKeyDown(KEY_SHORTCUT, e3) || isKeyDown("shiftKey", e3)) {
      last_active = self2.getLastActive(direction);
      if (last_active) {
        if (!last_active.classList.contains("active")) {
          adjacent = last_active;
        } else {
          adjacent = self2.getAdjacent(last_active, direction, "item");
        }
      } else if (direction > 0) {
        adjacent = self2.control_input.nextElementSibling;
      } else {
        adjacent = self2.control_input.previousElementSibling;
      }
      if (adjacent) {
        if (adjacent.classList.contains("active")) {
          self2.removeActiveItem(last_active);
        }
        self2.setActiveItemClass(adjacent);
      }
    } else {
      self2.moveCaret(direction);
    }
  }
  moveCaret(direction) {
  }
  getLastActive(direction) {
    let last_active = this.control.querySelector(".last-active");
    if (last_active) {
      return last_active;
    }
    var result = this.control.querySelectorAll(".active");
    if (result) {
      return getTail(result, direction);
    }
  }
  setCaret(new_pos) {
    this.caretPos = this.items.length;
  }
  controlChildren() {
    return Array.from(this.control.querySelectorAll("[data-ts-item]"));
  }
  lock() {
    this.isLocked = true;
    this.refreshState();
  }
  unlock() {
    this.isLocked = false;
    this.refreshState();
  }
  disable() {
    var self2 = this;
    self2.input.disabled = true;
    self2.control_input.disabled = true;
    self2.focus_node.tabIndex = -1;
    self2.isDisabled = true;
    this.close();
    self2.lock();
  }
  enable() {
    var self2 = this;
    self2.input.disabled = false;
    self2.control_input.disabled = false;
    self2.focus_node.tabIndex = self2.tabIndex;
    self2.isDisabled = false;
    self2.unlock();
  }
  destroy() {
    var self2 = this;
    var revertSettings = self2.revertSettings;
    self2.trigger("destroy");
    self2.off();
    self2.wrapper.remove();
    self2.dropdown.remove();
    self2.input.innerHTML = revertSettings.innerHTML;
    self2.input.tabIndex = revertSettings.tabIndex;
    removeClasses(self2.input, "tomselected", "ts-hidden-accessible");
    self2._destroy();
    delete self2.input.tomselect;
  }
  render(templateName, data) {
    var id2, html;
    const self2 = this;
    if (typeof this.settings.render[templateName] !== "function") {
      return null;
    }
    html = self2.settings.render[templateName].call(this, data, escape_html);
    if (!html) {
      return null;
    }
    html = getDom(html);
    if (templateName === "option" || templateName === "option_create") {
      if (data[self2.settings.disabledField]) {
        setAttr(html, {
          "aria-disabled": "true"
        });
      } else {
        setAttr(html, {
          "data-selectable": ""
        });
      }
    } else if (templateName === "optgroup") {
      id2 = data.group[self2.settings.optgroupValueField];
      setAttr(html, {
        "data-group": id2
      });
      if (data.group[self2.settings.disabledField]) {
        setAttr(html, {
          "data-disabled": ""
        });
      }
    }
    if (templateName === "option" || templateName === "item") {
      const value = get_hash(data[self2.settings.valueField]);
      setAttr(html, {
        "data-value": value
      });
      if (templateName === "item") {
        addClasses(html, self2.settings.itemClass);
        setAttr(html, {
          "data-ts-item": ""
        });
      } else {
        addClasses(html, self2.settings.optionClass);
        setAttr(html, {
          role: "option",
          id: data.$id
        });
        data.$div = html;
        self2.options[value] = data;
      }
    }
    return html;
  }
  _render(templateName, data) {
    const html = this.render(templateName, data);
    if (html == null) {
      throw "HTMLElement expected";
    }
    return html;
  }
  clearCache() {
    iterate$1(this.options, (option2) => {
      if (option2.$div) {
        option2.$div.remove();
        delete option2.$div;
      }
    });
  }
  uncacheValue(value) {
    const option_el = this.getOption(value);
    if (option_el)
      option_el.remove();
  }
  canCreate(input) {
    return this.settings.create && input.length > 0 && this.settings.createFilter.call(this, input);
  }
  hook(when, method, new_fn) {
    var self2 = this;
    var orig_method = self2[method];
    self2[method] = function() {
      var result, result_new;
      if (when === "after") {
        result = orig_method.apply(self2, arguments);
      }
      result_new = new_fn.apply(self2, arguments);
      if (when === "instead") {
        return result_new;
      }
      if (when === "before") {
        result = orig_method.apply(self2, arguments);
      }
      return result;
    };
  }
}
function change_listener() {
  addEvent(this.input, "change", () => {
    this.sync();
  });
}
function checkbox_options() {
  var self2 = this;
  var orig_onOptionSelect = self2.onOptionSelect;
  self2.settings.hideSelected = false;
  var UpdateCheckbox = function UpdateCheckbox2(option2) {
    setTimeout(() => {
      var checkbox2 = option2.querySelector("input");
      if (checkbox2 instanceof HTMLInputElement) {
        if (option2.classList.contains("selected")) {
          checkbox2.checked = true;
        } else {
          checkbox2.checked = false;
        }
      }
    }, 1);
  };
  self2.hook("after", "setupTemplates", () => {
    var orig_render_option = self2.settings.render.option;
    self2.settings.render.option = (data, escape_html2) => {
      var rendered = getDom(orig_render_option.call(self2, data, escape_html2));
      var checkbox2 = document.createElement("input");
      checkbox2.addEventListener("click", function(evt) {
        preventDefault(evt);
      });
      checkbox2.type = "checkbox";
      const hashed = hash_key(data[self2.settings.valueField]);
      if (hashed && self2.items.indexOf(hashed) > -1) {
        checkbox2.checked = true;
      }
      rendered.prepend(checkbox2);
      return rendered;
    };
  });
  self2.on("item_remove", (value) => {
    var option2 = self2.getOption(value);
    if (option2) {
      option2.classList.remove("selected");
      UpdateCheckbox(option2);
    }
  });
  self2.on("item_add", (value) => {
    var option2 = self2.getOption(value);
    if (option2) {
      UpdateCheckbox(option2);
    }
  });
  self2.hook("instead", "onOptionSelect", (evt, option2) => {
    if (option2.classList.contains("selected")) {
      option2.classList.remove("selected");
      self2.removeItem(option2.dataset.value);
      self2.refreshOptions();
      preventDefault(evt, true);
      return;
    }
    orig_onOptionSelect.call(self2, evt, option2);
    UpdateCheckbox(option2);
  });
}
function clear_button(userOptions) {
  const self2 = this;
  const options = Object.assign({
    className: "clear-button",
    title: "Clear All",
    html: (data) => {
      return `<div class="${data.className}" title="${data.title}">&#10799;</div>`;
    }
  }, userOptions);
  self2.on("initialize", () => {
    var button2 = getDom(options.html(options));
    button2.addEventListener("click", (evt) => {
      if (self2.isDisabled) {
        return;
      }
      self2.clear();
      if (self2.settings.mode === "single" && self2.settings.allowEmptyOption) {
        self2.addItem("");
      }
      evt.preventDefault();
      evt.stopPropagation();
    });
    self2.control.appendChild(button2);
  });
}
function drag_drop() {
  var self2 = this;
  if (!$.fn.sortable)
    throw new Error('The "drag_drop" plugin requires jQuery UI "sortable".');
  if (self2.settings.mode !== "multi")
    return;
  var orig_lock = self2.lock;
  var orig_unlock = self2.unlock;
  self2.hook("instead", "lock", () => {
    var sortable = $(self2.control).data("sortable");
    if (sortable)
      sortable.disable();
    return orig_lock.call(self2);
  });
  self2.hook("instead", "unlock", () => {
    var sortable = $(self2.control).data("sortable");
    if (sortable)
      sortable.enable();
    return orig_unlock.call(self2);
  });
  self2.on("initialize", () => {
    var $control = $(self2.control).sortable({
      items: "[data-value]",
      forcePlaceholderSize: true,
      disabled: self2.isLocked,
      start: (e3, ui2) => {
        ui2.placeholder.css("width", ui2.helper.css("width"));
        $control.css({
          overflow: "visible"
        });
      },
      stop: () => {
        $control.css({
          overflow: "hidden"
        });
        var values = [];
        $control.children("[data-value]").each(function() {
          if (this.dataset.value)
            values.push(this.dataset.value);
        });
        self2.setValue(values);
      }
    });
  });
}
function dropdown_header(userOptions) {
  const self2 = this;
  const options = Object.assign({
    title: "Untitled",
    headerClass: "dropdown-header",
    titleRowClass: "dropdown-header-title",
    labelClass: "dropdown-header-label",
    closeClass: "dropdown-header-close",
    html: (data) => {
      return '<div class="' + data.headerClass + '"><div class="' + data.titleRowClass + '"><span class="' + data.labelClass + '">' + data.title + '</span><a class="' + data.closeClass + '">&times;</a></div></div>';
    }
  }, userOptions);
  self2.on("initialize", () => {
    var header = getDom(options.html(options));
    var close_link = header.querySelector("." + options.closeClass);
    if (close_link) {
      close_link.addEventListener("click", (evt) => {
        preventDefault(evt, true);
        self2.close();
      });
    }
    self2.dropdown.insertBefore(header, self2.dropdown.firstChild);
  });
}
function caret_position() {
  var self2 = this;
  self2.hook("instead", "setCaret", (new_pos) => {
    if (self2.settings.mode === "single" || !self2.control.contains(self2.control_input)) {
      new_pos = self2.items.length;
    } else {
      new_pos = Math.max(0, Math.min(self2.items.length, new_pos));
      if (new_pos != self2.caretPos && !self2.isPending) {
        self2.controlChildren().forEach((child, j2) => {
          if (j2 < new_pos) {
            self2.control_input.insertAdjacentElement("beforebegin", child);
          } else {
            self2.control.appendChild(child);
          }
        });
      }
    }
    self2.caretPos = new_pos;
  });
  self2.hook("instead", "moveCaret", (direction) => {
    if (!self2.isFocused)
      return;
    const last_active = self2.getLastActive(direction);
    if (last_active) {
      const idx = nodeIndex(last_active);
      self2.setCaret(direction > 0 ? idx + 1 : idx);
      self2.setActiveItem();
      removeClasses(last_active, "last-active");
    } else {
      self2.setCaret(self2.caretPos + direction);
    }
  });
}
function dropdown_input() {
  const self2 = this;
  self2.settings.shouldOpen = true;
  self2.hook("before", "setup", () => {
    self2.focus_node = self2.control;
    addClasses(self2.control_input, "dropdown-input");
    const div2 = getDom('<div class="dropdown-input-wrap">');
    div2.append(self2.control_input);
    self2.dropdown.insertBefore(div2, self2.dropdown.firstChild);
    const placeholder = getDom('<input class="items-placeholder" tabindex="-1" />');
    placeholder.placeholder = self2.settings.placeholder || "";
    self2.control.append(placeholder);
  });
  self2.on("initialize", () => {
    self2.control_input.addEventListener("keydown", (evt) => {
      switch (evt.keyCode) {
        case KEY_ESC:
          if (self2.isOpen) {
            preventDefault(evt, true);
            self2.close();
          }
          self2.clearActiveItems();
          return;
        case KEY_TAB:
          self2.focus_node.tabIndex = -1;
          break;
      }
      return self2.onKeyDown.call(self2, evt);
    });
    self2.on("blur", () => {
      self2.focus_node.tabIndex = self2.isDisabled ? -1 : self2.tabIndex;
    });
    self2.on("dropdown_open", () => {
      self2.control_input.focus();
    });
    const orig_onBlur = self2.onBlur;
    self2.hook("instead", "onBlur", (evt) => {
      if (evt && evt.relatedTarget == self2.control_input)
        return;
      return orig_onBlur.call(self2);
    });
    addEvent(self2.control_input, "blur", () => self2.onBlur());
    self2.hook("before", "close", () => {
      if (!self2.isOpen)
        return;
      self2.focus_node.focus({
        preventScroll: true
      });
    });
  });
}
function input_autogrow() {
  var self2 = this;
  self2.on("initialize", () => {
    var test_input = document.createElement("span");
    var control = self2.control_input;
    test_input.style.cssText = "position:absolute; top:-99999px; left:-99999px; width:auto; padding:0; white-space:pre; ";
    self2.wrapper.appendChild(test_input);
    var transfer_styles = ["letterSpacing", "fontSize", "fontFamily", "fontWeight", "textTransform"];
    for (const style_name of transfer_styles) {
      test_input.style[style_name] = control.style[style_name];
    }
    var resize = () => {
      test_input.textContent = control.value;
      control.style.width = test_input.clientWidth + "px";
    };
    resize();
    self2.on("update item_add item_remove", resize);
    addEvent(control, "input", resize);
    addEvent(control, "keyup", resize);
    addEvent(control, "blur", resize);
    addEvent(control, "update", resize);
  });
}
function no_backspace_delete() {
  var self2 = this;
  var orig_deleteSelection = self2.deleteSelection;
  this.hook("instead", "deleteSelection", (evt) => {
    if (self2.activeItems.length) {
      return orig_deleteSelection.call(self2, evt);
    }
    return false;
  });
}
function no_active_items() {
  this.hook("instead", "setActiveItem", () => {
  });
  this.hook("instead", "selectAll", () => {
  });
}
function optgroup_columns() {
  var self2 = this;
  var orig_keydown = self2.onKeyDown;
  self2.hook("instead", "onKeyDown", (evt) => {
    var index2, option2, options, optgroup;
    if (!self2.isOpen || !(evt.keyCode === KEY_LEFT || evt.keyCode === KEY_RIGHT)) {
      return orig_keydown.call(self2, evt);
    }
    self2.ignoreHover = true;
    optgroup = parentMatch(self2.activeOption, "[data-group]");
    index2 = nodeIndex(self2.activeOption, "[data-selectable]");
    if (!optgroup) {
      return;
    }
    if (evt.keyCode === KEY_LEFT) {
      optgroup = optgroup.previousSibling;
    } else {
      optgroup = optgroup.nextSibling;
    }
    if (!optgroup) {
      return;
    }
    options = optgroup.querySelectorAll("[data-selectable]");
    option2 = options[Math.min(options.length - 1, index2)];
    if (option2) {
      self2.setActiveOption(option2);
    }
  });
}
function remove_button(userOptions) {
  const options = Object.assign({
    label: "&times;",
    title: "Remove",
    className: "remove",
    append: true
  }, userOptions);
  var self2 = this;
  if (!options.append) {
    return;
  }
  var html = '<a href="javascript:void(0)" class="' + options.className + '" tabindex="-1" title="' + escape_html(options.title) + '">' + options.label + "</a>";
  self2.hook("after", "setupTemplates", () => {
    var orig_render_item = self2.settings.render.item;
    self2.settings.render.item = (data, escape2) => {
      var item2 = getDom(orig_render_item.call(self2, data, escape2));
      var close_button = getDom(html);
      item2.appendChild(close_button);
      addEvent(close_button, "mousedown", (evt) => {
        preventDefault(evt, true);
      });
      addEvent(close_button, "click", (evt) => {
        preventDefault(evt, true);
        if (self2.isLocked)
          return;
        if (!self2.shouldDelete([item2], evt))
          return;
        self2.removeItem(item2);
        self2.refreshOptions(false);
        self2.inputState();
      });
      return item2;
    };
  });
}
function restore_on_backspace(userOptions) {
  const self2 = this;
  const options = Object.assign({
    text: (option2) => {
      return option2[self2.settings.labelField];
    }
  }, userOptions);
  self2.on("item_remove", function(value) {
    if (!self2.isFocused) {
      return;
    }
    if (self2.control_input.value.trim() === "") {
      var option2 = self2.options[value];
      if (option2) {
        self2.setTextboxValue(options.text.call(self2, option2));
      }
    }
  });
}
function virtual_scroll() {
  const self2 = this;
  const orig_canLoad = self2.canLoad;
  const orig_clearActiveOption = self2.clearActiveOption;
  const orig_loadCallback = self2.loadCallback;
  var pagination = {};
  var dropdown_content;
  var loading_more = false;
  var load_more_opt;
  var default_values = [];
  if (!self2.settings.shouldLoadMore) {
    self2.settings.shouldLoadMore = () => {
      const scroll_percent = dropdown_content.clientHeight / (dropdown_content.scrollHeight - dropdown_content.scrollTop);
      if (scroll_percent > 0.9) {
        return true;
      }
      if (self2.activeOption) {
        var selectable = self2.selectable();
        var index2 = Array.from(selectable).indexOf(self2.activeOption);
        if (index2 >= selectable.length - 2) {
          return true;
        }
      }
      return false;
    };
  }
  if (!self2.settings.firstUrl) {
    throw "virtual_scroll plugin requires a firstUrl() method";
  }
  self2.settings.sortField = [{
    field: "$order"
  }, {
    field: "$score"
  }];
  const canLoadMore = (query) => {
    if (typeof self2.settings.maxOptions === "number" && dropdown_content.children.length >= self2.settings.maxOptions) {
      return false;
    }
    if (query in pagination && pagination[query]) {
      return true;
    }
    return false;
  };
  const clearFilter = (option2, value) => {
    if (self2.items.indexOf(value) >= 0 || default_values.indexOf(value) >= 0) {
      return true;
    }
    return false;
  };
  self2.setNextUrl = (value, next_url) => {
    pagination[value] = next_url;
  };
  self2.getUrl = (query) => {
    if (query in pagination) {
      const next_url = pagination[query];
      pagination[query] = false;
      return next_url;
    }
    pagination = {};
    return self2.settings.firstUrl.call(self2, query);
  };
  self2.hook("instead", "clearActiveOption", () => {
    if (loading_more) {
      return;
    }
    return orig_clearActiveOption.call(self2);
  });
  self2.hook("instead", "canLoad", (query) => {
    if (!(query in pagination)) {
      return orig_canLoad.call(self2, query);
    }
    return canLoadMore(query);
  });
  self2.hook("instead", "loadCallback", (options, optgroups) => {
    if (!loading_more) {
      self2.clearOptions(clearFilter);
    } else if (load_more_opt) {
      const first_option = options[0];
      if (first_option !== void 0) {
        load_more_opt.dataset.value = first_option[self2.settings.valueField];
      }
    }
    orig_loadCallback.call(self2, options, optgroups);
    loading_more = false;
  });
  self2.hook("after", "refreshOptions", () => {
    const query = self2.lastValue;
    var option2;
    if (canLoadMore(query)) {
      option2 = self2.render("loading_more", {
        query
      });
      if (option2) {
        option2.setAttribute("data-selectable", "");
        load_more_opt = option2;
      }
    } else if (query in pagination && !dropdown_content.querySelector(".no-results")) {
      option2 = self2.render("no_more_results", {
        query
      });
    }
    if (option2) {
      addClasses(option2, self2.settings.optionClass);
      dropdown_content.append(option2);
    }
  });
  self2.on("initialize", () => {
    default_values = Object.keys(self2.options);
    dropdown_content = self2.dropdown_content;
    self2.settings.render = Object.assign({}, {
      loading_more: () => {
        return `<div class="loading-more-results">Loading more results ... </div>`;
      },
      no_more_results: () => {
        return `<div class="no-more-results">No more results</div>`;
      }
    }, self2.settings.render);
    dropdown_content.addEventListener("scroll", () => {
      if (!self2.settings.shouldLoadMore.call(self2)) {
        return;
      }
      if (!canLoadMore(self2.lastValue)) {
        return;
      }
      if (loading_more)
        return;
      loading_more = true;
      self2.load.call(self2, self2.lastValue);
    });
  });
}
TomSelect.define("change_listener", change_listener);
TomSelect.define("checkbox_options", checkbox_options);
TomSelect.define("clear_button", clear_button);
TomSelect.define("drag_drop", drag_drop);
TomSelect.define("dropdown_header", dropdown_header);
TomSelect.define("caret_position", caret_position);
TomSelect.define("dropdown_input", dropdown_input);
TomSelect.define("input_autogrow", input_autogrow);
TomSelect.define("no_backspace_delete", no_backspace_delete);
TomSelect.define("no_active_items", no_active_items);
TomSelect.define("optgroup_columns", optgroup_columns);
TomSelect.define("remove_button", remove_button);
TomSelect.define("restore_on_backspace", restore_on_backspace);
TomSelect.define("virtual_scroll", virtual_scroll);
/**!
 * Sortable 1.15.0
 * @author	RubaXa   <trash@rubaxa.org>
 * @author	owenm    <owen23355@gmail.com>
 * @license MIT
 */
function ownKeys(object, enumerableOnly) {
  var keys2 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread2(target) {
  for (var i3 = 1; i3 < arguments.length; i3++) {
    var source = arguments[i3] != null ? arguments[i3] : {};
    if (i3 % 2) {
      ownKeys(Object(source), true).forEach(function(key) {
        _defineProperty$w(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
function _typeof$D(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$D = function(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$D = function(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$D(obj);
}
function _defineProperty$w(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _extends() {
  _extends = Object.assign || function(target) {
    for (var i3 = 1; i3 < arguments.length; i3++) {
      var source = arguments[i3];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
function _objectWithoutPropertiesLoose$1(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i3;
  for (i3 = 0; i3 < sourceKeys.length; i3++) {
    key = sourceKeys[i3];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
function _objectWithoutProperties(source, excluded) {
  if (source == null)
    return {};
  var target = _objectWithoutPropertiesLoose$1(source, excluded);
  var key, i3;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i3 = 0; i3 < sourceSymbolKeys.length; i3++) {
      key = sourceSymbolKeys[i3];
      if (excluded.indexOf(key) >= 0)
        continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key))
        continue;
      target[key] = source[key];
    }
  }
  return target;
}
var version = "1.15.0";
function userAgent(pattern) {
  if (typeof window !== "undefined" && window.navigator) {
    return !!/* @__PURE__ */ navigator.userAgent.match(pattern);
  }
}
var IE11OrLess = userAgent(/(?:Trident.*rv[ :]?11\.|msie|iemobile|Windows Phone)/i);
var Edge = userAgent(/Edge/i);
var FireFox = userAgent(/firefox/i);
var Safari = userAgent(/safari/i) && !userAgent(/chrome/i) && !userAgent(/android/i);
var IOS = userAgent(/iP(ad|od|hone)/i);
var ChromeForAndroid = userAgent(/chrome/i) && userAgent(/android/i);
var captureMode = {
  capture: false,
  passive: false
};
function on$1(el2, event, fn3) {
  el2.addEventListener(event, fn3, !IE11OrLess && captureMode);
}
function off$1(el2, event, fn3) {
  el2.removeEventListener(event, fn3, !IE11OrLess && captureMode);
}
function matches$1(el2, selector) {
  if (!selector)
    return;
  selector[0] === ">" && (selector = selector.substring(1));
  if (el2) {
    try {
      if (el2.matches) {
        return el2.matches(selector);
      } else if (el2.msMatchesSelector) {
        return el2.msMatchesSelector(selector);
      } else if (el2.webkitMatchesSelector) {
        return el2.webkitMatchesSelector(selector);
      }
    } catch (_2) {
      return false;
    }
  }
  return false;
}
function getParentOrHost(el2) {
  return el2.host && el2 !== document && el2.host.nodeType ? el2.host : el2.parentNode;
}
function closest(el2, selector, ctx, includeCTX) {
  if (el2) {
    ctx = ctx || document;
    do {
      if (selector != null && (selector[0] === ">" ? el2.parentNode === ctx && matches$1(el2, selector) : matches$1(el2, selector)) || includeCTX && el2 === ctx) {
        return el2;
      }
      if (el2 === ctx)
        break;
    } while (el2 = getParentOrHost(el2));
  }
  return null;
}
var R_SPACE = /\s+/g;
function toggleClass(el2, name, state) {
  if (el2 && name) {
    if (el2.classList) {
      el2.classList[state ? "add" : "remove"](name);
    } else {
      var className = (" " + el2.className + " ").replace(R_SPACE, " ").replace(" " + name + " ", " ");
      el2.className = (className + (state ? " " + name : "")).replace(R_SPACE, " ");
    }
  }
}
function css(el2, prop, val) {
  var style2 = el2 && el2.style;
  if (style2) {
    if (val === void 0) {
      if (document.defaultView && document.defaultView.getComputedStyle) {
        val = document.defaultView.getComputedStyle(el2, "");
      } else if (el2.currentStyle) {
        val = el2.currentStyle;
      }
      return prop === void 0 ? val : val[prop];
    } else {
      if (!(prop in style2) && prop.indexOf("webkit") === -1) {
        prop = "-webkit-" + prop;
      }
      style2[prop] = val + (typeof val === "string" ? "" : "px");
    }
  }
}
function matrix(el2, selfOnly) {
  var appliedTransforms = "";
  if (typeof el2 === "string") {
    appliedTransforms = el2;
  } else {
    do {
      var transform = css(el2, "transform");
      if (transform && transform !== "none") {
        appliedTransforms = transform + " " + appliedTransforms;
      }
    } while (!selfOnly && (el2 = el2.parentNode));
  }
  var matrixFn = window.DOMMatrix || window.WebKitCSSMatrix || window.CSSMatrix || window.MSCSSMatrix;
  return matrixFn && new matrixFn(appliedTransforms);
}
function find$1(ctx, tagName, iterator) {
  if (ctx) {
    var list = ctx.getElementsByTagName(tagName), i3 = 0, n2 = list.length;
    if (iterator) {
      for (; i3 < n2; i3++) {
        iterator(list[i3], i3);
      }
    }
    return list;
  }
  return [];
}
function getWindowScrollingElement() {
  var scrollingElement = document.scrollingElement;
  if (scrollingElement) {
    return scrollingElement;
  } else {
    return document.documentElement;
  }
}
function getRect(el2, relativeToContainingBlock, relativeToNonStaticParent, undoScale, container) {
  if (!el2.getBoundingClientRect && el2 !== window)
    return;
  var elRect, top2, left2, bottom2, right2, height, width;
  if (el2 !== window && el2.parentNode && el2 !== getWindowScrollingElement()) {
    elRect = el2.getBoundingClientRect();
    top2 = elRect.top;
    left2 = elRect.left;
    bottom2 = elRect.bottom;
    right2 = elRect.right;
    height = elRect.height;
    width = elRect.width;
  } else {
    top2 = 0;
    left2 = 0;
    bottom2 = window.innerHeight;
    right2 = window.innerWidth;
    height = window.innerHeight;
    width = window.innerWidth;
  }
  if ((relativeToContainingBlock || relativeToNonStaticParent) && el2 !== window) {
    container = container || el2.parentNode;
    if (!IE11OrLess) {
      do {
        if (container && container.getBoundingClientRect && (css(container, "transform") !== "none" || relativeToNonStaticParent && css(container, "position") !== "static")) {
          var containerRect = container.getBoundingClientRect();
          top2 -= containerRect.top + parseInt(css(container, "border-top-width"));
          left2 -= containerRect.left + parseInt(css(container, "border-left-width"));
          bottom2 = top2 + elRect.height;
          right2 = left2 + elRect.width;
          break;
        }
      } while (container = container.parentNode);
    }
  }
  if (undoScale && el2 !== window) {
    var elMatrix = matrix(container || el2), scaleX2 = elMatrix && elMatrix.a, scaleY2 = elMatrix && elMatrix.d;
    if (elMatrix) {
      top2 /= scaleY2;
      left2 /= scaleX2;
      width /= scaleX2;
      height /= scaleY2;
      bottom2 = top2 + height;
      right2 = left2 + width;
    }
  }
  return {
    top: top2,
    left: left2,
    bottom: bottom2,
    right: right2,
    width,
    height
  };
}
function isScrolledPast(el2, elSide, parentSide) {
  var parent = getParentAutoScrollElement(el2, true), elSideVal = getRect(el2)[elSide];
  while (parent) {
    var parentSideVal = getRect(parent)[parentSide], visible = void 0;
    if (parentSide === "top" || parentSide === "left") {
      visible = elSideVal >= parentSideVal;
    } else {
      visible = elSideVal <= parentSideVal;
    }
    if (!visible)
      return parent;
    if (parent === getWindowScrollingElement())
      break;
    parent = getParentAutoScrollElement(parent, false);
  }
  return false;
}
function getChild(el2, childNum, options, includeDragEl) {
  var currentChild = 0, i3 = 0, children = el2.children;
  while (i3 < children.length) {
    if (children[i3].style.display !== "none" && children[i3] !== Sortable$1.ghost && (includeDragEl || children[i3] !== Sortable$1.dragged) && closest(children[i3], options.draggable, el2, false)) {
      if (currentChild === childNum) {
        return children[i3];
      }
      currentChild++;
    }
    i3++;
  }
  return null;
}
function lastChild(el2, selector) {
  var last = el2.lastElementChild;
  while (last && (last === Sortable$1.ghost || css(last, "display") === "none" || selector && !matches$1(last, selector))) {
    last = last.previousElementSibling;
  }
  return last || null;
}
function index(el2, selector) {
  var index2 = 0;
  if (!el2 || !el2.parentNode) {
    return -1;
  }
  while (el2 = el2.previousElementSibling) {
    if (el2.nodeName.toUpperCase() !== "TEMPLATE" && el2 !== Sortable$1.clone && (!selector || matches$1(el2, selector))) {
      index2++;
    }
  }
  return index2;
}
function getRelativeScrollOffset(el2) {
  var offsetLeft = 0, offsetTop2 = 0, winScroller = getWindowScrollingElement();
  if (el2) {
    do {
      var elMatrix = matrix(el2), scaleX2 = elMatrix.a, scaleY2 = elMatrix.d;
      offsetLeft += el2.scrollLeft * scaleX2;
      offsetTop2 += el2.scrollTop * scaleY2;
    } while (el2 !== winScroller && (el2 = el2.parentNode));
  }
  return [offsetLeft, offsetTop2];
}
function indexOfObject(arr, obj) {
  for (var i3 in arr) {
    if (!arr.hasOwnProperty(i3))
      continue;
    for (var key in obj) {
      if (obj.hasOwnProperty(key) && obj[key] === arr[i3][key])
        return Number(i3);
    }
  }
  return -1;
}
function getParentAutoScrollElement(el2, includeSelf) {
  if (!el2 || !el2.getBoundingClientRect)
    return getWindowScrollingElement();
  var elem = el2;
  var gotSelf = false;
  do {
    if (elem.clientWidth < elem.scrollWidth || elem.clientHeight < elem.scrollHeight) {
      var elemCSS = css(elem);
      if (elem.clientWidth < elem.scrollWidth && (elemCSS.overflowX == "auto" || elemCSS.overflowX == "scroll") || elem.clientHeight < elem.scrollHeight && (elemCSS.overflowY == "auto" || elemCSS.overflowY == "scroll")) {
        if (!elem.getBoundingClientRect || elem === document.body)
          return getWindowScrollingElement();
        if (gotSelf || includeSelf)
          return elem;
        gotSelf = true;
      }
    }
  } while (elem = elem.parentNode);
  return getWindowScrollingElement();
}
function extend(dst, src) {
  if (dst && src) {
    for (var key in src) {
      if (src.hasOwnProperty(key)) {
        dst[key] = src[key];
      }
    }
  }
  return dst;
}
function isRectEqual(rect1, rect2) {
  return Math.round(rect1.top) === Math.round(rect2.top) && Math.round(rect1.left) === Math.round(rect2.left) && Math.round(rect1.height) === Math.round(rect2.height) && Math.round(rect1.width) === Math.round(rect2.width);
}
var _throttleTimeout;
function throttle(callback, ms) {
  return function() {
    if (!_throttleTimeout) {
      var args = arguments, _this = this;
      if (args.length === 1) {
        callback.call(_this, args[0]);
      } else {
        callback.apply(_this, args);
      }
      _throttleTimeout = setTimeout(function() {
        _throttleTimeout = void 0;
      }, ms);
    }
  };
}
function cancelThrottle() {
  clearTimeout(_throttleTimeout);
  _throttleTimeout = void 0;
}
function scrollBy(el2, x3, y4) {
  el2.scrollLeft += x3;
  el2.scrollTop += y4;
}
function clone(el2) {
  var Polymer = window.Polymer;
  var $2 = window.jQuery || window.Zepto;
  if (Polymer && Polymer.dom) {
    return Polymer.dom(el2).cloneNode(true);
  } else if ($2) {
    return $2(el2).clone(true)[0];
  } else {
    return el2.cloneNode(true);
  }
}
var expando = "Sortable" + new Date().getTime();
function AnimationStateManager() {
  var animationStates = [], animationCallbackId;
  return {
    captureAnimationState: function captureAnimationState() {
      animationStates = [];
      if (!this.options.animation)
        return;
      var children = [].slice.call(this.el.children);
      children.forEach(function(child) {
        if (css(child, "display") === "none" || child === Sortable$1.ghost)
          return;
        animationStates.push({
          target: child,
          rect: getRect(child)
        });
        var fromRect = _objectSpread2({}, animationStates[animationStates.length - 1].rect);
        if (child.thisAnimationDuration) {
          var childMatrix = matrix(child, true);
          if (childMatrix) {
            fromRect.top -= childMatrix.f;
            fromRect.left -= childMatrix.e;
          }
        }
        child.fromRect = fromRect;
      });
    },
    addAnimationState: function addAnimationState(state) {
      animationStates.push(state);
    },
    removeAnimationState: function removeAnimationState(target) {
      animationStates.splice(indexOfObject(animationStates, {
        target
      }), 1);
    },
    animateAll: function animateAll(callback) {
      var _this = this;
      if (!this.options.animation) {
        clearTimeout(animationCallbackId);
        if (typeof callback === "function")
          callback();
        return;
      }
      var animating = false, animationTime = 0;
      animationStates.forEach(function(state) {
        var time = 0, target = state.target, fromRect = target.fromRect, toRect = getRect(target), prevFromRect = target.prevFromRect, prevToRect = target.prevToRect, animatingRect = state.rect, targetMatrix = matrix(target, true);
        if (targetMatrix) {
          toRect.top -= targetMatrix.f;
          toRect.left -= targetMatrix.e;
        }
        target.toRect = toRect;
        if (target.thisAnimationDuration) {
          if (isRectEqual(prevFromRect, toRect) && !isRectEqual(fromRect, toRect) && (animatingRect.top - toRect.top) / (animatingRect.left - toRect.left) === (fromRect.top - toRect.top) / (fromRect.left - toRect.left)) {
            time = calculateRealTime(animatingRect, prevFromRect, prevToRect, _this.options);
          }
        }
        if (!isRectEqual(toRect, fromRect)) {
          target.prevFromRect = fromRect;
          target.prevToRect = toRect;
          if (!time) {
            time = _this.options.animation;
          }
          _this.animate(target, animatingRect, toRect, time);
        }
        if (time) {
          animating = true;
          animationTime = Math.max(animationTime, time);
          clearTimeout(target.animationResetTimer);
          target.animationResetTimer = setTimeout(function() {
            target.animationTime = 0;
            target.prevFromRect = null;
            target.fromRect = null;
            target.prevToRect = null;
            target.thisAnimationDuration = null;
          }, time);
          target.thisAnimationDuration = time;
        }
      });
      clearTimeout(animationCallbackId);
      if (!animating) {
        if (typeof callback === "function")
          callback();
      } else {
        animationCallbackId = setTimeout(function() {
          if (typeof callback === "function")
            callback();
        }, animationTime);
      }
      animationStates = [];
    },
    animate: function animate(target, currentRect, toRect, duration2) {
      if (duration2) {
        css(target, "transition", "");
        css(target, "transform", "");
        var elMatrix = matrix(this.el), scaleX2 = elMatrix && elMatrix.a, scaleY2 = elMatrix && elMatrix.d, translateX2 = (currentRect.left - toRect.left) / (scaleX2 || 1), translateY2 = (currentRect.top - toRect.top) / (scaleY2 || 1);
        target.animatingX = !!translateX2;
        target.animatingY = !!translateY2;
        css(target, "transform", "translate3d(" + translateX2 + "px," + translateY2 + "px,0)");
        this.forRepaintDummy = repaint(target);
        css(target, "transition", "transform " + duration2 + "ms" + (this.options.easing ? " " + this.options.easing : ""));
        css(target, "transform", "translate3d(0,0,0)");
        typeof target.animated === "number" && clearTimeout(target.animated);
        target.animated = setTimeout(function() {
          css(target, "transition", "");
          css(target, "transform", "");
          target.animated = false;
          target.animatingX = false;
          target.animatingY = false;
        }, duration2);
      }
    }
  };
}
function repaint(target) {
  return target.offsetWidth;
}
function calculateRealTime(animatingRect, fromRect, toRect, options) {
  return Math.sqrt(Math.pow(fromRect.top - animatingRect.top, 2) + Math.pow(fromRect.left - animatingRect.left, 2)) / Math.sqrt(Math.pow(fromRect.top - toRect.top, 2) + Math.pow(fromRect.left - toRect.left, 2)) * options.animation;
}
var plugins = [];
var defaults$1 = {
  initializeByDefault: true
};
var PluginManager = {
  mount: function mount(plugin) {
    for (var option2 in defaults$1) {
      if (defaults$1.hasOwnProperty(option2) && !(option2 in plugin)) {
        plugin[option2] = defaults$1[option2];
      }
    }
    plugins.forEach(function(p2) {
      if (p2.pluginName === plugin.pluginName) {
        throw "Sortable: Cannot mount plugin ".concat(plugin.pluginName, " more than once");
      }
    });
    plugins.push(plugin);
  },
  pluginEvent: function pluginEvent(eventName, sortable, evt) {
    var _this = this;
    this.eventCanceled = false;
    evt.cancel = function() {
      _this.eventCanceled = true;
    };
    var eventNameGlobal = eventName + "Global";
    plugins.forEach(function(plugin) {
      if (!sortable[plugin.pluginName])
        return;
      if (sortable[plugin.pluginName][eventNameGlobal]) {
        sortable[plugin.pluginName][eventNameGlobal](_objectSpread2({
          sortable
        }, evt));
      }
      if (sortable.options[plugin.pluginName] && sortable[plugin.pluginName][eventName]) {
        sortable[plugin.pluginName][eventName](_objectSpread2({
          sortable
        }, evt));
      }
    });
  },
  initializePlugins: function initializePlugins(sortable, el2, defaults2, options) {
    plugins.forEach(function(plugin) {
      var pluginName = plugin.pluginName;
      if (!sortable.options[pluginName] && !plugin.initializeByDefault)
        return;
      var initialized = new plugin(sortable, el2, sortable.options);
      initialized.sortable = sortable;
      initialized.options = sortable.options;
      sortable[pluginName] = initialized;
      _extends(defaults2, initialized.defaults);
    });
    for (var option2 in sortable.options) {
      if (!sortable.options.hasOwnProperty(option2))
        continue;
      var modified = this.modifyOption(sortable, option2, sortable.options[option2]);
      if (typeof modified !== "undefined") {
        sortable.options[option2] = modified;
      }
    }
  },
  getEventProperties: function getEventProperties(name, sortable) {
    var eventProperties = {};
    plugins.forEach(function(plugin) {
      if (typeof plugin.eventProperties !== "function")
        return;
      _extends(eventProperties, plugin.eventProperties.call(sortable[plugin.pluginName], name));
    });
    return eventProperties;
  },
  modifyOption: function modifyOption(sortable, name, value) {
    var modifiedValue;
    plugins.forEach(function(plugin) {
      if (!sortable[plugin.pluginName])
        return;
      if (plugin.optionListeners && typeof plugin.optionListeners[name] === "function") {
        modifiedValue = plugin.optionListeners[name].call(sortable[plugin.pluginName], value);
      }
    });
    return modifiedValue;
  }
};
function dispatchEvent$1(_ref2) {
  var sortable = _ref2.sortable, rootEl2 = _ref2.rootEl, name = _ref2.name, targetEl = _ref2.targetEl, cloneEl2 = _ref2.cloneEl, toEl = _ref2.toEl, fromEl = _ref2.fromEl, oldIndex2 = _ref2.oldIndex, newIndex2 = _ref2.newIndex, oldDraggableIndex2 = _ref2.oldDraggableIndex, newDraggableIndex2 = _ref2.newDraggableIndex, originalEvent = _ref2.originalEvent, putSortable2 = _ref2.putSortable, extraEventProperties = _ref2.extraEventProperties;
  sortable = sortable || rootEl2 && rootEl2[expando];
  if (!sortable)
    return;
  var evt, options = sortable.options, onName = "on" + name.charAt(0).toUpperCase() + name.substr(1);
  if (window.CustomEvent && !IE11OrLess && !Edge) {
    evt = new CustomEvent(name, {
      bubbles: true,
      cancelable: true
    });
  } else {
    evt = document.createEvent("Event");
    evt.initEvent(name, true, true);
  }
  evt.to = toEl || rootEl2;
  evt.from = fromEl || rootEl2;
  evt.item = targetEl || rootEl2;
  evt.clone = cloneEl2;
  evt.oldIndex = oldIndex2;
  evt.newIndex = newIndex2;
  evt.oldDraggableIndex = oldDraggableIndex2;
  evt.newDraggableIndex = newDraggableIndex2;
  evt.originalEvent = originalEvent;
  evt.pullMode = putSortable2 ? putSortable2.lastPutMode : void 0;
  var allEventProperties = _objectSpread2(_objectSpread2({}, extraEventProperties), PluginManager.getEventProperties(name, sortable));
  for (var option2 in allEventProperties) {
    evt[option2] = allEventProperties[option2];
  }
  if (rootEl2) {
    rootEl2.dispatchEvent(evt);
  }
  if (options[onName]) {
    options[onName].call(sortable, evt);
  }
}
var _excluded = ["evt"];
var pluginEvent2 = function pluginEvent3(eventName, sortable) {
  var _ref2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, originalEvent = _ref2.evt, data = _objectWithoutProperties(_ref2, _excluded);
  PluginManager.pluginEvent.bind(Sortable$1)(eventName, sortable, _objectSpread2({
    dragEl,
    parentEl,
    ghostEl,
    rootEl,
    nextEl,
    lastDownEl,
    cloneEl,
    cloneHidden,
    dragStarted: moved,
    putSortable,
    activeSortable: Sortable$1.active,
    originalEvent,
    oldIndex,
    oldDraggableIndex,
    newIndex,
    newDraggableIndex,
    hideGhostForTarget: _hideGhostForTarget,
    unhideGhostForTarget: _unhideGhostForTarget,
    cloneNowHidden: function cloneNowHidden() {
      cloneHidden = true;
    },
    cloneNowShown: function cloneNowShown() {
      cloneHidden = false;
    },
    dispatchSortableEvent: function dispatchSortableEvent(name) {
      _dispatchEvent({
        sortable,
        name,
        originalEvent
      });
    }
  }, data));
};
function _dispatchEvent(info) {
  dispatchEvent$1(_objectSpread2({
    putSortable,
    cloneEl,
    targetEl: dragEl,
    rootEl,
    oldIndex,
    oldDraggableIndex,
    newIndex,
    newDraggableIndex
  }, info));
}
var dragEl, parentEl, ghostEl, rootEl, nextEl, lastDownEl, cloneEl, cloneHidden, oldIndex, newIndex, oldDraggableIndex, newDraggableIndex, activeGroup, putSortable, awaitingDragStarted = false, ignoreNextClick = false, sortables = [], tapEvt, touchEvt, lastDx, lastDy, tapDistanceLeft, tapDistanceTop, moved, lastTarget, lastDirection, pastFirstInvertThresh = false, isCircumstantialInvert = false, targetMoveDistance, ghostRelativeParent, ghostRelativeParentInitialScroll = [], _silent = false, savedInputChecked = [];
var documentExists = typeof document !== "undefined", PositionGhostAbsolutely = IOS, CSSFloatProperty = Edge || IE11OrLess ? "cssFloat" : "float", supportDraggable = documentExists && !ChromeForAndroid && !IOS && "draggable" in document.createElement("div"), supportCssPointerEvents = function() {
  if (!documentExists)
    return;
  if (IE11OrLess) {
    return false;
  }
  var el2 = document.createElement("x");
  el2.style.cssText = "pointer-events:auto";
  return el2.style.pointerEvents === "auto";
}(), _detectDirection = function _detectDirection2(el2, options) {
  var elCSS = css(el2), elWidth = parseInt(elCSS.width) - parseInt(elCSS.paddingLeft) - parseInt(elCSS.paddingRight) - parseInt(elCSS.borderLeftWidth) - parseInt(elCSS.borderRightWidth), child1 = getChild(el2, 0, options), child2 = getChild(el2, 1, options), firstChildCSS = child1 && css(child1), secondChildCSS = child2 && css(child2), firstChildWidth = firstChildCSS && parseInt(firstChildCSS.marginLeft) + parseInt(firstChildCSS.marginRight) + getRect(child1).width, secondChildWidth = secondChildCSS && parseInt(secondChildCSS.marginLeft) + parseInt(secondChildCSS.marginRight) + getRect(child2).width;
  if (elCSS.display === "flex") {
    return elCSS.flexDirection === "column" || elCSS.flexDirection === "column-reverse" ? "vertical" : "horizontal";
  }
  if (elCSS.display === "grid") {
    return elCSS.gridTemplateColumns.split(" ").length <= 1 ? "vertical" : "horizontal";
  }
  if (child1 && firstChildCSS["float"] && firstChildCSS["float"] !== "none") {
    var touchingSideChild2 = firstChildCSS["float"] === "left" ? "left" : "right";
    return child2 && (secondChildCSS.clear === "both" || secondChildCSS.clear === touchingSideChild2) ? "vertical" : "horizontal";
  }
  return child1 && (firstChildCSS.display === "block" || firstChildCSS.display === "flex" || firstChildCSS.display === "table" || firstChildCSS.display === "grid" || firstChildWidth >= elWidth && elCSS[CSSFloatProperty] === "none" || child2 && elCSS[CSSFloatProperty] === "none" && firstChildWidth + secondChildWidth > elWidth) ? "vertical" : "horizontal";
}, _dragElInRowColumn = function _dragElInRowColumn2(dragRect, targetRect, vertical) {
  var dragElS1Opp = vertical ? dragRect.left : dragRect.top, dragElS2Opp = vertical ? dragRect.right : dragRect.bottom, dragElOppLength = vertical ? dragRect.width : dragRect.height, targetS1Opp = vertical ? targetRect.left : targetRect.top, targetS2Opp = vertical ? targetRect.right : targetRect.bottom, targetOppLength = vertical ? targetRect.width : targetRect.height;
  return dragElS1Opp === targetS1Opp || dragElS2Opp === targetS2Opp || dragElS1Opp + dragElOppLength / 2 === targetS1Opp + targetOppLength / 2;
}, _detectNearestEmptySortable = function _detectNearestEmptySortable2(x3, y4) {
  var ret;
  sortables.some(function(sortable) {
    var threshold = sortable[expando].options.emptyInsertThreshold;
    if (!threshold || lastChild(sortable))
      return;
    var rect = getRect(sortable), insideHorizontally = x3 >= rect.left - threshold && x3 <= rect.right + threshold, insideVertically = y4 >= rect.top - threshold && y4 <= rect.bottom + threshold;
    if (insideHorizontally && insideVertically) {
      return ret = sortable;
    }
  });
  return ret;
}, _prepareGroup = function _prepareGroup2(options) {
  function toFn(value, pull) {
    return function(to, from3, dragEl2, evt) {
      var sameGroup = to.options.group.name && from3.options.group.name && to.options.group.name === from3.options.group.name;
      if (value == null && (pull || sameGroup)) {
        return true;
      } else if (value == null || value === false) {
        return false;
      } else if (pull && value === "clone") {
        return value;
      } else if (typeof value === "function") {
        return toFn(value(to, from3, dragEl2, evt), pull)(to, from3, dragEl2, evt);
      } else {
        var otherGroup = (pull ? to : from3).options.group.name;
        return value === true || typeof value === "string" && value === otherGroup || value.join && value.indexOf(otherGroup) > -1;
      }
    };
  }
  var group = {};
  var originalGroup = options.group;
  if (!originalGroup || _typeof$D(originalGroup) != "object") {
    originalGroup = {
      name: originalGroup
    };
  }
  group.name = originalGroup.name;
  group.checkPull = toFn(originalGroup.pull, true);
  group.checkPut = toFn(originalGroup.put);
  group.revertClone = originalGroup.revertClone;
  options.group = group;
}, _hideGhostForTarget = function _hideGhostForTarget2() {
  if (!supportCssPointerEvents && ghostEl) {
    css(ghostEl, "display", "none");
  }
}, _unhideGhostForTarget = function _unhideGhostForTarget2() {
  if (!supportCssPointerEvents && ghostEl) {
    css(ghostEl, "display", "");
  }
};
if (documentExists && !ChromeForAndroid) {
  document.addEventListener("click", function(evt) {
    if (ignoreNextClick) {
      evt.preventDefault();
      evt.stopPropagation && evt.stopPropagation();
      evt.stopImmediatePropagation && evt.stopImmediatePropagation();
      ignoreNextClick = false;
      return false;
    }
  }, true);
}
var nearestEmptyInsertDetectEvent = function nearestEmptyInsertDetectEvent2(evt) {
  if (dragEl) {
    evt = evt.touches ? evt.touches[0] : evt;
    var nearest = _detectNearestEmptySortable(evt.clientX, evt.clientY);
    if (nearest) {
      var event = {};
      for (var i3 in evt) {
        if (evt.hasOwnProperty(i3)) {
          event[i3] = evt[i3];
        }
      }
      event.target = event.rootEl = nearest;
      event.preventDefault = void 0;
      event.stopPropagation = void 0;
      nearest[expando]._onDragOver(event);
    }
  }
};
var _checkOutsideTargetEl = function _checkOutsideTargetEl2(evt) {
  if (dragEl) {
    dragEl.parentNode[expando]._isOutsideThisEl(evt.target);
  }
};
function Sortable$1(el2, options) {
  if (!(el2 && el2.nodeType && el2.nodeType === 1)) {
    throw "Sortable: `el` must be an HTMLElement, not ".concat({}.toString.call(el2));
  }
  this.el = el2;
  this.options = options = _extends({}, options);
  el2[expando] = this;
  var defaults2 = {
    group: null,
    sort: true,
    disabled: false,
    store: null,
    handle: null,
    draggable: /^[uo]l$/i.test(el2.nodeName) ? ">li" : ">*",
    swapThreshold: 1,
    invertSwap: false,
    invertedSwapThreshold: null,
    removeCloneOnHide: true,
    direction: function direction() {
      return _detectDirection(el2, this.options);
    },
    ghostClass: "sortable-ghost",
    chosenClass: "sortable-chosen",
    dragClass: "sortable-drag",
    ignore: "a, img",
    filter: null,
    preventOnFilter: true,
    animation: 0,
    easing: null,
    setData: function setData(dataTransfer, dragEl2) {
      dataTransfer.setData("Text", dragEl2.textContent);
    },
    dropBubble: false,
    dragoverBubble: false,
    dataIdAttr: "data-id",
    delay: 0,
    delayOnTouchOnly: false,
    touchStartThreshold: (Number.parseInt ? Number : window).parseInt(window.devicePixelRatio, 10) || 1,
    forceFallback: false,
    fallbackClass: "sortable-fallback",
    fallbackOnBody: false,
    fallbackTolerance: 0,
    fallbackOffset: {
      x: 0,
      y: 0
    },
    supportPointer: Sortable$1.supportPointer !== false && "PointerEvent" in window && !Safari,
    emptyInsertThreshold: 5
  };
  PluginManager.initializePlugins(this, el2, defaults2);
  for (var name in defaults2) {
    !(name in options) && (options[name] = defaults2[name]);
  }
  _prepareGroup(options);
  for (var fn3 in this) {
    if (fn3.charAt(0) === "_" && typeof this[fn3] === "function") {
      this[fn3] = this[fn3].bind(this);
    }
  }
  this.nativeDraggable = options.forceFallback ? false : supportDraggable;
  if (this.nativeDraggable) {
    this.options.touchStartThreshold = 1;
  }
  if (options.supportPointer) {
    on$1(el2, "pointerdown", this._onTapStart);
  } else {
    on$1(el2, "mousedown", this._onTapStart);
    on$1(el2, "touchstart", this._onTapStart);
  }
  if (this.nativeDraggable) {
    on$1(el2, "dragover", this);
    on$1(el2, "dragenter", this);
  }
  sortables.push(this.el);
  options.store && options.store.get && this.sort(options.store.get(this) || []);
  _extends(this, AnimationStateManager());
}
Sortable$1.prototype = {
  constructor: Sortable$1,
  _isOutsideThisEl: function _isOutsideThisEl(target) {
    if (!this.el.contains(target) && target !== this.el) {
      lastTarget = null;
    }
  },
  _getDirection: function _getDirection(evt, target) {
    return typeof this.options.direction === "function" ? this.options.direction.call(this, evt, target, dragEl) : this.options.direction;
  },
  _onTapStart: function _onTapStart(evt) {
    if (!evt.cancelable)
      return;
    var _this = this, el2 = this.el, options = this.options, preventOnFilter = options.preventOnFilter, type = evt.type, touch = evt.touches && evt.touches[0] || evt.pointerType && evt.pointerType === "touch" && evt, target = (touch || evt).target, originalTarget = evt.target.shadowRoot && (evt.path && evt.path[0] || evt.composedPath && evt.composedPath()[0]) || target, filter = options.filter;
    _saveInputCheckedState(el2);
    if (dragEl) {
      return;
    }
    if (/mousedown|pointerdown/.test(type) && evt.button !== 0 || options.disabled) {
      return;
    }
    if (originalTarget.isContentEditable) {
      return;
    }
    if (!this.nativeDraggable && Safari && target && target.tagName.toUpperCase() === "SELECT") {
      return;
    }
    target = closest(target, options.draggable, el2, false);
    if (target && target.animated) {
      return;
    }
    if (lastDownEl === target) {
      return;
    }
    oldIndex = index(target);
    oldDraggableIndex = index(target, options.draggable);
    if (typeof filter === "function") {
      if (filter.call(this, evt, target, this)) {
        _dispatchEvent({
          sortable: _this,
          rootEl: originalTarget,
          name: "filter",
          targetEl: target,
          toEl: el2,
          fromEl: el2
        });
        pluginEvent2("filter", _this, {
          evt
        });
        preventOnFilter && evt.cancelable && evt.preventDefault();
        return;
      }
    } else if (filter) {
      filter = filter.split(",").some(function(criteria) {
        criteria = closest(originalTarget, criteria.trim(), el2, false);
        if (criteria) {
          _dispatchEvent({
            sortable: _this,
            rootEl: criteria,
            name: "filter",
            targetEl: target,
            fromEl: el2,
            toEl: el2
          });
          pluginEvent2("filter", _this, {
            evt
          });
          return true;
        }
      });
      if (filter) {
        preventOnFilter && evt.cancelable && evt.preventDefault();
        return;
      }
    }
    if (options.handle && !closest(originalTarget, options.handle, el2, false)) {
      return;
    }
    this._prepareDragStart(evt, touch, target);
  },
  _prepareDragStart: function _prepareDragStart(evt, touch, target) {
    var _this = this, el2 = _this.el, options = _this.options, ownerDocument = el2.ownerDocument, dragStartFn;
    if (target && !dragEl && target.parentNode === el2) {
      var dragRect = getRect(target);
      rootEl = el2;
      dragEl = target;
      parentEl = dragEl.parentNode;
      nextEl = dragEl.nextSibling;
      lastDownEl = target;
      activeGroup = options.group;
      Sortable$1.dragged = dragEl;
      tapEvt = {
        target: dragEl,
        clientX: (touch || evt).clientX,
        clientY: (touch || evt).clientY
      };
      tapDistanceLeft = tapEvt.clientX - dragRect.left;
      tapDistanceTop = tapEvt.clientY - dragRect.top;
      this._lastX = (touch || evt).clientX;
      this._lastY = (touch || evt).clientY;
      dragEl.style["will-change"] = "all";
      dragStartFn = function dragStartFn2() {
        pluginEvent2("delayEnded", _this, {
          evt
        });
        if (Sortable$1.eventCanceled) {
          _this._onDrop();
          return;
        }
        _this._disableDelayedDragEvents();
        if (!FireFox && _this.nativeDraggable) {
          dragEl.draggable = true;
        }
        _this._triggerDragStart(evt, touch);
        _dispatchEvent({
          sortable: _this,
          name: "choose",
          originalEvent: evt
        });
        toggleClass(dragEl, options.chosenClass, true);
      };
      options.ignore.split(",").forEach(function(criteria) {
        find$1(dragEl, criteria.trim(), _disableDraggable);
      });
      on$1(ownerDocument, "dragover", nearestEmptyInsertDetectEvent);
      on$1(ownerDocument, "mousemove", nearestEmptyInsertDetectEvent);
      on$1(ownerDocument, "touchmove", nearestEmptyInsertDetectEvent);
      on$1(ownerDocument, "mouseup", _this._onDrop);
      on$1(ownerDocument, "touchend", _this._onDrop);
      on$1(ownerDocument, "touchcancel", _this._onDrop);
      if (FireFox && this.nativeDraggable) {
        this.options.touchStartThreshold = 4;
        dragEl.draggable = true;
      }
      pluginEvent2("delayStart", this, {
        evt
      });
      if (options.delay && (!options.delayOnTouchOnly || touch) && (!this.nativeDraggable || !(Edge || IE11OrLess))) {
        if (Sortable$1.eventCanceled) {
          this._onDrop();
          return;
        }
        on$1(ownerDocument, "mouseup", _this._disableDelayedDrag);
        on$1(ownerDocument, "touchend", _this._disableDelayedDrag);
        on$1(ownerDocument, "touchcancel", _this._disableDelayedDrag);
        on$1(ownerDocument, "mousemove", _this._delayedDragTouchMoveHandler);
        on$1(ownerDocument, "touchmove", _this._delayedDragTouchMoveHandler);
        options.supportPointer && on$1(ownerDocument, "pointermove", _this._delayedDragTouchMoveHandler);
        _this._dragStartTimer = setTimeout(dragStartFn, options.delay);
      } else {
        dragStartFn();
      }
    }
  },
  _delayedDragTouchMoveHandler: function _delayedDragTouchMoveHandler(e3) {
    var touch = e3.touches ? e3.touches[0] : e3;
    if (Math.max(Math.abs(touch.clientX - this._lastX), Math.abs(touch.clientY - this._lastY)) >= Math.floor(this.options.touchStartThreshold / (this.nativeDraggable && window.devicePixelRatio || 1))) {
      this._disableDelayedDrag();
    }
  },
  _disableDelayedDrag: function _disableDelayedDrag() {
    dragEl && _disableDraggable(dragEl);
    clearTimeout(this._dragStartTimer);
    this._disableDelayedDragEvents();
  },
  _disableDelayedDragEvents: function _disableDelayedDragEvents() {
    var ownerDocument = this.el.ownerDocument;
    off$1(ownerDocument, "mouseup", this._disableDelayedDrag);
    off$1(ownerDocument, "touchend", this._disableDelayedDrag);
    off$1(ownerDocument, "touchcancel", this._disableDelayedDrag);
    off$1(ownerDocument, "mousemove", this._delayedDragTouchMoveHandler);
    off$1(ownerDocument, "touchmove", this._delayedDragTouchMoveHandler);
    off$1(ownerDocument, "pointermove", this._delayedDragTouchMoveHandler);
  },
  _triggerDragStart: function _triggerDragStart(evt, touch) {
    touch = touch || evt.pointerType == "touch" && evt;
    if (!this.nativeDraggable || touch) {
      if (this.options.supportPointer) {
        on$1(document, "pointermove", this._onTouchMove);
      } else if (touch) {
        on$1(document, "touchmove", this._onTouchMove);
      } else {
        on$1(document, "mousemove", this._onTouchMove);
      }
    } else {
      on$1(dragEl, "dragend", this);
      on$1(rootEl, "dragstart", this._onDragStart);
    }
    try {
      if (document.selection) {
        _nextTick(function() {
          document.selection.empty();
        });
      } else {
        window.getSelection().removeAllRanges();
      }
    } catch (err) {
    }
  },
  _dragStarted: function _dragStarted(fallback, evt) {
    awaitingDragStarted = false;
    if (rootEl && dragEl) {
      pluginEvent2("dragStarted", this, {
        evt
      });
      if (this.nativeDraggable) {
        on$1(document, "dragover", _checkOutsideTargetEl);
      }
      var options = this.options;
      !fallback && toggleClass(dragEl, options.dragClass, false);
      toggleClass(dragEl, options.ghostClass, true);
      Sortable$1.active = this;
      fallback && this._appendGhost();
      _dispatchEvent({
        sortable: this,
        name: "start",
        originalEvent: evt
      });
    } else {
      this._nulling();
    }
  },
  _emulateDragOver: function _emulateDragOver() {
    if (touchEvt) {
      this._lastX = touchEvt.clientX;
      this._lastY = touchEvt.clientY;
      _hideGhostForTarget();
      var target = document.elementFromPoint(touchEvt.clientX, touchEvt.clientY);
      var parent = target;
      while (target && target.shadowRoot) {
        target = target.shadowRoot.elementFromPoint(touchEvt.clientX, touchEvt.clientY);
        if (target === parent)
          break;
        parent = target;
      }
      dragEl.parentNode[expando]._isOutsideThisEl(target);
      if (parent) {
        do {
          if (parent[expando]) {
            var inserted = void 0;
            inserted = parent[expando]._onDragOver({
              clientX: touchEvt.clientX,
              clientY: touchEvt.clientY,
              target,
              rootEl: parent
            });
            if (inserted && !this.options.dragoverBubble) {
              break;
            }
          }
          target = parent;
        } while (parent = parent.parentNode);
      }
      _unhideGhostForTarget();
    }
  },
  _onTouchMove: function _onTouchMove(evt) {
    if (tapEvt) {
      var options = this.options, fallbackTolerance = options.fallbackTolerance, fallbackOffset = options.fallbackOffset, touch = evt.touches ? evt.touches[0] : evt, ghostMatrix = ghostEl && matrix(ghostEl, true), scaleX2 = ghostEl && ghostMatrix && ghostMatrix.a, scaleY2 = ghostEl && ghostMatrix && ghostMatrix.d, relativeScrollOffset = PositionGhostAbsolutely && ghostRelativeParent && getRelativeScrollOffset(ghostRelativeParent), dx = (touch.clientX - tapEvt.clientX + fallbackOffset.x) / (scaleX2 || 1) + (relativeScrollOffset ? relativeScrollOffset[0] - ghostRelativeParentInitialScroll[0] : 0) / (scaleX2 || 1), dy = (touch.clientY - tapEvt.clientY + fallbackOffset.y) / (scaleY2 || 1) + (relativeScrollOffset ? relativeScrollOffset[1] - ghostRelativeParentInitialScroll[1] : 0) / (scaleY2 || 1);
      if (!Sortable$1.active && !awaitingDragStarted) {
        if (fallbackTolerance && Math.max(Math.abs(touch.clientX - this._lastX), Math.abs(touch.clientY - this._lastY)) < fallbackTolerance) {
          return;
        }
        this._onDragStart(evt, true);
      }
      if (ghostEl) {
        if (ghostMatrix) {
          ghostMatrix.e += dx - (lastDx || 0);
          ghostMatrix.f += dy - (lastDy || 0);
        } else {
          ghostMatrix = {
            a: 1,
            b: 0,
            c: 0,
            d: 1,
            e: dx,
            f: dy
          };
        }
        var cssMatrix = "matrix(".concat(ghostMatrix.a, ",").concat(ghostMatrix.b, ",").concat(ghostMatrix.c, ",").concat(ghostMatrix.d, ",").concat(ghostMatrix.e, ",").concat(ghostMatrix.f, ")");
        css(ghostEl, "webkitTransform", cssMatrix);
        css(ghostEl, "mozTransform", cssMatrix);
        css(ghostEl, "msTransform", cssMatrix);
        css(ghostEl, "transform", cssMatrix);
        lastDx = dx;
        lastDy = dy;
        touchEvt = touch;
      }
      evt.cancelable && evt.preventDefault();
    }
  },
  _appendGhost: function _appendGhost() {
    if (!ghostEl) {
      var container = this.options.fallbackOnBody ? document.body : rootEl, rect = getRect(dragEl, true, PositionGhostAbsolutely, true, container), options = this.options;
      if (PositionGhostAbsolutely) {
        ghostRelativeParent = container;
        while (css(ghostRelativeParent, "position") === "static" && css(ghostRelativeParent, "transform") === "none" && ghostRelativeParent !== document) {
          ghostRelativeParent = ghostRelativeParent.parentNode;
        }
        if (ghostRelativeParent !== document.body && ghostRelativeParent !== document.documentElement) {
          if (ghostRelativeParent === document)
            ghostRelativeParent = getWindowScrollingElement();
          rect.top += ghostRelativeParent.scrollTop;
          rect.left += ghostRelativeParent.scrollLeft;
        } else {
          ghostRelativeParent = getWindowScrollingElement();
        }
        ghostRelativeParentInitialScroll = getRelativeScrollOffset(ghostRelativeParent);
      }
      ghostEl = dragEl.cloneNode(true);
      toggleClass(ghostEl, options.ghostClass, false);
      toggleClass(ghostEl, options.fallbackClass, true);
      toggleClass(ghostEl, options.dragClass, true);
      css(ghostEl, "transition", "");
      css(ghostEl, "transform", "");
      css(ghostEl, "box-sizing", "border-box");
      css(ghostEl, "margin", 0);
      css(ghostEl, "top", rect.top);
      css(ghostEl, "left", rect.left);
      css(ghostEl, "width", rect.width);
      css(ghostEl, "height", rect.height);
      css(ghostEl, "opacity", "0.8");
      css(ghostEl, "position", PositionGhostAbsolutely ? "absolute" : "fixed");
      css(ghostEl, "zIndex", "100000");
      css(ghostEl, "pointerEvents", "none");
      Sortable$1.ghost = ghostEl;
      container.appendChild(ghostEl);
      css(ghostEl, "transform-origin", tapDistanceLeft / parseInt(ghostEl.style.width) * 100 + "% " + tapDistanceTop / parseInt(ghostEl.style.height) * 100 + "%");
    }
  },
  _onDragStart: function _onDragStart(evt, fallback) {
    var _this = this;
    var dataTransfer = evt.dataTransfer;
    var options = _this.options;
    pluginEvent2("dragStart", this, {
      evt
    });
    if (Sortable$1.eventCanceled) {
      this._onDrop();
      return;
    }
    pluginEvent2("setupClone", this);
    if (!Sortable$1.eventCanceled) {
      cloneEl = clone(dragEl);
      cloneEl.removeAttribute("id");
      cloneEl.draggable = false;
      cloneEl.style["will-change"] = "";
      this._hideClone();
      toggleClass(cloneEl, this.options.chosenClass, false);
      Sortable$1.clone = cloneEl;
    }
    _this.cloneId = _nextTick(function() {
      pluginEvent2("clone", _this);
      if (Sortable$1.eventCanceled)
        return;
      if (!_this.options.removeCloneOnHide) {
        rootEl.insertBefore(cloneEl, dragEl);
      }
      _this._hideClone();
      _dispatchEvent({
        sortable: _this,
        name: "clone"
      });
    });
    !fallback && toggleClass(dragEl, options.dragClass, true);
    if (fallback) {
      ignoreNextClick = true;
      _this._loopId = setInterval(_this._emulateDragOver, 50);
    } else {
      off$1(document, "mouseup", _this._onDrop);
      off$1(document, "touchend", _this._onDrop);
      off$1(document, "touchcancel", _this._onDrop);
      if (dataTransfer) {
        dataTransfer.effectAllowed = "move";
        options.setData && options.setData.call(_this, dataTransfer, dragEl);
      }
      on$1(document, "drop", _this);
      css(dragEl, "transform", "translateZ(0)");
    }
    awaitingDragStarted = true;
    _this._dragStartId = _nextTick(_this._dragStarted.bind(_this, fallback, evt));
    on$1(document, "selectstart", _this);
    moved = true;
    if (Safari) {
      css(document.body, "user-select", "none");
    }
  },
  _onDragOver: function _onDragOver(evt) {
    var el2 = this.el, target = evt.target, dragRect, targetRect, revert, options = this.options, group = options.group, activeSortable = Sortable$1.active, isOwner = activeGroup === group, canSort = options.sort, fromSortable = putSortable || activeSortable, vertical, _this = this, completedFired = false;
    if (_silent)
      return;
    function dragOverEvent(name, extra) {
      pluginEvent2(name, _this, _objectSpread2({
        evt,
        isOwner,
        axis: vertical ? "vertical" : "horizontal",
        revert,
        dragRect,
        targetRect,
        canSort,
        fromSortable,
        target,
        completed,
        onMove: function onMove(target2, after2) {
          return _onMove(rootEl, el2, dragEl, dragRect, target2, getRect(target2), evt, after2);
        },
        changed
      }, extra));
    }
    function capture() {
      dragOverEvent("dragOverAnimationCapture");
      _this.captureAnimationState();
      if (_this !== fromSortable) {
        fromSortable.captureAnimationState();
      }
    }
    function completed(insertion) {
      dragOverEvent("dragOverCompleted", {
        insertion
      });
      if (insertion) {
        if (isOwner) {
          activeSortable._hideClone();
        } else {
          activeSortable._showClone(_this);
        }
        if (_this !== fromSortable) {
          toggleClass(dragEl, putSortable ? putSortable.options.ghostClass : activeSortable.options.ghostClass, false);
          toggleClass(dragEl, options.ghostClass, true);
        }
        if (putSortable !== _this && _this !== Sortable$1.active) {
          putSortable = _this;
        } else if (_this === Sortable$1.active && putSortable) {
          putSortable = null;
        }
        if (fromSortable === _this) {
          _this._ignoreWhileAnimating = target;
        }
        _this.animateAll(function() {
          dragOverEvent("dragOverAnimationComplete");
          _this._ignoreWhileAnimating = null;
        });
        if (_this !== fromSortable) {
          fromSortable.animateAll();
          fromSortable._ignoreWhileAnimating = null;
        }
      }
      if (target === dragEl && !dragEl.animated || target === el2 && !target.animated) {
        lastTarget = null;
      }
      if (!options.dragoverBubble && !evt.rootEl && target !== document) {
        dragEl.parentNode[expando]._isOutsideThisEl(evt.target);
        !insertion && nearestEmptyInsertDetectEvent(evt);
      }
      !options.dragoverBubble && evt.stopPropagation && evt.stopPropagation();
      return completedFired = true;
    }
    function changed() {
      newIndex = index(dragEl);
      newDraggableIndex = index(dragEl, options.draggable);
      _dispatchEvent({
        sortable: _this,
        name: "change",
        toEl: el2,
        newIndex,
        newDraggableIndex,
        originalEvent: evt
      });
    }
    if (evt.preventDefault !== void 0) {
      evt.cancelable && evt.preventDefault();
    }
    target = closest(target, options.draggable, el2, true);
    dragOverEvent("dragOver");
    if (Sortable$1.eventCanceled)
      return completedFired;
    if (dragEl.contains(evt.target) || target.animated && target.animatingX && target.animatingY || _this._ignoreWhileAnimating === target) {
      return completed(false);
    }
    ignoreNextClick = false;
    if (activeSortable && !options.disabled && (isOwner ? canSort || (revert = parentEl !== rootEl) : putSortable === this || (this.lastPutMode = activeGroup.checkPull(this, activeSortable, dragEl, evt)) && group.checkPut(this, activeSortable, dragEl, evt))) {
      vertical = this._getDirection(evt, target) === "vertical";
      dragRect = getRect(dragEl);
      dragOverEvent("dragOverValid");
      if (Sortable$1.eventCanceled)
        return completedFired;
      if (revert) {
        parentEl = rootEl;
        capture();
        this._hideClone();
        dragOverEvent("revert");
        if (!Sortable$1.eventCanceled) {
          if (nextEl) {
            rootEl.insertBefore(dragEl, nextEl);
          } else {
            rootEl.appendChild(dragEl);
          }
        }
        return completed(true);
      }
      var elLastChild = lastChild(el2, options.draggable);
      if (!elLastChild || _ghostIsLast(evt, vertical, this) && !elLastChild.animated) {
        if (elLastChild === dragEl) {
          return completed(false);
        }
        if (elLastChild && el2 === evt.target) {
          target = elLastChild;
        }
        if (target) {
          targetRect = getRect(target);
        }
        if (_onMove(rootEl, el2, dragEl, dragRect, target, targetRect, evt, !!target) !== false) {
          capture();
          if (elLastChild && elLastChild.nextSibling) {
            el2.insertBefore(dragEl, elLastChild.nextSibling);
          } else {
            el2.appendChild(dragEl);
          }
          parentEl = el2;
          changed();
          return completed(true);
        }
      } else if (elLastChild && _ghostIsFirst(evt, vertical, this)) {
        var firstChild = getChild(el2, 0, options, true);
        if (firstChild === dragEl) {
          return completed(false);
        }
        target = firstChild;
        targetRect = getRect(target);
        if (_onMove(rootEl, el2, dragEl, dragRect, target, targetRect, evt, false) !== false) {
          capture();
          el2.insertBefore(dragEl, firstChild);
          parentEl = el2;
          changed();
          return completed(true);
        }
      } else if (target.parentNode === el2) {
        targetRect = getRect(target);
        var direction = 0, targetBeforeFirstSwap, differentLevel = dragEl.parentNode !== el2, differentRowCol = !_dragElInRowColumn(dragEl.animated && dragEl.toRect || dragRect, target.animated && target.toRect || targetRect, vertical), side1 = vertical ? "top" : "left", scrolledPastTop = isScrolledPast(target, "top", "top") || isScrolledPast(dragEl, "top", "top"), scrollBefore = scrolledPastTop ? scrolledPastTop.scrollTop : void 0;
        if (lastTarget !== target) {
          targetBeforeFirstSwap = targetRect[side1];
          pastFirstInvertThresh = false;
          isCircumstantialInvert = !differentRowCol && options.invertSwap || differentLevel;
        }
        direction = _getSwapDirection(evt, target, targetRect, vertical, differentRowCol ? 1 : options.swapThreshold, options.invertedSwapThreshold == null ? options.swapThreshold : options.invertedSwapThreshold, isCircumstantialInvert, lastTarget === target);
        var sibling;
        if (direction !== 0) {
          var dragIndex = index(dragEl);
          do {
            dragIndex -= direction;
            sibling = parentEl.children[dragIndex];
          } while (sibling && (css(sibling, "display") === "none" || sibling === ghostEl));
        }
        if (direction === 0 || sibling === target) {
          return completed(false);
        }
        lastTarget = target;
        lastDirection = direction;
        var nextSibling = target.nextElementSibling, after = false;
        after = direction === 1;
        var moveVector = _onMove(rootEl, el2, dragEl, dragRect, target, targetRect, evt, after);
        if (moveVector !== false) {
          if (moveVector === 1 || moveVector === -1) {
            after = moveVector === 1;
          }
          _silent = true;
          setTimeout(_unsilent, 30);
          capture();
          if (after && !nextSibling) {
            el2.appendChild(dragEl);
          } else {
            target.parentNode.insertBefore(dragEl, after ? nextSibling : target);
          }
          if (scrolledPastTop) {
            scrollBy(scrolledPastTop, 0, scrollBefore - scrolledPastTop.scrollTop);
          }
          parentEl = dragEl.parentNode;
          if (targetBeforeFirstSwap !== void 0 && !isCircumstantialInvert) {
            targetMoveDistance = Math.abs(targetBeforeFirstSwap - getRect(target)[side1]);
          }
          changed();
          return completed(true);
        }
      }
      if (el2.contains(dragEl)) {
        return completed(false);
      }
    }
    return false;
  },
  _ignoreWhileAnimating: null,
  _offMoveEvents: function _offMoveEvents() {
    off$1(document, "mousemove", this._onTouchMove);
    off$1(document, "touchmove", this._onTouchMove);
    off$1(document, "pointermove", this._onTouchMove);
    off$1(document, "dragover", nearestEmptyInsertDetectEvent);
    off$1(document, "mousemove", nearestEmptyInsertDetectEvent);
    off$1(document, "touchmove", nearestEmptyInsertDetectEvent);
  },
  _offUpEvents: function _offUpEvents() {
    var ownerDocument = this.el.ownerDocument;
    off$1(ownerDocument, "mouseup", this._onDrop);
    off$1(ownerDocument, "touchend", this._onDrop);
    off$1(ownerDocument, "pointerup", this._onDrop);
    off$1(ownerDocument, "touchcancel", this._onDrop);
    off$1(document, "selectstart", this);
  },
  _onDrop: function _onDrop(evt) {
    var el2 = this.el, options = this.options;
    newIndex = index(dragEl);
    newDraggableIndex = index(dragEl, options.draggable);
    pluginEvent2("drop", this, {
      evt
    });
    parentEl = dragEl && dragEl.parentNode;
    newIndex = index(dragEl);
    newDraggableIndex = index(dragEl, options.draggable);
    if (Sortable$1.eventCanceled) {
      this._nulling();
      return;
    }
    awaitingDragStarted = false;
    isCircumstantialInvert = false;
    pastFirstInvertThresh = false;
    clearInterval(this._loopId);
    clearTimeout(this._dragStartTimer);
    _cancelNextTick(this.cloneId);
    _cancelNextTick(this._dragStartId);
    if (this.nativeDraggable) {
      off$1(document, "drop", this);
      off$1(el2, "dragstart", this._onDragStart);
    }
    this._offMoveEvents();
    this._offUpEvents();
    if (Safari) {
      css(document.body, "user-select", "");
    }
    css(dragEl, "transform", "");
    if (evt) {
      if (moved) {
        evt.cancelable && evt.preventDefault();
        !options.dropBubble && evt.stopPropagation();
      }
      ghostEl && ghostEl.parentNode && ghostEl.parentNode.removeChild(ghostEl);
      if (rootEl === parentEl || putSortable && putSortable.lastPutMode !== "clone") {
        cloneEl && cloneEl.parentNode && cloneEl.parentNode.removeChild(cloneEl);
      }
      if (dragEl) {
        if (this.nativeDraggable) {
          off$1(dragEl, "dragend", this);
        }
        _disableDraggable(dragEl);
        dragEl.style["will-change"] = "";
        if (moved && !awaitingDragStarted) {
          toggleClass(dragEl, putSortable ? putSortable.options.ghostClass : this.options.ghostClass, false);
        }
        toggleClass(dragEl, this.options.chosenClass, false);
        _dispatchEvent({
          sortable: this,
          name: "unchoose",
          toEl: parentEl,
          newIndex: null,
          newDraggableIndex: null,
          originalEvent: evt
        });
        if (rootEl !== parentEl) {
          if (newIndex >= 0) {
            _dispatchEvent({
              rootEl: parentEl,
              name: "add",
              toEl: parentEl,
              fromEl: rootEl,
              originalEvent: evt
            });
            _dispatchEvent({
              sortable: this,
              name: "remove",
              toEl: parentEl,
              originalEvent: evt
            });
            _dispatchEvent({
              rootEl: parentEl,
              name: "sort",
              toEl: parentEl,
              fromEl: rootEl,
              originalEvent: evt
            });
            _dispatchEvent({
              sortable: this,
              name: "sort",
              toEl: parentEl,
              originalEvent: evt
            });
          }
          putSortable && putSortable.save();
        } else {
          if (newIndex !== oldIndex) {
            if (newIndex >= 0) {
              _dispatchEvent({
                sortable: this,
                name: "update",
                toEl: parentEl,
                originalEvent: evt
              });
              _dispatchEvent({
                sortable: this,
                name: "sort",
                toEl: parentEl,
                originalEvent: evt
              });
            }
          }
        }
        if (Sortable$1.active) {
          if (newIndex == null || newIndex === -1) {
            newIndex = oldIndex;
            newDraggableIndex = oldDraggableIndex;
          }
          _dispatchEvent({
            sortable: this,
            name: "end",
            toEl: parentEl,
            originalEvent: evt
          });
          this.save();
        }
      }
    }
    this._nulling();
  },
  _nulling: function _nulling() {
    pluginEvent2("nulling", this);
    rootEl = dragEl = parentEl = ghostEl = nextEl = cloneEl = lastDownEl = cloneHidden = tapEvt = touchEvt = moved = newIndex = newDraggableIndex = oldIndex = oldDraggableIndex = lastTarget = lastDirection = putSortable = activeGroup = Sortable$1.dragged = Sortable$1.ghost = Sortable$1.clone = Sortable$1.active = null;
    savedInputChecked.forEach(function(el2) {
      el2.checked = true;
    });
    savedInputChecked.length = lastDx = lastDy = 0;
  },
  handleEvent: function handleEvent(evt) {
    switch (evt.type) {
      case "drop":
      case "dragend":
        this._onDrop(evt);
        break;
      case "dragenter":
      case "dragover":
        if (dragEl) {
          this._onDragOver(evt);
          _globalDragOver(evt);
        }
        break;
      case "selectstart":
        evt.preventDefault();
        break;
    }
  },
  toArray: function toArray2() {
    var order2 = [], el2, children = this.el.children, i3 = 0, n2 = children.length, options = this.options;
    for (; i3 < n2; i3++) {
      el2 = children[i3];
      if (closest(el2, options.draggable, this.el, false)) {
        order2.push(el2.getAttribute(options.dataIdAttr) || _generateId(el2));
      }
    }
    return order2;
  },
  sort: function sort(order2, useAnimation) {
    var items = {}, rootEl2 = this.el;
    this.toArray().forEach(function(id2, i3) {
      var el2 = rootEl2.children[i3];
      if (closest(el2, this.options.draggable, rootEl2, false)) {
        items[id2] = el2;
      }
    }, this);
    useAnimation && this.captureAnimationState();
    order2.forEach(function(id2) {
      if (items[id2]) {
        rootEl2.removeChild(items[id2]);
        rootEl2.appendChild(items[id2]);
      }
    });
    useAnimation && this.animateAll();
  },
  save: function save() {
    var store = this.options.store;
    store && store.set && store.set(this);
  },
  closest: function closest$1(el2, selector) {
    return closest(el2, selector || this.options.draggable, this.el, false);
  },
  option: function option(name, value) {
    var options = this.options;
    if (value === void 0) {
      return options[name];
    } else {
      var modifiedValue = PluginManager.modifyOption(this, name, value);
      if (typeof modifiedValue !== "undefined") {
        options[name] = modifiedValue;
      } else {
        options[name] = value;
      }
      if (name === "group") {
        _prepareGroup(options);
      }
    }
  },
  destroy: function destroy() {
    pluginEvent2("destroy", this);
    var el2 = this.el;
    el2[expando] = null;
    off$1(el2, "mousedown", this._onTapStart);
    off$1(el2, "touchstart", this._onTapStart);
    off$1(el2, "pointerdown", this._onTapStart);
    if (this.nativeDraggable) {
      off$1(el2, "dragover", this);
      off$1(el2, "dragenter", this);
    }
    Array.prototype.forEach.call(el2.querySelectorAll("[draggable]"), function(el3) {
      el3.removeAttribute("draggable");
    });
    this._onDrop();
    this._disableDelayedDragEvents();
    sortables.splice(sortables.indexOf(this.el), 1);
    this.el = el2 = null;
  },
  _hideClone: function _hideClone() {
    if (!cloneHidden) {
      pluginEvent2("hideClone", this);
      if (Sortable$1.eventCanceled)
        return;
      css(cloneEl, "display", "none");
      if (this.options.removeCloneOnHide && cloneEl.parentNode) {
        cloneEl.parentNode.removeChild(cloneEl);
      }
      cloneHidden = true;
    }
  },
  _showClone: function _showClone(putSortable2) {
    if (putSortable2.lastPutMode !== "clone") {
      this._hideClone();
      return;
    }
    if (cloneHidden) {
      pluginEvent2("showClone", this);
      if (Sortable$1.eventCanceled)
        return;
      if (dragEl.parentNode == rootEl && !this.options.group.revertClone) {
        rootEl.insertBefore(cloneEl, dragEl);
      } else if (nextEl) {
        rootEl.insertBefore(cloneEl, nextEl);
      } else {
        rootEl.appendChild(cloneEl);
      }
      if (this.options.group.revertClone) {
        this.animate(dragEl, cloneEl);
      }
      css(cloneEl, "display", "");
      cloneHidden = false;
    }
  }
};
function _globalDragOver(evt) {
  if (evt.dataTransfer) {
    evt.dataTransfer.dropEffect = "move";
  }
  evt.cancelable && evt.preventDefault();
}
function _onMove(fromEl, toEl, dragEl2, dragRect, targetEl, targetRect, originalEvent, willInsertAfter) {
  var evt, sortable = fromEl[expando], onMoveFn = sortable.options.onMove, retVal;
  if (window.CustomEvent && !IE11OrLess && !Edge) {
    evt = new CustomEvent("move", {
      bubbles: true,
      cancelable: true
    });
  } else {
    evt = document.createEvent("Event");
    evt.initEvent("move", true, true);
  }
  evt.to = toEl;
  evt.from = fromEl;
  evt.dragged = dragEl2;
  evt.draggedRect = dragRect;
  evt.related = targetEl || toEl;
  evt.relatedRect = targetRect || getRect(toEl);
  evt.willInsertAfter = willInsertAfter;
  evt.originalEvent = originalEvent;
  fromEl.dispatchEvent(evt);
  if (onMoveFn) {
    retVal = onMoveFn.call(sortable, evt, originalEvent);
  }
  return retVal;
}
function _disableDraggable(el2) {
  el2.draggable = false;
}
function _unsilent() {
  _silent = false;
}
function _ghostIsFirst(evt, vertical, sortable) {
  var rect = getRect(getChild(sortable.el, 0, sortable.options, true));
  var spacer = 10;
  return vertical ? evt.clientX < rect.left - spacer || evt.clientY < rect.top && evt.clientX < rect.right : evt.clientY < rect.top - spacer || evt.clientY < rect.bottom && evt.clientX < rect.left;
}
function _ghostIsLast(evt, vertical, sortable) {
  var rect = getRect(lastChild(sortable.el, sortable.options.draggable));
  var spacer = 10;
  return vertical ? evt.clientX > rect.right + spacer || evt.clientX <= rect.right && evt.clientY > rect.bottom && evt.clientX >= rect.left : evt.clientX > rect.right && evt.clientY > rect.top || evt.clientX <= rect.right && evt.clientY > rect.bottom + spacer;
}
function _getSwapDirection(evt, target, targetRect, vertical, swapThreshold, invertedSwapThreshold, invertSwap, isLastTarget) {
  var mouseOnAxis = vertical ? evt.clientY : evt.clientX, targetLength = vertical ? targetRect.height : targetRect.width, targetS1 = vertical ? targetRect.top : targetRect.left, targetS2 = vertical ? targetRect.bottom : targetRect.right, invert = false;
  if (!invertSwap) {
    if (isLastTarget && targetMoveDistance < targetLength * swapThreshold) {
      if (!pastFirstInvertThresh && (lastDirection === 1 ? mouseOnAxis > targetS1 + targetLength * invertedSwapThreshold / 2 : mouseOnAxis < targetS2 - targetLength * invertedSwapThreshold / 2)) {
        pastFirstInvertThresh = true;
      }
      if (!pastFirstInvertThresh) {
        if (lastDirection === 1 ? mouseOnAxis < targetS1 + targetMoveDistance : mouseOnAxis > targetS2 - targetMoveDistance) {
          return -lastDirection;
        }
      } else {
        invert = true;
      }
    } else {
      if (mouseOnAxis > targetS1 + targetLength * (1 - swapThreshold) / 2 && mouseOnAxis < targetS2 - targetLength * (1 - swapThreshold) / 2) {
        return _getInsertDirection(target);
      }
    }
  }
  invert = invert || invertSwap;
  if (invert) {
    if (mouseOnAxis < targetS1 + targetLength * invertedSwapThreshold / 2 || mouseOnAxis > targetS2 - targetLength * invertedSwapThreshold / 2) {
      return mouseOnAxis > targetS1 + targetLength / 2 ? 1 : -1;
    }
  }
  return 0;
}
function _getInsertDirection(target) {
  if (index(dragEl) < index(target)) {
    return 1;
  } else {
    return -1;
  }
}
function _generateId(el2) {
  var str = el2.tagName + el2.className + el2.src + el2.href + el2.textContent, i3 = str.length, sum = 0;
  while (i3--) {
    sum += str.charCodeAt(i3);
  }
  return sum.toString(36);
}
function _saveInputCheckedState(root2) {
  savedInputChecked.length = 0;
  var inputs = root2.getElementsByTagName("input");
  var idx = inputs.length;
  while (idx--) {
    var el2 = inputs[idx];
    el2.checked && savedInputChecked.push(el2);
  }
}
function _nextTick(fn3) {
  return setTimeout(fn3, 0);
}
function _cancelNextTick(id2) {
  return clearTimeout(id2);
}
if (documentExists) {
  on$1(document, "touchmove", function(evt) {
    if ((Sortable$1.active || awaitingDragStarted) && evt.cancelable) {
      evt.preventDefault();
    }
  });
}
Sortable$1.utils = {
  on: on$1,
  off: off$1,
  css,
  find: find$1,
  is: function is(el2, selector) {
    return !!closest(el2, selector, el2, false);
  },
  extend,
  throttle,
  closest,
  toggleClass,
  clone,
  index,
  nextTick: _nextTick,
  cancelNextTick: _cancelNextTick,
  detectDirection: _detectDirection,
  getChild
};
Sortable$1.get = function(element) {
  return element[expando];
};
Sortable$1.mount = function() {
  for (var _len = arguments.length, plugins2 = new Array(_len), _key = 0; _key < _len; _key++) {
    plugins2[_key] = arguments[_key];
  }
  if (plugins2[0].constructor === Array)
    plugins2 = plugins2[0];
  plugins2.forEach(function(plugin) {
    if (!plugin.prototype || !plugin.prototype.constructor) {
      throw "Sortable: Mounted plugin must be a constructor function, not ".concat({}.toString.call(plugin));
    }
    if (plugin.utils)
      Sortable$1.utils = _objectSpread2(_objectSpread2({}, Sortable$1.utils), plugin.utils);
    PluginManager.mount(plugin);
  });
};
Sortable$1.create = function(el2, options) {
  return new Sortable$1(el2, options);
};
Sortable$1.version = version;
var autoScrolls = [], scrollEl, scrollRootEl, scrolling = false, lastAutoScrollX, lastAutoScrollY, touchEvt$1, pointerElemChangedInterval;
function AutoScrollPlugin() {
  function AutoScroll() {
    this.defaults = {
      scroll: true,
      forceAutoScrollFallback: false,
      scrollSensitivity: 30,
      scrollSpeed: 10,
      bubbleScroll: true
    };
    for (var fn3 in this) {
      if (fn3.charAt(0) === "_" && typeof this[fn3] === "function") {
        this[fn3] = this[fn3].bind(this);
      }
    }
  }
  AutoScroll.prototype = {
    dragStarted: function dragStarted(_ref2) {
      var originalEvent = _ref2.originalEvent;
      if (this.sortable.nativeDraggable) {
        on$1(document, "dragover", this._handleAutoScroll);
      } else {
        if (this.options.supportPointer) {
          on$1(document, "pointermove", this._handleFallbackAutoScroll);
        } else if (originalEvent.touches) {
          on$1(document, "touchmove", this._handleFallbackAutoScroll);
        } else {
          on$1(document, "mousemove", this._handleFallbackAutoScroll);
        }
      }
    },
    dragOverCompleted: function dragOverCompleted(_ref2) {
      var originalEvent = _ref2.originalEvent;
      if (!this.options.dragOverBubble && !originalEvent.rootEl) {
        this._handleAutoScroll(originalEvent);
      }
    },
    drop: function drop3() {
      if (this.sortable.nativeDraggable) {
        off$1(document, "dragover", this._handleAutoScroll);
      } else {
        off$1(document, "pointermove", this._handleFallbackAutoScroll);
        off$1(document, "touchmove", this._handleFallbackAutoScroll);
        off$1(document, "mousemove", this._handleFallbackAutoScroll);
      }
      clearPointerElemChangedInterval();
      clearAutoScrolls();
      cancelThrottle();
    },
    nulling: function nulling() {
      touchEvt$1 = scrollRootEl = scrollEl = scrolling = pointerElemChangedInterval = lastAutoScrollX = lastAutoScrollY = null;
      autoScrolls.length = 0;
    },
    _handleFallbackAutoScroll: function _handleFallbackAutoScroll(evt) {
      this._handleAutoScroll(evt, true);
    },
    _handleAutoScroll: function _handleAutoScroll(evt, fallback) {
      var _this = this;
      var x3 = (evt.touches ? evt.touches[0] : evt).clientX, y4 = (evt.touches ? evt.touches[0] : evt).clientY, elem = document.elementFromPoint(x3, y4);
      touchEvt$1 = evt;
      if (fallback || this.options.forceAutoScrollFallback || Edge || IE11OrLess || Safari) {
        autoScroll(evt, this.options, elem, fallback);
        var ogElemScroller = getParentAutoScrollElement(elem, true);
        if (scrolling && (!pointerElemChangedInterval || x3 !== lastAutoScrollX || y4 !== lastAutoScrollY)) {
          pointerElemChangedInterval && clearPointerElemChangedInterval();
          pointerElemChangedInterval = setInterval(function() {
            var newElem = getParentAutoScrollElement(document.elementFromPoint(x3, y4), true);
            if (newElem !== ogElemScroller) {
              ogElemScroller = newElem;
              clearAutoScrolls();
            }
            autoScroll(evt, _this.options, newElem, fallback);
          }, 10);
          lastAutoScrollX = x3;
          lastAutoScrollY = y4;
        }
      } else {
        if (!this.options.bubbleScroll || getParentAutoScrollElement(elem, true) === getWindowScrollingElement()) {
          clearAutoScrolls();
          return;
        }
        autoScroll(evt, this.options, getParentAutoScrollElement(elem, false), false);
      }
    }
  };
  return _extends(AutoScroll, {
    pluginName: "scroll",
    initializeByDefault: true
  });
}
function clearAutoScrolls() {
  autoScrolls.forEach(function(autoScroll2) {
    clearInterval(autoScroll2.pid);
  });
  autoScrolls = [];
}
function clearPointerElemChangedInterval() {
  clearInterval(pointerElemChangedInterval);
}
var autoScroll = throttle(function(evt, options, rootEl2, isFallback) {
  if (!options.scroll)
    return;
  var x3 = (evt.touches ? evt.touches[0] : evt).clientX, y4 = (evt.touches ? evt.touches[0] : evt).clientY, sens = options.scrollSensitivity, speed = options.scrollSpeed, winScroller = getWindowScrollingElement();
  var scrollThisInstance = false, scrollCustomFn;
  if (scrollRootEl !== rootEl2) {
    scrollRootEl = rootEl2;
    clearAutoScrolls();
    scrollEl = options.scroll;
    scrollCustomFn = options.scrollFn;
    if (scrollEl === true) {
      scrollEl = getParentAutoScrollElement(rootEl2, true);
    }
  }
  var layersOut = 0;
  var currentParent = scrollEl;
  do {
    var el2 = currentParent, rect = getRect(el2), top2 = rect.top, bottom2 = rect.bottom, left2 = rect.left, right2 = rect.right, width = rect.width, height = rect.height, canScrollX = void 0, canScrollY = void 0, scrollWidth = el2.scrollWidth, scrollHeight = el2.scrollHeight, elCSS = css(el2), scrollPosX = el2.scrollLeft, scrollPosY = el2.scrollTop;
    if (el2 === winScroller) {
      canScrollX = width < scrollWidth && (elCSS.overflowX === "auto" || elCSS.overflowX === "scroll" || elCSS.overflowX === "visible");
      canScrollY = height < scrollHeight && (elCSS.overflowY === "auto" || elCSS.overflowY === "scroll" || elCSS.overflowY === "visible");
    } else {
      canScrollX = width < scrollWidth && (elCSS.overflowX === "auto" || elCSS.overflowX === "scroll");
      canScrollY = height < scrollHeight && (elCSS.overflowY === "auto" || elCSS.overflowY === "scroll");
    }
    var vx = canScrollX && (Math.abs(right2 - x3) <= sens && scrollPosX + width < scrollWidth) - (Math.abs(left2 - x3) <= sens && !!scrollPosX);
    var vy = canScrollY && (Math.abs(bottom2 - y4) <= sens && scrollPosY + height < scrollHeight) - (Math.abs(top2 - y4) <= sens && !!scrollPosY);
    if (!autoScrolls[layersOut]) {
      for (var i3 = 0; i3 <= layersOut; i3++) {
        if (!autoScrolls[i3]) {
          autoScrolls[i3] = {};
        }
      }
    }
    if (autoScrolls[layersOut].vx != vx || autoScrolls[layersOut].vy != vy || autoScrolls[layersOut].el !== el2) {
      autoScrolls[layersOut].el = el2;
      autoScrolls[layersOut].vx = vx;
      autoScrolls[layersOut].vy = vy;
      clearInterval(autoScrolls[layersOut].pid);
      if (vx != 0 || vy != 0) {
        scrollThisInstance = true;
        autoScrolls[layersOut].pid = setInterval(function() {
          if (isFallback && this.layer === 0) {
            Sortable$1.active._onTouchMove(touchEvt$1);
          }
          var scrollOffsetY = autoScrolls[this.layer].vy ? autoScrolls[this.layer].vy * speed : 0;
          var scrollOffsetX = autoScrolls[this.layer].vx ? autoScrolls[this.layer].vx * speed : 0;
          if (typeof scrollCustomFn === "function") {
            if (scrollCustomFn.call(Sortable$1.dragged.parentNode[expando], scrollOffsetX, scrollOffsetY, evt, touchEvt$1, autoScrolls[this.layer].el) !== "continue") {
              return;
            }
          }
          scrollBy(autoScrolls[this.layer].el, scrollOffsetX, scrollOffsetY);
        }.bind({
          layer: layersOut
        }), 24);
      }
    }
    layersOut++;
  } while (options.bubbleScroll && currentParent !== winScroller && (currentParent = getParentAutoScrollElement(currentParent, false)));
  scrolling = scrollThisInstance;
}, 30);
var drop = function drop2(_ref2) {
  var originalEvent = _ref2.originalEvent, putSortable2 = _ref2.putSortable, dragEl2 = _ref2.dragEl, activeSortable = _ref2.activeSortable, dispatchSortableEvent = _ref2.dispatchSortableEvent, hideGhostForTarget = _ref2.hideGhostForTarget, unhideGhostForTarget = _ref2.unhideGhostForTarget;
  if (!originalEvent)
    return;
  var toSortable = putSortable2 || activeSortable;
  hideGhostForTarget();
  var touch = originalEvent.changedTouches && originalEvent.changedTouches.length ? originalEvent.changedTouches[0] : originalEvent;
  var target = document.elementFromPoint(touch.clientX, touch.clientY);
  unhideGhostForTarget();
  if (toSortable && !toSortable.el.contains(target)) {
    dispatchSortableEvent("spill");
    this.onSpill({
      dragEl: dragEl2,
      putSortable: putSortable2
    });
  }
};
function Revert() {
}
Revert.prototype = {
  startIndex: null,
  dragStart: function dragStart(_ref2) {
    var oldDraggableIndex2 = _ref2.oldDraggableIndex;
    this.startIndex = oldDraggableIndex2;
  },
  onSpill: function onSpill(_ref3) {
    var dragEl2 = _ref3.dragEl, putSortable2 = _ref3.putSortable;
    this.sortable.captureAnimationState();
    if (putSortable2) {
      putSortable2.captureAnimationState();
    }
    var nextSibling = getChild(this.sortable.el, this.startIndex, this.options);
    if (nextSibling) {
      this.sortable.el.insertBefore(dragEl2, nextSibling);
    } else {
      this.sortable.el.appendChild(dragEl2);
    }
    this.sortable.animateAll();
    if (putSortable2) {
      putSortable2.animateAll();
    }
  },
  drop
};
_extends(Revert, {
  pluginName: "revertOnSpill"
});
function Remove() {
}
Remove.prototype = {
  onSpill: function onSpill2(_ref4) {
    var dragEl2 = _ref4.dragEl, putSortable2 = _ref4.putSortable;
    var parentSortable = putSortable2 || this.sortable;
    parentSortable.captureAnimationState();
    dragEl2.parentNode && dragEl2.parentNode.removeChild(dragEl2);
    parentSortable.animateAll();
  },
  drop
};
_extends(Remove, {
  pluginName: "removeOnSpill"
});
Sortable$1.mount(new AutoScrollPlugin());
Sortable$1.mount(Remove, Revert);
function Icon$1({ name, size, path = "sprite.svg" }) {
  const className = `icon icon-${name}`;
  const href = `/${path}#${name}`;
  return /* @__PURE__ */ jsx$1("svg", { className, width: size, height: size, children: /* @__PURE__ */ jsx$1("use", { xlinkHref: href }) });
}
function Alert({
  type = "success",
  message = "",
  duration: duration2 = 3,
  isFloating = false,
  ...props
}) {
  const ref = react.exports.useRef(null);
  const [alertType, setAlertType] = react.exports.useState(type);
  const [icon, setIcon] = react.exports.useState("");
  react.exports.useEffect(() => {
    if (type !== null || type !== void 0) {
      setAlertType(type);
      setIcon(type);
    }
    if (type === "error" || type === null) {
      setAlertType("danger");
      setIcon("warning");
    }
    if (type === "success") {
      setIcon("check");
    }
  }, [type]);
  const close2 = (e3) => {
    if (ref.current) {
      const alertElement = ref.current;
      ref.current.classList.add("out");
      window.setTimeout(async () => {
        await slideUp(alertElement);
        alertElement.dispatchEvent(new CustomEvent("close"));
      }, 500);
    }
    e3.preventDefault();
  };
  react.exports.useEffect(() => {
    const timer = window.setTimeout(close2, duration2 * 1e3);
    return () => clearTimeout(timer);
  }, [duration2]);
  return /* @__PURE__ */ jsxs$1(
    "div",
    {
      className: `alert alert-${alertType} ${isFloating ? "is-floating" : ""}`,
      ref,
      children: [
        /* @__PURE__ */ jsx$1(Icon$1, { name: icon }),
        /* @__PURE__ */ jsx$1("div", { children: message }),
        /* @__PURE__ */ jsx$1("button", { className: "alert-close", onClick: close2, children: /* @__PURE__ */ jsx$1(Icon$1, { name: "cross" }) }),
        /* @__PURE__ */ jsx$1(
          "div",
          {
            className: "alert__progress",
            style: { animationDuration: `${duration2}s` }
          }
        )
      ]
    }
  );
}
function FieldTextarea(props) {
  return /* @__PURE__ */ jsx$1("textarea", { ...props });
}
function FieldCheckbox(props) {
  return /* @__PURE__ */ jsx$1("input", { ...props });
}
function FieldInput(props) {
  return /* @__PURE__ */ jsx$1("input", { ...props });
}
function FieldSelect(props) {
  return /* @__PURE__ */ jsx$1("select", {
    ...props,
    children: props.options.map((option2, key) => {
      return /* @__PURE__ */ jsx$1("option", { value: option2.value, children: option2.label }, key);
    })
  });
}
function Field$2({
  name,
  onInput,
  value,
  error,
  children,
  type = "text",
  className = "",
  wrapperClass = "",
  component = null,
  autofocus = false,
  placeholder,
  ...props
}) {
  const [dirty, setDirty] = react.exports.useState(false);
  const ref = react.exports.useRef(null);
  useAutofocus(ref, autofocus);
  const showError = error && !dirty;
  function handleInput(e3) {
    if (!dirty) {
      setDirty(true);
    }
    if (onInput) {
      onInput(e3);
    }
  }
  if (showError) {
    className += ` ${"is-invalid"}`;
  }
  const attr = {
    name,
    id: name,
    className,
    onInput: handleInput,
    type,
    ...value === void 0 ? {} : { value },
    ...props
  };
  const FieldComponent = react.exports.useMemo(() => {
    if (component) {
      return component;
    }
    switch (type) {
      case "textarea":
        return FieldTextarea;
      case "select":
        return FieldSelect;
      case "checkbox":
        return FieldCheckbox;
      default:
        return FieldInput;
    }
  }, [component, type]);
  react.exports.useLayoutEffect(() => {
    setDirty(false);
  }, [error]);
  if (FieldComponent === FieldCheckbox) {
    return /* @__PURE__ */ jsxs$1("div", { className: `${"form-check"} ${wrapperClass}`, children: [
      /* @__PURE__ */ jsx$1(FieldComponent, { ...attr }),
      children && /* @__PURE__ */ jsx$1("label", { htmlFor: name, className: "form-check-label", children }),
      showError && /* @__PURE__ */ jsx$1("div", { className: "invalid-feedback", children: error })
    ] });
  }
  return /* @__PURE__ */ jsxs$1("div", { className: `${"form-group"} ${wrapperClass}`, ref, children: [
    children && /* @__PURE__ */ jsx$1("label", { htmlFor: name, children }),
    /* @__PURE__ */ jsx$1(FieldComponent, { ...attr }),
    showError && /* @__PURE__ */ jsx$1("div", { className: "invalid-feedback", children: error })
  ] });
}
function Loader({
  dots = 8,
  width = 28,
  strokeWidth = 4,
  className
}) {
  const buildCircles = (w3, n2, r2) => {
    const circleRadius = w3 / 2 - r2;
    let dom = [];
    for (let i3 = 0; i3 < n2; i3++) {
      const a4 = Math.PI / (n2 / 2) * i3;
      const x3 = circleRadius * Math.sin(a4) + w3 / 2;
      const y4 = circleRadius * Math.cos(a4) + w3 / 2;
      dom.push(/* @__PURE__ */ jsx$1("circle", { cx: x3, cy: y4, r: r2, fill: "currentColor" }));
    }
    return dom;
  };
  const offset2 = Math.PI * (width - strokeWidth);
  const style2 = {
    "--loader-width": `${width}px`,
    "--loader-offset": offset2,
    "--loader-dashoffset": offset2 + offset2 / dots,
    "--loader-dashoffset50": offset2 + 2.5 * offset2 / dots
  };
  return /* @__PURE__ */ jsx$1("div", { className: `loader ${className}`, style: style2, children: /* @__PURE__ */ jsxs$1("div", { className: "loaderContainer", children: [
    /* @__PURE__ */ jsx$1(
      "svg",
      {
        className: "circles",
        viewBox: `0 0 ${width} ${width}`,
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        children: buildCircles(width, dots, strokeWidth / 2)
      }
    ),
    /* @__PURE__ */ jsx$1(
      "svg",
      {
        className: "halo",
        viewBox: `0 0 ${width} ${width}`,
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        children: /* @__PURE__ */ jsx$1(
          "circle",
          {
            cx: width / 2,
            cy: width / 2,
            r: width / 2 - strokeWidth / 2,
            strokeWidth,
            strokeLinecap: "round",
            stroke: "currentColor"
          }
        )
      }
    )
  ] }) });
}
react.exports.createContext({
  errors: {},
  loading: false,
  emptyError: () => {
  }
});
var InputChoicesElement = class extends HTMLInputElement {
};
var SelectChoicesElement = class extends HTMLSelectElement {
};
function bindBehaviour(cls) {
  cls.prototype.connectedCallback = function() {
    if (this.getAttribute("choicesBinded")) {
      return;
    }
    this.setAttribute("choicesBinded", "true");
    const options = {
      hideSelected: true,
      persist: false,
      plugins: {
        no_backspace_delete: {}
      },
      closeAfterSelect: true
    };
    if (this.tagName === "SELECT") {
      options.allowEmptyOption = true;
      options.plugins.no_backspace_delete = {};
      options.plugins.dropdown_input = {};
      if (this.getAttribute("multiple")) {
        options.plugins.remove_button = {
          title: "Supprimer cet \xE9l\xE9ment"
        };
      }
    } else {
      options.plugins.remove_button = {
        title: "Supprimer cet \xE9l\xE9ment"
      };
    }
    if (this.dataset.remote) {
      options.valueField = this.dataset.value;
      options.labelField = this.dataset.label;
      options.searchField = this.dataset.label;
      options.load = async (query, callback) => {
        const url = `${this.dataset.remote}?q=${encodeURIComponent(query)}`;
        const data = await jsonFetch(url);
        callback(data);
      };
    }
    if (this.dataset.create) {
      options.create = true;
    }
    this.widget = new TomSelect(this, options);
    if (this.dataset.redirect !== void 0) {
      this.widget.on("change", () => redirectOnChange(this));
    }
  };
  cls.prototype.disconnectedCallback = function() {
    if (this.widget) {
      this.widget.destroy();
    }
  };
}
function redirectOnChange(select) {
  const params = new URLSearchParams(window.location.search);
  if (select.value === "") {
    params.delete(select.name);
  } else {
    params.set(select.name, select.value);
  }
  if (params.has("page")) {
    params.delete("page");
  }
  redirect(`${location.pathname}?${params}`);
}
Array.from([InputChoicesElement, SelectChoicesElement]).forEach(bindBehaviour);
function Field$1({
  children,
  label,
  help,
  type = "text",
  options,
  tooltip: tooltip2,
  icon,
  ...props
}) {
  if (!children) {
    if (options) {
      children = /* @__PURE__ */ jsx(Field$2, {
        children: label,
        type: "select",
        options,
        ...props
      });
    } else if (["text", "number", "textarea"].includes(type)) {
      children = /* @__PURE__ */ jsx(Field$2, {
        children: label,
        type,
        ...props
      });
    } else {
      throw new Error("Cannot render this type of field : " + type);
    }
  }
  if (tooltip2) {
    children = /* @__PURE__ */ jsx(Tooltip, {
      content: tooltip2,
      children
    });
  }
  return /* @__PURE__ */ jsxs("div", {
    style: {
      position: "relative"
    },
    children: [/* @__PURE__ */ jsxs("div", {
      children: [children, icon && /* @__PURE__ */ jsx(Icon, {
        children: icon
      })]
    }), help && /* @__PURE__ */ jsx(HelpMessage, {
      children: help
    })]
  });
}
const HelpMessage = /* @__PURE__ */ createStyled("div", {
  target: "e1nnlyiu2"
})({
  name: "1vp9oxk",
  styles: "font-style:italic;margin-top:.5em;font-size:.8em"
});
const Icon = /* @__PURE__ */ createStyled("div", {
  target: "e1nnlyiu0"
})({
  name: "3amdln",
  styles: "display:flex;align-items:center;justify-content:center;color:var(--color);cursor:pointer;height:40px;position:absolute;right:0;top:calc(50% - 16px);width:40px"
});
function composeRefs(...o2) {
  return (e3) => o2.forEach((o3) => function(o4, e4) {
    "function" == typeof o4 ? o4(e4) : null != o4 && (o4.current = e4);
  }(o3, e3));
}
function useComposedRefs(...e3) {
  return react.exports.useCallback(composeRefs(...e3), e3);
}
const Slot = /* @__PURE__ */ react.exports.forwardRef((e3, o2) => {
  const { children: a4, ...s4 } = e3;
  return react.exports.Children.toArray(a4).some(l$4) ? /* @__PURE__ */ react.exports.createElement(react.exports.Fragment, null, react.exports.Children.map(a4, (e4) => l$4(e4) ? /* @__PURE__ */ react.exports.createElement(n$3, _extends$1({}, s4, { ref: o2 }), e4.props.children) : e4)) : /* @__PURE__ */ react.exports.createElement(n$3, _extends$1({}, s4, { ref: o2 }), a4);
});
Slot.displayName = "Slot";
const n$3 = /* @__PURE__ */ react.exports.forwardRef((r2, n2) => {
  const { children: l2, ...a4 } = r2;
  return react.exports.isValidElement(l2) ? /* @__PURE__ */ react.exports.cloneElement(l2, { ...o$5(a4, l2.props), ref: composeRefs(n2, l2.ref) }) : react.exports.Children.count(l2) > 1 ? react.exports.Children.only(null) : null;
});
n$3.displayName = "SlotClone";
const Slottable = ({ children: e3 }) => /* @__PURE__ */ react.exports.createElement(react.exports.Fragment, null, e3);
function l$4(e3) {
  return react.exports.isValidElement(e3) && e3.type === Slottable;
}
function o$5(e3, t3) {
  const r2 = { ...t3 };
  for (const n2 in t3) {
    const l2 = e3[n2], o2 = t3[n2];
    /^on[A-Z]/.test(n2) ? r2[n2] = (...e4) => {
      null == o2 || o2(...e4), null == l2 || l2(...e4);
    } : "style" === n2 ? r2[n2] = { ...l2, ...o2 } : "className" === n2 && (r2[n2] = [l2, o2].filter(Boolean).join(" "));
  }
  return { ...e3, ...r2 };
}
var getDefaultParent = function(originalTarget) {
  if (typeof document === "undefined") {
    return null;
  }
  var sampleTarget = Array.isArray(originalTarget) ? originalTarget[0] : originalTarget;
  return sampleTarget.ownerDocument.body;
};
var counterMap = /* @__PURE__ */ new WeakMap();
var uncontrolledNodes = /* @__PURE__ */ new WeakMap();
var markerMap = {};
var lockCount = 0;
var unwrapHost = function(node2) {
  return node2 && (node2.host || unwrapHost(node2.parentNode));
};
var correctTargets = function(parent, targets) {
  return targets.map(function(target) {
    if (parent.contains(target)) {
      return target;
    }
    var correctedTarget = unwrapHost(target);
    if (correctedTarget && parent.contains(correctedTarget)) {
      return correctedTarget;
    }
    console.error("aria-hidden", target, "in not contained inside", parent, ". Doing nothing");
    return null;
  }).filter(function(x3) {
    return Boolean(x3);
  });
};
var applyAttributeToOthers = function(originalTarget, parentNode2, markerName, controlAttribute) {
  var targets = correctTargets(parentNode2, Array.isArray(originalTarget) ? originalTarget : [originalTarget]);
  if (!markerMap[markerName]) {
    markerMap[markerName] = /* @__PURE__ */ new WeakMap();
  }
  var markerCounter = markerMap[markerName];
  var hiddenNodes = [];
  var elementsToKeep = /* @__PURE__ */ new Set();
  var elementsToStop = new Set(targets);
  var keep = function(el2) {
    if (!el2 || elementsToKeep.has(el2)) {
      return;
    }
    elementsToKeep.add(el2);
    keep(el2.parentNode);
  };
  targets.forEach(keep);
  var deep = function(parent) {
    if (!parent || elementsToStop.has(parent)) {
      return;
    }
    Array.prototype.forEach.call(parent.children, function(node2) {
      if (elementsToKeep.has(node2)) {
        deep(node2);
      } else {
        var attr = node2.getAttribute(controlAttribute);
        var alreadyHidden = attr !== null && attr !== "false";
        var counterValue = (counterMap.get(node2) || 0) + 1;
        var markerValue = (markerCounter.get(node2) || 0) + 1;
        counterMap.set(node2, counterValue);
        markerCounter.set(node2, markerValue);
        hiddenNodes.push(node2);
        if (counterValue === 1 && alreadyHidden) {
          uncontrolledNodes.set(node2, true);
        }
        if (markerValue === 1) {
          node2.setAttribute(markerName, "true");
        }
        if (!alreadyHidden) {
          node2.setAttribute(controlAttribute, "true");
        }
      }
    });
  };
  deep(parentNode2);
  elementsToKeep.clear();
  lockCount++;
  return function() {
    hiddenNodes.forEach(function(node2) {
      var counterValue = counterMap.get(node2) - 1;
      var markerValue = markerCounter.get(node2) - 1;
      counterMap.set(node2, counterValue);
      markerCounter.set(node2, markerValue);
      if (!counterValue) {
        if (!uncontrolledNodes.has(node2)) {
          node2.removeAttribute(controlAttribute);
        }
        uncontrolledNodes.delete(node2);
      }
      if (!markerValue) {
        node2.removeAttribute(markerName);
      }
    });
    lockCount--;
    if (!lockCount) {
      counterMap = /* @__PURE__ */ new WeakMap();
      counterMap = /* @__PURE__ */ new WeakMap();
      uncontrolledNodes = /* @__PURE__ */ new WeakMap();
      markerMap = {};
    }
  };
};
var hideOthers = function(originalTarget, parentNode2, markerName) {
  if (markerName === void 0) {
    markerName = "data-aria-hidden";
  }
  var targets = Array.from(Array.isArray(originalTarget) ? originalTarget : [originalTarget]);
  var activeParentNode = parentNode2 || getDefaultParent(originalTarget);
  if (!activeParentNode) {
    return function() {
      return null;
    };
  }
  targets.push.apply(targets, Array.from(activeParentNode.querySelectorAll("[aria-live]")));
  return applyAttributeToOthers(targets, activeParentNode, markerName, "aria-hidden");
};
var __assign = function() {
  __assign = Object.assign || function __assign2(t3) {
    for (var s4, i3 = 1, n2 = arguments.length; i3 < n2; i3++) {
      s4 = arguments[i3];
      for (var p2 in s4)
        if (Object.prototype.hasOwnProperty.call(s4, p2))
          t3[p2] = s4[p2];
    }
    return t3;
  };
  return __assign.apply(this, arguments);
};
function __rest(s4, e3) {
  var t3 = {};
  for (var p2 in s4)
    if (Object.prototype.hasOwnProperty.call(s4, p2) && e3.indexOf(p2) < 0)
      t3[p2] = s4[p2];
  if (s4 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i3 = 0, p2 = Object.getOwnPropertySymbols(s4); i3 < p2.length; i3++) {
      if (e3.indexOf(p2[i3]) < 0 && Object.prototype.propertyIsEnumerable.call(s4, p2[i3]))
        t3[p2[i3]] = s4[p2[i3]];
    }
  return t3;
}
function __spreadArray(to, from3, pack) {
  if (pack || arguments.length === 2)
    for (var i3 = 0, l2 = from3.length, ar; i3 < l2; i3++) {
      if (ar || !(i3 in from3)) {
        if (!ar)
          ar = Array.prototype.slice.call(from3, 0, i3);
        ar[i3] = from3[i3];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from3));
}
var zeroRightClassName = "right-scroll-bar-position";
var fullWidthClassName = "width-before-scroll-bar";
var noScrollbarsClassName = "with-scroll-bars-hidden";
var removedBarSizeVariable = "--removed-body-scroll-bar-size";
function assignRef(ref, value) {
  if (typeof ref === "function") {
    ref(value);
  } else if (ref) {
    ref.current = value;
  }
  return ref;
}
function useCallbackRef$1(initialValue, callback) {
  var ref = react.exports.useState(function() {
    return {
      value: initialValue,
      callback,
      facade: {
        get current() {
          return ref.value;
        },
        set current(value) {
          var last = ref.value;
          if (last !== value) {
            ref.value = value;
            ref.callback(value, last);
          }
        }
      }
    };
  })[0];
  ref.callback = callback;
  return ref.facade;
}
function useMergeRefs(refs, defaultValue2) {
  return useCallbackRef$1(defaultValue2 || null, function(newValue) {
    return refs.forEach(function(ref) {
      return assignRef(ref, newValue);
    });
  });
}
function ItoI(a4) {
  return a4;
}
function innerCreateMedium(defaults2, middleware2) {
  if (middleware2 === void 0) {
    middleware2 = ItoI;
  }
  var buffer = [];
  var assigned = false;
  var medium = {
    read: function() {
      if (assigned) {
        throw new Error("Sidecar: could not `read` from an `assigned` medium. `read` could be used only with `useMedium`.");
      }
      if (buffer.length) {
        return buffer[buffer.length - 1];
      }
      return defaults2;
    },
    useMedium: function(data) {
      var item2 = middleware2(data, assigned);
      buffer.push(item2);
      return function() {
        buffer = buffer.filter(function(x3) {
          return x3 !== item2;
        });
      };
    },
    assignSyncMedium: function(cb2) {
      assigned = true;
      while (buffer.length) {
        var cbs = buffer;
        buffer = [];
        cbs.forEach(cb2);
      }
      buffer = {
        push: function(x3) {
          return cb2(x3);
        },
        filter: function() {
          return buffer;
        }
      };
    },
    assignMedium: function(cb2) {
      assigned = true;
      var pendingQueue = [];
      if (buffer.length) {
        var cbs = buffer;
        buffer = [];
        cbs.forEach(cb2);
        pendingQueue = buffer;
      }
      var executeQueue = function() {
        var cbs2 = pendingQueue;
        pendingQueue = [];
        cbs2.forEach(cb2);
      };
      var cycle = function() {
        return Promise.resolve().then(executeQueue);
      };
      cycle();
      buffer = {
        push: function(x3) {
          pendingQueue.push(x3);
          cycle();
        },
        filter: function(filter) {
          pendingQueue = pendingQueue.filter(filter);
          return buffer;
        }
      };
    }
  };
  return medium;
}
function createSidecarMedium(options) {
  if (options === void 0) {
    options = {};
  }
  var medium = innerCreateMedium(null);
  medium.options = __assign({ async: true, ssr: false }, options);
  return medium;
}
var SideCar$1 = function(_a) {
  var sideCar = _a.sideCar, rest = __rest(_a, ["sideCar"]);
  if (!sideCar) {
    throw new Error("Sidecar: please provide `sideCar` property to import the right car");
  }
  var Target = sideCar.read();
  if (!Target) {
    throw new Error("Sidecar medium not found");
  }
  return react.exports.createElement(Target, __assign({}, rest));
};
SideCar$1.isSideCarExport = true;
function exportSidecar(medium, exported) {
  medium.useMedium(exported);
  return SideCar$1;
}
var effectCar = createSidecarMedium();
var nothing = function() {
  return;
};
var RemoveScroll = react.exports.forwardRef(function(props, parentRef) {
  var ref = react.exports.useRef(null);
  var _a = react.exports.useState({
    onScrollCapture: nothing,
    onWheelCapture: nothing,
    onTouchMoveCapture: nothing
  }), callbacks = _a[0], setCallbacks = _a[1];
  var forwardProps = props.forwardProps, children = props.children, className = props.className, removeScrollBar = props.removeScrollBar, enabled = props.enabled, shards = props.shards, sideCar = props.sideCar, noIsolation = props.noIsolation, inert = props.inert, allowPinchZoom = props.allowPinchZoom, _b = props.as, Container = _b === void 0 ? "div" : _b, rest = __rest(props, ["forwardProps", "children", "className", "removeScrollBar", "enabled", "shards", "sideCar", "noIsolation", "inert", "allowPinchZoom", "as"]);
  var SideCar2 = sideCar;
  var containerRef = useMergeRefs([ref, parentRef]);
  var containerProps = __assign(__assign({}, rest), callbacks);
  return react.exports.createElement(
    react.exports.Fragment,
    null,
    enabled && react.exports.createElement(SideCar2, { sideCar: effectCar, removeScrollBar, shards, noIsolation, inert, setCallbacks, allowPinchZoom: !!allowPinchZoom, lockRef: ref }),
    forwardProps ? react.exports.cloneElement(react.exports.Children.only(children), __assign(__assign({}, containerProps), { ref: containerRef })) : react.exports.createElement(Container, __assign({}, containerProps, { className, ref: containerRef }), children)
  );
});
RemoveScroll.defaultProps = {
  enabled: true,
  removeScrollBar: true,
  inert: false
};
RemoveScroll.classNames = {
  fullWidth: fullWidthClassName,
  zeroRight: zeroRightClassName
};
var getNonce = function() {
  if (typeof __webpack_nonce__ !== "undefined") {
    return __webpack_nonce__;
  }
  return void 0;
};
function makeStyleTag() {
  if (!document)
    return null;
  var tag = document.createElement("style");
  tag.type = "text/css";
  var nonce = getNonce();
  if (nonce) {
    tag.setAttribute("nonce", nonce);
  }
  return tag;
}
function injectStyles(tag, css2) {
  if (tag.styleSheet) {
    tag.styleSheet.cssText = css2;
  } else {
    tag.appendChild(document.createTextNode(css2));
  }
}
function insertStyleTag(tag) {
  var head = document.head || document.getElementsByTagName("head")[0];
  head.appendChild(tag);
}
var stylesheetSingleton = function() {
  var counter = 0;
  var stylesheet = null;
  return {
    add: function(style2) {
      if (counter == 0) {
        if (stylesheet = makeStyleTag()) {
          injectStyles(stylesheet, style2);
          insertStyleTag(stylesheet);
        }
      }
      counter++;
    },
    remove: function() {
      counter--;
      if (!counter && stylesheet) {
        stylesheet.parentNode && stylesheet.parentNode.removeChild(stylesheet);
        stylesheet = null;
      }
    }
  };
};
var styleHookSingleton = function() {
  var sheet = stylesheetSingleton();
  return function(styles, isDynamic) {
    react.exports.useEffect(function() {
      sheet.add(styles);
      return function() {
        sheet.remove();
      };
    }, [styles && isDynamic]);
  };
};
var styleSingleton = function() {
  var useStyle = styleHookSingleton();
  var Sheet = function(_a) {
    var styles = _a.styles, dynamic = _a.dynamic;
    useStyle(styles, dynamic);
    return null;
  };
  return Sheet;
};
var zeroGap = {
  left: 0,
  top: 0,
  right: 0,
  gap: 0
};
var parse$2 = function(x3) {
  return parseInt(x3 || "", 10) || 0;
};
var getOffset = function(gapMode) {
  var cs = window.getComputedStyle(document.body);
  var left2 = cs[gapMode === "padding" ? "paddingLeft" : "marginLeft"];
  var top2 = cs[gapMode === "padding" ? "paddingTop" : "marginTop"];
  var right2 = cs[gapMode === "padding" ? "paddingRight" : "marginRight"];
  return [parse$2(left2), parse$2(top2), parse$2(right2)];
};
var getGapWidth = function(gapMode) {
  if (gapMode === void 0) {
    gapMode = "margin";
  }
  if (typeof window === "undefined") {
    return zeroGap;
  }
  var offsets = getOffset(gapMode);
  var documentWidth = document.documentElement.clientWidth;
  var windowWidth = window.innerWidth;
  return {
    left: offsets[0],
    top: offsets[1],
    right: offsets[2],
    gap: Math.max(0, windowWidth - documentWidth + offsets[2] - offsets[0])
  };
};
var Style$9 = styleSingleton();
var getStyles = function(_a, allowRelative, gapMode, important) {
  var left2 = _a.left, top2 = _a.top, right2 = _a.right, gap = _a.gap;
  if (gapMode === void 0) {
    gapMode = "margin";
  }
  return "\n  .".concat(noScrollbarsClassName, " {\n   overflow: hidden ").concat(important, ";\n   padding-right: ").concat(gap, "px ").concat(important, ";\n  }\n  body {\n    overflow: hidden ").concat(important, ";\n    overscroll-behavior: contain;\n    ").concat([
    allowRelative && "position: relative ".concat(important, ";"),
    gapMode === "margin" && "\n    padding-left: ".concat(left2, "px;\n    padding-top: ").concat(top2, "px;\n    padding-right: ").concat(right2, "px;\n    margin-left:0;\n    margin-top:0;\n    margin-right: ").concat(gap, "px ").concat(important, ";\n    "),
    gapMode === "padding" && "padding-right: ".concat(gap, "px ").concat(important, ";")
  ].filter(Boolean).join(""), "\n  }\n  \n  .").concat(zeroRightClassName, " {\n    right: ").concat(gap, "px ").concat(important, ";\n  }\n  \n  .").concat(fullWidthClassName, " {\n    margin-right: ").concat(gap, "px ").concat(important, ";\n  }\n  \n  .").concat(zeroRightClassName, " .").concat(zeroRightClassName, " {\n    right: 0 ").concat(important, ";\n  }\n  \n  .").concat(fullWidthClassName, " .").concat(fullWidthClassName, " {\n    margin-right: 0 ").concat(important, ";\n  }\n  \n  body {\n    ").concat(removedBarSizeVariable, ": ").concat(gap, "px;\n  }\n");
};
var RemoveScrollBar = function(props) {
  var noRelative = props.noRelative, noImportant = props.noImportant, _a = props.gapMode, gapMode = _a === void 0 ? "margin" : _a;
  var gap = react.exports.useMemo(function() {
    return getGapWidth(gapMode);
  }, [gapMode]);
  return react.exports.createElement(Style$9, { styles: getStyles(gap, !noRelative, gapMode, !noImportant ? "!important" : "") });
};
var passiveSupported = false;
if (typeof window !== "undefined") {
  try {
    var options = Object.defineProperty({}, "passive", {
      get: function() {
        passiveSupported = true;
        return true;
      }
    });
    window.addEventListener("test", options, options);
    window.removeEventListener("test", options, options);
  } catch (err) {
    passiveSupported = false;
  }
}
var nonPassive = passiveSupported ? { passive: false } : false;
var alwaysContainsScroll = function(node2) {
  return node2.tagName === "TEXTAREA";
};
var elementCanBeScrolled = function(node2, overflow) {
  var styles = window.getComputedStyle(node2);
  return styles[overflow] !== "hidden" && !(styles.overflowY === styles.overflowX && !alwaysContainsScroll(node2) && styles[overflow] === "visible");
};
var elementCouldBeVScrolled = function(node2) {
  return elementCanBeScrolled(node2, "overflowY");
};
var elementCouldBeHScrolled = function(node2) {
  return elementCanBeScrolled(node2, "overflowX");
};
var locationCouldBeScrolled = function(axis, node2) {
  var current = node2;
  do {
    if (typeof ShadowRoot !== "undefined" && current instanceof ShadowRoot) {
      current = current.host;
    }
    var isScrollable2 = elementCouldBeScrolled(axis, current);
    if (isScrollable2) {
      var _a = getScrollVariables(axis, current), s4 = _a[1], d4 = _a[2];
      if (s4 > d4) {
        return true;
      }
    }
    current = current.parentNode;
  } while (current && current !== document.body);
  return false;
};
var getVScrollVariables = function(_a) {
  var scrollTop = _a.scrollTop, scrollHeight = _a.scrollHeight, clientHeight = _a.clientHeight;
  return [
    scrollTop,
    scrollHeight,
    clientHeight
  ];
};
var getHScrollVariables = function(_a) {
  var scrollLeft = _a.scrollLeft, scrollWidth = _a.scrollWidth, clientWidth = _a.clientWidth;
  return [
    scrollLeft,
    scrollWidth,
    clientWidth
  ];
};
var elementCouldBeScrolled = function(axis, node2) {
  return axis === "v" ? elementCouldBeVScrolled(node2) : elementCouldBeHScrolled(node2);
};
var getScrollVariables = function(axis, node2) {
  return axis === "v" ? getVScrollVariables(node2) : getHScrollVariables(node2);
};
var getDirectionFactor = function(axis, direction) {
  return axis === "h" && direction === "rtl" ? -1 : 1;
};
var handleScroll = function(axis, endTarget, event, sourceDelta, noOverscroll) {
  var directionFactor = getDirectionFactor(axis, window.getComputedStyle(endTarget).direction);
  var delta = directionFactor * sourceDelta;
  var target = event.target;
  var targetInLock = endTarget.contains(target);
  var shouldCancelScroll = false;
  var isDeltaPositive = delta > 0;
  var availableScroll = 0;
  var availableScrollTop = 0;
  do {
    var _a = getScrollVariables(axis, target), position2 = _a[0], scroll_1 = _a[1], capacity = _a[2];
    var elementScroll = scroll_1 - capacity - directionFactor * position2;
    if (position2 || elementScroll) {
      if (elementCouldBeScrolled(axis, target)) {
        availableScroll += elementScroll;
        availableScrollTop += position2;
      }
    }
    target = target.parentNode;
  } while (!targetInLock && target !== document.body || targetInLock && (endTarget.contains(target) || endTarget === target));
  if (isDeltaPositive && (noOverscroll && availableScroll === 0 || !noOverscroll && delta > availableScroll)) {
    shouldCancelScroll = true;
  } else if (!isDeltaPositive && (noOverscroll && availableScrollTop === 0 || !noOverscroll && -delta > availableScrollTop)) {
    shouldCancelScroll = true;
  }
  return shouldCancelScroll;
};
var getTouchXY = function(event) {
  return "changedTouches" in event ? [event.changedTouches[0].clientX, event.changedTouches[0].clientY] : [0, 0];
};
var getDeltaXY = function(event) {
  return [event.deltaX, event.deltaY];
};
var extractRef = function(ref) {
  return ref && "current" in ref ? ref.current : ref;
};
var deltaCompare = function(x3, y4) {
  return x3[0] === y4[0] && x3[1] === y4[1];
};
var generateStyle = function(id2) {
  return "\n  .block-interactivity-".concat(id2, " {pointer-events: none;}\n  .allow-interactivity-").concat(id2, " {pointer-events: all;}\n");
};
var idCounter = 0;
var lockStack = [];
function RemoveScrollSideCar(props) {
  var shouldPreventQueue = react.exports.useRef([]);
  var touchStartRef = react.exports.useRef([0, 0]);
  var activeAxis = react.exports.useRef();
  var id2 = react.exports.useState(idCounter++)[0];
  var Style2 = react.exports.useState(function() {
    return styleSingleton();
  })[0];
  var lastProps = react.exports.useRef(props);
  react.exports.useEffect(function() {
    lastProps.current = props;
  }, [props]);
  react.exports.useEffect(function() {
    if (props.inert) {
      document.body.classList.add("block-interactivity-".concat(id2));
      var allow_1 = __spreadArray([props.lockRef.current], (props.shards || []).map(extractRef), true).filter(Boolean);
      allow_1.forEach(function(el2) {
        return el2.classList.add("allow-interactivity-".concat(id2));
      });
      return function() {
        document.body.classList.remove("block-interactivity-".concat(id2));
        allow_1.forEach(function(el2) {
          return el2.classList.remove("allow-interactivity-".concat(id2));
        });
      };
    }
    return;
  }, [props.inert, props.lockRef.current, props.shards]);
  var shouldCancelEvent = react.exports.useCallback(function(event, parent) {
    if ("touches" in event && event.touches.length === 2) {
      return !lastProps.current.allowPinchZoom;
    }
    var touch = getTouchXY(event);
    var touchStart = touchStartRef.current;
    var deltaX = "deltaX" in event ? event.deltaX : touchStart[0] - touch[0];
    var deltaY = "deltaY" in event ? event.deltaY : touchStart[1] - touch[1];
    var currentAxis;
    var target = event.target;
    var moveDirection = Math.abs(deltaX) > Math.abs(deltaY) ? "h" : "v";
    if ("touches" in event && moveDirection === "h" && target.type === "range") {
      return false;
    }
    var canBeScrolledInMainDirection = locationCouldBeScrolled(moveDirection, target);
    if (!canBeScrolledInMainDirection) {
      return true;
    }
    if (canBeScrolledInMainDirection) {
      currentAxis = moveDirection;
    } else {
      currentAxis = moveDirection === "v" ? "h" : "v";
      canBeScrolledInMainDirection = locationCouldBeScrolled(moveDirection, target);
    }
    if (!canBeScrolledInMainDirection) {
      return false;
    }
    if (!activeAxis.current && "changedTouches" in event && (deltaX || deltaY)) {
      activeAxis.current = currentAxis;
    }
    if (!currentAxis) {
      return true;
    }
    var cancelingAxis = activeAxis.current || currentAxis;
    return handleScroll(cancelingAxis, parent, event, cancelingAxis === "h" ? deltaX : deltaY, true);
  }, []);
  var shouldPrevent = react.exports.useCallback(function(_event) {
    var event = _event;
    if (!lockStack.length || lockStack[lockStack.length - 1] !== Style2) {
      return;
    }
    var delta = "deltaY" in event ? getDeltaXY(event) : getTouchXY(event);
    var sourceEvent = shouldPreventQueue.current.filter(function(e3) {
      return e3.name === event.type && e3.target === event.target && deltaCompare(e3.delta, delta);
    })[0];
    if (sourceEvent && sourceEvent.should) {
      if (event.cancelable) {
        event.preventDefault();
      }
      return;
    }
    if (!sourceEvent) {
      var shardNodes = (lastProps.current.shards || []).map(extractRef).filter(Boolean).filter(function(node2) {
        return node2.contains(event.target);
      });
      var shouldStop = shardNodes.length > 0 ? shouldCancelEvent(event, shardNodes[0]) : !lastProps.current.noIsolation;
      if (shouldStop) {
        if (event.cancelable) {
          event.preventDefault();
        }
      }
    }
  }, []);
  var shouldCancel = react.exports.useCallback(function(name, delta, target, should) {
    var event = { name, delta, target, should };
    shouldPreventQueue.current.push(event);
    setTimeout(function() {
      shouldPreventQueue.current = shouldPreventQueue.current.filter(function(e3) {
        return e3 !== event;
      });
    }, 1);
  }, []);
  var scrollTouchStart = react.exports.useCallback(function(event) {
    touchStartRef.current = getTouchXY(event);
    activeAxis.current = void 0;
  }, []);
  var scrollWheel = react.exports.useCallback(function(event) {
    shouldCancel(event.type, getDeltaXY(event), event.target, shouldCancelEvent(event, props.lockRef.current));
  }, []);
  var scrollTouchMove = react.exports.useCallback(function(event) {
    shouldCancel(event.type, getTouchXY(event), event.target, shouldCancelEvent(event, props.lockRef.current));
  }, []);
  react.exports.useEffect(function() {
    lockStack.push(Style2);
    props.setCallbacks({
      onScrollCapture: scrollWheel,
      onWheelCapture: scrollWheel,
      onTouchMoveCapture: scrollTouchMove
    });
    document.addEventListener("wheel", shouldPrevent, nonPassive);
    document.addEventListener("touchmove", shouldPrevent, nonPassive);
    document.addEventListener("touchstart", scrollTouchStart, nonPassive);
    return function() {
      lockStack = lockStack.filter(function(inst) {
        return inst !== Style2;
      });
      document.removeEventListener("wheel", shouldPrevent, nonPassive);
      document.removeEventListener("touchmove", shouldPrevent, nonPassive);
      document.removeEventListener("touchstart", scrollTouchStart, nonPassive);
    };
  }, []);
  var removeScrollBar = props.removeScrollBar, inert = props.inert;
  return react.exports.createElement(
    react.exports.Fragment,
    null,
    inert ? react.exports.createElement(Style2, { styles: generateStyle(id2) }) : null,
    removeScrollBar ? react.exports.createElement(RemoveScrollBar, { gapMode: "margin" }) : null
  );
}
var SideCar = exportSidecar(effectCar, RemoveScrollSideCar);
var ReactRemoveScroll = react.exports.forwardRef(function(props, ref) {
  return react.exports.createElement(RemoveScroll, __assign({}, props, { ref, sideCar: SideCar }));
});
ReactRemoveScroll.classNames = RemoveScroll.classNames;
var o$4 = ReactRemoveScroll;
let t$4 = 0;
function useFocusGuards() {
  react.exports.useEffect(() => {
    var e3, n2;
    const r2 = document.querySelectorAll("[data-radix-focus-guard]");
    return document.body.insertAdjacentElement("afterbegin", null !== (e3 = r2[0]) && void 0 !== e3 ? e3 : o$3()), document.body.insertAdjacentElement("beforeend", null !== (n2 = r2[1]) && void 0 !== n2 ? n2 : o$3()), t$4++, () => {
      1 === t$4 && document.querySelectorAll("[data-radix-focus-guard]").forEach((e4) => e4.remove()), t$4--;
    };
  }, []);
}
function o$3() {
  const e3 = document.createElement("span");
  return e3.setAttribute("data-radix-focus-guard", ""), e3.tabIndex = 0, e3.style.cssText = "outline: none; opacity: 0; position: fixed; pointer-events: none", e3;
}
const Primitive = ["a", "button", "div", "h2", "h3", "img", "li", "nav", "ol", "p", "span", "svg", "ul"].reduce((o2, i3) => ({ ...o2, [i3]: /* @__PURE__ */ react.exports.forwardRef((o3, m4) => {
  const { asChild: a4, ...s4 } = o3, n2 = a4 ? Slot : i3;
  return react.exports.useEffect(() => {
    window[Symbol.for("radix-ui")] = true;
  }, []), /* @__PURE__ */ react.exports.createElement(n2, _extends$1({}, s4, { ref: m4 }));
}) }), {});
const useLayoutEffect = Boolean(null === globalThis || void 0 === globalThis ? void 0 : globalThis.document) ? react.exports.useLayoutEffect : () => {
};
const Presence = (u3) => {
  const { present: o2, children: i3 } = u3, s4 = function(n2) {
    const [u4, o3] = react.exports.useState(), i4 = react.exports.useRef({}), s5 = react.exports.useRef(n2), c4 = react.exports.useRef("none"), a5 = n2 ? "mounted" : "unmounted", [d4, m4] = function(e3, n3) {
      return react.exports.useReducer((e4, t3) => {
        const r2 = n3[e4][t3];
        return null != r2 ? r2 : e4;
      }, e3);
    }(a5, { mounted: { UNMOUNT: "unmounted", ANIMATION_OUT: "unmountSuspended" }, unmountSuspended: { MOUNT: "mounted", ANIMATION_END: "unmounted" }, unmounted: { MOUNT: "mounted" } });
    return react.exports.useEffect(() => {
      const e3 = r$4(i4.current);
      c4.current = "mounted" === d4 ? e3 : "none";
    }, [d4]), useLayoutEffect(() => {
      const e3 = i4.current, t3 = s5.current;
      if (t3 !== n2) {
        const u5 = c4.current, o4 = r$4(e3);
        if (n2)
          m4("MOUNT");
        else if ("none" === o4 || "none" === (null == e3 ? void 0 : e3.display))
          m4("UNMOUNT");
        else {
          const e4 = u5 !== o4;
          m4(t3 && e4 ? "ANIMATION_OUT" : "UNMOUNT");
        }
        s5.current = n2;
      }
    }, [n2, m4]), useLayoutEffect(() => {
      if (u4) {
        const e3 = (e4) => {
          const n4 = r$4(i4.current).includes(e4.animationName);
          e4.target === u4 && n4 && m4("ANIMATION_END");
        }, n3 = (e4) => {
          e4.target === u4 && (c4.current = r$4(i4.current));
        };
        return u4.addEventListener("animationstart", n3), u4.addEventListener("animationcancel", e3), u4.addEventListener("animationend", e3), () => {
          u4.removeEventListener("animationstart", n3), u4.removeEventListener("animationcancel", e3), u4.removeEventListener("animationend", e3);
        };
      }
      m4("ANIMATION_END");
    }, [u4, m4]), { isPresent: ["mounted", "unmountSuspended"].includes(d4), ref: react.exports.useCallback((e3) => {
      e3 && (i4.current = getComputedStyle(e3)), o3(e3);
    }, []) };
  }(o2), c3 = "function" == typeof i3 ? i3({ present: s4.isPresent }) : react.exports.Children.only(i3), a4 = useComposedRefs(s4.ref, c3.ref);
  return "function" == typeof i3 || s4.isPresent ? /* @__PURE__ */ react.exports.cloneElement(c3, { ref: a4 }) : null;
};
function r$4(e3) {
  return (null == e3 ? void 0 : e3.animationName) || "none";
}
Presence.displayName = "Presence";
const Portal = /* @__PURE__ */ react.exports.forwardRef((a4, i3) => {
  var n2, d4;
  const { containerRef: s4, style: u3, ...c3 } = a4, m4 = null !== (n2 = null == s4 ? void 0 : s4.current) && void 0 !== n2 ? n2 : null === globalThis || void 0 === globalThis || null === (d4 = globalThis.document) || void 0 === d4 ? void 0 : d4.body, [, f2] = react.exports.useState({});
  return useLayoutEffect(() => {
    f2({});
  }, []), m4 ? /* @__PURE__ */ ae.createPortal(/* @__PURE__ */ react.exports.createElement(Primitive.div, _extends$1({ "data-radix-portal": "" }, c3, { ref: i3, style: m4 === document.body ? { position: "absolute", top: 0, left: 0, zIndex: 2147483647, ...u3 } : void 0 })), m4) : null;
});
function useCallbackRef(r2) {
  const t3 = react.exports.useRef(r2);
  return react.exports.useEffect(() => {
    t3.current = r2;
  }), react.exports.useMemo(() => (...e3) => {
    var r3;
    return null === (r3 = t3.current) || void 0 === r3 ? void 0 : r3.call(t3, ...e3);
  }, []);
}
const c$5 = { bubbles: false, cancelable: true };
const FocusScope = /* @__PURE__ */ react.exports.forwardRef((i3, f2) => {
  const { loop: l2 = false, trapped: m4 = false, onMountAutoFocus: p2, onUnmountAutoFocus: v2, ...E3 } = i3, [F2, S4] = react.exports.useState(null), b3 = useCallbackRef(p2), T3 = useCallbackRef(v2), y4 = react.exports.useRef(null), L3 = useComposedRefs(f2, (e3) => S4(e3)), h4 = react.exports.useRef({ paused: false, pause() {
    this.paused = true;
  }, resume() {
    this.paused = false;
  } }).current;
  react.exports.useEffect(() => {
    if (m4) {
      let e3 = function(e4) {
        if (h4.paused || !F2)
          return;
        const t4 = e4.target;
        F2.contains(t4) ? y4.current = t4 : a$2(y4.current, { select: true });
      }, t3 = function(e4) {
        !h4.paused && F2 && (F2.contains(e4.relatedTarget) || a$2(y4.current, { select: true }));
      };
      return document.addEventListener("focusin", e3), document.addEventListener("focusout", t3), () => {
        document.removeEventListener("focusin", e3), document.removeEventListener("focusout", t3);
      };
    }
  }, [m4, F2, h4.paused]), react.exports.useEffect(() => {
    if (F2) {
      d$6.add(h4);
      const t3 = document.activeElement;
      if (!F2.contains(t3)) {
        const n2 = new Event("focusScope.autoFocusOnMount", c$5);
        F2.addEventListener("focusScope.autoFocusOnMount", b3), F2.dispatchEvent(n2), n2.defaultPrevented || (!function(e4, { select: t4 = false } = {}) {
          const n3 = document.activeElement;
          for (const o2 of e4)
            if (a$2(o2, { select: t4 }), document.activeElement !== n3)
              return;
        }((e3 = r$3(F2), e3.filter((e4) => "A" !== e4.tagName)), { select: true }), document.activeElement === t3 && a$2(F2));
      }
      return () => {
        F2.removeEventListener("focusScope.autoFocusOnMount", b3), setTimeout(() => {
          const e4 = new Event("focusScope.autoFocusOnUnmount", c$5);
          F2.addEventListener("focusScope.autoFocusOnUnmount", T3), F2.dispatchEvent(e4), e4.defaultPrevented || a$2(null != t3 ? t3 : document.body, { select: true }), F2.removeEventListener("focusScope.autoFocusOnUnmount", T3), d$6.remove(h4);
        }, 0);
      };
    }
    var e3;
  }, [F2, b3, T3, h4]);
  const N2 = react.exports.useCallback((e3) => {
    if (!l2 && !m4)
      return;
    if (h4.paused)
      return;
    const t3 = "Tab" === e3.key && !e3.altKey && !e3.ctrlKey && !e3.metaKey, n2 = document.activeElement;
    if (t3 && n2) {
      const t4 = e3.currentTarget, [o2, u3] = function(e4) {
        const t5 = r$3(e4), n3 = s$1(t5, e4), o3 = s$1(t5.reverse(), e4);
        return [n3, o3];
      }(t4);
      o2 && u3 ? e3.shiftKey || n2 !== u3 ? e3.shiftKey && n2 === o2 && (e3.preventDefault(), l2 && a$2(u3, { select: true })) : (e3.preventDefault(), l2 && a$2(o2, { select: true })) : n2 === t4 && e3.preventDefault();
    }
  }, [l2, m4, h4.paused]);
  return react.exports.createElement(Primitive.div, _extends$1({ tabIndex: -1 }, E3, { ref: L3, onKeyDown: N2 }));
});
function r$3(e3) {
  const t3 = [], n2 = document.createTreeWalker(e3, NodeFilter.SHOW_ELEMENT, { acceptNode: (e4) => {
    const t4 = "INPUT" === e4.tagName && "hidden" === e4.type;
    return e4.disabled || e4.hidden || t4 ? NodeFilter.FILTER_SKIP : e4.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
  } });
  for (; n2.nextNode(); )
    t3.push(n2.currentNode);
  return t3;
}
function s$1(e3, t3) {
  for (const n2 of e3)
    if (!i$2(n2, { upTo: t3 }))
      return n2;
}
function i$2(e3, { upTo: t3 }) {
  if ("hidden" === getComputedStyle(e3).visibility)
    return true;
  for (; e3; ) {
    if (void 0 !== t3 && e3 === t3)
      return false;
    if ("none" === getComputedStyle(e3).display)
      return true;
    e3 = e3.parentElement;
  }
  return false;
}
function a$2(e3, { select: t3 = false } = {}) {
  if (e3 && e3.focus) {
    const n2 = document.activeElement;
    e3.focus({ preventScroll: true }), e3 !== n2 && function(e4) {
      return e4 instanceof HTMLInputElement && "select" in e4;
    }(e3) && t3 && e3.select();
  }
}
const d$6 = function() {
  let e3 = [];
  return { add(t3) {
    const n2 = e3[0];
    t3 !== n2 && (null == n2 || n2.pause()), e3 = f$6(e3, t3), e3.unshift(t3);
  }, remove(t3) {
    var n2;
    e3 = f$6(e3, t3), null === (n2 = e3[0]) || void 0 === n2 || n2.resume();
  } };
}();
function f$6(e3, t3) {
  const n2 = [...e3], o2 = n2.indexOf(t3);
  return -1 !== o2 && n2.splice(o2, 1), n2;
}
function useEscapeKeydown(n2) {
  const o2 = useCallbackRef(n2);
  react.exports.useEffect(() => {
    const e3 = (e4) => {
      "Escape" === e4.key && o2(e4);
    };
    return document.addEventListener("keydown", e3), () => document.removeEventListener("keydown", e3);
  }, [o2]);
}
let n$2, o$2 = 0;
function useBodyPointerEvents({ disabled: r2 }) {
  const i3 = react.exports.useRef(false);
  useLayoutEffect(() => {
    if (r2) {
      let e3 = function() {
        o$2--, 0 === o$2 && (document.body.style.pointerEvents = n$2);
      }, t3 = function(e4) {
        i3.current = "mouse" !== e4.pointerType;
      };
      return 0 === o$2 && (n$2 = document.body.style.pointerEvents), document.body.style.pointerEvents = "none", o$2++, document.addEventListener("pointerup", t3), () => {
        i3.current ? document.addEventListener("click", e3, { once: true }) : e3(), document.removeEventListener("pointerup", t3);
      };
    }
  }, [r2]);
}
function composeEventHandlers(e3, n2, { checkForDefaultPrevented: t3 = true } = {}) {
  return function(r2) {
    if (null == e3 || e3(r2), false === t3 || !r2.defaultPrevented)
      return null == n2 ? void 0 : n2(r2);
  };
}
const u$4 = /* @__PURE__ */ react.exports.createContext({ layers: /* @__PURE__ */ new Set(), layersWithOutsidePointerEventsDisabled: /* @__PURE__ */ new Set(), branches: /* @__PURE__ */ new Set() });
const DismissableLayer = /* @__PURE__ */ react.exports.forwardRef((l2, m4) => {
  const { disableOutsidePointerEvents: f2 = false, onEscapeKeyDown: p2, onPointerDownOutside: v2, onFocusOutside: b3, onInteractOutside: E3, onDismiss: y4, ...w3 } = l2, h4 = react.exports.useContext(u$4), [D3, x3] = react.exports.useState(null), [, C2] = react.exports.useState({}), L3 = useComposedRefs(m4, (e3) => x3(e3)), P2 = Array.from(h4.layers), [O3] = [...h4.layersWithOutsidePointerEventsDisabled].slice(-1), g2 = P2.indexOf(O3), B3 = D3 ? P2.indexOf(D3) : -1, R3 = h4.layersWithOutsidePointerEventsDisabled.size > 0, F2 = B3 >= g2, S4 = function(e3) {
    const n2 = useCallbackRef(e3), r2 = react.exports.useRef(false);
    return react.exports.useEffect(() => {
      const e4 = (e5) => {
        if (e5.target && !r2.current) {
          d$5("dismissableLayer.pointerDownOutside", n2, { originalEvent: e5 });
        }
        r2.current = false;
      }, t3 = window.setTimeout(() => {
        document.addEventListener("pointerdown", e4);
      }, 0);
      return () => {
        window.clearTimeout(t3), document.removeEventListener("pointerdown", e4);
      };
    }, [n2]), { onPointerDownCapture: () => r2.current = true };
  }((e3) => {
    const t3 = e3.target, n2 = [...h4.branches].some((e4) => e4.contains(t3));
    F2 && !n2 && (null == v2 || v2(e3), null == E3 || E3(e3), e3.defaultPrevented || null == y4 || y4());
  }), W2 = function(e3) {
    const n2 = useCallbackRef(e3), r2 = react.exports.useRef(false);
    return react.exports.useEffect(() => {
      const e4 = (e5) => {
        if (e5.target && !r2.current) {
          d$5("dismissableLayer.focusOutside", n2, { originalEvent: e5 });
        }
      };
      return document.addEventListener("focusin", e4), () => document.removeEventListener("focusin", e4);
    }, [n2]), { onFocusCapture: () => r2.current = true, onBlurCapture: () => r2.current = false };
  }((e3) => {
    const t3 = e3.target;
    [...h4.branches].some((e4) => e4.contains(t3)) || (null == b3 || b3(e3), null == E3 || E3(e3), e3.defaultPrevented || null == y4 || y4());
  });
  return useEscapeKeydown((e3) => {
    B3 === h4.layers.size - 1 && (null == p2 || p2(e3), e3.defaultPrevented || null == y4 || y4());
  }), useBodyPointerEvents({ disabled: f2 }), react.exports.useEffect(() => {
    D3 && (f2 && h4.layersWithOutsidePointerEventsDisabled.add(D3), h4.layers.add(D3), c$4());
  }, [D3, f2, h4]), react.exports.useEffect(() => () => {
    D3 && (h4.layers.delete(D3), h4.layersWithOutsidePointerEventsDisabled.delete(D3), c$4());
  }, [D3, h4]), react.exports.useEffect(() => {
    const e3 = () => C2({});
    return document.addEventListener("dismissableLayer.update", e3), () => document.removeEventListener("dismissableLayer.update", e3);
  }, []), /* @__PURE__ */ react.exports.createElement(Primitive.div, _extends$1({}, w3, { ref: L3, style: { pointerEvents: R3 ? F2 ? "auto" : "none" : void 0, ...l2.style }, onFocusCapture: composeEventHandlers(l2.onFocusCapture, W2.onFocusCapture), onBlurCapture: composeEventHandlers(l2.onBlurCapture, W2.onBlurCapture), onPointerDownCapture: composeEventHandlers(l2.onPointerDownCapture, S4.onPointerDownCapture) }));
});
function c$4() {
  const e3 = new Event("dismissableLayer.update");
  document.dispatchEvent(e3);
}
function d$5(e3, t3, n2) {
  const r2 = n2.originalEvent.target, s4 = new CustomEvent(e3, { bubbles: false, cancelable: true, detail: n2 });
  return t3 && r2.addEventListener(e3, t3, { once: true }), !r2.dispatchEvent(s4);
}
function useControllableState({ prop: o2, defaultProp: r2, onChange: n2 = () => {
} }) {
  const [a4, u3] = function({ defaultProp: o3, onChange: r3 }) {
    const n3 = react.exports.useState(o3), [a5] = n3, u4 = react.exports.useRef(a5), c4 = useCallbackRef(r3);
    return react.exports.useEffect(() => {
      u4.current !== a5 && (c4(a5), u4.current = a5);
    }, [a5, u4, c4]), n3;
  }({ defaultProp: r2, onChange: n2 }), c3 = void 0 !== o2, f2 = c3 ? o2 : a4, l2 = useCallbackRef(n2);
  return [f2, react.exports.useCallback((e3) => {
    if (c3) {
      const t3 = e3, r3 = "function" == typeof e3 ? t3(o2) : e3;
      r3 !== o2 && l2(r3);
    } else
      u3(e3);
  }, [c3, o2, u3, l2])];
}
const r$2 = React["useId".toString()] || (() => {
});
let n$1 = 0;
function useId(o2) {
  const [u3, i3] = react.exports.useState(r$2());
  return useLayoutEffect(() => {
    o2 || i3((t3) => null != t3 ? t3 : String(n$1++));
  }, [o2]), o2 || (u3 ? `radix-${u3}` : "");
}
function createContextScope(n2, o2 = []) {
  let r2 = [];
  const c3 = () => {
    const t3 = r2.map((t4) => /* @__PURE__ */ react.exports.createContext(t4));
    return function(o3) {
      const r3 = (null == o3 ? void 0 : o3[n2]) || t3;
      return react.exports.useMemo(() => ({ [`__scope${n2}`]: { ...o3, [n2]: r3 } }), [o3, r3]);
    };
  };
  return c3.scopeName = n2, [function(t3, o3) {
    const c4 = /* @__PURE__ */ react.exports.createContext(o3), u3 = r2.length;
    function s4(t4) {
      const { scope: o4, children: r3, ...s5 } = t4, i3 = (null == o4 ? void 0 : o4[n2][u3]) || c4, a4 = react.exports.useMemo(() => s5, Object.values(s5));
      return react.exports.createElement(i3.Provider, { value: a4 }, r3);
    }
    return r2 = [...r2, o3], s4.displayName = t3 + "Provider", [s4, function(r3, s5) {
      const i3 = (null == s5 ? void 0 : s5[n2][u3]) || c4, a4 = react.exports.useContext(i3);
      if (a4)
        return a4;
      if (void 0 !== o3)
        return o3;
      throw new Error(`\`${r3}\` must be used within \`${t3}\``);
    }];
  }, t$3(c3, ...o2)];
}
function t$3(...t3) {
  const n2 = t3[0];
  if (1 === t3.length)
    return n2;
  const o2 = () => {
    const o3 = t3.map((e3) => ({ useScope: e3(), scopeName: e3.scopeName }));
    return function(t4) {
      const r2 = o3.reduce((e3, { useScope: n3, scopeName: o4 }) => ({ ...e3, ...n3(t4)[`__scope${o4}`] }), {});
      return react.exports.useMemo(() => ({ [`__scope${n2.scopeName}`]: r2 }), [r2]);
    };
  };
  return o2.scopeName = n2.scopeName, o2;
}
const [x$3, C$2] = createContextScope("Dialog");
const [v$3, E$3] = x$3("Dialog");
const Dialog = (e3) => {
  const { __scopeDialog: o2, children: t3, open: r2, defaultOpen: n2, onOpenChange: a4, modal: i3 = true, allowPinchZoom: l2 } = e3, c3 = react.exports.useRef(null), p2 = react.exports.useRef(null), [d4 = false, f2] = useControllableState({ prop: r2, defaultProp: n2, onChange: a4 });
  return react.exports.createElement(v$3, { scope: o2, triggerRef: c3, contentRef: p2, contentId: useId(), titleId: useId(), descriptionId: useId(), open: d4, onOpenChange: f2, onOpenToggle: react.exports.useCallback(() => f2((e4) => !e4), [f2]), modal: i3, allowPinchZoom: l2 }, t3);
};
const DialogOverlay = /* @__PURE__ */ react.exports.forwardRef((e3, o2) => {
  const { forceMount: t3, ...r2 } = e3, n2 = E$3("DialogOverlay", e3.__scopeDialog);
  return n2.modal ? /* @__PURE__ */ react.exports.createElement(Presence, { present: t3 || n2.open }, /* @__PURE__ */ react.exports.createElement(R$4, _extends$1({}, r2, { ref: o2 }))) : null;
});
const R$4 = /* @__PURE__ */ react.exports.forwardRef((o2, r2) => {
  const { __scopeDialog: a4, ...i3 } = o2, l2 = E$3("DialogOverlay", a4);
  return react.exports.createElement(o$4, { as: Slot, allowPinchZoom: l2.allowPinchZoom, shards: [l2.contentRef] }, /* @__PURE__ */ react.exports.createElement(Primitive.div, _extends$1({ "data-state": b$4(l2.open) }, i3, { ref: r2, style: { pointerEvents: "auto", ...i3.style } })));
});
const DialogContent = /* @__PURE__ */ react.exports.forwardRef((e3, o2) => {
  const { forceMount: t3, ...r2 } = e3, n2 = E$3("DialogContent", e3.__scopeDialog);
  return react.exports.createElement(Presence, { present: t3 || n2.open }, n2.modal ? /* @__PURE__ */ react.exports.createElement(_$2, _extends$1({}, r2, { ref: o2 })) : /* @__PURE__ */ react.exports.createElement(O$2, _extends$1({}, r2, { ref: o2 })));
});
const _$2 = /* @__PURE__ */ react.exports.forwardRef((e3, t3) => {
  const r2 = E$3("DialogContent", e3.__scopeDialog), n2 = react.exports.useRef(null), a4 = useComposedRefs(t3, r2.contentRef, n2);
  return react.exports.useEffect(() => {
    const e4 = n2.current;
    if (e4)
      return hideOthers(e4);
  }, []), /* @__PURE__ */ react.exports.createElement(h$4, _extends$1({}, e3, { ref: a4, trapFocus: r2.open, disableOutsidePointerEvents: true, onCloseAutoFocus: composeEventHandlers(e3.onCloseAutoFocus, (e4) => {
    var o2;
    e4.preventDefault(), null === (o2 = r2.triggerRef.current) || void 0 === o2 || o2.focus();
  }), onPointerDownOutside: composeEventHandlers(e3.onPointerDownOutside, (e4) => {
    const o2 = e4.detail.originalEvent, t4 = 0 === o2.button && true === o2.ctrlKey;
    (2 === o2.button || t4) && e4.preventDefault();
  }), onFocusOutside: composeEventHandlers(e3.onFocusOutside, (e4) => e4.preventDefault()) }));
}), O$2 = /* @__PURE__ */ react.exports.forwardRef((e3, o2) => {
  const t3 = E$3("DialogContent", e3.__scopeDialog), r2 = react.exports.useRef(false);
  return react.exports.createElement(h$4, _extends$1({}, e3, { ref: o2, trapFocus: false, disableOutsidePointerEvents: false, onCloseAutoFocus: (o3) => {
    var n2, a4;
    (null === (n2 = e3.onCloseAutoFocus) || void 0 === n2 || n2.call(e3, o3), o3.defaultPrevented) || (r2.current || null === (a4 = t3.triggerRef.current) || void 0 === a4 || a4.focus(), o3.preventDefault());
    r2.current = false;
  }, onInteractOutside: (o3) => {
    var n2, a4;
    null === (n2 = e3.onInteractOutside) || void 0 === n2 || n2.call(e3, o3), o3.defaultPrevented || (r2.current = true);
    const i3 = o3.target;
    (null === (a4 = t3.triggerRef.current) || void 0 === a4 ? void 0 : a4.contains(i3)) && o3.preventDefault();
  } }));
}), h$4 = /* @__PURE__ */ react.exports.forwardRef((e3, o2) => {
  const { __scopeDialog: t3, trapFocus: n2, onOpenAutoFocus: a4, onCloseAutoFocus: i3, ...s4 } = e3, u3 = E$3("DialogContent", t3), p2 = react.exports.useRef(null), d4 = useComposedRefs(o2, p2);
  return useFocusGuards(), /* @__PURE__ */ react.exports.createElement(react.exports.Fragment, null, /* @__PURE__ */ react.exports.createElement(FocusScope, { asChild: true, loop: true, trapped: n2, onMountAutoFocus: a4, onUnmountAutoFocus: i3 }, /* @__PURE__ */ react.exports.createElement(DismissableLayer, _extends$1({ role: "dialog", id: u3.contentId, "aria-describedby": u3.descriptionId, "aria-labelledby": u3.titleId, "data-state": b$4(u3.open) }, s4, { ref: d4, onDismiss: () => u3.onOpenChange(false) }))), false);
});
const DialogTitle = /* @__PURE__ */ react.exports.forwardRef((e3, o2) => {
  const { __scopeDialog: t3, ...r2 } = e3, a4 = E$3("DialogTitle", t3);
  return react.exports.createElement(Primitive.h2, _extends$1({ id: a4.titleId }, r2, { ref: o2 }));
});
function b$4(e3) {
  return e3 ? "open" : "closed";
}
const Root$4 = Dialog;
const Overlay = DialogOverlay;
const Content$2 = DialogContent;
const Title$2 = DialogTitle;
var __create = Object.create;
var __defProp2 = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn3, res) => function __init() {
  return fn3 && (res = (0, fn3[__getOwnPropNames(fn3)[0]])(fn3 = 0)), res;
};
var __commonJS = (cb2, mod) => function __require() {
  return mod || (0, cb2[__getOwnPropNames(cb2)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __copyProps = (to, from3, except, desc) => {
  if (from3 && typeof from3 === "object" || typeof from3 === "function") {
    for (let key of __getOwnPropNames(from3))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp2(to, key, { get: () => from3[key], enumerable: !(desc = __getOwnPropDesc(from3, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  isNodeMode || !mod || !mod.__esModule ? __defProp2(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var init_react_shim = __esm({
  "react-shim.js"() {
  }
});
var require_turbolinks = __commonJS({
  "node_modules/turbolinks/dist/turbolinks.js"(exports, module) {
    init_react_shim();
    (function() {
      var t3 = this;
      (function() {
        (function() {
          this.Turbolinks = { supported: function() {
            return null != window.history.pushState && null != window.requestAnimationFrame && null != window.addEventListener;
          }(), visit: function(t22, r2) {
            return e3.controller.visit(t22, r2);
          }, clearCache: function() {
            return e3.controller.clearCache();
          }, setProgressBarDelay: function(t22) {
            return e3.controller.setProgressBarDelay(t22);
          } };
        }).call(this);
      }).call(t3);
      var e3 = t3.Turbolinks;
      (function() {
        (function() {
          var t22, r2, n2, o2 = [].slice;
          e3.copyObject = function(t32) {
            var e22, r22, n22;
            r22 = {};
            for (e22 in t32)
              n22 = t32[e22], r22[e22] = n22;
            return r22;
          }, e3.closest = function(e22, r22) {
            return t22.call(e22, r22);
          }, t22 = function() {
            var t32, e22;
            return t32 = document.documentElement, null != (e22 = t32.closest) ? e22 : function(t4) {
              var e32;
              for (e32 = this; e32; ) {
                if (e32.nodeType === Node.ELEMENT_NODE && r2.call(e32, t4))
                  return e32;
                e32 = e32.parentNode;
              }
            };
          }(), e3.defer = function(t32) {
            return setTimeout(t32, 1);
          }, e3.throttle = function(t32) {
            var e22;
            return e22 = null, function() {
              var r22;
              return r22 = 1 <= arguments.length ? o2.call(arguments, 0) : [], null != e22 ? e22 : e22 = requestAnimationFrame(function(n22) {
                return function() {
                  return e22 = null, t32.apply(n22, r22);
                };
              }(this));
            };
          }, e3.dispatch = function(t32, e22) {
            var r22, o22, i3, s4, a4, u3;
            return a4 = null != e22 ? e22 : {}, u3 = a4.target, r22 = a4.cancelable, o22 = a4.data, i3 = document.createEvent("Events"), i3.initEvent(t32, true, r22 === true), i3.data = null != o22 ? o22 : {}, i3.cancelable && !n2 && (s4 = i3.preventDefault, i3.preventDefault = function() {
              return this.defaultPrevented || Object.defineProperty(this, "defaultPrevented", { get: function() {
                return true;
              } }), s4.call(this);
            }), (null != u3 ? u3 : document).dispatchEvent(i3), i3;
          }, n2 = function() {
            var t32;
            return t32 = document.createEvent("Events"), t32.initEvent("test", true, true), t32.preventDefault(), t32.defaultPrevented;
          }(), e3.match = function(t32, e22) {
            return r2.call(t32, e22);
          }, r2 = function() {
            var t32, e22, r22, n22;
            return t32 = document.documentElement, null != (e22 = null != (r22 = null != (n22 = t32.matchesSelector) ? n22 : t32.webkitMatchesSelector) ? r22 : t32.msMatchesSelector) ? e22 : t32.mozMatchesSelector;
          }(), e3.uuid = function() {
            var t32, e22, r22;
            for (r22 = "", t32 = e22 = 1; 36 >= e22; t32 = ++e22)
              r22 += 9 === t32 || 14 === t32 || 19 === t32 || 24 === t32 ? "-" : 15 === t32 ? "4" : 20 === t32 ? (Math.floor(4 * Math.random()) + 8).toString(16) : Math.floor(15 * Math.random()).toString(16);
            return r22;
          };
        }).call(this), function() {
          e3.Location = function() {
            function t22(t32) {
              var e32, r22;
              null == t32 && (t32 = ""), r22 = document.createElement("a"), r22.href = t32.toString(), this.absoluteURL = r22.href, e32 = r22.hash.length, 2 > e32 ? this.requestURL = this.absoluteURL : (this.requestURL = this.absoluteURL.slice(0, -e32), this.anchor = r22.hash.slice(1));
            }
            var e22, r2, n2, o2;
            return t22.wrap = function(t32) {
              return t32 instanceof this ? t32 : new this(t32);
            }, t22.prototype.getOrigin = function() {
              return this.absoluteURL.split("/", 3).join("/");
            }, t22.prototype.getPath = function() {
              var t32, e32;
              return null != (t32 = null != (e32 = this.requestURL.match(/\/\/[^\/]*(\/[^?;]*)/)) ? e32[1] : void 0) ? t32 : "/";
            }, t22.prototype.getPathComponents = function() {
              return this.getPath().split("/").slice(1);
            }, t22.prototype.getLastPathComponent = function() {
              return this.getPathComponents().slice(-1)[0];
            }, t22.prototype.getExtension = function() {
              var t32, e32;
              return null != (t32 = null != (e32 = this.getLastPathComponent().match(/\.[^.]*$/)) ? e32[0] : void 0) ? t32 : "";
            }, t22.prototype.isHTML = function() {
              return this.getExtension().match(/^(?:|\.(?:htm|html|xhtml))$/);
            }, t22.prototype.isPrefixedBy = function(t32) {
              var e32;
              return e32 = r2(t32), this.isEqualTo(t32) || o2(this.absoluteURL, e32);
            }, t22.prototype.isEqualTo = function(t32) {
              return this.absoluteURL === (null != t32 ? t32.absoluteURL : void 0);
            }, t22.prototype.toCacheKey = function() {
              return this.requestURL;
            }, t22.prototype.toJSON = function() {
              return this.absoluteURL;
            }, t22.prototype.toString = function() {
              return this.absoluteURL;
            }, t22.prototype.valueOf = function() {
              return this.absoluteURL;
            }, r2 = function(t32) {
              return e22(t32.getOrigin() + t32.getPath());
            }, e22 = function(t32) {
              return n2(t32, "/") ? t32 : t32 + "/";
            }, o2 = function(t32, e32) {
              return t32.slice(0, e32.length) === e32;
            }, n2 = function(t32, e32) {
              return t32.slice(-e32.length) === e32;
            }, t22;
          }();
        }.call(this), function() {
          var t22 = function(t32, e22) {
            return function() {
              return t32.apply(e22, arguments);
            };
          };
          e3.HttpRequest = function() {
            function r2(r22, n2, o2) {
              this.delegate = r22, this.requestCanceled = t22(this.requestCanceled, this), this.requestTimedOut = t22(this.requestTimedOut, this), this.requestFailed = t22(this.requestFailed, this), this.requestLoaded = t22(this.requestLoaded, this), this.requestProgressed = t22(this.requestProgressed, this), this.url = e3.Location.wrap(n2).requestURL, this.referrer = e3.Location.wrap(o2).absoluteURL, this.createXHR();
            }
            return r2.NETWORK_FAILURE = 0, r2.TIMEOUT_FAILURE = -1, r2.timeout = 60, r2.prototype.send = function() {
              var t32;
              return this.xhr && !this.sent ? (this.notifyApplicationBeforeRequestStart(), this.setProgress(0), this.xhr.send(), this.sent = true, "function" == typeof (t32 = this.delegate).requestStarted ? t32.requestStarted() : void 0) : void 0;
            }, r2.prototype.cancel = function() {
              return this.xhr && this.sent ? this.xhr.abort() : void 0;
            }, r2.prototype.requestProgressed = function(t32) {
              return t32.lengthComputable ? this.setProgress(t32.loaded / t32.total) : void 0;
            }, r2.prototype.requestLoaded = function() {
              return this.endRequest(function(t32) {
                return function() {
                  var e22;
                  return 200 <= (e22 = t32.xhr.status) && 300 > e22 ? t32.delegate.requestCompletedWithResponse(t32.xhr.responseText, t32.xhr.getResponseHeader("Turbolinks-Location")) : (t32.failed = true, t32.delegate.requestFailedWithStatusCode(t32.xhr.status, t32.xhr.responseText));
                };
              }(this));
            }, r2.prototype.requestFailed = function() {
              return this.endRequest(function(t32) {
                return function() {
                  return t32.failed = true, t32.delegate.requestFailedWithStatusCode(t32.constructor.NETWORK_FAILURE);
                };
              }(this));
            }, r2.prototype.requestTimedOut = function() {
              return this.endRequest(function(t32) {
                return function() {
                  return t32.failed = true, t32.delegate.requestFailedWithStatusCode(t32.constructor.TIMEOUT_FAILURE);
                };
              }(this));
            }, r2.prototype.requestCanceled = function() {
              return this.endRequest();
            }, r2.prototype.notifyApplicationBeforeRequestStart = function() {
              return e3.dispatch("turbolinks:request-start", { data: { url: this.url, xhr: this.xhr } });
            }, r2.prototype.notifyApplicationAfterRequestEnd = function() {
              return e3.dispatch("turbolinks:request-end", { data: { url: this.url, xhr: this.xhr } });
            }, r2.prototype.createXHR = function() {
              return this.xhr = new XMLHttpRequest(), this.xhr.open("GET", this.url, true), this.xhr.timeout = 1e3 * this.constructor.timeout, this.xhr.setRequestHeader("Accept", "text/html, application/xhtml+xml"), this.xhr.setRequestHeader("Turbolinks-Referrer", this.referrer), this.xhr.onprogress = this.requestProgressed, this.xhr.onload = this.requestLoaded, this.xhr.onerror = this.requestFailed, this.xhr.ontimeout = this.requestTimedOut, this.xhr.onabort = this.requestCanceled;
            }, r2.prototype.endRequest = function(t32) {
              return this.xhr ? (this.notifyApplicationAfterRequestEnd(), null != t32 && t32.call(this), this.destroy()) : void 0;
            }, r2.prototype.setProgress = function(t32) {
              var e22;
              return this.progress = t32, "function" == typeof (e22 = this.delegate).requestProgressed ? e22.requestProgressed(this.progress) : void 0;
            }, r2.prototype.destroy = function() {
              var t32;
              return this.setProgress(1), "function" == typeof (t32 = this.delegate).requestFinished && t32.requestFinished(), this.delegate = null, this.xhr = null;
            }, r2;
          }();
        }.call(this), function() {
          var t22 = function(t32, e22) {
            return function() {
              return t32.apply(e22, arguments);
            };
          };
          e3.ProgressBar = function() {
            function e22() {
              this.trickle = t22(this.trickle, this), this.stylesheetElement = this.createStylesheetElement(), this.progressElement = this.createProgressElement();
            }
            var r2;
            return r2 = 300, e22.defaultCSS = ".turbolinks-progress-bar {\n  position: fixed;\n  display: block;\n  top: 0;\n  left: 0;\n  height: 3px;\n  background: #0076ff;\n  z-index: 9999;\n  transition: width " + r2 + "ms ease-out, opacity " + r2 / 2 + "ms " + r2 / 2 + "ms ease-in;\n  transform: translate3d(0, 0, 0);\n}", e22.prototype.show = function() {
              return this.visible ? void 0 : (this.visible = true, this.installStylesheetElement(), this.installProgressElement(), this.startTrickling());
            }, e22.prototype.hide = function() {
              return this.visible && !this.hiding ? (this.hiding = true, this.fadeProgressElement(function(t32) {
                return function() {
                  return t32.uninstallProgressElement(), t32.stopTrickling(), t32.visible = false, t32.hiding = false;
                };
              }(this))) : void 0;
            }, e22.prototype.setValue = function(t32) {
              return this.value = t32, this.refresh();
            }, e22.prototype.installStylesheetElement = function() {
              return document.head.insertBefore(this.stylesheetElement, document.head.firstChild);
            }, e22.prototype.installProgressElement = function() {
              return this.progressElement.style.width = 0, this.progressElement.style.opacity = 1, document.documentElement.insertBefore(this.progressElement, document.body), this.refresh();
            }, e22.prototype.fadeProgressElement = function(t32) {
              return this.progressElement.style.opacity = 0, setTimeout(t32, 1.5 * r2);
            }, e22.prototype.uninstallProgressElement = function() {
              return this.progressElement.parentNode ? document.documentElement.removeChild(this.progressElement) : void 0;
            }, e22.prototype.startTrickling = function() {
              return null != this.trickleInterval ? this.trickleInterval : this.trickleInterval = setInterval(this.trickle, r2);
            }, e22.prototype.stopTrickling = function() {
              return clearInterval(this.trickleInterval), this.trickleInterval = null;
            }, e22.prototype.trickle = function() {
              return this.setValue(this.value + Math.random() / 100);
            }, e22.prototype.refresh = function() {
              return requestAnimationFrame(function(t32) {
                return function() {
                  return t32.progressElement.style.width = 10 + 90 * t32.value + "%";
                };
              }(this));
            }, e22.prototype.createStylesheetElement = function() {
              var t32;
              return t32 = document.createElement("style"), t32.type = "text/css", t32.textContent = this.constructor.defaultCSS, t32;
            }, e22.prototype.createProgressElement = function() {
              var t32;
              return t32 = document.createElement("div"), t32.className = "turbolinks-progress-bar", t32;
            }, e22;
          }();
        }.call(this), function() {
          var t22 = function(t32, e22) {
            return function() {
              return t32.apply(e22, arguments);
            };
          };
          e3.BrowserAdapter = function() {
            function r2(r22) {
              this.controller = r22, this.showProgressBar = t22(this.showProgressBar, this), this.progressBar = new e3.ProgressBar();
            }
            var n2, o2, i3;
            return i3 = e3.HttpRequest, n2 = i3.NETWORK_FAILURE, o2 = i3.TIMEOUT_FAILURE, r2.prototype.visitProposedToLocationWithAction = function(t32, e22) {
              return this.controller.startVisitToLocationWithAction(t32, e22);
            }, r2.prototype.visitStarted = function(t32) {
              return t32.issueRequest(), t32.changeHistory(), t32.loadCachedSnapshot();
            }, r2.prototype.visitRequestStarted = function(t32) {
              return this.progressBar.setValue(0), t32.hasCachedSnapshot() || "restore" !== t32.action ? this.showProgressBarAfterDelay() : this.showProgressBar();
            }, r2.prototype.visitRequestProgressed = function(t32) {
              return this.progressBar.setValue(t32.progress);
            }, r2.prototype.visitRequestCompleted = function(t32) {
              return t32.loadResponse();
            }, r2.prototype.visitRequestFailedWithStatusCode = function(t32, e22) {
              switch (e22) {
                case n2:
                case o2:
                  return this.reload();
                default:
                  return t32.loadResponse();
              }
            }, r2.prototype.visitRequestFinished = function(t32) {
              return this.hideProgressBar();
            }, r2.prototype.visitCompleted = function(t32) {
              return t32.followRedirect();
            }, r2.prototype.pageInvalidated = function() {
              return this.reload();
            }, r2.prototype.showProgressBarAfterDelay = function() {
              return this.progressBarTimeout = setTimeout(this.showProgressBar, this.controller.progressBarDelay);
            }, r2.prototype.showProgressBar = function() {
              return this.progressBar.show();
            }, r2.prototype.hideProgressBar = function() {
              return this.progressBar.hide(), clearTimeout(this.progressBarTimeout);
            }, r2.prototype.reload = function() {
              return window.location.reload();
            }, r2;
          }();
        }.call(this), function() {
          var t22 = function(t32, e22) {
            return function() {
              return t32.apply(e22, arguments);
            };
          };
          e3.History = function() {
            function r2(e22) {
              this.delegate = e22, this.onPageLoad = t22(this.onPageLoad, this), this.onPopState = t22(this.onPopState, this);
            }
            return r2.prototype.start = function() {
              return this.started ? void 0 : (addEventListener("popstate", this.onPopState, false), addEventListener("load", this.onPageLoad, false), this.started = true);
            }, r2.prototype.stop = function() {
              return this.started ? (removeEventListener("popstate", this.onPopState, false), removeEventListener("load", this.onPageLoad, false), this.started = false) : void 0;
            }, r2.prototype.push = function(t32, r22) {
              return t32 = e3.Location.wrap(t32), this.update("push", t32, r22);
            }, r2.prototype.replace = function(t32, r22) {
              return t32 = e3.Location.wrap(t32), this.update("replace", t32, r22);
            }, r2.prototype.onPopState = function(t32) {
              var r22, n2, o2, i3;
              return this.shouldHandlePopState() && (i3 = null != (n2 = t32.state) ? n2.turbolinks : void 0) ? (r22 = e3.Location.wrap(window.location), o2 = i3.restorationIdentifier, this.delegate.historyPoppedToLocationWithRestorationIdentifier(r22, o2)) : void 0;
            }, r2.prototype.onPageLoad = function(t32) {
              return e3.defer(function(t4) {
                return function() {
                  return t4.pageLoaded = true;
                };
              }(this));
            }, r2.prototype.shouldHandlePopState = function() {
              return this.pageIsLoaded();
            }, r2.prototype.pageIsLoaded = function() {
              return this.pageLoaded || "complete" === document.readyState;
            }, r2.prototype.update = function(t32, e22, r22) {
              var n2;
              return n2 = { turbolinks: { restorationIdentifier: r22 } }, history[t32 + "State"](n2, null, e22);
            }, r2;
          }();
        }.call(this), function() {
          e3.HeadDetails = function() {
            function t22(t32) {
              var e32, r22, n22, s4, a4, u3;
              for (this.elements = {}, n22 = 0, a4 = t32.length; a4 > n22; n22++)
                u3 = t32[n22], u3.nodeType === Node.ELEMENT_NODE && (s4 = u3.outerHTML, r22 = null != (e32 = this.elements)[s4] ? e32[s4] : e32[s4] = { type: i3(u3), tracked: o2(u3), elements: [] }, r22.elements.push(u3));
            }
            var e22, r2, n2, o2, i3;
            return t22.fromHeadElement = function(t32) {
              var e32;
              return new this(null != (e32 = null != t32 ? t32.childNodes : void 0) ? e32 : []);
            }, t22.prototype.hasElementWithKey = function(t32) {
              return t32 in this.elements;
            }, t22.prototype.getTrackedElementSignature = function() {
              var t32, e32;
              return function() {
                var r22, n22;
                r22 = this.elements, n22 = [];
                for (t32 in r22)
                  e32 = r22[t32].tracked, e32 && n22.push(t32);
                return n22;
              }.call(this).join("");
            }, t22.prototype.getScriptElementsNotInDetails = function(t32) {
              return this.getElementsMatchingTypeNotInDetails("script", t32);
            }, t22.prototype.getStylesheetElementsNotInDetails = function(t32) {
              return this.getElementsMatchingTypeNotInDetails("stylesheet", t32);
            }, t22.prototype.getElementsMatchingTypeNotInDetails = function(t32, e32) {
              var r22, n22, o22, i22, s4, a4;
              o22 = this.elements, s4 = [];
              for (n22 in o22)
                i22 = o22[n22], a4 = i22.type, r22 = i22.elements, a4 !== t32 || e32.hasElementWithKey(n22) || s4.push(r22[0]);
              return s4;
            }, t22.prototype.getProvisionalElements = function() {
              var t32, e32, r22, n22, o22, i22, s4;
              r22 = [], n22 = this.elements;
              for (e32 in n22)
                o22 = n22[e32], s4 = o22.type, i22 = o22.tracked, t32 = o22.elements, null != s4 || i22 ? t32.length > 1 && r22.push.apply(r22, t32.slice(1)) : r22.push.apply(r22, t32);
              return r22;
            }, t22.prototype.getMetaValue = function(t32) {
              var e32;
              return null != (e32 = this.findMetaElementByName(t32)) ? e32.getAttribute("content") : void 0;
            }, t22.prototype.findMetaElementByName = function(t32) {
              var r22, n22, o22, i22;
              r22 = void 0, i22 = this.elements;
              for (o22 in i22)
                n22 = i22[o22].elements, e22(n22[0], t32) && (r22 = n22[0]);
              return r22;
            }, i3 = function(t32) {
              return r2(t32) ? "script" : n2(t32) ? "stylesheet" : void 0;
            }, o2 = function(t32) {
              return "reload" === t32.getAttribute("data-turbolinks-track");
            }, r2 = function(t32) {
              var e32;
              return e32 = t32.tagName.toLowerCase(), "script" === e32;
            }, n2 = function(t32) {
              var e32;
              return e32 = t32.tagName.toLowerCase(), "style" === e32 || "link" === e32 && "stylesheet" === t32.getAttribute("rel");
            }, e22 = function(t32, e32) {
              var r22;
              return r22 = t32.tagName.toLowerCase(), "meta" === r22 && t32.getAttribute("name") === e32;
            }, t22;
          }();
        }.call(this), function() {
          e3.Snapshot = function() {
            function t22(t32, e22) {
              this.headDetails = t32, this.bodyElement = e22;
            }
            return t22.wrap = function(t32) {
              return t32 instanceof this ? t32 : "string" == typeof t32 ? this.fromHTMLString(t32) : this.fromHTMLElement(t32);
            }, t22.fromHTMLString = function(t32) {
              var e22;
              return e22 = document.createElement("html"), e22.innerHTML = t32, this.fromHTMLElement(e22);
            }, t22.fromHTMLElement = function(t32) {
              var r2, n2, o2, i3;
              return o2 = t32.querySelector("head"), r2 = null != (i3 = t32.querySelector("body")) ? i3 : document.createElement("body"), n2 = e3.HeadDetails.fromHeadElement(o2), new this(n2, r2);
            }, t22.prototype.clone = function() {
              return new this.constructor(this.headDetails, this.bodyElement.cloneNode(true));
            }, t22.prototype.getRootLocation = function() {
              var t32, r2;
              return r2 = null != (t32 = this.getSetting("root")) ? t32 : "/", new e3.Location(r2);
            }, t22.prototype.getCacheControlValue = function() {
              return this.getSetting("cache-control");
            }, t22.prototype.getElementForAnchor = function(t32) {
              try {
                return this.bodyElement.querySelector("[id='" + t32 + "'], a[name='" + t32 + "']");
              } catch (e22) {
              }
            }, t22.prototype.getPermanentElements = function() {
              return this.bodyElement.querySelectorAll("[id][data-turbolinks-permanent]");
            }, t22.prototype.getPermanentElementById = function(t32) {
              return this.bodyElement.querySelector("#" + t32 + "[data-turbolinks-permanent]");
            }, t22.prototype.getPermanentElementsPresentInSnapshot = function(t32) {
              var e22, r2, n2, o2, i3;
              for (o2 = this.getPermanentElements(), i3 = [], r2 = 0, n2 = o2.length; n2 > r2; r2++)
                e22 = o2[r2], t32.getPermanentElementById(e22.id) && i3.push(e22);
              return i3;
            }, t22.prototype.findFirstAutofocusableElement = function() {
              return this.bodyElement.querySelector("[autofocus]");
            }, t22.prototype.hasAnchor = function(t32) {
              return null != this.getElementForAnchor(t32);
            }, t22.prototype.isPreviewable = function() {
              return "no-preview" !== this.getCacheControlValue();
            }, t22.prototype.isCacheable = function() {
              return "no-cache" !== this.getCacheControlValue();
            }, t22.prototype.isVisitable = function() {
              return "reload" !== this.getSetting("visit-control");
            }, t22.prototype.getSetting = function(t32) {
              return this.headDetails.getMetaValue("turbolinks-" + t32);
            }, t22;
          }();
        }.call(this), function() {
          var t22 = [].slice;
          e3.Renderer = function() {
            function e22() {
            }
            var r2;
            return e22.render = function() {
              var e32, r22, n2, o2;
              return n2 = arguments[0], r22 = arguments[1], e32 = 3 <= arguments.length ? t22.call(arguments, 2) : [], o2 = function(t32, e4, r3) {
                r3.prototype = t32.prototype;
                var n22 = new r3(), o22 = t32.apply(n22, e4);
                return Object(o22) === o22 ? o22 : n22;
              }(this, e32, function() {
              }), o2.delegate = n2, o2.render(r22), o2;
            }, e22.prototype.renderView = function(t32) {
              return this.delegate.viewWillRender(this.newBody), t32(), this.delegate.viewRendered(this.newBody);
            }, e22.prototype.invalidateView = function() {
              return this.delegate.viewInvalidated();
            }, e22.prototype.createScriptElement = function(t32) {
              var e32;
              return "false" === t32.getAttribute("data-turbolinks-eval") ? t32 : (e32 = document.createElement("script"), e32.textContent = t32.textContent, e32.async = false, r2(e32, t32), e32);
            }, r2 = function(t32, e32) {
              var r22, n2, o2, i3, s4, a4, u3;
              for (i3 = e32.attributes, a4 = [], r22 = 0, n2 = i3.length; n2 > r22; r22++)
                s4 = i3[r22], o2 = s4.name, u3 = s4.value, a4.push(t32.setAttribute(o2, u3));
              return a4;
            }, e22;
          }();
        }.call(this), function() {
          var t22, r2, n2 = function(t32, e22) {
            function r22() {
              this.constructor = t32;
            }
            for (var n22 in e22)
              o2.call(e22, n22) && (t32[n22] = e22[n22]);
            return r22.prototype = e22.prototype, t32.prototype = new r22(), t32.__super__ = e22.prototype, t32;
          }, o2 = {}.hasOwnProperty;
          e3.SnapshotRenderer = function(e22) {
            function o22(t32, e32, r22) {
              this.currentSnapshot = t32, this.newSnapshot = e32, this.isPreview = r22, this.currentHeadDetails = this.currentSnapshot.headDetails, this.newHeadDetails = this.newSnapshot.headDetails, this.currentBody = this.currentSnapshot.bodyElement, this.newBody = this.newSnapshot.bodyElement;
            }
            return n2(o22, e22), o22.prototype.render = function(t32) {
              return this.shouldRender() ? (this.mergeHead(), this.renderView(function(e32) {
                return function() {
                  return e32.replaceBody(), e32.isPreview || e32.focusFirstAutofocusableElement(), t32();
                };
              }(this))) : this.invalidateView();
            }, o22.prototype.mergeHead = function() {
              return this.copyNewHeadStylesheetElements(), this.copyNewHeadScriptElements(), this.removeCurrentHeadProvisionalElements(), this.copyNewHeadProvisionalElements();
            }, o22.prototype.replaceBody = function() {
              var t32;
              return t32 = this.relocateCurrentBodyPermanentElements(), this.activateNewBodyScriptElements(), this.assignNewBody(), this.replacePlaceholderElementsWithClonedPermanentElements(t32);
            }, o22.prototype.shouldRender = function() {
              return this.newSnapshot.isVisitable() && this.trackedElementsAreIdentical();
            }, o22.prototype.trackedElementsAreIdentical = function() {
              return this.currentHeadDetails.getTrackedElementSignature() === this.newHeadDetails.getTrackedElementSignature();
            }, o22.prototype.copyNewHeadStylesheetElements = function() {
              var t32, e32, r22, n22, o3;
              for (n22 = this.getNewHeadStylesheetElements(), o3 = [], e32 = 0, r22 = n22.length; r22 > e32; e32++)
                t32 = n22[e32], o3.push(document.head.appendChild(t32));
              return o3;
            }, o22.prototype.copyNewHeadScriptElements = function() {
              var t32, e32, r22, n22, o3;
              for (n22 = this.getNewHeadScriptElements(), o3 = [], e32 = 0, r22 = n22.length; r22 > e32; e32++)
                t32 = n22[e32], o3.push(document.head.appendChild(this.createScriptElement(t32)));
              return o3;
            }, o22.prototype.removeCurrentHeadProvisionalElements = function() {
              var t32, e32, r22, n22, o3;
              for (n22 = this.getCurrentHeadProvisionalElements(), o3 = [], e32 = 0, r22 = n22.length; r22 > e32; e32++)
                t32 = n22[e32], o3.push(document.head.removeChild(t32));
              return o3;
            }, o22.prototype.copyNewHeadProvisionalElements = function() {
              var t32, e32, r22, n22, o3;
              for (n22 = this.getNewHeadProvisionalElements(), o3 = [], e32 = 0, r22 = n22.length; r22 > e32; e32++)
                t32 = n22[e32], o3.push(document.head.appendChild(t32));
              return o3;
            }, o22.prototype.relocateCurrentBodyPermanentElements = function() {
              var e32, n22, o3, i3, s4, a4, u3;
              for (a4 = this.getCurrentBodyPermanentElements(), u3 = [], e32 = 0, n22 = a4.length; n22 > e32; e32++)
                i3 = a4[e32], s4 = t22(i3), o3 = this.newSnapshot.getPermanentElementById(i3.id), r2(i3, s4.element), r2(o3, i3), u3.push(s4);
              return u3;
            }, o22.prototype.replacePlaceholderElementsWithClonedPermanentElements = function(t32) {
              var e32, n22, o3, i3, s4, a4, u3;
              for (u3 = [], o3 = 0, i3 = t32.length; i3 > o3; o3++)
                a4 = t32[o3], n22 = a4.element, s4 = a4.permanentElement, e32 = s4.cloneNode(true), u3.push(r2(n22, e32));
              return u3;
            }, o22.prototype.activateNewBodyScriptElements = function() {
              var t32, e32, n22, o3, i3, s4;
              for (i3 = this.getNewBodyScriptElements(), s4 = [], e32 = 0, o3 = i3.length; o3 > e32; e32++)
                n22 = i3[e32], t32 = this.createScriptElement(n22), s4.push(r2(n22, t32));
              return s4;
            }, o22.prototype.assignNewBody = function() {
              return document.body = this.newBody;
            }, o22.prototype.focusFirstAutofocusableElement = function() {
              var t32;
              return null != (t32 = this.newSnapshot.findFirstAutofocusableElement()) ? t32.focus() : void 0;
            }, o22.prototype.getNewHeadStylesheetElements = function() {
              return this.newHeadDetails.getStylesheetElementsNotInDetails(this.currentHeadDetails);
            }, o22.prototype.getNewHeadScriptElements = function() {
              return this.newHeadDetails.getScriptElementsNotInDetails(this.currentHeadDetails);
            }, o22.prototype.getCurrentHeadProvisionalElements = function() {
              return this.currentHeadDetails.getProvisionalElements();
            }, o22.prototype.getNewHeadProvisionalElements = function() {
              return this.newHeadDetails.getProvisionalElements();
            }, o22.prototype.getCurrentBodyPermanentElements = function() {
              return this.currentSnapshot.getPermanentElementsPresentInSnapshot(this.newSnapshot);
            }, o22.prototype.getNewBodyScriptElements = function() {
              return this.newBody.querySelectorAll("script");
            }, o22;
          }(e3.Renderer), t22 = function(t32) {
            var e22;
            return e22 = document.createElement("meta"), e22.setAttribute("name", "turbolinks-permanent-placeholder"), e22.setAttribute("content", t32.id), { element: e22, permanentElement: t32 };
          }, r2 = function(t32, e22) {
            var r22;
            return (r22 = t32.parentNode) ? r22.replaceChild(e22, t32) : void 0;
          };
        }.call(this), function() {
          var t22 = function(t32, e22) {
            function n2() {
              this.constructor = t32;
            }
            for (var o2 in e22)
              r2.call(e22, o2) && (t32[o2] = e22[o2]);
            return n2.prototype = e22.prototype, t32.prototype = new n2(), t32.__super__ = e22.prototype, t32;
          }, r2 = {}.hasOwnProperty;
          e3.ErrorRenderer = function(e22) {
            function r22(t32) {
              var e32;
              e32 = document.createElement("html"), e32.innerHTML = t32, this.newHead = e32.querySelector("head"), this.newBody = e32.querySelector("body");
            }
            return t22(r22, e22), r22.prototype.render = function(t32) {
              return this.renderView(function(e32) {
                return function() {
                  return e32.replaceHeadAndBody(), e32.activateBodyScriptElements(), t32();
                };
              }(this));
            }, r22.prototype.replaceHeadAndBody = function() {
              var t32, e32;
              return e32 = document.head, t32 = document.body, e32.parentNode.replaceChild(this.newHead, e32), t32.parentNode.replaceChild(this.newBody, t32);
            }, r22.prototype.activateBodyScriptElements = function() {
              var t32, e32, r3, n2, o2, i3;
              for (n2 = this.getScriptElements(), i3 = [], e32 = 0, r3 = n2.length; r3 > e32; e32++)
                o2 = n2[e32], t32 = this.createScriptElement(o2), i3.push(o2.parentNode.replaceChild(t32, o2));
              return i3;
            }, r22.prototype.getScriptElements = function() {
              return document.documentElement.querySelectorAll("script");
            }, r22;
          }(e3.Renderer);
        }.call(this), function() {
          e3.View = function() {
            function t22(t32) {
              this.delegate = t32, this.htmlElement = document.documentElement;
            }
            return t22.prototype.getRootLocation = function() {
              return this.getSnapshot().getRootLocation();
            }, t22.prototype.getElementForAnchor = function(t32) {
              return this.getSnapshot().getElementForAnchor(t32);
            }, t22.prototype.getSnapshot = function() {
              return e3.Snapshot.fromHTMLElement(this.htmlElement);
            }, t22.prototype.render = function(t32, e22) {
              var r2, n2, o2;
              return o2 = t32.snapshot, r2 = t32.error, n2 = t32.isPreview, this.markAsPreview(n2), null != o2 ? this.renderSnapshot(o2, n2, e22) : this.renderError(r2, e22);
            }, t22.prototype.markAsPreview = function(t32) {
              return t32 ? this.htmlElement.setAttribute("data-turbolinks-preview", "") : this.htmlElement.removeAttribute("data-turbolinks-preview");
            }, t22.prototype.renderSnapshot = function(t32, r2, n2) {
              return e3.SnapshotRenderer.render(this.delegate, n2, this.getSnapshot(), e3.Snapshot.wrap(t32), r2);
            }, t22.prototype.renderError = function(t32, r2) {
              return e3.ErrorRenderer.render(this.delegate, r2, t32);
            }, t22;
          }();
        }.call(this), function() {
          var t22 = function(t32, e22) {
            return function() {
              return t32.apply(e22, arguments);
            };
          };
          e3.ScrollManager = function() {
            function r2(r22) {
              this.delegate = r22, this.onScroll = t22(this.onScroll, this), this.onScroll = e3.throttle(this.onScroll);
            }
            return r2.prototype.start = function() {
              return this.started ? void 0 : (addEventListener("scroll", this.onScroll, false), this.onScroll(), this.started = true);
            }, r2.prototype.stop = function() {
              return this.started ? (removeEventListener("scroll", this.onScroll, false), this.started = false) : void 0;
            }, r2.prototype.scrollToElement = function(t32) {
              return t32.scrollIntoView();
            }, r2.prototype.scrollToPosition = function(t32) {
              var e22, r22;
              return e22 = t32.x, r22 = t32.y, window.scrollTo(e22, r22);
            }, r2.prototype.onScroll = function(t32) {
              return this.updatePosition({ x: window.pageXOffset, y: window.pageYOffset });
            }, r2.prototype.updatePosition = function(t32) {
              var e22;
              return this.position = t32, null != (e22 = this.delegate) ? e22.scrollPositionChanged(this.position) : void 0;
            }, r2;
          }();
        }.call(this), function() {
          e3.SnapshotCache = function() {
            function t22(t32) {
              this.size = t32, this.keys = [], this.snapshots = {};
            }
            var r2;
            return t22.prototype.has = function(t32) {
              var e22;
              return e22 = r2(t32), e22 in this.snapshots;
            }, t22.prototype.get = function(t32) {
              var e22;
              if (this.has(t32))
                return e22 = this.read(t32), this.touch(t32), e22;
            }, t22.prototype.put = function(t32, e22) {
              return this.write(t32, e22), this.touch(t32), e22;
            }, t22.prototype.read = function(t32) {
              var e22;
              return e22 = r2(t32), this.snapshots[e22];
            }, t22.prototype.write = function(t32, e22) {
              var n2;
              return n2 = r2(t32), this.snapshots[n2] = e22;
            }, t22.prototype.touch = function(t32) {
              var e22, n2;
              return n2 = r2(t32), e22 = this.keys.indexOf(n2), e22 > -1 && this.keys.splice(e22, 1), this.keys.unshift(n2), this.trim();
            }, t22.prototype.trim = function() {
              var t32, e22, r22, n2, o2;
              for (n2 = this.keys.splice(this.size), o2 = [], t32 = 0, r22 = n2.length; r22 > t32; t32++)
                e22 = n2[t32], o2.push(delete this.snapshots[e22]);
              return o2;
            }, r2 = function(t32) {
              return e3.Location.wrap(t32).toCacheKey();
            }, t22;
          }();
        }.call(this), function() {
          var t22 = function(t32, e22) {
            return function() {
              return t32.apply(e22, arguments);
            };
          };
          e3.Visit = function() {
            function r2(r22, n22, o2) {
              this.controller = r22, this.action = o2, this.performScroll = t22(this.performScroll, this), this.identifier = e3.uuid(), this.location = e3.Location.wrap(n22), this.adapter = this.controller.adapter, this.state = "initialized", this.timingMetrics = {};
            }
            var n2;
            return r2.prototype.start = function() {
              return "initialized" === this.state ? (this.recordTimingMetric("visitStart"), this.state = "started", this.adapter.visitStarted(this)) : void 0;
            }, r2.prototype.cancel = function() {
              var t32;
              return "started" === this.state ? (null != (t32 = this.request) && t32.cancel(), this.cancelRender(), this.state = "canceled") : void 0;
            }, r2.prototype.complete = function() {
              var t32;
              return "started" === this.state ? (this.recordTimingMetric("visitEnd"), this.state = "completed", "function" == typeof (t32 = this.adapter).visitCompleted && t32.visitCompleted(this), this.controller.visitCompleted(this)) : void 0;
            }, r2.prototype.fail = function() {
              var t32;
              return "started" === this.state ? (this.state = "failed", "function" == typeof (t32 = this.adapter).visitFailed ? t32.visitFailed(this) : void 0) : void 0;
            }, r2.prototype.changeHistory = function() {
              var t32, e22;
              return this.historyChanged ? void 0 : (t32 = this.location.isEqualTo(this.referrer) ? "replace" : this.action, e22 = n2(t32), this.controller[e22](this.location, this.restorationIdentifier), this.historyChanged = true);
            }, r2.prototype.issueRequest = function() {
              return this.shouldIssueRequest() && null == this.request ? (this.progress = 0, this.request = new e3.HttpRequest(this, this.location, this.referrer), this.request.send()) : void 0;
            }, r2.prototype.getCachedSnapshot = function() {
              var t32;
              return !(t32 = this.controller.getCachedSnapshotForLocation(this.location)) || null != this.location.anchor && !t32.hasAnchor(this.location.anchor) || "restore" !== this.action && !t32.isPreviewable() ? void 0 : t32;
            }, r2.prototype.hasCachedSnapshot = function() {
              return null != this.getCachedSnapshot();
            }, r2.prototype.loadCachedSnapshot = function() {
              var t32, e22;
              return (e22 = this.getCachedSnapshot()) ? (t32 = this.shouldIssueRequest(), this.render(function() {
                var r22;
                return this.cacheSnapshot(), this.controller.render({ snapshot: e22, isPreview: t32 }, this.performScroll), "function" == typeof (r22 = this.adapter).visitRendered && r22.visitRendered(this), t32 ? void 0 : this.complete();
              })) : void 0;
            }, r2.prototype.loadResponse = function() {
              return null != this.response ? this.render(function() {
                var t32, e22;
                return this.cacheSnapshot(), this.request.failed ? (this.controller.render({ error: this.response }, this.performScroll), "function" == typeof (t32 = this.adapter).visitRendered && t32.visitRendered(this), this.fail()) : (this.controller.render({ snapshot: this.response }, this.performScroll), "function" == typeof (e22 = this.adapter).visitRendered && e22.visitRendered(this), this.complete());
              }) : void 0;
            }, r2.prototype.followRedirect = function() {
              return this.redirectedToLocation && !this.followedRedirect ? (this.location = this.redirectedToLocation, this.controller.replaceHistoryWithLocationAndRestorationIdentifier(this.redirectedToLocation, this.restorationIdentifier), this.followedRedirect = true) : void 0;
            }, r2.prototype.requestStarted = function() {
              var t32;
              return this.recordTimingMetric("requestStart"), "function" == typeof (t32 = this.adapter).visitRequestStarted ? t32.visitRequestStarted(this) : void 0;
            }, r2.prototype.requestProgressed = function(t32) {
              var e22;
              return this.progress = t32, "function" == typeof (e22 = this.adapter).visitRequestProgressed ? e22.visitRequestProgressed(this) : void 0;
            }, r2.prototype.requestCompletedWithResponse = function(t32, r22) {
              return this.response = t32, null != r22 && (this.redirectedToLocation = e3.Location.wrap(r22)), this.adapter.visitRequestCompleted(this);
            }, r2.prototype.requestFailedWithStatusCode = function(t32, e22) {
              return this.response = e22, this.adapter.visitRequestFailedWithStatusCode(this, t32);
            }, r2.prototype.requestFinished = function() {
              var t32;
              return this.recordTimingMetric("requestEnd"), "function" == typeof (t32 = this.adapter).visitRequestFinished ? t32.visitRequestFinished(this) : void 0;
            }, r2.prototype.performScroll = function() {
              return this.scrolled ? void 0 : ("restore" === this.action ? this.scrollToRestoredPosition() || this.scrollToTop() : this.scrollToAnchor() || this.scrollToTop(), this.scrolled = true);
            }, r2.prototype.scrollToRestoredPosition = function() {
              var t32, e22;
              return t32 = null != (e22 = this.restorationData) ? e22.scrollPosition : void 0, null != t32 ? (this.controller.scrollToPosition(t32), true) : void 0;
            }, r2.prototype.scrollToAnchor = function() {
              return null != this.location.anchor ? (this.controller.scrollToAnchor(this.location.anchor), true) : void 0;
            }, r2.prototype.scrollToTop = function() {
              return this.controller.scrollToPosition({ x: 0, y: 0 });
            }, r2.prototype.recordTimingMetric = function(t32) {
              var e22;
              return null != (e22 = this.timingMetrics)[t32] ? e22[t32] : e22[t32] = new Date().getTime();
            }, r2.prototype.getTimingMetrics = function() {
              return e3.copyObject(this.timingMetrics);
            }, n2 = function(t32) {
              switch (t32) {
                case "replace":
                  return "replaceHistoryWithLocationAndRestorationIdentifier";
                case "advance":
                case "restore":
                  return "pushHistoryWithLocationAndRestorationIdentifier";
              }
            }, r2.prototype.shouldIssueRequest = function() {
              return "restore" === this.action ? !this.hasCachedSnapshot() : true;
            }, r2.prototype.cacheSnapshot = function() {
              return this.snapshotCached ? void 0 : (this.controller.cacheSnapshot(), this.snapshotCached = true);
            }, r2.prototype.render = function(t32) {
              return this.cancelRender(), this.frame = requestAnimationFrame(function(e22) {
                return function() {
                  return e22.frame = null, t32.call(e22);
                };
              }(this));
            }, r2.prototype.cancelRender = function() {
              return this.frame ? cancelAnimationFrame(this.frame) : void 0;
            }, r2;
          }();
        }.call(this), function() {
          var t22 = function(t32, e22) {
            return function() {
              return t32.apply(e22, arguments);
            };
          };
          e3.Controller = function() {
            function r2() {
              this.clickBubbled = t22(this.clickBubbled, this), this.clickCaptured = t22(this.clickCaptured, this), this.pageLoaded = t22(this.pageLoaded, this), this.history = new e3.History(this), this.view = new e3.View(this), this.scrollManager = new e3.ScrollManager(this), this.restorationData = {}, this.clearCache(), this.setProgressBarDelay(500);
            }
            return r2.prototype.start = function() {
              return e3.supported && !this.started ? (addEventListener("click", this.clickCaptured, true), addEventListener("DOMContentLoaded", this.pageLoaded, false), this.scrollManager.start(), this.startHistory(), this.started = true, this.enabled = true) : void 0;
            }, r2.prototype.disable = function() {
              return this.enabled = false;
            }, r2.prototype.stop = function() {
              return this.started ? (removeEventListener("click", this.clickCaptured, true), removeEventListener("DOMContentLoaded", this.pageLoaded, false), this.scrollManager.stop(), this.stopHistory(), this.started = false) : void 0;
            }, r2.prototype.clearCache = function() {
              return this.cache = new e3.SnapshotCache(10);
            }, r2.prototype.visit = function(t32, r22) {
              var n2, o2;
              return null == r22 && (r22 = {}), t32 = e3.Location.wrap(t32), this.applicationAllowsVisitingLocation(t32) ? this.locationIsVisitable(t32) ? (n2 = null != (o2 = r22.action) ? o2 : "advance", this.adapter.visitProposedToLocationWithAction(t32, n2)) : window.location = t32 : void 0;
            }, r2.prototype.startVisitToLocationWithAction = function(t32, r22, n2) {
              var o2;
              return e3.supported ? (o2 = this.getRestorationDataForIdentifier(n2), this.startVisit(t32, r22, { restorationData: o2 })) : window.location = t32;
            }, r2.prototype.setProgressBarDelay = function(t32) {
              return this.progressBarDelay = t32;
            }, r2.prototype.startHistory = function() {
              return this.location = e3.Location.wrap(window.location), this.restorationIdentifier = e3.uuid(), this.history.start(), this.history.replace(this.location, this.restorationIdentifier);
            }, r2.prototype.stopHistory = function() {
              return this.history.stop();
            }, r2.prototype.pushHistoryWithLocationAndRestorationIdentifier = function(t32, r22) {
              return this.restorationIdentifier = r22, this.location = e3.Location.wrap(t32), this.history.push(this.location, this.restorationIdentifier);
            }, r2.prototype.replaceHistoryWithLocationAndRestorationIdentifier = function(t32, r22) {
              return this.restorationIdentifier = r22, this.location = e3.Location.wrap(t32), this.history.replace(this.location, this.restorationIdentifier);
            }, r2.prototype.historyPoppedToLocationWithRestorationIdentifier = function(t32, r22) {
              var n2;
              return this.restorationIdentifier = r22, this.enabled ? (n2 = this.getRestorationDataForIdentifier(this.restorationIdentifier), this.startVisit(t32, "restore", { restorationIdentifier: this.restorationIdentifier, restorationData: n2, historyChanged: true }), this.location = e3.Location.wrap(t32)) : this.adapter.pageInvalidated();
            }, r2.prototype.getCachedSnapshotForLocation = function(t32) {
              var e22;
              return null != (e22 = this.cache.get(t32)) ? e22.clone() : void 0;
            }, r2.prototype.shouldCacheSnapshot = function() {
              return this.view.getSnapshot().isCacheable();
            }, r2.prototype.cacheSnapshot = function() {
              var t32, r22;
              return this.shouldCacheSnapshot() ? (this.notifyApplicationBeforeCachingSnapshot(), r22 = this.view.getSnapshot(), t32 = this.lastRenderedLocation, e3.defer(function(e22) {
                return function() {
                  return e22.cache.put(t32, r22.clone());
                };
              }(this))) : void 0;
            }, r2.prototype.scrollToAnchor = function(t32) {
              var e22;
              return (e22 = this.view.getElementForAnchor(t32)) ? this.scrollToElement(e22) : this.scrollToPosition({ x: 0, y: 0 });
            }, r2.prototype.scrollToElement = function(t32) {
              return this.scrollManager.scrollToElement(t32);
            }, r2.prototype.scrollToPosition = function(t32) {
              return this.scrollManager.scrollToPosition(t32);
            }, r2.prototype.scrollPositionChanged = function(t32) {
              var e22;
              return e22 = this.getCurrentRestorationData(), e22.scrollPosition = t32;
            }, r2.prototype.render = function(t32, e22) {
              return this.view.render(t32, e22);
            }, r2.prototype.viewInvalidated = function() {
              return this.adapter.pageInvalidated();
            }, r2.prototype.viewWillRender = function(t32) {
              return this.notifyApplicationBeforeRender(t32);
            }, r2.prototype.viewRendered = function() {
              return this.lastRenderedLocation = this.currentVisit.location, this.notifyApplicationAfterRender();
            }, r2.prototype.pageLoaded = function() {
              return this.lastRenderedLocation = this.location, this.notifyApplicationAfterPageLoad();
            }, r2.prototype.clickCaptured = function() {
              return removeEventListener("click", this.clickBubbled, false), addEventListener("click", this.clickBubbled, false);
            }, r2.prototype.clickBubbled = function(t32) {
              var e22, r22, n2;
              return this.enabled && this.clickEventIsSignificant(t32) && (r22 = this.getVisitableLinkForNode(t32.target)) && (n2 = this.getVisitableLocationForLink(r22)) && this.applicationAllowsFollowingLinkToLocation(r22, n2) ? (t32.preventDefault(), e22 = this.getActionForLink(r22), this.visit(n2, { action: e22 })) : void 0;
            }, r2.prototype.applicationAllowsFollowingLinkToLocation = function(t32, e22) {
              var r22;
              return r22 = this.notifyApplicationAfterClickingLinkToLocation(t32, e22), !r22.defaultPrevented;
            }, r2.prototype.applicationAllowsVisitingLocation = function(t32) {
              var e22;
              return e22 = this.notifyApplicationBeforeVisitingLocation(t32), !e22.defaultPrevented;
            }, r2.prototype.notifyApplicationAfterClickingLinkToLocation = function(t32, r22) {
              return e3.dispatch("turbolinks:click", { target: t32, data: { url: r22.absoluteURL }, cancelable: true });
            }, r2.prototype.notifyApplicationBeforeVisitingLocation = function(t32) {
              return e3.dispatch("turbolinks:before-visit", { data: { url: t32.absoluteURL }, cancelable: true });
            }, r2.prototype.notifyApplicationAfterVisitingLocation = function(t32) {
              return e3.dispatch("turbolinks:visit", { data: { url: t32.absoluteURL } });
            }, r2.prototype.notifyApplicationBeforeCachingSnapshot = function() {
              return e3.dispatch("turbolinks:before-cache");
            }, r2.prototype.notifyApplicationBeforeRender = function(t32) {
              return e3.dispatch("turbolinks:before-render", { data: { newBody: t32 } });
            }, r2.prototype.notifyApplicationAfterRender = function() {
              return e3.dispatch("turbolinks:render");
            }, r2.prototype.notifyApplicationAfterPageLoad = function(t32) {
              return null == t32 && (t32 = {}), e3.dispatch("turbolinks:load", { data: { url: this.location.absoluteURL, timing: t32 } });
            }, r2.prototype.startVisit = function(t32, e22, r22) {
              var n2;
              return null != (n2 = this.currentVisit) && n2.cancel(), this.currentVisit = this.createVisit(t32, e22, r22), this.currentVisit.start(), this.notifyApplicationAfterVisitingLocation(t32);
            }, r2.prototype.createVisit = function(t32, r22, n2) {
              var o2, i3, s4, a4, u3;
              return i3 = null != n2 ? n2 : {}, a4 = i3.restorationIdentifier, s4 = i3.restorationData, o2 = i3.historyChanged, u3 = new e3.Visit(this, t32, r22), u3.restorationIdentifier = null != a4 ? a4 : e3.uuid(), u3.restorationData = e3.copyObject(s4), u3.historyChanged = o2, u3.referrer = this.location, u3;
            }, r2.prototype.visitCompleted = function(t32) {
              return this.notifyApplicationAfterPageLoad(t32.getTimingMetrics());
            }, r2.prototype.clickEventIsSignificant = function(t32) {
              return !(t32.defaultPrevented || t32.target.isContentEditable || t32.which > 1 || t32.altKey || t32.ctrlKey || t32.metaKey || t32.shiftKey);
            }, r2.prototype.getVisitableLinkForNode = function(t32) {
              return this.nodeIsVisitable(t32) ? e3.closest(t32, "a[href]:not([target]):not([download])") : void 0;
            }, r2.prototype.getVisitableLocationForLink = function(t32) {
              var r22;
              return r22 = new e3.Location(t32.getAttribute("href")), this.locationIsVisitable(r22) ? r22 : void 0;
            }, r2.prototype.getActionForLink = function(t32) {
              var e22;
              return null != (e22 = t32.getAttribute("data-turbolinks-action")) ? e22 : "advance";
            }, r2.prototype.nodeIsVisitable = function(t32) {
              var r22;
              return (r22 = e3.closest(t32, "[data-turbolinks]")) ? "false" !== r22.getAttribute("data-turbolinks") : true;
            }, r2.prototype.locationIsVisitable = function(t32) {
              return t32.isPrefixedBy(this.view.getRootLocation()) && t32.isHTML();
            }, r2.prototype.getCurrentRestorationData = function() {
              return this.getRestorationDataForIdentifier(this.restorationIdentifier);
            }, r2.prototype.getRestorationDataForIdentifier = function(t32) {
              var e22;
              return null != (e22 = this.restorationData)[t32] ? e22[t32] : e22[t32] = {};
            }, r2;
          }();
        }.call(this), function() {
          !function() {
            var t22, e22;
            if ((t22 = e22 = document.currentScript) && !e22.hasAttribute("data-turbolinks-suppress-warning")) {
              for (; t22 = t22.parentNode; )
                if (t22 === document.body)
                  return console.warn("You are loading Turbolinks from a <script> element inside the <body> element. This is probably not what you meant to do!\n\nLoad your application\u2019s JavaScript bundle inside the <head> element instead. <script> elements in <body> are evaluated with each page change.\n\nFor more information, see: https://github.com/turbolinks/turbolinks#working-with-script-elements\n\n\u2014\u2014\nSuppress this warning by adding a `data-turbolinks-suppress-warning` attribute to: %s", e22.outerHTML);
            }
          }();
        }.call(this), function() {
          var t22, r2, n2;
          e3.start = function() {
            return r2() ? (null == e3.controller && (e3.controller = t22()), e3.controller.start()) : void 0;
          }, r2 = function() {
            return null == window.Turbolinks && (window.Turbolinks = e3), n2();
          }, t22 = function() {
            var t32;
            return t32 = new e3.Controller(), t32.adapter = new e3.BrowserAdapter(t32), t32;
          }, n2 = function() {
            return window.Turbolinks === e3;
          }, n2() && e3.start();
        }.call(this);
      }).call(this), "object" == typeof module && module.exports ? module.exports = e3 : "function" == typeof define && define.amd && define(e3);
    }).call(exports);
  }
});
init_react_shim();
init_react_shim();
init_react_shim();
init_react_shim();
function index_module_default(n2) {
  for (var l2, e3, s4 = arguments, t3 = 1, r2 = "", u3 = "", a4 = [0], c3 = function(n22) {
    1 === t3 && (n22 || (r2 = r2.replace(/^\s*\n\s*|\s*\n\s*$/g, ""))) ? a4.push(n22 ? s4[n22] : r2) : 3 === t3 && (n22 || r2) ? (a4[1] = n22 ? s4[n22] : r2, t3 = 2) : 2 === t3 && "..." === r2 && n22 ? a4[2] = Object.assign(a4[2] || {}, s4[n22]) : 2 === t3 && r2 && !n22 ? (a4[2] = a4[2] || {})[r2] = true : t3 >= 5 && (5 === t3 ? ((a4[2] = a4[2] || {})[e3] = n22 ? r2 ? r2 + s4[n22] : s4[n22] : r2, t3 = 6) : (n22 || r2) && (a4[2][e3] += n22 ? r2 + s4[n22] : r2)), r2 = "";
  }, h4 = 0; h4 < n2.length; h4++) {
    h4 && (1 === t3 && c3(), c3(h4));
    for (var i3 = 0; i3 < n2[h4].length; i3++)
      l2 = n2[h4][i3], 1 === t3 ? "<" === l2 ? (c3(), a4 = [a4, "", null], t3 = 3) : r2 += l2 : 4 === t3 ? "--" === r2 && ">" === l2 ? (t3 = 1, r2 = "") : r2 = l2 + r2[0] : u3 ? l2 === u3 ? u3 = "" : r2 += l2 : '"' === l2 || "'" === l2 ? u3 = l2 : ">" === l2 ? (c3(), t3 = 1) : t3 && ("=" === l2 ? (t3 = 5, e3 = r2, r2 = "") : "/" === l2 && (t3 < 5 || ">" === n2[h4][i3 + 1]) ? (c3(), 3 === t3 && (a4 = a4[0]), t3 = a4, (a4 = a4[0]).push(this.apply(null, t3.slice(1))), t3 = 0) : " " === l2 || "	" === l2 || "\n" === l2 || "\r" === l2 ? (c3(), t3 = 2) : r2 += l2), 3 === t3 && "!--" === r2 && (t3 = 4, a4 = a4[0]);
  }
  return c3(), a4.length > 2 ? a4.slice(1) : a4[1];
}
function offsetTop(element, parent = null) {
  let top2 = element.offsetTop;
  while (element = element.offsetParent) {
    if (parent === element) {
      return top2;
    }
    top2 += element.offsetTop;
  }
  return top2;
}
function createElement(tagName, attributes = {}, ...children) {
  if (typeof tagName === "function") {
    return tagName(attributes);
  }
  const svgTags = ["svg", "use", "path", "circle", "g"];
  const e3 = !svgTags.includes(tagName) ? document.createElement(tagName) : document.createElementNS("http://www.w3.org/2000/svg", tagName);
  for (let k3 of Object.keys(attributes || {})) {
    if (typeof k3 === "number") {
      k3 = k3.toString();
    }
    if (typeof attributes[k3] === "function" && k3.startsWith("on")) {
      e3.addEventListener(k3.substr(2).toLowerCase(), attributes[k3]);
    } else if (k3 === "xlink:href") {
      e3.setAttributeNS("http://www.w3.org/1999/xlink", "href", attributes[k3]);
    } else {
      e3.setAttribute(k3, attributes[k3]);
    }
  }
  children = children.reduce((acc, child) => {
    return Array.isArray(child) ? [...acc, ...child] : [...acc, child];
  }, []);
  for (const child of children) {
    if (typeof child === "string") {
      e3.appendChild(document.createTextNode(child));
    } else if (child instanceof HTMLElement || child instanceof SVGElement) {
      e3.appendChild(child);
    } else {
      console.error("Impossible d'ajouter l'\xE9l\xE9ment", child, typeof child);
    }
  }
  return e3;
}
index_module_default.bind(createElement);
function strToDom(str) {
  return document.createRange().createContextualFragment(str.trim()).firstChild;
}
init_react_shim();
var uuid = new Date().getTime().toString();
if (localStorage) {
  localStorage.setItem("windowId", uuid);
  window.addEventListener("focus", function() {
    localStorage.setItem("windowId", uuid);
  });
}
init_react_shim();
init_react_shim();
init_react_shim();
init_react_shim();
init_react_shim();
var debounce$1 = (func, wait2) => {
  let timeout = null;
  const debounced = (...args) => {
    if (timeout !== null) {
      clearTimeout(timeout);
      timeout = null;
    }
    timeout = setTimeout(() => func(...args), wait2);
  };
  return debounced;
};
init_react_shim();
function uniqId() {
  return `_${Math.random().toString(36).substr(2, 9)}`;
}
function textContent(str) {
  return new DOMParser().parseFromString(str, "text/html").body.textContent;
}
function capitalize(str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
}
function useToggle(initialValue = false) {
  const [value, setValue] = react.exports.useState(initialValue);
  return [value, react.exports.useCallback(() => setValue((v2) => !v2), []), setValue];
}
function useAsyncEffect(fn3, deps = []) {
  react.exports.useEffect(() => {
    fn3();
  }, deps);
}
function useEffectDebounced(callback, deps, time) {
  const callbackRef = react.exports.useRef(callback);
  const debouncedCallback = react.exports.useMemo(() => {
    return debounce$1((...args) => callbackRef.current(...args), time);
  }, []);
  callbackRef.current = callback;
  react.exports.useEffect(() => {
    debouncedCallback();
  }, deps);
}
function useStateDelayed(originalState, duration2 = 700, onlyOnFalse = true) {
  const [delayedState, setDelayedState] = react.exports.useState(originalState);
  react.exports.useEffect(() => {
    if (originalState && onlyOnFalse) {
      setDelayedState(originalState);
    } else {
      const timer = window.setTimeout(
        () => setDelayedState(originalState),
        700
      );
      return () => window.clearTimeout(timer);
    }
  }, [originalState]);
  return delayedState;
}
var stopPropagation = (e3) => e3.stopPropagation();
function useStopPropagation(ref, eventNames) {
  react.exports.useEffect(() => {
    if (!ref.current) {
      return;
    }
    eventNames.map((eventName) => {
      ref.current.addEventListener(eventName, stopPropagation);
    });
    return () => {
      if (!ref.current) {
        return;
      }
      eventNames.map((eventName) => {
        ref.current.removeEventListener(eventName, stopPropagation);
      });
    };
  });
}
function useUniqId(prefix2 = "") {
  return react.exports.useMemo(() => prefix2 + uniqId(), []);
}
function useUpdateEffect(cb2, deps) {
  const isFirstRender = react.exports.useRef(true);
  react.exports.useEffect(() => {
    if (isFirstRender.current) {
      isFirstRender.current = false;
      return;
    }
    return cb2();
  }, deps);
}
init_react_shim();
init_react_shim();
__toESM(require_turbolinks(), 1);
init_react_shim();
async function copyToClipboard(text2) {
  try {
    const permissionName = "clipboard-write";
    const result = await navigator.permissions.query({
      name: permissionName
    });
    if (result.state == "granted" || result.state == "prompt") {
      await navigator.clipboard.writeText(text2);
      return true;
    }
    throw result;
  } catch (e3) {
    await navigator.clipboard.writeText(text2);
    return true;
  }
}
init_react_shim();
function colorToProperty(color2) {
  if (typeof color2 !== "string") {
    return void 0;
  }
  if (color2.startsWith("--")) {
    return `var(${color2})`;
  }
  return color2;
}
init_react_shim();
function clamp$1(value, min2, max2) {
  return Math.min(Math.max(value, min2), max2);
}
init_react_shim();
function keys$1(ks) {
  return Array.isArray(ks) ? ks : ks.split(".");
}
function deepGet(o2, kp, d4 = null) {
  return keys$1(kp).reduce(
    (o22, k3) => o22 && (Array.isArray(o22) ? o22[parseInt(k3)] : o22[k3]) || d4,
    o2
  );
}
function deepSet(object, keyPath, value) {
  if (!keyPath) {
    return value;
  }
  return keys$1(keyPath).reduceRight((acc, key, i3, keys2) => {
    const original = deepGet(object, keys2.slice(0, i3));
    if (Array.isArray(original)) {
      return original.map((v2, k3) => {
        if (k3.toString() === key) {
          return acc;
        }
        return v2;
      });
    } else {
      return Object.assign({}, original, { [key]: acc });
    }
  }, value);
}
function stringifyFields(source) {
  return JSON.stringify(
    source,
    (key, value) => {
      if (key === "_id") {
        return void 0;
      }
      return value;
    },
    2
  );
}
function indexify(object) {
  if (Array.isArray(object)) {
    const prefix2 = Math.round(Date.now() / 1e3);
    object.forEach((v2, k3) => {
      if (typeof v2 === "object") {
        v2._id = prefix2 + k3.toString();
        indexify(v2);
      }
    });
  } else if (typeof object === "object" && object !== null) {
    Object.keys(object).forEach((key) => indexify(object[key]));
  }
  return object;
}
function cast(value, expectedValue) {
  if (typeof expectedValue === "boolean") {
    return !!value;
  }
  if (typeof expectedValue === "string") {
    if (typeof value === "boolean") {
      return "";
    }
    return "" + (value != null ? value : "");
  }
  throw new Error(`Cannot cast ${typeof value} into a ${typeof expectedValue}`);
}
init_react_shim();
function prevent(callback) {
  if (!callback) {
    return;
  }
  return (e3) => {
    e3.preventDefault();
    callback(e3);
  };
}
function Modal({
  children,
  title: title2,
  visible,
  onVisibilityChange
}) {
  return /* @__PURE__ */ jsxs(Root$4, {
    open: visible,
    onOpenChange: onVisibilityChange,
    children: [/* @__PURE__ */ jsx(ModalOverlay, {}), /* @__PURE__ */ jsxs(ModalContent, {
      children: [/* @__PURE__ */ jsx(ModalTitle, {
        children: title2
      }), /* @__PURE__ */ jsx("div", {
        children
      }), /* @__PURE__ */ jsx(ModalClose, {
        onClick: prevent(() => onVisibilityChange(false)),
        children: /* @__PURE__ */ jsx(IconCross, {
          size: 16
        })
      })]
    })]
  });
}
const FadeIn = keyframes({
  from: {
    opacity: 0
  },
  to: {
    opacity: 1
  }
});
const ContentIn = keyframes({
  from: {
    opacity: 0,
    transform: "translateY(-48%) scale(.96)"
  },
  to: {
    opacity: 1,
    transform: "translateY(-50%) scale(1)"
  }
});
const ModalOverlay = /* @__PURE__ */ createStyled(Overlay, {
  target: "e1b9jrq43"
})({
  position: "fixed",
  inset: 0,
  zIndex: 50,
  overflow: "auto",
  backgroundColor: "rgba(0, 0, 0, 0.5)",
  animation: `${FadeIn} 300ms cubic-bezier(0.16, 1, 0.3, 1)`
}, "");
const ModalContent = /* @__PURE__ */ createStyled(Content$2, {
  target: "e1b9jrq42"
})({
  position: "fixed",
  top: "50%",
  left: "0",
  right: "0",
  zIndex: 51,
  marginLeft: "auto",
  marginRight: "auto",
  width: "calc(100% - 2rem)",
  maxWidth: "1290px",
  borderRadius: "8px",
  backgroundColor: "var(--background)",
  padding: "1.5rem 2rem",
  transform: "translateY(-50%)",
  animation: `${ContentIn} 300ms cubic-bezier(0.16, 1, 0.3, 1)`
}, "");
const ModalTitle = /* @__PURE__ */ createStyled(Title$2, {
  target: "e1b9jrq41"
})({
  name: "12ftyuo",
  styles: "font-size:1.5rem;font-weight:500;margin:0;padding:0;color:var(--color-dark)"
});
const ModalClose = /* @__PURE__ */ createStyled(ButtonIcon, {
  target: "e1b9jrq40"
})({
  name: "yqq9j2",
  styles: "position:absolute;top:1.2rem;right:1.5rem"
});
function createCollection(c3) {
  const n2 = c3 + "CollectionProvider", [l2, i3] = createContextScope(n2), [f2, a4] = l2(n2, { collectionRef: { current: null }, itemMap: /* @__PURE__ */ new Map() }), u3 = (e3) => {
    const { scope: r2, children: t3 } = e3, c4 = e$3.useRef(null), n3 = e$3.useRef(/* @__PURE__ */ new Map()).current;
    return e$3.createElement(f2, { scope: r2, itemMap: n3, collectionRef: c4 }, t3);
  }, m4 = c3 + "CollectionSlot", s4 = /* @__PURE__ */ e$3.forwardRef((t3, c4) => {
    const { scope: n3, children: l3 } = t3, i4 = a4(m4, n3), f3 = useComposedRefs(c4, i4.collectionRef);
    return e$3.createElement(Slot, { ref: f3 }, l3);
  }), p2 = c3 + "CollectionItemSlot", d4 = "data-radix-collection-item", R3 = /* @__PURE__ */ e$3.forwardRef((t3, c4) => {
    const { scope: n3, children: l3, ...i4 } = t3, f3 = e$3.useRef(null), u4 = useComposedRefs(c4, f3), m5 = a4(p2, n3);
    return e$3.useEffect(() => (m5.itemMap.set(f3, { ref: f3, ...i4 }), () => {
      m5.itemMap.delete(f3);
    })), /* @__PURE__ */ e$3.createElement(Slot, { [d4]: "", ref: u4 }, l3);
  });
  return [{ Provider: u3, Slot: s4, ItemSlot: R3 }, function(e3) {
    const r2 = a4(c3 + "CollectionConsumer", e3);
    return e$3.useCallback(() => {
      const e4 = r2.collectionRef.current;
      if (!e4)
        return [];
      const t3 = Array.from(e4.querySelectorAll(`[${d4}]`));
      return Array.from(r2.itemMap.values()).sort((e5, r3) => t3.indexOf(e5.ref.current) - t3.indexOf(r3.ref.current));
    }, [r2.collectionRef, r2.itemMap]);
  }, i3];
}
const f$5 = { bubbles: false, cancelable: true }, [p$4, l$3, m$5] = createCollection("RovingFocusGroup"), [d$4, v$2] = createContextScope("RovingFocusGroup", [m$5]);
const [g$3, F$1] = d$4("RovingFocusGroup");
const RovingFocusGroup = /* @__PURE__ */ react.exports.forwardRef((e3, o2) => /* @__PURE__ */ react.exports.createElement(p$4.Provider, { scope: e3.__scopeRovingFocusGroup }, /* @__PURE__ */ react.exports.createElement(p$4.Slot, { scope: e3.__scopeRovingFocusGroup }, /* @__PURE__ */ react.exports.createElement(w$3, _extends$1({}, e3, { ref: o2 })))));
const w$3 = /* @__PURE__ */ react.exports.forwardRef((t3, n2) => {
  const { __scopeRovingFocusGroup: c3, orientation: p2, dir: m4 = "ltr", loop: d4 = false, currentTabStopId: v2, defaultCurrentTabStopId: F2, onCurrentTabStopIdChange: w3, onEntryFocus: b3, ...x3 } = t3, E3 = react.exports.useRef(null), I3 = useComposedRefs(n2, E3), [G3 = null, h4] = useControllableState({ prop: v2, defaultProp: F2, onChange: w3 }), [T3, A2] = react.exports.useState(false), y4 = useCallbackRef(b3), D3 = l$3(c3), S4 = react.exports.useRef(false);
  return react.exports.useEffect(() => {
    const e3 = E3.current;
    if (e3)
      return e3.addEventListener("rovingFocusGroup.onEntryFocus", y4), () => e3.removeEventListener("rovingFocusGroup.onEntryFocus", y4);
  }, [y4]), /* @__PURE__ */ react.exports.createElement(g$3, { scope: c3, orientation: p2, dir: m4, loop: d4, currentTabStopId: G3, onItemFocus: react.exports.useCallback((e3) => h4(e3), [h4]), onItemShiftTab: react.exports.useCallback(() => A2(true), []) }, /* @__PURE__ */ react.exports.createElement(Primitive.div, _extends$1({ tabIndex: T3 ? -1 : 0, "data-orientation": p2 }, x3, { ref: I3, style: { outline: "none", ...t3.style }, onMouseDown: composeEventHandlers(t3.onMouseDown, () => {
    S4.current = true;
  }), onFocus: composeEventHandlers(t3.onFocus, (e3) => {
    const o2 = !S4.current;
    if (e3.target === e3.currentTarget && o2 && !T3) {
      const o3 = new Event("rovingFocusGroup.onEntryFocus", f$5);
      if (e3.currentTarget.dispatchEvent(o3), !o3.defaultPrevented) {
        const e4 = D3().filter((e5) => e5.focusable);
        R$3([e4.find((e5) => e5.active), e4.find((e5) => e5.id === G3), ...e4].filter(Boolean).map((e5) => e5.ref.current));
      }
    }
    S4.current = false;
  }), onBlur: composeEventHandlers(t3.onBlur, () => A2(false)) })));
});
const RovingFocusGroupItem = /* @__PURE__ */ react.exports.forwardRef((e3, o2) => {
  const { __scopeRovingFocusGroup: n2, focusable: i3 = true, active: c3 = false, ...f2 } = e3, m4 = useId(), d4 = F$1("RovingFocusGroupItem", n2), v2 = d4.currentTabStopId === m4, g2 = l$3(n2);
  return react.exports.createElement(p$4.ItemSlot, { scope: n2, id: m4, focusable: i3, active: c3 }, /* @__PURE__ */ react.exports.createElement(Primitive.span, _extends$1({ tabIndex: v2 ? 0 : -1, "data-orientation": d4.orientation }, f2, { ref: o2, onMouseDown: composeEventHandlers(e3.onMouseDown, (e4) => {
    i3 ? d4.onItemFocus(m4) : e4.preventDefault();
  }), onFocus: composeEventHandlers(e3.onFocus, () => d4.onItemFocus(m4)), onKeyDown: composeEventHandlers(e3.onKeyDown, (e4) => {
    if ("Tab" === e4.key && e4.shiftKey)
      return void d4.onItemShiftTab();
    if (e4.target !== e4.currentTarget)
      return;
    const o3 = function(e5, o4, r3) {
      const t4 = function(e6, o5) {
        return "rtl" !== o5 ? e6 : "ArrowLeft" === e6 ? "ArrowRight" : "ArrowRight" === e6 ? "ArrowLeft" : e6;
      }(e5.key, r3);
      return "vertical" === o4 && ["ArrowLeft", "ArrowRight"].includes(t4) || "horizontal" === o4 && ["ArrowUp", "ArrowDown"].includes(t4) ? void 0 : b$3[t4];
    }(e4, d4.orientation, d4.dir);
    if (void 0 !== o3) {
      e4.preventDefault();
      let n3 = g2().filter((e5) => e5.focusable).map((e5) => e5.ref.current);
      if ("last" === o3)
        n3.reverse();
      else if ("prev" === o3 || "next" === o3) {
        "prev" === o3 && n3.reverse();
        const i4 = n3.indexOf(e4.currentTarget);
        n3 = d4.loop ? (t3 = i4 + 1, (r2 = n3).map((e5, o4) => r2[(t3 + o4) % r2.length])) : n3.slice(i4 + 1);
      }
      setTimeout(() => R$3(n3));
    }
    var r2, t3;
  }) })));
});
const b$3 = { ArrowLeft: "prev", ArrowUp: "prev", ArrowRight: "next", ArrowDown: "next", PageUp: "first", Home: "first", PageDown: "last", End: "last" };
function R$3(e3) {
  const o2 = document.activeElement;
  for (const r2 of e3) {
    if (r2 === o2)
      return;
    if (r2.focus(), document.activeElement !== o2)
      return;
  }
}
const Root$3 = RovingFocusGroup;
const Item$1 = RovingFocusGroupItem;
const [d$3, l$2] = createContextScope("Tabs", [v$2]);
const u$3 = v$2(), [b$2, p$3] = d$3("Tabs");
const Tabs$2 = /* @__PURE__ */ react.exports.forwardRef((t3, o2) => {
  const { __scopeTabs: n2, value: i3, onValueChange: d4, defaultValue: l2, orientation: u3 = "horizontal", dir: p2 = "ltr", activationMode: m4 = "automatic", ...f2 } = t3, [v2, T3] = useControllableState({ prop: i3, onChange: d4, defaultProp: l2 });
  return react.exports.createElement(b$2, { scope: n2, baseId: useId(), value: v2, onValueChange: T3, orientation: u3, dir: p2, activationMode: m4 }, /* @__PURE__ */ react.exports.createElement(Primitive.div, _extends$1({ "data-orientation": u3 }, f2, { ref: o2 })));
});
const TabsList$1 = /* @__PURE__ */ react.exports.forwardRef((e3, o2) => {
  const { __scopeTabs: r2, loop: n2 = true, ...i3 } = e3, d4 = p$3("TabsList", r2), l2 = u$3(r2);
  return react.exports.createElement(Root$3, _extends$1({ asChild: true }, l2, { orientation: d4.orientation, dir: d4.dir, loop: n2 }), /* @__PURE__ */ react.exports.createElement(Primitive.div, _extends$1({ role: "tablist", "aria-orientation": d4.orientation, dir: d4.dir }, i3, { ref: o2 })));
});
const TabsTrigger = /* @__PURE__ */ react.exports.forwardRef((e3, o2) => {
  const { __scopeTabs: r2, value: n2, disabled: d4 = false, ...l2 } = e3, b3 = p$3("TabsTrigger", r2), v2 = u$3(r2), T3 = m$4(b3.baseId, n2), x3 = f$4(b3.baseId, n2), g2 = n2 === b3.value;
  return react.exports.createElement(Item$1, _extends$1({ asChild: true }, v2, { focusable: !d4, active: g2 }), /* @__PURE__ */ react.exports.createElement(Primitive.button, _extends$1({ type: "button", role: "tab", "aria-selected": g2, "aria-controls": x3, "data-state": g2 ? "active" : "inactive", "data-disabled": d4 ? "" : void 0, disabled: d4, id: T3 }, l2, { ref: o2, onMouseDown: composeEventHandlers(e3.onMouseDown, (e4) => {
    d4 || 0 !== e4.button || false !== e4.ctrlKey ? e4.preventDefault() : b3.onValueChange(n2);
  }), onKeyDown: composeEventHandlers(e3.onKeyDown, (e4) => {
    [" ", "Enter"].includes(e4.key) && b3.onValueChange(n2);
  }), onFocus: composeEventHandlers(e3.onFocus, () => {
    const e4 = "manual" !== b3.activationMode;
    g2 || d4 || !e4 || b3.onValueChange(n2);
  }) })));
});
const TabsContent = /* @__PURE__ */ react.exports.forwardRef((e3, t3) => {
  const { __scopeTabs: o2, value: r2, children: n2, ...i3 } = e3, d4 = p$3("TabsContent", o2), l2 = m$4(d4.baseId, r2), u3 = f$4(d4.baseId, r2), b3 = r2 === d4.value;
  return react.exports.createElement(Primitive.div, _extends$1({ "data-state": b3 ? "active" : "inactive", "data-orientation": d4.orientation, role: "tabpanel", "aria-labelledby": l2, hidden: !b3, id: u3, tabIndex: 0 }, i3, { ref: t3 }), b3 && n2);
});
function m$4(e3, t3) {
  return `${e3}-trigger-${t3}`;
}
function f$4(e3, t3) {
  return `${e3}-content-${t3}`;
}
const TabsList = /* @__PURE__ */ createStyled(TabsList$1, {
  target: "e1ea9zvl1"
})({
  name: "2whhw8",
  styles: "display:flex;gap:.5rem;margin-bottom:1em"
});
const TabButton = /* @__PURE__ */ createStyled(TabsTrigger, {
  target: "e1ea9zvl0"
})({
  name: "72sfnq",
  styles: "color:var(--color-dark);background-color:var(--color-light);border-radius:56px;padding:.6rem 1rem;border:none;font-weight:500;cursor:pointer;transition:color .3s, background-color .3s"
});
const TabButtonSelected = {
  color: "var(--color-light)",
  backgroundColor: "var(--contrast)"
};
function Tabs$1({
  children,
  ...props
}) {
  var _a;
  const childrenArray = e$3.Children.toArray(children);
  const [currentTab, setCurrentTab] = react.exports.useState((_a = childrenArray[0]) == null ? void 0 : _a.props.title);
  return /* @__PURE__ */ jsxs(Tabs$2, {
    value: currentTab,
    onValueChange: setCurrentTab,
    children: [/* @__PURE__ */ jsx(TabsList, {
      ...props,
      children: childrenArray.map((child) => /* @__PURE__ */ jsx(TabButton, {
        css: [currentTab === child.props.title && TabButtonSelected, "", ""],
        value: child.props.title,
        children: child.props.title
      }, child.props.title))
    }), childrenArray.map((child) => /* @__PURE__ */ jsx(TabsContent, {
      value: child.props.title,
      children: child
    }, child.props.title))]
  });
}
function Tab(props) {
  return /* @__PURE__ */ jsx("div", {
    ...props
  });
}
Tabs$1.Tab = Tab;
const Flex = react.exports.forwardRef(({
  between,
  column: column2,
  ...props
}, ref) => {
  return /* @__PURE__ */ jsx(Wrapper$9, {
    ...props,
    ref,
    css: [between && Between, column2 && Column, "", ""]
  });
});
Flex.displayName = "Flex";
const Wrapper$9 = /* @__PURE__ */ createStyled("div", {
  target: "e1580l3h0"
})("display:flex;align-items:center;justify-content:flex-start;", ({
  gap = 1
}) => ({
  gap: gap + "em",
  gridGap: gap + "em"
}), "");
const Between = {
  justifyContent: "space-between"
};
const Column = {
  display: "grid",
  alignContent: "flex-start",
  gridTemplateColumns: "1fr",
  alignItems: "flex-start"
};
const defaultTimestep = 1 / 60 * 1e3;
const getCurrentTime = typeof performance !== "undefined" ? () => performance.now() : () => Date.now();
const onNextFrame = typeof window !== "undefined" ? (callback) => window.requestAnimationFrame(callback) : (callback) => setTimeout(() => callback(getCurrentTime()), defaultTimestep);
function createRenderStep(runNextFrame2) {
  let toRun = [];
  let toRunNextFrame = [];
  let numToRun = 0;
  let isProcessing2 = false;
  let flushNextFrame = false;
  const toKeepAlive = /* @__PURE__ */ new WeakSet();
  const step = {
    schedule: (callback, keepAlive = false, immediate = false) => {
      const addToCurrentFrame = immediate && isProcessing2;
      const buffer = addToCurrentFrame ? toRun : toRunNextFrame;
      if (keepAlive)
        toKeepAlive.add(callback);
      if (buffer.indexOf(callback) === -1) {
        buffer.push(callback);
        if (addToCurrentFrame && isProcessing2)
          numToRun = toRun.length;
      }
      return callback;
    },
    cancel: (callback) => {
      const index2 = toRunNextFrame.indexOf(callback);
      if (index2 !== -1)
        toRunNextFrame.splice(index2, 1);
      toKeepAlive.delete(callback);
    },
    process: (frameData) => {
      if (isProcessing2) {
        flushNextFrame = true;
        return;
      }
      isProcessing2 = true;
      [toRun, toRunNextFrame] = [toRunNextFrame, toRun];
      toRunNextFrame.length = 0;
      numToRun = toRun.length;
      if (numToRun) {
        for (let i3 = 0; i3 < numToRun; i3++) {
          const callback = toRun[i3];
          callback(frameData);
          if (toKeepAlive.has(callback)) {
            step.schedule(callback);
            runNextFrame2();
          }
        }
      }
      isProcessing2 = false;
      if (flushNextFrame) {
        flushNextFrame = false;
        step.process(frameData);
      }
    }
  };
  return step;
}
const maxElapsed = 40;
let useDefaultElapsed = true;
let runNextFrame = false;
let isProcessing = false;
const frame = {
  delta: 0,
  timestamp: 0
};
const stepsOrder = [
  "read",
  "update",
  "preRender",
  "render",
  "postRender"
];
const steps = stepsOrder.reduce((acc, key) => {
  acc[key] = createRenderStep(() => runNextFrame = true);
  return acc;
}, {});
const sync = stepsOrder.reduce((acc, key) => {
  const step = steps[key];
  acc[key] = (process, keepAlive = false, immediate = false) => {
    if (!runNextFrame)
      startLoop();
    return step.schedule(process, keepAlive, immediate);
  };
  return acc;
}, {});
stepsOrder.reduce((acc, key) => {
  acc[key] = steps[key].cancel;
  return acc;
}, {});
stepsOrder.reduce((acc, key) => {
  acc[key] = () => steps[key].process(frame);
  return acc;
}, {});
const processStep = (stepId) => steps[stepId].process(frame);
const processFrame = (timestamp) => {
  runNextFrame = false;
  frame.delta = useDefaultElapsed ? defaultTimestep : Math.max(Math.min(timestamp - frame.timestamp, maxElapsed), 1);
  frame.timestamp = timestamp;
  isProcessing = true;
  stepsOrder.forEach(processStep);
  isProcessing = false;
  if (runNextFrame) {
    useDefaultElapsed = false;
    onNextFrame(processFrame);
  }
};
const startLoop = () => {
  runNextFrame = true;
  useDefaultElapsed = true;
  if (!isProcessing)
    onNextFrame(processFrame);
};
function useUnmountEffect(callback) {
  return react.exports.useEffect(() => () => callback(), []);
}
function useForceUpdate$1() {
  const isUnmountingRef = react.exports.useRef(false);
  const [forcedRenderCount, setForcedRenderCount] = react.exports.useState(0);
  useUnmountEffect(() => isUnmountingRef.current = true);
  const forceRender = react.exports.useCallback(() => {
    !isUnmountingRef.current && setForcedRenderCount(forcedRenderCount + 1);
  }, [forcedRenderCount]);
  const deferredForceRender = react.exports.useCallback(() => sync.postRender(forceRender), [forceRender]);
  return [deferredForceRender, forcedRenderCount];
}
function useConstant(init2) {
  const ref = react.exports.useRef(null);
  if (ref.current === null) {
    ref.current = init2();
  }
  return ref.current;
}
const Base = {
  animationDuration: ".7s",
  animationTimingFunction: "cubic-bezier(0.19, 1, 0.22, 1)",
  animateFill: "both"
};
const PresenceChild = ({
  children,
  isPresent,
  onExitComplete,
  in: inKeyframes,
  out: outKeyframes
}) => {
  const presenceChildren = useConstant(newChildrenMap);
  const animationName = isPresent ? inKeyframes : outKeyframes;
  react.exports.useMemo(() => {
    presenceChildren.forEach((_2, key) => presenceChildren.set(key, false));
  }, [isPresent]);
  return /* @__PURE__ */ jsx(ClassNames, {
    children: ({
      css: css2,
      cx: cx2
    }) => react.exports.cloneElement(children, {
      className: cx2(children.props.className, css2({
        ...Base,
        animationName: animationName.toString()
      })),
      onAnimationEnd: isPresent ? null : onExitComplete
    })
  });
};
function newChildrenMap() {
  return /* @__PURE__ */ new Map();
}
const LayoutGroupContext = react.exports.createContext({});
function getChildKey(child) {
  return child.key || "";
}
function updateChildLookup(children, allChildren) {
  children.forEach((child) => {
    const key = getChildKey(child);
    allChildren.set(key, child);
  });
}
function onlyElements(children) {
  const filtered = [];
  react.exports.Children.forEach(children, (child) => {
    if (react.exports.isValidElement(child))
      filtered.push(child);
  });
  return filtered;
}
const AnimatePresence = ({
  children,
  in: inKeyframes,
  out: outKeyframes,
  exitBeforeEnter
}) => {
  let [forceRender] = useForceUpdate$1();
  const forceRenderLayoutGroup = react.exports.useContext(LayoutGroupContext).forceRender;
  if (forceRenderLayoutGroup)
    forceRender = forceRenderLayoutGroup;
  const isInitialRender = react.exports.useRef(true);
  const isMounted = react.exports.useRef(true);
  react.exports.useEffect(() => () => {
    isMounted.current = false;
  }, []);
  const filteredChildren = onlyElements(children);
  const presentChildren = react.exports.useRef(filteredChildren);
  const allChildren = react.exports.useRef(/* @__PURE__ */ new Map()).current;
  const exiting = react.exports.useRef(/* @__PURE__ */ new Set()).current;
  updateChildLookup(filteredChildren, allChildren);
  if (isInitialRender.current) {
    isInitialRender.current = false;
    return /* @__PURE__ */ jsx(Fragment$1, {
      children: filteredChildren.map((child) => /* @__PURE__ */ jsx(PresenceChild, {
        isPresent: true,
        in: inKeyframes,
        out: outKeyframes,
        children: child
      }, getChildKey(child)))
    });
  }
  let childrenToRender = [...filteredChildren];
  const presentKeys = presentChildren.current.map(getChildKey);
  const targetKeys = filteredChildren.map(getChildKey);
  const numPresent = presentKeys.length;
  for (let i3 = 0; i3 < numPresent; i3++) {
    const key = presentKeys[i3] || "";
    if (targetKeys.indexOf(key) === -1) {
      exiting.add(key);
    } else {
      exiting.delete(key);
    }
  }
  if (exitBeforeEnter && exiting.size) {
    childrenToRender = [];
  }
  exiting.forEach((key) => {
    if (targetKeys.indexOf(key) !== -1)
      return;
    const child = allChildren.get(key);
    if (!child)
      return;
    const insertionIndex = presentKeys.indexOf(key);
    const onExit = () => {
      allChildren.delete(key);
      exiting.delete(key);
      const removeIndex = presentChildren.current.findIndex((presentChild) => presentChild.key === key);
      presentChildren.current.splice(removeIndex, 1);
      if (!exiting.size) {
        presentChildren.current = filteredChildren;
        if (!isMounted.current) {
          return;
        }
        forceRender();
      }
    };
    childrenToRender.splice(insertionIndex, 0, /* @__PURE__ */ jsx(PresenceChild, {
      isPresent: false,
      onExitComplete: onExit,
      in: inKeyframes,
      out: outKeyframes,
      children: child
    }, getChildKey(child)));
  });
  childrenToRender = childrenToRender.map((child) => {
    const key = child.key;
    return exiting.has(key) ? child : /* @__PURE__ */ jsx(PresenceChild, {
      isPresent: true,
      in: inKeyframes,
      out: outKeyframes,
      children: child
    }, getChildKey(child));
  });
  presentChildren.current = childrenToRender;
  return /* @__PURE__ */ jsx(Fragment$1, {
    children: exiting.size ? childrenToRender : childrenToRender.map((child) => react.exports.cloneElement(child))
  });
};
function Flash({
  children,
  action,
  onClick,
  duration: duration2,
  onHide: onHide2
}) {
  return /* @__PURE__ */ jsx(AnimatePresence, {
    in: FlashIn,
    out: FlashOut,
    children: children && /* @__PURE__ */ jsx(Alert, {
      duration: duration2,
      isFloating: true,
      message: children.toString(),
      type: "success"
    })
  });
}
keyframes({
  from: {
    transform: "scaleX(0)"
  },
  to: {
    transform: "scaleX(1)"
  }
});
const FlashIn = keyframes({
  from: {
    transform: "translateX(3em);",
    opacity: 0
  },
  to: {
    transform: "translateX(0)",
    opacity: 1
  }
});
const FlashOut = keyframes({
  from: {
    transform: "translateX(0)",
    opacity: 1
  },
  to: {
    transform: "translateX(-3em);",
    opacity: 0
  }
});
const Styles = {
  Mosaic: {
    backgroundColor: "#d0d0d0",
    backgroundImage: "linear-gradient(45deg, var(--color-transparent) 25%, transparent 25%), linear-gradient(-45deg, var(--color-transparent) 25%, transparent 25%), linear-gradient(45deg, transparent 75%, var(--color-transparent) 75%), linear-gradient(-45deg, transparent 75%, var(--color-transparent) 75%)",
    backgroundSize: "10px 10px",
    backgroundPosition: "0 0, 0 5px, 5px -5px, -5px 0px"
  },
  FocusState: {
    borderColor: "var(--contrast)",
    outline: 0,
    boxShadow: "0 0 0 0.25rem rgb(23 113 230 / 25%)"
  }
};
const Card = /* @__PURE__ */ createStyled("div", {
  target: "e1x2lmrp0"
})("padding:.8em .6em .8em 1.4em;background-color:#fff;border:1px solid rgba(0,0,0,0.06);box-shadow:0 1px 2px 0 rgba(0,0,0,0.05);transition:box-shadow .3s!important;", (props) => props.hoverable ? {
  "&:hover": {
    zIndex: 10
  }
} : {}, "");
const SpinnerKeyframes = keyframes({
  from: {
    transform: "rotate(0deg)"
  },
  to: {
    transform: "rotate(-360deg)"
  }
});
const SpinnerWrapper = /* @__PURE__ */ createStyled("div", {
  target: "e1dg6hoh0"
})({
  position: "absolute",
  top: "calc(50% - var(--size) * 0.5)",
  left: "calc(50% - var(--size) * 0.5)",
  width: "var(--size)",
  height: "var(--size)",
  animation: `${SpinnerKeyframes} 1.4s infinite linear`,
  svg: {
    display: "block",
    width: "var(--size)",
    height: "var(--size)"
  }
}, ({
  size = 30
}) => ({
  "--size": `${size}px`
}), "");
function Spinner(props) {
  return /* @__PURE__ */ jsx(SpinnerWrapper, {
    ...props,
    children: /* @__PURE__ */ jsxs("svg", {
      viewBox: "0 0 60 60",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      children: [/* @__PURE__ */ jsx("path", {
        fillRule: "evenodd",
        clipRule: "evenodd",
        d: "M30 60C46.5685 60 60 46.5685 60 30C60 13.4315 46.5685 0 30 0C13.4315 0 0 13.4315 0 30C0 46.5685 13.4315 60 30 60ZM30 50C41.0457 50 50 41.0457 50 30C50 18.9543 41.0457 10 30 10C18.9543 10 10 18.9543 10 30C10 41.0457 18.9543 50 30 50Z",
        fill: "url(#paint0_linear_313_15)"
      }), /* @__PURE__ */ jsx("path", {
        fillRule: "evenodd",
        clipRule: "evenodd",
        d: "M10 30H0C0 46.5685 13.4315 60 30 60V50C18.9543 50 10 41.0457 10 30Z",
        fill: "currentColor"
      }), /* @__PURE__ */ jsx("defs", {
        children: /* @__PURE__ */ jsxs("linearGradient", {
          id: "paint0_linear_313_15",
          x1: "30",
          y1: "30",
          x2: "17",
          y2: "30",
          gradientUnits: "userSpaceOnUse",
          children: [/* @__PURE__ */ jsx("stop", {
            stopColor: "currentColor",
            stopOpacity: "0"
          }), /* @__PURE__ */ jsx("stop", {
            offset: "0.198062",
            stopColor: "currentColor",
            stopOpacity: "0.217786"
          }), /* @__PURE__ */ jsx("stop", {
            offset: "0.434425",
            stopColor: "currentColor",
            stopOpacity: "0.477687"
          }), /* @__PURE__ */ jsx("stop", {
            offset: "1",
            stopColor: "currentColor"
          })]
        })
      })]
    })
  });
}
function IconPhone({
  size = 18
}) {
  return /* @__PURE__ */ jsx("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    width: size,
    height: size,
    children: /* @__PURE__ */ jsx("path", {
      fill: "currentColor",
      d: "M7 4v16h10V4H7zM6 2h12a1 1 0 0 1 1 1v18a1 1 0 0 1-1 1H6a1 1 0 0 1-1-1V3a1 1 0 0 1 1-1zm6 15a1 1 0 1 1 0 2 1 1 0 0 1 0-2z"
    })
  });
}
function IconDesktop({
  size = 24
}) {
  return /* @__PURE__ */ jsx("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    width: size,
    height: size,
    children: /* @__PURE__ */ jsx("path", {
      fill: "currentColor",
      d: "M4 16h16V5H4v11zm9 2v2h4v2H7v-2h4v-2H2.992A.998.998 0 0 1 2 16.993V4.007C2 3.451 2.455 3 2.992 3h18.016c.548 0 .992.449.992 1.007v12.986c0 .556-.455 1.007-.992 1.007H13z"
    })
  });
}
function IconCheck({
  size = 18
}) {
  return /* @__PURE__ */ jsxs("svg", {
    width: size,
    height: size,
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 16 16",
    children: [/* @__PURE__ */ jsx("path", {
      fill: "currentColor",
      d: "M13.315 2.716A7.461 7.461 0 102.763 13.268 7.461 7.461 0 0013.315 2.716zM8.039 14.454a6.468 6.468 0 01-6.46-6.46 6.468 6.468 0 016.46-6.462A6.468 6.468 0 0114.5 7.992a6.468 6.468 0 01-6.46 6.461z"
    }), /* @__PURE__ */ jsx("path", {
      fill: "currentColor",
      d: "M6.915 9.556L4.62 7.262l-.708.707 3.002 3.002 5.234-5.235-.707-.707-4.527 4.527z"
    })]
  });
}
function IconAlignLeft({
  size = 24
}) {
  return /* @__PURE__ */ jsxs("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    width: size,
    height: size,
    fill: "none",
    viewBox: "0 0 24 24",
    children: [/* @__PURE__ */ jsx("path", {
      fill: "currentColor",
      fillRule: "evenodd",
      d: "M10 6H5v13h5V6zM3 4v17h9V4H3z",
      clipRule: "evenodd"
    }), /* @__PURE__ */ jsx("path", {
      fill: "currentColor",
      d: "M22 7v2h-7V7h7zM22 11v2h-7v-2h7zM19 15v2h-4v-2h4z"
    })]
  });
}
function IconAlignRight({
  size = 24
}) {
  return /* @__PURE__ */ jsxs("svg", {
    width: size,
    height: size,
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    children: [/* @__PURE__ */ jsx("path", {
      fill: "currentColor",
      fillRule: "evenodd",
      d: "M19 6h-5v13h5V6zm-7-2v17h9V4h-9z",
      clipRule: "evenodd"
    }), /* @__PURE__ */ jsx("path", {
      fill: "currentColor",
      d: "M10 7v2H3V7h7zM10 11v2H3v-2h7zM7 15v2H3v-2h4z"
    })]
  });
}
function IconAlignTop({
  size = 24
}) {
  return /* @__PURE__ */ jsxs("svg", {
    width: size,
    height: size,
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    children: [/* @__PURE__ */ jsx("defs", {}), /* @__PURE__ */ jsx("path", {
      fill: "currentColor",
      fillRule: "evenodd",
      d: "M19 5H5v5h14V5zM3 3v9h18V3H3z",
      clipRule: "evenodd"
    }), /* @__PURE__ */ jsx("path", {
      fill: "currentColor",
      d: "M20 14v2H3v-2h17zM14 18v2H3v-2h11z"
    })]
  });
}
function IconAlignBottom({
  size = 24
}) {
  return /* @__PURE__ */ jsxs("svg", {
    width: size,
    height: size,
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    children: [/* @__PURE__ */ jsx("path", {
      fill: "currentColor",
      fillRule: "evenodd",
      d: "M19 14H5v5h14v-5zM3 12v9h18v-9H3z",
      clipRule: "evenodd"
    }), /* @__PURE__ */ jsx("path", {
      fill: "currentColor",
      d: "M20 4v2H3V4h17zM14 8v2H3V8h11zM7 12v2H3v-2h4z"
    })]
  });
}
function IconTextLeft({
  size = 24
}) {
  return /* @__PURE__ */ jsx("svg", {
    width: size,
    height: size,
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    children: /* @__PURE__ */ jsx("path", {
      fill: "currentColor",
      d: "M3 8V6h8v2zM3 13v-2h18v2zM3 18v-2h14v2z"
    })
  });
}
function IconTextCenter({
  size = 24
}) {
  return /* @__PURE__ */ jsx("svg", {
    width: size,
    height: size,
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    children: /* @__PURE__ */ jsx("path", {
      fill: "currentColor",
      d: "M8 8V6h8v2zM3 13v-2h18v2zM5 18v-2h14v2z"
    })
  });
}
function IconTextRight({
  size = 24
}) {
  return /* @__PURE__ */ jsx("svg", {
    width: size,
    height: size,
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    children: /* @__PURE__ */ jsx("path", {
      fill: "currentColor",
      d: "M11 8V6h10v2zM3 13v-2h18v2zM6 18v-2h15v2z"
    })
  });
}
function IconCirclePlus({
  size = 24
}) {
  return /* @__PURE__ */ jsxs("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    width: size,
    height: size,
    children: [/* @__PURE__ */ jsx("path", {
      fill: "none",
      d: "M0 0h24v24H0z"
    }), /* @__PURE__ */ jsx("path", {
      d: "M11 11V7h2v4h4v2h-4v4h-2v-4H7v-2h4zm1 11C6.477 22 2 17.523 2 12S6.477 2 12 2s10 4.477 10 10-4.477 10-10 10zm0-2a8 8 0 1 0 0-16 8 8 0 0 0 0 16z",
      fill: "currentColor"
    })]
  });
}
function IconDown({
  size = 24
}) {
  return /* @__PURE__ */ jsx("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    width: size,
    height: size,
    children: /* @__PURE__ */ jsx("path", {
      d: "M12 13.172l4.95-4.95 1.414 1.414L12 16 5.636 9.636 7.05 8.222z",
      fill: "currentColor"
    })
  });
}
function IconTrash({
  size = 24
}) {
  return /* @__PURE__ */ jsx("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    width: size,
    height: size,
    children: /* @__PURE__ */ jsx("path", {
      d: "M17 6h5v2h-2v13a1 1 0 0 1-1 1H5a1 1 0 0 1-1-1V8H2V6h5V3a1 1 0 0 1 1-1h8a1 1 0 0 1 1 1v3zm1 2H6v12h12V8zm-4.586 6l1.768 1.768-1.414 1.414L12 15.414l-1.768 1.768-1.414-1.414L10.586 14l-1.768-1.768 1.414-1.414L12 12.586l1.768-1.768 1.414 1.414L13.414 14zM9 4v2h6V4H9z",
      fill: "currentColor"
    })
  });
}
function IconCross({
  size = 24
}) {
  return /* @__PURE__ */ jsx("svg", {
    width: size,
    height: size,
    viewBox: "0 0 14 14",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    children: /* @__PURE__ */ jsx("path", {
      d: "M6.99999 5.58599L11.95 0.635986L13.364 2.04999L8.41399 6.99999L13.364 11.95L11.95 13.364L6.99999 8.41399L2.04999 13.364L0.635986 11.95L5.58599 6.99999L0.635986 2.04999L2.04999 0.635986L6.99999 5.58599Z",
      fill: "currentColor"
    })
  });
}
function IconSearch({
  size = 24
}) {
  return /* @__PURE__ */ jsx("svg", {
    width: size,
    height: size,
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    children: /* @__PURE__ */ jsx("path", {
      d: "m11.02 10.078 2.856 2.855-.943.943-2.855-2.855A6.002 6.002 0 0 1 .333 6.334c0-3.313 2.688-6 6-6a6.002 6.002 0 0 1 4.688 9.744Zm-1.337-.495a4.665 4.665 0 0 0-3.35-7.917 4.665 4.665 0 0 0-4.666 4.667 4.665 4.665 0 0 0 7.916 3.35l.1-.1Z",
      fill: "currentColor"
    })
  });
}
function IconCode({
  size = 24
}) {
  return /* @__PURE__ */ jsx("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    width: size,
    height: size,
    children: /* @__PURE__ */ jsx("path", {
      fill: "currentColor",
      d: "M24 12l-5.657 5.657-1.414-1.414L21.172 12l-4.243-4.243 1.414-1.414L24 12zM2.828 12l4.243 4.243-1.414 1.414L0 12l5.657-5.657L7.07 7.757 2.828 12zm6.96 9H7.66l6.552-18h2.128L9.788 21z"
    })
  });
}
function IconFolder({
  size = 24
}) {
  return /* @__PURE__ */ jsx("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    width: size,
    height: size,
    children: /* @__PURE__ */ jsx("path", {
      fill: "currentColor",
      d: "M3 21a1 1 0 0 1-1-1V4a1 1 0 0 1 1-1h7.414l2 2H20a1 1 0 0 1 1 1v3h-2V7h-7.414l-2-2H4v11.998L5.5 11h17l-2.31 9.243a1 1 0 0 1-.97.757H3zm16.938-8H7.062l-1.5 6h12.876l1.5-6z"
    })
  });
}
function IconSave({
  size = 24
}) {
  return /* @__PURE__ */ jsx("svg", {
    width: size,
    height: size,
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    children: /* @__PURE__ */ jsx("path", {
      d: "M7 19v-6h10v6h2V7.828L16.172 5H5v14h2zM4 3h13l4 4v13a1 1 0 0 1-1 1H4a1 1 0 0 1-1-1V4a1 1 0 0 1 1-1zm5 12v4h6v-4H9z",
      fill: "currentColor"
    })
  });
}
function IconCalendar({
  size = 24
}) {
  return /* @__PURE__ */ jsx("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    width: size,
    height: size,
    children: /* @__PURE__ */ jsx("path", {
      fill: "currentColor",
      d: "M17 3h4a1 1 0 0 1 1 1v16a1 1 0 0 1-1 1H3a1 1 0 0 1-1-1V4a1 1 0 0 1 1-1h4V1h2v2h6V1h2v2zm-2 2H9v2H7V5H4v4h16V5h-3v2h-2V5zm5 6H4v8h16v-8z"
    })
  });
}
function IconPage({
  size = 24
}) {
  return /* @__PURE__ */ jsx("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    width: size,
    height: size,
    children: /* @__PURE__ */ jsx("path", {
      fill: "currentColor",
      d: "M5 8v12h14V8H5zm0-2h14V4H5v2zm15 16H4a1 1 0 0 1-1-1V3a1 1 0 0 1 1-1h16a1 1 0 0 1 1 1v18a1 1 0 0 1-1 1zM7 10h4v4H7v-4zm0 6h10v2H7v-2zm6-5h4v2h-4v-2z"
    })
  });
}
function IconBlocs({
  size = 24
}) {
  return /* @__PURE__ */ jsxs("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    width: size,
    height: size,
    children: [/* @__PURE__ */ jsx("path", {
      fill: "currentColor",
      fillRule: "evenodd",
      d: "M4 4v5h16V4H4ZM3 2a1 1 0 0 0-1 1v7c0 .6.4 1 1 1h18c.6 0 1-.4 1-1V3c0-.6-.4-1-1-1H3ZM4 15v5h16v-5H4Zm-1-2a1 1 0 0 0-1 1v7c0 .6.4 1 1 1h18c.6 0 1-.4 1-1v-7c0-.6-.4-1-1-1H3Z",
      clipRule: "evenodd"
    }), /* @__PURE__ */ jsx("path", {
      fill: "currentColor",
      d: "M5 5h6v1H5V5ZM5 16h6v1H5v-1Z"
    })]
  });
}
function SortableWrapper({
  items,
  children,
  onMove
}) {
  const ids2 = items.map((item2) => item2._id);
  const sensors = useSensors(useSensor(PointerSensor), useSensor(KeyboardSensor, {
    coordinateGetter: sortableKeyboardCoordinates
  }));
  function handleDragEnd(event) {
    const {
      active,
      over
    } = event;
    if (over && active.id !== over.id) {
      onMove(ids2.indexOf(active.id.toString()), ids2.indexOf(over.id.toString()));
    }
  }
  return /* @__PURE__ */ jsx(DndContext, {
    sensors,
    collisionDetection: closestCenter,
    onDragEnd: handleDragEnd,
    modifiers: [restrictToVerticalAxis, restrictToParentElement],
    children: /* @__PURE__ */ jsx(SortableContext, {
      items: ids2,
      strategy: verticalListSortingStrategy,
      children
    })
  });
}
function Sortable({
  item: item2,
  children,
  className,
  ...props
}) {
  const {
    attributes,
    listeners,
    setNodeRef,
    transform,
    transition,
    isDragging
  } = useSortable({
    id: item2._id
  });
  const style2 = {
    transform: CSS.Translate.toString(transform),
    transition: transition || void 0
  };
  return /* @__PURE__ */ jsxs("div", {
    className,
    "data-dragging": isDragging ? true : void 0,
    ref: setNodeRef,
    style: style2,
    ...attributes,
    ...props,
    children: [/* @__PURE__ */ jsx(DragHandle, {
      ...listeners
    }), children]
  });
}
function moveItem(items, from3, to) {
  return arrayMove(items, from3, to);
}
function insertItem(items, index2, value) {
  const clone2 = [...items];
  clone2.splice(index2, 0, value);
  return clone2;
}
function createStore$1(createState) {
  let state;
  const listeners = /* @__PURE__ */ new Set();
  const setState = (partial, replace2) => {
    const nextState = typeof partial === "function" ? partial(state) : partial;
    if (nextState !== state) {
      const previousState = state;
      state = replace2 ? nextState : Object.assign({}, state, nextState);
      listeners.forEach((listener) => listener(state, previousState));
    }
  };
  const getState = () => state;
  const subscribeWithSelector = (listener, selector = getState, equalityFn = Object.is) => {
    console.warn("[DEPRECATED] Please use `subscribeWithSelector` middleware");
    let currentSlice = selector(state);
    function listenerToAdd() {
      const nextSlice = selector(state);
      if (!equalityFn(currentSlice, nextSlice)) {
        const previousSlice = currentSlice;
        listener(currentSlice = nextSlice, previousSlice);
      }
    }
    listeners.add(listenerToAdd);
    return () => listeners.delete(listenerToAdd);
  };
  const subscribe = (listener, selector, equalityFn) => {
    if (selector || equalityFn) {
      return subscribeWithSelector(listener, selector, equalityFn);
    }
    listeners.add(listener);
    return () => listeners.delete(listener);
  };
  const destroy2 = () => listeners.clear();
  const api = { setState, getState, subscribe, destroy: destroy2 };
  state = createState(setState, getState, api);
  return api;
}
const isSSR = typeof window === "undefined" || !window.navigator || /ServerSideRendering|^Deno\//.test(window.navigator.userAgent);
const useIsomorphicLayoutEffect$1 = isSSR ? react.exports.useEffect : react.exports.useLayoutEffect;
function create(createState) {
  const api = typeof createState === "function" ? createStore$1(createState) : createState;
  const useStore2 = (selector = api.getState, equalityFn = Object.is) => {
    const [, forceUpdate] = react.exports.useReducer((c3) => c3 + 1, 0);
    const state = api.getState();
    const stateRef = react.exports.useRef(state);
    const selectorRef = react.exports.useRef(selector);
    const equalityFnRef = react.exports.useRef(equalityFn);
    const erroredRef = react.exports.useRef(false);
    const currentSliceRef = react.exports.useRef();
    if (currentSliceRef.current === void 0) {
      currentSliceRef.current = selector(state);
    }
    let newStateSlice;
    let hasNewStateSlice = false;
    if (stateRef.current !== state || selectorRef.current !== selector || equalityFnRef.current !== equalityFn || erroredRef.current) {
      newStateSlice = selector(state);
      hasNewStateSlice = !equalityFn(currentSliceRef.current, newStateSlice);
    }
    useIsomorphicLayoutEffect$1(() => {
      if (hasNewStateSlice) {
        currentSliceRef.current = newStateSlice;
      }
      stateRef.current = state;
      selectorRef.current = selector;
      equalityFnRef.current = equalityFn;
      erroredRef.current = false;
    });
    const stateBeforeSubscriptionRef = react.exports.useRef(state);
    useIsomorphicLayoutEffect$1(() => {
      const listener = () => {
        try {
          const nextState = api.getState();
          const nextStateSlice = selectorRef.current(nextState);
          if (!equalityFnRef.current(currentSliceRef.current, nextStateSlice)) {
            stateRef.current = nextState;
            currentSliceRef.current = nextStateSlice;
            forceUpdate();
          }
        } catch (error) {
          erroredRef.current = true;
          forceUpdate();
        }
      };
      const unsubscribe = api.subscribe(listener);
      if (api.getState() !== stateBeforeSubscriptionRef.current) {
        listener();
      }
      return unsubscribe;
    }, []);
    const sliceToReturn = hasNewStateSlice ? newStateSlice : currentSliceRef.current;
    react.exports.useDebugValue(sliceToReturn);
    return sliceToReturn;
  };
  Object.assign(useStore2, api);
  useStore2[Symbol.iterator] = function() {
    console.warn("[useStore, api] = create() is deprecated and will be removed in v4");
    const items = [useStore2, api];
    return {
      next() {
        const done = items.length <= 0;
        return { value: items.shift(), done };
      }
    };
  };
  return useStore2;
}
function devtools(fn3, options) {
  return (set2, get3, api) => {
    var _a;
    let didWarnAboutNameDeprecation = false;
    if (typeof options === "string" && !didWarnAboutNameDeprecation) {
      console.warn("[zustand devtools middleware]: passing `name` as directly will be not allowed in next majorpass the `name` in an object `{ name: ... }` instead");
      didWarnAboutNameDeprecation = true;
    }
    const devtoolsOptions = options === void 0 ? { name: void 0, anonymousActionType: void 0 } : typeof options === "string" ? { name: options } : options;
    if (typeof ((_a = devtoolsOptions == null ? void 0 : devtoolsOptions.serialize) == null ? void 0 : _a.options) !== "undefined") {
      console.warn("[zustand devtools middleware]: `serialize.options` is deprecated, just use `serialize`");
    }
    let extensionConnector;
    try {
      extensionConnector = window.__REDUX_DEVTOOLS_EXTENSION__ || window.top.__REDUX_DEVTOOLS_EXTENSION__;
    } catch {
    }
    if (!extensionConnector) {
      if (({ "BASE_URL": "/", "MODE": "production", "DEV": false, "PROD": true } && "production") !== "production" && typeof window !== "undefined") {
        console.warn("[zustand devtools middleware] Please install/enable Redux devtools extension");
      }
      return fn3(set2, get3, api);
    }
    let extension = Object.create(extensionConnector.connect(devtoolsOptions));
    let didWarnAboutDevtools = false;
    Object.defineProperty(api, "devtools", {
      get: () => {
        if (!didWarnAboutDevtools) {
          console.warn("[zustand devtools middleware] `devtools` property on the store is deprecated it will be removed in the next major.\nYou shouldn't interact with the extension directly. But in case you still want to you can patch `window.__REDUX_DEVTOOLS_EXTENSION__` directly");
          didWarnAboutDevtools = true;
        }
        return extension;
      },
      set: (value) => {
        if (!didWarnAboutDevtools) {
          console.warn("[zustand devtools middleware] `api.devtools` is deprecated, it will be removed in the next major.\nYou shouldn't interact with the extension directly. But in case you still want to you can patch `window.__REDUX_DEVTOOLS_EXTENSION__` directly");
          didWarnAboutDevtools = true;
        }
        extension = value;
      }
    });
    let didWarnAboutPrefix = false;
    Object.defineProperty(extension, "prefix", {
      get: () => {
        if (!didWarnAboutPrefix) {
          console.warn("[zustand devtools middleware] along with `api.devtools`, `api.devtools.prefix` is deprecated.\nWe no longer prefix the actions/names" + devtoolsOptions.name === void 0 ? ", pass the `name` option to create a separate instance of devtools for each store." : ", because the `name` option already creates a separate instance of devtools for each store.");
          didWarnAboutPrefix = true;
        }
        return "";
      },
      set: () => {
        if (!didWarnAboutPrefix) {
          console.warn("[zustand devtools middleware] along with `api.devtools`, `api.devtools.prefix` is deprecated.\nWe no longer prefix the actions/names" + devtoolsOptions.name === void 0 ? ", pass the `name` option to create a separate instance of devtools for each store." : ", because the `name` option already creates a separate instance of devtools for each store.");
          didWarnAboutPrefix = true;
        }
      }
    });
    let isRecording = true;
    api.setState = (state, replace2, nameOrAction) => {
      set2(state, replace2);
      if (!isRecording)
        return;
      extension.send(nameOrAction === void 0 ? { type: devtoolsOptions.anonymousActionType || "anonymous" } : typeof nameOrAction === "string" ? { type: nameOrAction } : nameOrAction, get3());
    };
    const setStateFromDevtools = (...a4) => {
      const originalIsRecording = isRecording;
      isRecording = false;
      set2(...a4);
      isRecording = originalIsRecording;
    };
    const initialState = fn3(api.setState, get3, api);
    extension.init(initialState);
    if (api.dispatchFromDevtools && typeof api.dispatch === "function") {
      let didWarnAboutReservedActionType = false;
      const originalDispatch = api.dispatch;
      api.dispatch = (...a4) => {
        if (a4[0].type === "__setState" && !didWarnAboutReservedActionType) {
          console.warn('[zustand devtools middleware] "__setState" action type is reserved to set state from the devtools. Avoid using it.');
          didWarnAboutReservedActionType = true;
        }
        originalDispatch(...a4);
      };
    }
    extension.subscribe((message) => {
      var _a2;
      switch (message.type) {
        case "ACTION":
          if (typeof message.payload !== "string") {
            console.error("[zustand devtools middleware] Unsupported action format");
            return;
          }
          return parseJsonThen(message.payload, (action) => {
            if (action.type === "__setState") {
              setStateFromDevtools(action.state);
              return;
            }
            if (!api.dispatchFromDevtools)
              return;
            if (typeof api.dispatch !== "function")
              return;
            api.dispatch(action);
          });
        case "DISPATCH":
          switch (message.payload.type) {
            case "RESET":
              setStateFromDevtools(initialState);
              return extension.init(api.getState());
            case "COMMIT":
              return extension.init(api.getState());
            case "ROLLBACK":
              return parseJsonThen(message.state, (state) => {
                setStateFromDevtools(state);
                extension.init(api.getState());
              });
            case "JUMP_TO_STATE":
            case "JUMP_TO_ACTION":
              return parseJsonThen(message.state, (state) => {
                setStateFromDevtools(state);
              });
            case "IMPORT_STATE": {
              const { nextLiftedState } = message.payload;
              const lastComputedState = (_a2 = nextLiftedState.computedStates.slice(-1)[0]) == null ? void 0 : _a2.state;
              if (!lastComputedState)
                return;
              setStateFromDevtools(lastComputedState);
              extension.send(null, nextLiftedState);
              return;
            }
            case "PAUSE_RECORDING":
              return isRecording = !isRecording;
          }
          return;
      }
    });
    return initialState;
  };
}
const parseJsonThen = (stringified, f2) => {
  let parsed;
  try {
    parsed = JSON.parse(stringified);
  } catch (e3) {
    console.error("[zustand devtools middleware] Could not parse the received json", e3);
  }
  if (parsed !== void 0)
    f2(parsed);
};
const combine = (initialState, create2) => (set2, get3, api) => Object.assign({}, initialState, create2(set2, get3, api));
function createContext() {
  const ZustandContext = react.exports.createContext(void 0);
  const Provider2 = ({
    initialStore,
    createStore: createStore2,
    children
  }) => {
    const storeRef = react.exports.useRef();
    if (!storeRef.current) {
      if (initialStore) {
        console.warn("Provider initialStore is deprecated and will be removed in the next version.");
        if (!createStore2) {
          createStore2 = () => initialStore;
        }
      }
      storeRef.current = createStore2();
    }
    return react.exports.createElement(ZustandContext.Provider, { value: storeRef.current }, children);
  };
  const useStore2 = (selector, equalityFn = Object.is) => {
    const useProviderStore = react.exports.useContext(ZustandContext);
    if (!useProviderStore) {
      throw new Error("Seems like you have not used zustand provider as an ancestor.");
    }
    return useProviderStore(selector, equalityFn);
  };
  const useStoreApi = () => {
    const useProviderStore = react.exports.useContext(ZustandContext);
    if (!useProviderStore) {
      throw new Error("Seems like you have not used zustand provider as an ancestor.");
    }
    return react.exports.useMemo(() => ({
      getState: useProviderStore.getState,
      setState: useProviderStore.setState,
      subscribe: useProviderStore.subscribe,
      destroy: useProviderStore.destroy
    }), [useProviderStore]);
  };
  return {
    Provider: Provider2,
    useStore: useStore2,
    useStoreApi
  };
}
function fillDefaults(data, fields) {
  let newData = {
    ...data
  };
  for (const field of fields) {
    if (field.group) {
      newData = fillDefaults(newData, field.fields);
      continue;
    }
    const name = field.name;
    if (data[name] === void 0 && "default" in field.options) {
      newData[name] = field.options.default;
    }
  }
  return newData;
}
function t$2(key) {
  return Editor.i18n[key];
}
var InsertPosition = /* @__PURE__ */ ((InsertPosition2) => {
  InsertPosition2["Start"] = "start";
  InsertPosition2["End"] = "end";
  return InsertPosition2;
})(InsertPosition || {});
var PreviewModes = /* @__PURE__ */ ((PreviewModes2) => {
  PreviewModes2[PreviewModes2["PHONE"] = 0] = "PHONE";
  PreviewModes2[PreviewModes2["DESKTOP"] = 1] = "DESKTOP";
  return PreviewModes2;
})(PreviewModes || {});
const sidebarWidth = typeof localStorage !== "undefined" ? localStorage.getItem("veSidebarWidth") : 0;
const createStore = (data = [], definitions, hiddenCategories = [], rootElement, templates2, insertPosition) => create(devtools(combine({
  data,
  definitions,
  hiddenCategories,
  rootElement,
  templates: templates2,
  insertPosition,
  previousData: [],
  rollbackMessage: null,
  addBlockIndex: null,
  focusIndex: null,
  previewMode: 1,
  sidebarWidth: clamp$1(sidebarWidth ? parseInt(sidebarWidth, 10) : 33, 0, window.innerWidth - 375)
}, (set2) => ({
  setSidebarWidth: function(width) {
    localStorage.setItem("veSidebarWidth", width.toString());
    set2(() => ({
      sidebarWidth: width
    }));
  },
  updateData: function(newData, path) {
    return set2((state) => ({
      data: deepSet(state.data, path, newData)
    }));
  },
  removeBloc: function(removedData) {
    return set2(({
      data: data2
    }) => ({
      previousData: data2,
      data: data2.filter((d4) => d4 !== removedData),
      rollbackMessage: t$2("deleteItemConfirm")
    }));
  },
  rollback: function() {
    return set2(({
      previousData
    }) => ({
      previousData: [],
      rollbackMessage: null,
      data: previousData
    }));
  },
  voidRollback: function() {
    return set2(() => ({
      rollbackMessage: null,
      previousData: []
    }));
  },
  insertData: function(name, index2, extraData) {
    const newData = {
      ...extraData,
      _name: name,
      _id: name + uniqId()
    };
    set2((state) => {
      return {
        data: insertItem(state.data, index2, newData),
        focusIndex: newData._id
      };
    });
    return newData;
  },
  setData: function(newData) {
    set2(() => {
      return {
        data: indexify(newData),
        focusIndex: null
      };
    });
  },
  setFocusIndex: function(id2) {
    set2(() => ({
      focusIndex: id2
    }));
  },
  setAddBlockIndex: function(index2) {
    if (index2 === void 0) {
      set2((state) => ({
        addBlockIndex: state.insertPosition === InsertPosition.Start ? 0 : state.data.length
      }));
      return;
    }
    set2(() => ({
      addBlockIndex: index2
    }));
  },
  togglePreviewMode: function() {
    set2(({
      previewMode
    }) => ({
      previewMode: previewMode === 1 ? 0 : 1
    }));
  }
}))));
const {
  Provider,
  useStore
} = createContext();
function StoreProvider({
  children,
  data,
  definitions,
  hiddenCategories,
  rootElement,
  templates: templates2,
  insertPosition
}) {
  return /* @__PURE__ */ jsx(Provider, {
    createStore: () => createStore(data, definitions, hiddenCategories, rootElement, templates2, insertPosition),
    children
  });
}
function useData() {
  return useStore((state) => state.data);
}
function useRootElement() {
  return useStore((state) => state.rootElement);
}
function useUpdateData() {
  return useStore((state) => state.updateData);
}
function useRemoveBloc() {
  return useStore((state) => state.removeBloc);
}
function useInsertData() {
  return useStore((state) => state.insertData);
}
function useSetData() {
  return useStore((state) => state.setData);
}
function useDefinitions() {
  return useStore((state) => state.definitions);
}
function useSetFocusIndex() {
  return useStore((state) => state.setFocusIndex);
}
function useFieldFocused(id2) {
  return useStore((state) => state.focusIndex === id2);
}
function usePreviewMode() {
  return useStore((state) => state.previewMode);
}
function useTogglePreviewMode() {
  return useStore((state) => state.togglePreviewMode);
}
function useSidebarWidth() {
  return useStore((state) => state.sidebarWidth);
}
function useSetSidebarWidth() {
  return useStore((state) => state.setSidebarWidth);
}
function useFieldDefinitions() {
  return useStore((state) => state.definitions);
}
function useHiddenCategories() {
  return useStore((state) => state.hiddenCategories);
}
function useBlocSelectionVisible() {
  return useStore((state) => state.addBlockIndex) !== null;
}
function useSetBlockIndex() {
  return useStore((state) => state.setAddBlockIndex);
}
function useTemplates() {
  return useStore((state) => state.templates);
}
function useAddBlock() {
  const insertData = useInsertData();
  const blockIndex = useStore((state) => state.addBlockIndex) || 0;
  const definitions = useDefinitions();
  const setBlockIndex = useSetBlockIndex();
  return react.exports.useCallback((blocName) => {
    insertData(blocName, blockIndex, fillDefaults({}, definitions[blocName].fields));
    setBlockIndex(null);
  }, [insertData, blockIndex, definitions, setBlockIndex]);
}
function useRollbackMessage() {
  const message = useStore((state) => state.rollbackMessage);
  const rollback = useStore((state) => state.rollback);
  const voidRollback = useStore((state) => state.voidRollback);
  return {
    message,
    rollback,
    voidRollback
  };
}
const Wrapper$8 = /* @__PURE__ */ createStyled(Flex, {
  target: "e1l1taxg2"
})({
  name: "0",
  styles: ""
});
const Title$1 = /* @__PURE__ */ createStyled("div", {
  target: "e1l1taxg1"
})({
  name: "1oqnmi0",
  styles: "width:100%;color:var(--color);text-align:left;font-size:.95em;scroll-margin:1.8em;cursor:pointer;strong{display:block;color:var(--color-dark);font-weight:500;font-size:1.1em;}"
});
const HoverableActions = /* @__PURE__ */ createStyled(Flex, {
  target: "e1l1taxg0"
})({
  opacity: 0,
  transition: "opacity .3s",
  [`*:hover > * > &`]: {
    opacity: 1
  }
}, "");
const SidebarHeading = react.exports.forwardRef(({
  children,
  onClick,
  title: title2,
  description
}, ref) => {
  const as = onClick ? UnstyledButton : "div";
  return /* @__PURE__ */ jsxs(Wrapper$8, {
    ref,
    gap: 0,
    between: true,
    children: [/* @__PURE__ */ jsxs(Title$1, {
      as,
      onClick,
      children: [/* @__PURE__ */ jsx("strong", {
        children: title2
      }), description]
    }), children]
  });
});
SidebarHeading.displayName = "SidebarHeading";
const SidebarHeadingHoverable = (props) => {
  return /* @__PURE__ */ jsx(HoverableActions, {
    gap: 0,
    ...props
  });
};
SidebarHeading.Hover = SidebarHeadingHoverable;
const SidebarBlocWrapper = /* @__PURE__ */ createStyled(Sortable, {
  target: "SidebarBlocWrapper"
})({
  name: "uamvte",
  styles: "position:relative;padding:.8em .6em .8em 1.4em;background-color:#fff;border:1px solid rgba(0,0,0,0.06);box-shadow:0 1px 2px 0 rgba(0,0,0,0.05);transition:box-shadow .3s;cursor:inherit;&[data-dragging]{z-index:10;}"
});
var _ref$7 = {
  name: "h39r9o",
  styles: "background-color:var(--color-light);box-shadow:none"
};
function SidebarBlocMissing({
  data
}) {
  const removeBloc = useRemoveBloc();
  return /* @__PURE__ */ jsx(SidebarBlocWrapper, {
    item: data,
    css: _ref$7,
    children: /* @__PURE__ */ jsx(SidebarHeading, {
      title: `${t$2("unknownComponent")} : ${data._name}`,
      children: /* @__PURE__ */ jsx(ButtonIcon, {
        danger: true,
        onClick: prevent(() => removeBloc(data)),
        title: t$2("deleteComponent"),
        children: /* @__PURE__ */ jsx(IconTrash, {
          size: 20
        })
      })
    })
  });
}
function FieldsRenderer({
  data,
  fields,
  path,
  onUpdate
}) {
  return /* @__PURE__ */ jsx(Fragment$1, {
    children: fields.filter((field) => field.shouldRender(data)).map((field, k3) => field.group ? /* @__PURE__ */ jsx(field.render, {
      options: field.options,
      children: /* @__PURE__ */ jsx(FieldsRenderer, {
        fields: field.fields,
        data,
        path,
        onUpdate
      })
    }, k3) : /* @__PURE__ */ jsx(Field, {
      field,
      value: field.name ? data[field.name] : void 0,
      path: `${path}.${field.name}`,
      extraProps: field.extraProps ? field.extraProps(data) : void 0,
      onUpdate
    }, field.name))
  });
}
function Field({
  field,
  value,
  path,
  extraProps,
  onUpdate
}) {
  const Component2 = field.render;
  const handleChange = react.exports.useCallback((v2) => {
    onUpdate(v2, path);
  }, [path, onUpdate]);
  return /* @__PURE__ */ jsx(Component2, {
    value,
    onChange: handleChange,
    options: field.options,
    ...extraProps
  });
}
function SidebarFields({
  fields,
  data,
  path
}) {
  const updateData = useUpdateData();
  return /* @__PURE__ */ jsx(FieldsRenderer, {
    fields,
    data,
    onUpdate: updateData,
    path
  });
}
function CopyAction({
  data,
  size,
  ...props
}) {
  const [success2, setSuccess] = react.exports.useState(false);
  const timer = react.exports.useRef();
  const handleCopy = async () => {
    try {
      await copyToClipboard(stringifyFields(data));
      setSuccess(true);
      timer.current = window.setTimeout(() => {
        setSuccess(false);
      }, 4e3);
    } catch (e3) {
      alert(e3);
    }
  };
  const tooltipLabel = Array.isArray(data) ? t$2("copyPage") : t$2("copyComponent");
  react.exports.useEffect(() => {
    clearTimeout(timer.current);
  }, []);
  return /* @__PURE__ */ jsx(Tooltip, {
    content: success2 ? /* @__PURE__ */ jsxs(Fragment$1, {
      children: [t$2("copySuccess"), /* @__PURE__ */ jsx("br", {}), t$2("copyInstructions")]
    }) : tooltipLabel,
    trigger: "focus",
    children: /* @__PURE__ */ jsx("div", {
      children: /* @__PURE__ */ jsx(ButtonIcon, {
        onClick: prevent(handleCopy),
        success: success2,
        ...props,
        children: success2 ? /* @__PURE__ */ jsx(IconCheck, {
          size
        }) : /* @__PURE__ */ jsx(IconCode, {
          size
        })
      })
    })
  });
}
var _ref$6 = {
  name: "1xvwyp0",
  styles: "margin-top:.5em"
};
const SidebarBloc = react.exports.memo(function SidebarItem({
  data,
  definition,
  path
}) {
  const ref = react.exports.useRef(null);
  const isFocused = useFieldFocused(data._id);
  const [isCollapsed, toggleCollapsed, setCollapsed] = useToggle(!isFocused);
  const removeBloc = useRemoveBloc();
  const setFocusIndex = useSetFocusIndex();
  const label = (definition == null ? void 0 : definition.label) && data[definition.label] ? data[definition.label] : null;
  useUpdateEffect(() => {
    if (isFocused) {
      setCollapsed(false);
      window.setTimeout(() => ref.current.scrollIntoView({
        behavior: "smooth",
        block: "start"
      }), 100);
    } else {
      setCollapsed(true);
    }
  }, [isFocused]);
  const labelHTMLSafe = react.exports.useMemo(() => (label == null ? void 0 : label.includes("<")) ? strToDom(label).innerText : label, [label]);
  const handleRemove = () => {
    removeBloc(data);
  };
  const focusBloc = () => {
    if (isCollapsed) {
      setFocusIndex(path);
    }
    toggleCollapsed();
  };
  console.log(JSON.stringify(data));
  if (!definition) {
    return /* @__PURE__ */ jsx(SidebarBlocMissing, {
      data
    });
  }
  return /* @__PURE__ */ jsxs(SidebarBlocWrapper, {
    item: data,
    children: [/* @__PURE__ */ jsxs(SidebarHeading, {
      ref,
      title: definition.title,
      description: isCollapsed ? labelHTMLSafe : null,
      onClick: prevent(focusBloc),
      children: [/* @__PURE__ */ jsxs(SidebarHeading.Hover, {
        children: [/* @__PURE__ */ jsx(CopyAction, {
          data,
          size: 20
        }), /* @__PURE__ */ jsx(ButtonIcon, {
          danger: true,
          onClick: handleRemove,
          title: t$2("deleteComponent"),
          children: /* @__PURE__ */ jsx(IconTrash, {
            size: 20
          })
        })]
      }), /* @__PURE__ */ jsx(ButtonIcon, {
        rotate: isCollapsed ? -90 : 0,
        onClick: prevent(toggleCollapsed),
        children: /* @__PURE__ */ jsx(IconDown, {
          size: 20
        })
      })]
    }), !isCollapsed && /* @__PURE__ */ jsx(Flex, {
      column: true,
      gap: 1,
      css: _ref$6,
      children: /* @__PURE__ */ jsx(SidebarFields, {
        fields: definition.fields,
        data,
        path
      })
    })]
  });
});
function SidebarBlocs({
  data
}) {
  const updateData = useUpdateData();
  const definitions = useFieldDefinitions();
  const handleMove = (from3, to) => {
    updateData(moveItem(data, from3, to));
  };
  return /* @__PURE__ */ jsx(Wrapper$7, {
    children: /* @__PURE__ */ jsx(SortableWrapper, {
      items: data,
      onMove: handleMove,
      children: data.map((v2, k3) => /* @__PURE__ */ jsx(SidebarBloc, {
        data: v2,
        definition: definitions[v2._name],
        path: `${k3}`
      }, v2._id))
    })
  });
}
const Wrapper$7 = /* @__PURE__ */ createStyled("div", {
  target: "e19cyu0e0"
})({
  name: "fr4z9h",
  styles: "display:grid;grid-template-columns:1fr;flex-direction:column;grid-gap:1em;padding:1em;overflow:auto;scrollbar-gutter:stable"
});
function SidebarHeader({
  onClose,
  children
}) {
  const togglePreviewMode = useTogglePreviewMode();
  const previewMode = usePreviewMode();
  const isPhone = previewMode === PreviewModes.PHONE;
  const setAddBlock = useSetBlockIndex();
  const data = useData();
  return /* @__PURE__ */ jsxs(Wrapper$6, {
    between: true,
    children: [/* @__PURE__ */ jsx("div", {
      children: /* @__PURE__ */ jsx(ButtonIcon, {
        title: t$2("close"),
        onClick: prevent(onClose),
        children: /* @__PURE__ */ jsx(IconCross, {
          size: 12
        })
      })
    }), /* @__PURE__ */ jsxs(Flex, {
      children: [children, /* @__PURE__ */ jsx(CopyAction, {
        data,
        size: 20
      }), /* @__PURE__ */ jsx(ButtonIcon, {
        onClick: prevent(togglePreviewMode),
        title: t$2("responsiveView"),
        children: isPhone ? /* @__PURE__ */ jsx(IconDesktop, {
          size: 20
        }) : /* @__PURE__ */ jsx(IconPhone, {
          size: 24
        })
      }), /* @__PURE__ */ jsx(Button$1, {
        icon: IconCirclePlus,
        onClick: prevent(() => setAddBlock()),
        children: t$2("addComponent")
      })]
    })]
  });
}
const Wrapper$6 = /* @__PURE__ */ createStyled(Flex, {
  target: "e1c0grpi0"
})({
  name: "dryaye",
  styles: "padding:0 1em;flex:none;background-color:#FFF;border-bottom:1px solid rgba(0,0,0,0.06);box-shadow:rgba(0, 0, 0, 0.05) 0 1px 2px 0;height:64px"
});
function SidebarFooter() {
  return /* @__PURE__ */ jsx(Wrapper$5, {
    between: true,
    children: /* @__PURE__ */ jsx(Button$1, {
      type: "submit",
      icon: IconSave,
      children: t$2("save")
    })
  });
}
const Wrapper$5 = /* @__PURE__ */ createStyled(Flex, {
  target: "e1xusuwu0"
})({
  name: "1t65jij",
  styles: "margin-top:auto;background-color:#FFF;justify-content:flex-end;border-top:1px solid rgba(0,0,0,0.06);padding:.5em 1em;box-shadow:0 -1px 2px 0 rgba(0,0,0,0.05)"
});
function SidebarEmpty(data) {
  return /* @__PURE__ */ jsxs(Wrapper$4, {
    children: [/* @__PURE__ */ jsx(Description, {
      children: t$2("noContent")
    }), /* @__PURE__ */ jsx("div", {
      children: /* @__PURE__ */ jsx(Button$1, {
        outline: true,
        onClick: prevent(data.onAction),
        size: "small",
        children: t$2("useTemplate")
      })
    })]
  });
}
const Wrapper$4 = /* @__PURE__ */ createStyled("div", {
  target: "e1fevb3i1"
})({
  name: "d3jdti",
  styles: "display:flex;align-items:center;flex-direction:column;justify-content:center;height:100%;text-align:center"
});
const Description = /* @__PURE__ */ createStyled("p", {
  target: "e1fevb3i0"
})({
  name: "1gpzra0",
  styles: "margin-bottom:1em"
});
function SidebarTemplates({
  onTemplate
}) {
  const templates2 = useTemplates();
  const setData = useSetData();
  const [loadingTemplate, setLoadingTemplate] = react.exports.useState();
  const callback = react.exports.useCallback(async (t3) => {
    setLoadingTemplate(t3);
    let data;
    if (typeof t3.data === "function") {
      setLoadingTemplate(t3);
      data = await t3.data().catch(() => []);
      setLoadingTemplate(t3);
    } else {
      data = t3.data;
    }
    setData(data);
    onTemplate();
  }, [setData, onTemplate]);
  return /* @__PURE__ */ jsx(Wrapper$3, {
    children: templates2.map((t3) => /* @__PURE__ */ jsx(TemplateCard, {
      template: t3,
      onClick: callback,
      loading: loadingTemplate === t3
    }))
  });
}
function TemplateCard({
  template,
  onClick,
  loading
}) {
  return /* @__PURE__ */ jsxs(StyledCard, {
    hoverable: true,
    onClick: prevent(() => loading ? null : onClick(template)),
    loading,
    children: [loading && /* @__PURE__ */ jsx(Spinner, {}), /* @__PURE__ */ jsx(TemplateImage, {
      src: template.image,
      alt: ""
    }), /* @__PURE__ */ jsxs(Body, {
      children: [/* @__PURE__ */ jsx(Title, {
        children: template.name
      }), /* @__PURE__ */ jsx("div", {
        children: template.description
      })]
    })]
  });
}
const Wrapper$3 = /* @__PURE__ */ createStyled("div", {
  target: "e1nj7kcq4"
})({
  name: "rouwkd",
  styles: "display:flex;flex-direction:column;justify-content:flex-start;height:100%;padding:1em;gap:1em;overflow:auto"
});
const StyledCard = /* @__PURE__ */ createStyled(Card, {
  target: "e1nj7kcq3"
})("padding:0;display:grid;position:relative;grid-template-columns:150px 1fr;grid-gap:1.5em;align-items:center;width:100%;cursor:pointer;", (props) => props.loading ? {
  opacity: 0.4,
  cursor: "inherit"
} : {}, "");
const TemplateImage = /* @__PURE__ */ createStyled("img", {
  target: "e1nj7kcq2"
})({
  name: "1iynevt",
  styles: "width:100%;height:150px;object-fit:cover"
});
const Body = /* @__PURE__ */ createStyled("div", {
  target: "e1nj7kcq1"
})({
  name: "j8h71g",
  styles: "display:grid;grid-template-columns:1fr"
});
const Title = /* @__PURE__ */ createStyled("div", {
  target: "e1nj7kcq0"
})({
  name: "j221xy",
  styles: "color:var(--color-dark);font-weight:500;font-size:1.1em"
});
function Sidebar({
  data,
  onClose,
  ...props
}) {
  const [state, setState] = react.exports.useState(0);
  const templates2 = useTemplates();
  const toggleMode = react.exports.useCallback(() => {
    setState((v2) => v2 === 0 ? 1 : 0);
  }, []);
  const hasTemplates = templates2.length > 0;
  const showEmpty = data.length === 0 && hasTemplates;
  const isTemplateMode = state === 1;
  return /* @__PURE__ */ jsxs(SidebarWrapper, {
    ...props,
    children: [/* @__PURE__ */ jsx(SidebarHeader, {
      onClose,
      children: hasTemplates && /* @__PURE__ */ jsx(ButtonIcon, {
        onClick: prevent(toggleMode),
        title: t$2(isTemplateMode ? "addComponent" : "useTemplate"),
        children: isTemplateMode ? /* @__PURE__ */ jsx(IconBlocs, {}) : /* @__PURE__ */ jsx(IconPage, {})
      })
    }), state === 0 && (showEmpty ? /* @__PURE__ */ jsx(SidebarEmpty, {
      onAction: () => setState(1)
    }) : /* @__PURE__ */ jsx(SidebarBlocs, {
      data
    })), state === 1 && /* @__PURE__ */ jsx(SidebarTemplates, {
      onTemplate: () => setState(0)
    }), /* @__PURE__ */ jsx(SidebarFooter, {})]
  });
}
const Out$2 = keyframes({
  from: {
    transform: "translateX(0)"
  },
  to: {
    transform: "translateX(-100%)"
  }
});
const In$3 = keyframes({
  from: {
    transform: "translateX(-100%)"
  },
  to: {
    transform: "translateX(0)"
  }
});
const SidebarWrapper = /* @__PURE__ */ createStyled("div", {
  target: "evyczb0"
})({
  position: "relative",
  display: "flex",
  flexDirection: "column",
  height: "100vh",
  backgroundColor: "#FBFBFD",
  zIndex: 2,
  boxShadow: "0 20px 25px -5px rgba(0,0,0,0.2),0 10px 10px -5px rgba(0,0,0,0.04)",
  transition: "transform .5s cubic-bezier(0.19, 1, 0.22, 1)",
  animation: `${In$3} .7s cubic-bezier(0.19, 1, 0.22, 1) both`,
  "[hidden=hidden] &": {
    animation: `${Out$2} .7s cubic-bezier(0.19, 1, 0.22, 1) both`
  }
}, "");
function on(obj) {
  var args = [];
  for (var _i = 1; _i < arguments.length; _i++) {
    args[_i - 1] = arguments[_i];
  }
  if (obj && obj.addEventListener) {
    obj.addEventListener.apply(obj, args);
  }
}
function off(obj) {
  var args = [];
  for (var _i = 1; _i < arguments.length; _i++) {
    args[_i - 1] = arguments[_i];
  }
  if (obj && obj.removeEventListener) {
    obj.removeEventListener.apply(obj, args);
  }
}
var isBrowser = typeof window !== "undefined";
var useEffectOnce = function(effect3) {
  react.exports.useEffect(effect3, []);
};
var useEffectOnce$1 = useEffectOnce;
var useUnmount = function(fn3) {
  var fnRef = react.exports.useRef(fn3);
  fnRef.current = fn3;
  useEffectOnce$1(function() {
    return function() {
      return fnRef.current();
    };
  });
};
var useUnmount$1 = useUnmount;
var useRafState = function(initialState) {
  var frame2 = react.exports.useRef(0);
  var _a = react.exports.useState(initialState), state = _a[0], setState = _a[1];
  var setRafState = react.exports.useCallback(function(value) {
    cancelAnimationFrame(frame2.current);
    frame2.current = requestAnimationFrame(function() {
      setState(value);
    });
  }, []);
  useUnmount$1(function() {
    cancelAnimationFrame(frame2.current);
  });
  return [state, setRafState];
};
var useRafState$1 = useRafState;
var useWindowSize = function(initialWidth, initialHeight) {
  if (initialWidth === void 0) {
    initialWidth = Infinity;
  }
  if (initialHeight === void 0) {
    initialHeight = Infinity;
  }
  var _a = useRafState$1({
    width: isBrowser ? window.innerWidth : initialWidth,
    height: isBrowser ? window.innerHeight : initialHeight
  }), state = _a[0], setState = _a[1];
  react.exports.useEffect(function() {
    if (isBrowser) {
      var handler_1 = function() {
        setState({
          width: window.innerWidth,
          height: window.innerHeight
        });
      };
      on(window, "resize", handler_1);
      return function() {
        off(window, "resize", handler_1);
      };
    }
  }, []);
  return state;
};
var useWindowSize$1 = useWindowSize;
const PHONE_HEIGHT = 844;
/*! @license Rematrix v0.2.2

	Copyright 2018 Fisssion LLC.

	Permission is hereby granted, free of charge, to any person obtaining a copy
	of this software and associated documentation files (the "Software"), to deal
	in the Software without restriction, including without limitation the rights
	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	copies of the Software, and to permit persons to whom the Software is
	furnished to do so, subject to the following conditions:

	The above copyright notice and this permission notice shall be included in
	all copies or substantial portions of the Software.

	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	THE SOFTWARE.
*/
function format$1(source) {
  if (source.constructor !== Array) {
    throw new TypeError("Expected array.");
  }
  if (source.length === 16) {
    return source;
  }
  if (source.length === 6) {
    var matrix2 = identity();
    matrix2[0] = source[0];
    matrix2[1] = source[1];
    matrix2[4] = source[2];
    matrix2[5] = source[3];
    matrix2[12] = source[4];
    matrix2[13] = source[5];
    return matrix2;
  }
  throw new RangeError("Expected array with either 6 or 16 values.");
}
function identity() {
  var matrix2 = [];
  for (var i3 = 0; i3 < 16; i3++) {
    i3 % 5 == 0 ? matrix2.push(1) : matrix2.push(0);
  }
  return matrix2;
}
function multiply(m4, x3) {
  var fm = format$1(m4);
  var fx = format$1(x3);
  var product = [];
  for (var i3 = 0; i3 < 4; i3++) {
    var row2 = [fm[i3], fm[i3 + 4], fm[i3 + 8], fm[i3 + 12]];
    for (var j2 = 0; j2 < 4; j2++) {
      var k3 = j2 * 4;
      var col = [fx[k3], fx[k3 + 1], fx[k3 + 2], fx[k3 + 3]];
      var result = row2[0] * col[0] + row2[1] * col[1] + row2[2] * col[2] + row2[3] * col[3];
      product[i3 + k3] = result;
    }
  }
  return product;
}
function parse$1(source) {
  if (typeof source === "string") {
    var match2 = source.match(/matrix(3d)?\(([^)]+)\)/);
    if (match2) {
      var raw = match2[2].split(", ").map(parseFloat);
      return format$1(raw);
    }
  }
  return identity();
}
function scaleX(scalar) {
  var matrix2 = identity();
  matrix2[0] = scalar;
  return matrix2;
}
function scaleY(scalar) {
  var matrix2 = identity();
  matrix2[5] = scalar;
  return matrix2;
}
function translateX(distance) {
  var matrix2 = identity();
  matrix2[12] = distance;
  return matrix2;
}
function translateY(distance) {
  var matrix2 = identity();
  matrix2[13] = distance;
  return matrix2;
}
var a$1 = function(t3) {
  return "number" == typeof t3;
}, o$1 = function(t3) {
  return "function" == typeof t3;
}, l$1 = function(t3) {
  return "[object Object]" === Object.prototype.toString.call(t3);
}, p$2 = function(t3) {
  return Array.prototype.slice.apply(t3);
}, c$3 = function(t3) {
  var e3 = t3.reduce(function(t4, e4) {
    return t4[e4] = (t4[e4] || 0) + 1, t4;
  }, {});
  return Object.keys(e3).filter(function(t4) {
    return e3[t4] > 1;
  });
};
function u$2(t3) {
  return [].slice.call(arguments, 1).forEach(function(e3) {
    if (e3)
      for (var i3 in e3)
        Object.prototype.hasOwnProperty.call(e3, i3) && (t3[i3] = e3[i3]);
  }), t3;
}
var d$2, f$3 = function(t3, e3, i3) {
  return t3 + (e3 - t3) * i3;
}, h$3 = { __proto__: null, isNumber: a$1, isFunction: o$1, isObject: l$1, toArray: p$2, getDuplicateValsAsStrings: c$3, assign: u$2, tweenProp: f$3 }, g$2 = { __proto__: null, DATA_FLIP_ID: "data-flip-id", DATA_INVERSE_FLIP_ID: "data-inverse-flip-id", DATA_FLIP_COMPONENT_ID: "data-flip-component-id", DATA_FLIP_CONFIG: "data-flip-config", DATA_PORTAL_KEY: "data-portal-key", DATA_EXIT_CONTAINER: "data-exit-container" }, m$3 = { noWobble: { stiffness: 200, damping: 26 }, gentle: { stiffness: 120, damping: 14 }, veryGentle: { stiffness: 130, damping: 17 }, wobbly: { stiffness: 180, damping: 12 }, stiff: { stiffness: 260, damping: 26 } }, v$1 = function(t3) {
  return l$1(t3) ? t3 : Object.keys(m$3).indexOf(t3) > -1 ? m$3[t3] : {};
};
"undefined" != typeof window && (d$2 = window.requestAnimationFrame);
var y$1 = d$2 = d$2 || function(t3) {
  window.setTimeout(t3, 1e3 / 60);
}, _$1 = Date.now(), S$1 = "object" == typeof performance && "function" == typeof performance.now ? function() {
  return performance.now();
} : function() {
  return Date.now() - _$1;
};
function E$2(t3, e3) {
  var i3 = t3.indexOf(e3);
  -1 !== i3 && t3.splice(i3, 1);
}
var A$1 = function() {
  function t3() {
  }
  return t3.prototype.run = function() {
    var t4 = this;
    y$1(function() {
      t4.springSystem.loop(S$1());
    });
  }, t3;
}(), C$1 = function() {
  this.position = 0, this.velocity = 0;
}, b$1 = 0, I = function() {
  function t3(t4) {
    this._id = "s" + b$1++, this._springSystem = t4, this.listeners = [], this._startValue = 0, this._currentState = new C$1(), this._displacementFromRestThreshold = 1e-3, this._endValue = 0, this._overshootClampingEnabled = false, this._previousState = new C$1(), this._restSpeedThreshold = 1e-3, this._tempState = new C$1(), this._timeAccumulator = 0, this._wasAtRest = true, this._cachedSpringConfig = {};
  }
  var e3 = t3.prototype;
  return e3.getId = function() {
    return this._id;
  }, e3.destroy = function() {
    this.listeners = [], this._springSystem.deregisterSpring(this);
  }, e3.setSpringConfig = function(t4) {
    return this._springConfig = t4, this;
  }, e3.getCurrentValue = function() {
    return this._currentState.position;
  }, e3.getDisplacementDistanceForState = function(t4) {
    return Math.abs(this._endValue - t4.position);
  }, e3.setEndValue = function(t4) {
    if (t4 === this._endValue)
      return this;
    if (this.prevEndValue = t4, this._endValue === t4 && this.isAtRest())
      return this;
    this._startValue = this.getCurrentValue(), this._endValue = t4, this._springSystem.activateSpring(this.getId());
    for (var e4 = 0, i3 = this.listeners.length; e4 < i3; e4++) {
      var n2 = this.listeners[e4].onSpringEndStateChange;
      n2 && n2(this);
    }
    return this;
  }, e3.setVelocity = function(t4) {
    return t4 === this._currentState.velocity || (this._currentState.velocity = t4, this._springSystem.activateSpring(this.getId())), this;
  }, e3.setCurrentValue = function(t4) {
    this._startValue = t4, this._currentState.position = t4;
    for (var e4 = 0, i3 = this.listeners.length; e4 < i3; e4++) {
      var n2 = this.listeners[e4];
      n2.onSpringUpdate && n2.onSpringUpdate(this);
    }
    return this;
  }, e3.setAtRest = function() {
    return this._endValue = this._currentState.position, this._tempState.position = this._currentState.position, this._currentState.velocity = 0, this;
  }, e3.setOvershootClampingEnabled = function(t4) {
    return this._overshootClampingEnabled = t4, this;
  }, e3.isOvershooting = function() {
    var t4 = this._startValue, e4 = this._endValue;
    return this._springConfig.tension > 0 && (t4 < e4 && this.getCurrentValue() > e4 || t4 > e4 && this.getCurrentValue() < e4);
  }, e3.advance = function(t4, e4) {
    var i3 = this.isAtRest();
    if (!i3 || !this._wasAtRest) {
      var n2 = e4;
      e4 > 0.064 && (n2 = 0.064), this._timeAccumulator += n2;
      for (var r2, s4, a4, o2, l2, p2, c3 = this._springConfig.tension, u3 = this._springConfig.friction, d4 = this._currentState.position, f2 = this._currentState.velocity, h4 = this._tempState.position, g2 = this._tempState.velocity; this._timeAccumulator >= 1e-3; )
        this._timeAccumulator -= 1e-3, this._timeAccumulator < 1e-3 && (this._previousState.position = d4, this._previousState.velocity = f2), s4 = c3 * (this._endValue - h4) - u3 * f2, o2 = c3 * (this._endValue - (h4 = d4 + 1e-3 * (r2 = f2) * 0.5)) - u3 * (g2 = f2 + 1e-3 * s4 * 0.5), p2 = c3 * (this._endValue - (h4 = d4 + 1e-3 * (a4 = g2) * 0.5)) - u3 * (g2 = f2 + 1e-3 * o2 * 0.5), h4 = d4 + 1e-3 * (l2 = g2), d4 += 1 / 6 * (r2 + 2 * (a4 + l2) + (g2 = f2 + 1e-3 * p2)) * 1e-3, f2 += 1 / 6 * (s4 + 2 * (o2 + p2) + (c3 * (this._endValue - h4) - u3 * g2)) * 1e-3;
      this._tempState.position = h4, this._tempState.velocity = g2, this._currentState.position = d4, this._currentState.velocity = f2, this._timeAccumulator > 0 && this._interpolate(this._timeAccumulator / 1e-3), (this.isAtRest() || this._overshootClampingEnabled && this.isOvershooting()) && (this._springConfig.tension > 0 ? (this._startValue = this._endValue, this._currentState.position = this._endValue) : (this._endValue = this._currentState.position, this._startValue = this._endValue), this.setVelocity(0), i3 = true);
      var m4 = false;
      this._wasAtRest && (this._wasAtRest = false, m4 = true);
      var v2 = false;
      i3 && (this._wasAtRest = true, v2 = true), this.notifyPositionUpdated(m4, v2);
    }
  }, e3.notifyPositionUpdated = function(t4, e4) {
    var i3 = this;
    this.listeners.filter(Boolean).forEach(function(n2) {
      t4 && n2.onSpringActivate && !i3._onActivateCalled && (n2.onSpringActivate(i3), i3._onActivateCalled = true), n2.onSpringUpdate && n2.onSpringUpdate(i3), e4 && n2.onSpringAtRest && n2.onSpringAtRest(i3);
    });
  }, e3.systemShouldAdvance = function() {
    return !this.isAtRest() || !this.wasAtRest();
  }, e3.wasAtRest = function() {
    return this._wasAtRest;
  }, e3.isAtRest = function() {
    return Math.abs(this._currentState.velocity) < this._restSpeedThreshold && (this.getDisplacementDistanceForState(this._currentState) <= this._displacementFromRestThreshold || 0 === this._springConfig.tension);
  }, e3._interpolate = function(t4) {
    this._currentState.position = this._currentState.position * t4 + this._previousState.position * (1 - t4), this._currentState.velocity = this._currentState.velocity * t4 + this._previousState.velocity * (1 - t4);
  }, e3.addListener = function(t4) {
    return this.listeners.push(t4), this;
  }, e3.addOneTimeListener = function(t4) {
    var e4 = this;
    return Object.keys(t4).forEach(function(i3) {
      var n2;
      t4[i3] = (n2 = t4[i3], function() {
        n2.apply(void 0, [].slice.call(arguments)), e4.removeListener(t4);
      });
    }), this.listeners.push(t4), this;
  }, e3.removeListener = function(t4) {
    return E$2(this.listeners, t4), this;
  }, t3;
}(), O$1 = function() {
  function t3(t4) {
    this.looper = t4 || new A$1(), this.looper.springSystem = this, this.listeners = [], this._activeSprings = [], this._idleSpringIndices = [], this._isIdle = true, this._lastTimeMillis = -1, this._springRegistry = {};
  }
  var e3 = t3.prototype;
  return e3.createSpring = function(t4, e4) {
    return this.createSpringWithConfig({ tension: t4, friction: e4 });
  }, e3.createSpringWithConfig = function(t4) {
    var e4 = new I(this);
    return this.registerSpring(e4), e4.setSpringConfig(t4), e4;
  }, e3.getIsIdle = function() {
    return this._isIdle;
  }, e3.registerSpring = function(t4) {
    this._springRegistry[t4.getId()] = t4;
  }, e3.deregisterSpring = function(t4) {
    E$2(this._activeSprings, t4), delete this._springRegistry[t4.getId()];
  }, e3.advance = function(t4, e4) {
    for (var i3 = this; this._idleSpringIndices.length > 0; )
      this._idleSpringIndices.pop();
    for (this._activeSprings.filter(Boolean).forEach(function(n3) {
      n3.systemShouldAdvance() ? n3.advance(t4 / 1e3, e4 / 1e3) : i3._idleSpringIndices.push(i3._activeSprings.indexOf(n3));
    }); this._idleSpringIndices.length > 0; ) {
      var n2 = this._idleSpringIndices.pop();
      n2 >= 0 && this._activeSprings.splice(n2, 1);
    }
  }, e3.loop = function(t4) {
    var e4;
    -1 === this._lastTimeMillis && (this._lastTimeMillis = t4 - 1);
    var i3 = t4 - this._lastTimeMillis;
    this._lastTimeMillis = t4;
    var n2 = 0, r2 = this.listeners.length;
    for (n2 = 0; n2 < r2; n2++)
      (e4 = this.listeners[n2]).onBeforeIntegrate && e4.onBeforeIntegrate(this);
    for (this.advance(t4, i3), 0 === this._activeSprings.length && (this._isIdle = true, this._lastTimeMillis = -1), n2 = 0; n2 < r2; n2++)
      (e4 = this.listeners[n2]).onAfterIntegrate && e4.onAfterIntegrate(this);
    this._isIdle || this.looper.run();
  }, e3.activateSpring = function(t4) {
    var e4 = this._springRegistry[t4];
    -1 === this._activeSprings.indexOf(e4) && this._activeSprings.push(e4), this.getIsIdle() && (this._isIdle = false, this.looper.run());
  }, t3;
}(), w$2 = new O$1(), x$2 = function(t3) {
  var e3 = t3.springConfig, i3 = e3.overshootClamping, n2 = t3.getOnUpdateFunc, r2 = t3.onAnimationEnd, s4 = t3.onSpringActivate, a4 = w$2.createSpring(e3.stiffness, e3.damping);
  a4.setOvershootClampingEnabled(!!i3);
  var o2 = { onSpringActivate: s4, onSpringAtRest: function() {
    a4.destroy(), r2();
  }, onSpringUpdate: n2({ spring: a4, onAnimationEnd: r2 }) };
  return a4.addListener(o2), a4;
}, U = function(t3) {
  var e3 = x$2(t3);
  return e3.setEndValue(1), e3;
}, V = function(t3, e3) {
  if (void 0 === e3 && (e3 = {}), t3 && t3.length) {
    e3.reverse && t3.reverse();
    var i3, n2 = "number" != typeof (i3 = e3.speed) ? 1.1 : 1 + Math.min(Math.max(5 * i3, 0), 5), r2 = 1 / Math.max(Math.min(t3.length, 100), 10), s4 = t3.map(function(t4, e4) {
      var i4 = t4.getOnUpdateFunc;
      return t4.getOnUpdateFunc = function(t5) {
        var a4 = i4(t5);
        return function(t6) {
          var i5 = t6.getCurrentValue();
          (i5 = i5 < 0.01 ? 0 : i5 > 0.99 ? 1 : i5) >= r2 && s4[e4 + 1] && s4[e4 + 1](Math.max(Math.min(i5 * n2, 1), 0)), a4(t6);
        };
      }, t4;
    }).map(function(t4) {
      var e4 = x$2(t4);
      if (e4)
        return e4.setEndValue.bind(e4);
    }).filter(Boolean);
    s4[0] && s4[0](1);
  }
}, F = function(t3) {
  return [0, 1, 4, 5, 12, 13].map(function(e3) {
    return t3[e3];
  });
}, P$1 = function(t3) {
  return t3.top < window.innerHeight && t3.bottom > 0 && t3.left < window.innerWidth && t3.right > 0;
};
function R$2(t3) {
  return JSON.parse(t3.dataset.flipConfig || "{}");
}
var T$1 = function(t3, e3) {
  var i3;
  return u$2(t3, ((i3 = {})[e3[0]] = e3[1], i3));
}, D$1 = function(t3, e3) {
  return p$2(e3 ? document.querySelectorAll('[data-portal-key="' + e3 + '"]') : t3.querySelectorAll("[data-flip-id]"));
}, M$1 = function(t3) {
  return t3.map(function(t4) {
    return [t4, t4.getBoundingClientRect()];
  });
}, k = function(l2) {
  var d4, h4 = l2.cachedOrderedFlipIds, g2 = void 0 === h4 ? [] : h4, y4 = l2.inProgressAnimations, _2 = void 0 === y4 ? {} : y4, S4 = l2.flippedElementPositionsBeforeUpdate, E3 = void 0 === S4 ? {} : S4, A2 = l2.flipCallbacks, C2 = void 0 === A2 ? {} : A2, b3 = l2.containerEl, I3 = l2.applyTransformOrigin, O3 = l2.spring, w3 = l2.debug, x3 = l2.portalKey, k3 = l2.staggerConfig, j2 = void 0 === k3 ? {} : k3, B3 = l2.decisionData, N2 = void 0 === B3 ? {} : B3, L3 = l2.handleEnterUpdateDelete, q3 = l2.onComplete, W2 = l2.onStart, K3 = M$1(D$1((d4 = { element: b3, portalKey: x3 }).element, d4.portalKey)).map(function(t3) {
    var e3 = t3[0], i3 = t3[1], n2 = window.getComputedStyle(e3);
    return [e3.dataset.flipId, { element: e3, rect: i3, opacity: parseFloat(n2.opacity), transform: n2.transform }];
  }).reduce(T$1, {}), X3 = function(t3) {
    var e3 = t3.containerEl, i3 = t3.portalKey;
    return i3 ? function(t4) {
      return function(e4) {
        return p$2(document.querySelectorAll('[data-portal-key="' + t4 + '"]' + e4));
      };
    }(i3) : e3 ? function(t4) {
      var e4 = Math.random().toFixed(5);
      return t4.dataset.flipperId = e4, function(i4) {
        return p$2(t4.querySelectorAll('[data-flipper-id="' + e4 + '"] ' + i4));
      };
    }(e3) : function() {
      return [];
    };
  }({ containerEl: b3, portalKey: x3 }), Y3 = function(t3) {
    return function(e3) {
      return t3('[data-flip-id="' + e3 + '"]')[0];
    };
  }(X3), H4 = function(t3) {
    return E3[t3] && K3[t3];
  }, J2 = Object.keys(E3).concat(Object.keys(K3)).filter(function(t3) {
    return !H4(t3);
  }), z3 = { flipCallbacks: C2, getElement: Y3, flippedElementPositionsBeforeUpdate: E3, flippedElementPositionsAfterUpdate: K3, inProgressAnimations: _2, decisionData: N2 }, G3 = function(t3) {
    var e3, i3 = t3.unflippedIds, n2 = t3.flipCallbacks, r2 = t3.getElement, s4 = t3.flippedElementPositionsBeforeUpdate, a4 = t3.flippedElementPositionsAfterUpdate, o2 = t3.inProgressAnimations, l3 = t3.decisionData, p2 = i3.filter(function(t4) {
      return a4[t4];
    }).filter(function(t4) {
      return n2[t4] && n2[t4].onAppear;
    }), c3 = i3.filter(function(t4) {
      return s4[t4] && n2[t4] && n2[t4].onExit;
    }), u3 = new Promise(function(t4) {
      e3 = t4;
    }), d5 = [], f2 = 0, h5 = c3.map(function(t4, i4) {
      var r3 = s4[t4].domDataForExitAnimations, a5 = r3.element, p3 = r3.parent, c4 = r3.childPosition, u4 = c4.top, h6 = c4.left, g3 = c4.width, m4 = c4.height;
      "static" === getComputedStyle(p3).position && (p3.style.position = "relative"), a5.style.transform = "matrix(1, 0, 0, 1, 0, 0)", a5.style.position = "absolute", a5.style.top = u4 + "px", a5.style.left = h6 + "px", a5.style.height = m4 + "px", a5.style.width = g3 + "px";
      var v2 = d5.filter(function(t5) {
        return t5[0] === p3;
      })[0];
      v2 || (v2 = [p3, document.createDocumentFragment()], d5.push(v2)), v2[1].appendChild(a5), f2 += 1;
      var y5 = function() {
        try {
          p3.removeChild(a5);
        } catch (t5) {
        } finally {
          0 == (f2 -= 1) && e3();
        }
      };
      return o2[t4] = { stop: y5 }, function() {
        return n2[t4].onExit(a5, i4, y5, l3);
      };
    });
    return d5.forEach(function(t4) {
      t4[0].appendChild(t4[1]);
    }), h5.length || e3(), { hideEnteringElements: function() {
      p2.forEach(function(t4) {
        var e4 = r2(t4);
        e4 && (e4.style.opacity = "0");
      });
    }, animateEnteringElements: function() {
      p2.forEach(function(t4, e4) {
        var i4 = r2(t4);
        i4 && n2[t4].onAppear(i4, e4, l3);
      });
    }, animateExitingElements: function() {
      return h5.forEach(function(t4) {
        return t4();
      }), u3;
    } };
  }(u$2({}, z3, { unflippedIds: J2 })), Q3 = G3.hideEnteringElements, Z2 = G3.animateEnteringElements, $2 = G3.animateExitingElements, tt3 = u$2({}, z3, { containerEl: b3, flippedIds: g2.filter(H4), applyTransformOrigin: I3, spring: O3, debug: w3, staggerConfig: j2, scopedSelector: X3, onComplete: q3 });
  W2 && W2(b3, N2);
  var et2 = function(l3) {
    var d5, h5 = l3.flippedIds, g3 = l3.flipCallbacks, y5 = l3.inProgressAnimations, _3 = l3.flippedElementPositionsBeforeUpdate, S5 = l3.flippedElementPositionsAfterUpdate, E4 = l3.applyTransformOrigin, A3 = l3.spring, C3 = l3.getElement, b4 = l3.debug, I4 = l3.staggerConfig, O4 = void 0 === I4 ? {} : I4, w4 = l3.decisionData, x4 = void 0 === w4 ? {} : w4, T3 = l3.onComplete, D3 = l3.containerEl, M4 = new Promise(function(t3) {
      d5 = t3;
    });
    if (T3 && M4.then(function() {
      return T3(D3, x4);
    }), !h5.length)
      return function() {
        return d5([]), M4;
      };
    var k4 = [], j3 = C3(h5[0]), B4 = j3 ? j3.ownerDocument.querySelector("body") : document.querySelector("body"), N3 = (c$3(h5), h5.map(function(l4) {
      var c3 = _3[l4].rect, h6 = S5[l4].rect, C4 = _3[l4].opacity, b5 = S5[l4].opacity, I5 = h6.width < 1 || h6.height < 1, O5 = S5[l4].element;
      if (!P$1(c3) && !P$1(h6))
        return false;
      if (!O5)
        return false;
      var w5, U2, V2, T4 = R$2(O5), D4 = (V2 = (U2 = void 0 === (w5 = { flipperSpring: A3, flippedSpring: T4.spring }) ? {} : w5).flippedSpring, u$2({}, m$3.noWobble, v$1(U2.flipperSpring), v$1(V2))), M5 = true === T4.stagger ? "default" : T4.stagger, j4 = { element: O5, id: l4, stagger: M5, springConfig: D4 };
      if (g3[l4] && g3[l4].shouldFlip && !g3[l4].shouldFlip(x4.previous, x4.current))
        return false;
      var L5 = Math.abs(c3.left - h6.left) + Math.abs(c3.top - h6.top), q5 = Math.abs(c3.width - h6.width) + Math.abs(c3.height - h6.height), W4 = Math.abs(b5 - C4);
      if (0 === c3.height && 0 === h6.height || 0 === c3.width && 0 === h6.width || L5 < 0.5 && q5 < 0.5 && W4 < 0.01)
        return false;
      var K5 = parse$1(S5[l4].transform), X5 = { matrix: K5 }, Y5 = { matrix: [] }, H5 = [K5];
      T4.translate && (H5.push(translateX(c3.left - h6.left)), H5.push(translateY(c3.top - h6.top))), T4.scale && (H5.push(scaleX(Math.max(c3.width, 1) / Math.max(h6.width, 1))), H5.push(scaleY(Math.max(c3.height, 1) / Math.max(h6.height, 1)))), T4.opacity && (Y5.opacity = C4, X5.opacity = b5);
      var J3 = [];
      if (!g3[l4] || !g3[l4].shouldInvert || g3[l4].shouldInvert(x4.previous, x4.current)) {
        var z4 = function(t3, e3) {
          return p$2(t3.querySelectorAll('[data-inverse-flip-id="' + e3 + '"]'));
        }(O5, l4);
        J3 = z4.map(function(t3) {
          return [t3, R$2(t3)];
        });
      }
      Y5.matrix = F(H5.reduce(multiply)), X5.matrix = F(X5.matrix);
      var G4, Q4 = function(t3) {
        var e3 = t3.element, i3 = t3.invertedChildren, n2 = t3.body;
        return function(t4) {
          var r2 = t4.matrix, s4 = t4.opacity, o2 = t4.forceMinVals;
          if (a$1(s4) && (e3.style.opacity = s4 + ""), o2 && (e3.style.minHeight = "1px", e3.style.minWidth = "1px"), r2) {
            var l5 = function(t5) {
              return "matrix(" + t5.join(", ") + ")";
            }(r2);
            e3.style.transform = l5, i3 && function(t5) {
              var e4 = t5.matrix, i4 = t5.body;
              t5.invertedChildren.forEach(function(t6) {
                var n3 = t6[0], r3 = t6[1];
                if (i4.contains(n3)) {
                  var s5 = e4[0], a4 = e4[3], o3 = e4[5], l6 = { translateX: 0, translateY: 0, scaleX: 1, scaleY: 1 }, p2 = "";
                  r3.translate && (l6.translateX = -e4[4] / s5, l6.translateY = -o3 / a4, p2 += "translate(" + l6.translateX + "px, " + l6.translateY + "px)"), r3.scale && (l6.scaleX = 1 / s5, l6.scaleY = 1 / a4, p2 += " scale(" + l6.scaleX + ", " + l6.scaleY + ")"), n3.style.transform = p2;
                }
              });
            }({ invertedChildren: i3, matrix: r2, body: n2 });
          }
        };
      }({ element: O5, invertedChildren: J3, body: B4 });
      if (g3[l4] && g3[l4].onComplete) {
        var Z3 = g3[l4].onComplete;
        G4 = function() {
          return Z3(O5, x4);
        };
      }
      var $3 = a$1(Y5.opacity) && a$1(X5.opacity) && Y5.opacity !== X5.opacity, tt4 = false;
      return u$2({}, j4, { stagger: M5, springConfig: D4, getOnUpdateFunc: function(t3) {
        var e3 = t3.spring, i3 = t3.onAnimationEnd;
        return y5[l4] = { destroy: e3.destroy.bind(e3), onAnimationEnd: i3 }, function(t4) {
          g3[l4] && g3[l4].onSpringUpdate && g3[l4].onSpringUpdate(t4.getCurrentValue()), tt4 || (tt4 = true, g3[l4] && g3[l4].onStart && g3[l4].onStart(O5, x4));
          var e4 = t4.getCurrentValue();
          if (B4.contains(O5)) {
            var i4 = { matrix: [] };
            i4.matrix = Y5.matrix.map(function(t5, i5) {
              return f$3(t5, X5.matrix[i5], e4);
            }), $3 && (i4.opacity = f$3(Y5.opacity, X5.opacity, e4)), Q4(i4);
          } else
            t4.destroy();
        };
      }, initializeFlip: function() {
        Q4({ matrix: Y5.matrix, opacity: $3 ? Y5.opacity : void 0, forceMinVals: I5 }), g3[l4] && g3[l4].onStartImmediate && g3[l4].onStartImmediate(O5, x4), T4.transformOrigin ? O5.style.transformOrigin = T4.transformOrigin : E4 && (O5.style.transformOrigin = "0 0"), J3.forEach(function(t3) {
          var e3 = t3[0], i3 = t3[1];
          i3.transformOrigin ? e3.style.transformOrigin = i3.transformOrigin : E4 && (e3.style.transformOrigin = "0 0");
        });
      }, onAnimationEnd: function(t3) {
        delete y5[l4], o$1(G4) && G4(), O5.style.transform = "", J3.forEach(function(t4) {
          t4[0].style.transform = "";
        }), I5 && O5 && (O5.style.minHeight = "", O5.style.minWidth = ""), t3 || (k4.push(l4), k4.length >= N3.length && d5(k4));
      }, delayUntil: T4.delayUntil });
    }).filter(Boolean));
    if (N3.forEach(function(t3) {
      return (0, t3.initializeFlip)();
    }), b4)
      return function() {
      };
    var L4 = N3.filter(function(t3) {
      return t3.delayUntil && (e3 = t3.delayUntil, N3.filter(function(t4) {
        return t4.id === e3;
      }).length);
      var e3;
    }), q4 = {}, W3 = {}, K4 = {};
    L4.forEach(function(t3) {
      t3.stagger ? (K4[t3.stagger] = true, W3[t3.delayUntil] ? W3[t3.delayUntil].push(t3.stagger) : W3[t3.delayUntil] = [t3.stagger]) : q4[t3.delayUntil] ? q4[t3.delayUntil].push(t3) : q4[t3.delayUntil] = [t3];
    });
    var X4 = N3.filter(function(t3) {
      return t3.stagger;
    }).reduce(function(t3, e3) {
      return t3[e3.stagger] ? t3[e3.stagger].push(e3) : t3[e3.stagger] = [e3], t3;
    }, {}), Y4 = N3.filter(function(t3) {
      return -1 === L4.indexOf(t3);
    });
    return Y4.forEach(function(t3) {
      t3.onSpringActivate = function() {
        q4[t3.id] && q4[t3.id].forEach(U), W3[t3.id] && Object.keys(W3[t3.id].reduce(function(t4, e3) {
          var i3;
          return u$2(t4, ((i3 = {})[e3] = true, i3));
        }, {})).forEach(function(t4) {
          V(X4[t4], O4[t4]);
        });
      };
    }), function() {
      return N3.length || d5([]), Y4.filter(function(t3) {
        return !t3.stagger;
      }).forEach(U), Object.keys(X4).forEach(function(t3) {
        K4[t3] || V(X4[t3], O4[t3]);
      }), M4;
    };
  }(tt3);
  L3 ? L3({ hideEnteringElements: Q3, animateEnteringElements: Z2, animateExitingElements: $2, animateFlippedElements: et2 }) : (Q3(), $2().then(Z2), et2());
}, j = function(t3) {
  var e3 = t3.element, i3 = t3.flipCallbacks, n2 = void 0 === i3 ? {} : i3, r2 = t3.inProgressAnimations, s4 = void 0 === r2 ? {} : r2, a4 = D$1(e3, t3.portalKey), o2 = p$2(e3.querySelectorAll("[data-inverse-flip-id]")), l2 = {}, c3 = [], d4 = {};
  a4.filter(function(t4) {
    return n2 && n2[t4.dataset.flipId] && n2[t4.dataset.flipId].onExit;
  }).forEach(function(t4) {
    var e4 = t4.parentNode;
    if (t4.closest) {
      var i4 = t4.closest("[data-exit-container]");
      i4 && (e4 = i4);
    }
    var n3 = c3.findIndex(function(t5) {
      return t5[0] === e4;
    });
    -1 === n3 && (c3.push([e4, e4.getBoundingClientRect()]), n3 = c3.length - 1), l2[t4.dataset.flipId] = c3[n3][1], d4[t4.dataset.flipId] = e4;
  });
  var f2 = M$1(a4), h4 = f2.map(function(t4) {
    var e4 = t4[0], i4 = t4[1], r3 = {};
    if (n2 && n2[e4.dataset.flipId] && n2[e4.dataset.flipId].onExit) {
      var s5 = l2[e4.dataset.flipId];
      u$2(r3, { element: e4, parent: d4[e4.dataset.flipId], childPosition: { top: i4.top - s5.top, left: i4.left - s5.left, width: i4.width, height: i4.height } });
    }
    return [e4.dataset.flipId, { rect: i4, opacity: parseFloat(window.getComputedStyle(e4).opacity || "1"), domDataForExitAnimations: r3 }];
  }).reduce(T$1, {});
  return function(t4, e4) {
    Object.keys(t4).forEach(function(e5) {
      t4[e5].destroy && t4[e5].destroy(), t4[e5].onAnimationEnd && t4[e5].onAnimationEnd(true), delete t4[e5];
    }), e4.forEach(function(t5) {
      t5.style.transform = "", t5.style.opacity = "";
    });
  }(s4, a4.concat(o2)), { flippedElementPositions: h4, cachedOrderedFlipIds: f2.map(function(t4) {
    return t4[0].dataset.flipId;
  }) };
};
new O$1();
function c$2(e3, t3) {
  if (null == e3)
    return {};
  var r2, n2, i3 = {}, o2 = Object.keys(e3);
  for (n2 = 0; n2 < o2.length; n2++)
    t3.indexOf(r2 = o2[n2]) >= 0 || (i3[r2] = e3[r2]);
  return i3;
}
var d$1 = react.exports.createContext({}), f$2 = react.exports.createContext("portal"), u$1 = function(t3) {
  var r2, n2;
  function i3() {
    var e3;
    return (e3 = t3.apply(this, arguments) || this).inProgressAnimations = {}, e3.flipCallbacks = {}, e3.el = void 0, e3;
  }
  n2 = t3, (r2 = i3).prototype = Object.create(n2.prototype), r2.prototype.constructor = r2, r2.__proto__ = n2;
  var l2 = i3.prototype;
  return l2.getSnapshotBeforeUpdate = function(e3) {
    return e3.flipKey !== this.props.flipKey && this.el ? j({ element: this.el, flipCallbacks: this.flipCallbacks, inProgressAnimations: this.inProgressAnimations, portalKey: this.props.portalKey }) : null;
  }, l2.componentDidUpdate = function(e3, t4, r3) {
    this.props.flipKey !== e3.flipKey && this.el && k({ flippedElementPositionsBeforeUpdate: r3.flippedElementPositions, cachedOrderedFlipIds: r3.cachedOrderedFlipIds, containerEl: this.el, inProgressAnimations: this.inProgressAnimations, flipCallbacks: this.flipCallbacks, applyTransformOrigin: this.props.applyTransformOrigin, spring: this.props.spring, debug: this.props.debug, portalKey: this.props.portalKey, staggerConfig: this.props.staggerConfig, handleEnterUpdateDelete: this.props.handleEnterUpdateDelete, decisionData: { previous: e3.decisionData, current: this.props.decisionData }, onComplete: this.props.onComplete, onStart: this.props.onStart });
  }, l2.render = function() {
    var t4 = this, r3 = this.props, n3 = r3.portalKey, i4 = e$3.createElement(d$1.Provider, { value: this.flipCallbacks }, e$3.createElement(r3.element, { className: r3.className, ref: function(e3) {
      return t4.el = e3;
    } }, this.props.children));
    return n3 && (i4 = e$3.createElement(f$2.Provider, { value: n3 }, i4)), i4;
  }, i3;
}(react.exports.Component);
u$1.defaultProps = { applyTransformOrigin: true, element: "div" };
var h$2 = function(e3) {
  var t3, r2 = e3.children, o2 = e3.flipId, p2 = e3.inverseFlipId, s4 = e3.portalKey, d4 = c$2(e3, ["children", "flipId", "inverseFlipId", "portalKey"]), f2 = r2, u3 = function(e4) {
    return "function" == typeof e4;
  }(f2);
  if (!u3)
    try {
      f2 = react.exports.Children.only(r2);
    } catch (e4) {
      throw new Error("Each Flipped component must wrap a single child");
    }
  d4.scale || d4.translate || d4.opacity || h$3.assign(d4, { translate: true, scale: true, opacity: true });
  var h4 = ((t3 = {})[g$2.DATA_FLIP_CONFIG] = JSON.stringify(d4), t3);
  return void 0 !== o2 ? h4[g$2.DATA_FLIP_ID] = String(o2) : p2 && (h4[g$2.DATA_INVERSE_FLIP_ID] = String(p2)), void 0 !== s4 && (h4[g$2.DATA_PORTAL_KEY] = s4), u3 ? f2(h4) : react.exports.cloneElement(f2, h4);
}, m$2 = function(t3) {
  var r2 = t3.children, n2 = t3.flipId, i3 = t3.shouldFlip, o2 = t3.shouldInvert, p2 = t3.onAppear, a4 = t3.onStart, s4 = t3.onStartImmediate, u3 = t3.onComplete, m4 = t3.onExit, g2 = t3.onSpringUpdate, y4 = c$2(t3, ["children", "flipId", "shouldFlip", "shouldInvert", "onAppear", "onStart", "onStartImmediate", "onComplete", "onExit", "onSpringUpdate"]);
  return r2 ? y4.inverseFlipId ? e$3.createElement(h$2, Object.assign({}, y4), r2) : e$3.createElement(f$2.Consumer, null, function(t4) {
    return e$3.createElement(d$1.Consumer, null, function(c3) {
      return h$3.isObject(c3) && n2 && (c3[n2] = { shouldFlip: i3, shouldInvert: o2, onAppear: p2, onStart: a4, onStartImmediate: s4, onComplete: u3, onExit: m4, onSpringUpdate: g2 }), e$3.createElement(h$2, Object.assign({ flipId: n2 }, y4, { portalKey: t4 }), r2);
    });
  }) : null;
};
m$2.displayName = "Flipped";
const preview = "_preview_ewrx5_1";
const In$2 = "_In_ewrx5_1";
const Out$1 = "_Out_ewrx5_1";
const loaded = "_loaded_ewrx5_47";
const mobile = "_mobile_ewrx5_50";
const item$2 = "_item_ewrx5_55";
const title = "_title_ewrx5_70";
const focused = "_focused_ewrx5_85";
const addButton = "_addButton_ewrx5_105";
const addButtonFloating = "_addButtonFloating_ewrx5_118";
var Style$8 = {
  preview,
  In: In$2,
  Out: Out$1,
  loaded,
  mobile,
  item: item$2,
  title,
  focused,
  addButton,
  addButtonFloating
};
function PreviewAddFloating({
  position: position2
}) {
  const setAddBlockIndex = useSetBlockIndex();
  return /* @__PURE__ */ jsx("button", {
    className: Style$8.addButtonFloating,
    onClick: prevent(() => setAddBlockIndex(position2)),
    children: /* @__PURE__ */ jsx("span", {
      children: "Ajouter un bloc"
    })
  });
}
function usePreview(data, previewUrl, initialHTML) {
  const [loading, setLoading] = react.exports.useState(false);
  const [html, setHTML] = react.exports.useState(initialHTML);
  const isFirstRender = react.exports.useRef(!!initialHTML);
  useEffectDebounced(() => {
    if (isFirstRender.current) {
      isFirstRender.current = false;
      return;
    }
    const timer = window.setTimeout(() => setLoading(true), 200);
    fetch(previewUrl, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Accept: "application/json"
      },
      body: JSON.stringify({
        ...data,
        preview: true
      })
    }).then((r2) => r2.text()).then(setHTML).finally(() => {
      clearTimeout(timer);
      setLoading(false);
    });
    return () => clearTimeout(timer);
  }, [data], 500);
  return {
    loading,
    html
  };
}
function PreviewItem({
  data,
  initialHTML,
  previewUrl,
  title: title2
}) {
  const ref = react.exports.useRef(null);
  const {
    loading,
    html
  } = usePreview(data, previewUrl, initialHTML);
  const setFocusIndex = useSetFocusIndex();
  const isFocused = useFieldFocused(data._id);
  react.exports.useEffect(() => {
    if (isFocused) {
      const top2 = offsetTop(ref.current) - 40;
      const root2 = ref.current.closest("html");
      root2.scrollTop = top2;
    }
  }, [isFocused]);
  return /* @__PURE__ */ jsx(m$2, {
    flipId: data._id,
    children: /* @__PURE__ */ jsxs("div", {
      className: `${Style$8.item} ${isFocused ? Style$8.focused : ""}`,
      id: `previewItem${data._id}`,
      ref,
      onClick: () => setFocusIndex(data._id),
      children: [loading && /* @__PURE__ */ jsx(Loader, {
        width: 15,
        dots: 6
      }), /* @__PURE__ */ jsx("div", {
        className: `${Style$8.title} ${isFocused ? Style$8.focused : ""}`,
        children: title2
      }), /* @__PURE__ */ jsx("div", {
        dangerouslySetInnerHTML: {
          __html: html
        }
      })]
    })
  });
}
function PreviewAddButton({
  position: position2
}) {
  const setAddBlockIndex = useSetBlockIndex();
  return /* @__PURE__ */ jsx("div", {
    className: Style$8.addButton,
    children: /* @__PURE__ */ jsx(Button$1, {
      icon: IconCirclePlus,
      onClick: prevent(() => setAddBlockIndex(position2)),
      children: "Ajouter un bloc"
    })
  });
}
function PreviewItems({
  data,
  initialHTML = {},
  previewUrl
}) {
  const definitions = useFieldDefinitions();
  return /* @__PURE__ */ jsxs(Fragment$1, {
    children: [/* @__PURE__ */ jsx(u$1, {
      flipKey: data.map((d4) => d4._id).join("_"),
      children: data.map((v2, k3) => {
        var _a;
        return /* @__PURE__ */ jsxs("div", {
          children: [/* @__PURE__ */ jsx(PreviewAddFloating, {
            position: k3
          }), /* @__PURE__ */ jsx(PreviewItem, {
            title: ((_a = definitions[v2._name]) == null ? void 0 : _a.title) || "",
            data: v2,
            initialHTML: initialHTML[v2._id] || "",
            previewUrl
          })]
        }, v2._id);
      })
    }), /* @__PURE__ */ jsx(PreviewAddButton, {
      position: data.length
    })]
  });
}
function Preview({
  data,
  previewUrl
}) {
  const iframe = react.exports.useRef(null);
  const [iframeRoot, setIframeRoot] = react.exports.useState(null);
  const initialHTML = react.exports.useRef({});
  const [loaded2, setLoaded] = react.exports.useState(false);
  const showSpinner = !loaded2;
  useAsyncEffect(async () => {
    const r2 = await fetch(previewUrl, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Accept: "application/json"
      },
      body: JSON.stringify(data)
    });
    if (!r2.ok) {
      return;
    }
    const iframeDocument = iframe.current.contentDocument;
    iframeDocument.open();
    iframeDocument.write(await r2.text());
    iframeDocument.close();
    const root2 = iframeDocument.querySelector("#ve-components");
    initialHTML.current = Array.from(root2.children).reduce((acc, v2, k3) => ({
      ...acc,
      [data[k3]._id]: v2.outerHTML
    }), {});
    root2.innerHTML = "";
    setIframeRoot(root2);
  }, []);
  const previewMode = usePreviewMode();
  const {
    height: windowHeight
  } = useWindowSize$1();
  let transform = void 0;
  if (previewMode === PreviewModes.PHONE && windowHeight < 844) {
    transform = {
      transform: `scale(${windowHeight / PHONE_HEIGHT})`
    };
  }
  return /* @__PURE__ */ jsxs("div", {
    className: Style$8.preview,
    children: [showSpinner && /* @__PURE__ */ jsx(Loader, {
      width: 40,
      dots: 12
    }), /* @__PURE__ */ jsx("iframe", {
      className: `${loaded2 ? Style$8.loaded : ""} ${previewMode === PreviewModes.PHONE ? Style$8.mobile : ""}`,
      ref: iframe,
      style: transform,
      onLoad: () => setLoaded(true)
    }), iframeRoot && reactDom.exports.createPortal(/* @__PURE__ */ jsx(PreviewItems, {
      data,
      initialHTML: initialHTML.current,
      previewUrl
    }), iframeRoot)]
  });
}
function ResizeBar() {
  const [drag, setDrag] = react.exports.useState(false);
  const setSidebarWidth = useSetSidebarWidth();
  const handleMouseDown = (e3) => {
    e3.stopPropagation();
    e3.preventDefault();
    setDrag(true);
    const listener = (e22) => {
      setSidebarWidth(Math.round(100 * e22.clientX / window.innerWidth));
    };
    document.documentElement.addEventListener("mousemove", listener);
    document.documentElement.addEventListener("mouseup", () => {
      setDrag(false);
      document.documentElement.removeEventListener("mousemove", listener);
    }, {
      once: true
    });
  };
  return /* @__PURE__ */ jsxs(Fragment$1, {
    children: [/* @__PURE__ */ jsx(Wrapper$2, {
      isDragging: drag,
      onMouseDown: handleMouseDown
    }), drag && /* @__PURE__ */ jsx(ResizeBarOverlay, {})]
  });
}
const Wrapper$2 = /* @__PURE__ */ createStyled("div", {
  target: "eu1gqac1"
})("position:fixed;top:0;bottom:0;height:100%;left:var(--clampedSidebar);width:15px;z-index:1002;cursor:ew-resize;transition:box-shadow .3s;:hover{box-shadow:-1px -1px 0 1px var(--contrast);}", ({
  isDragging
}) => isDragging ? {
  boxShadow: "-1px -1px 0 1px var(--contrast)"
} : null, "");
const ResizeBarOverlay = /* @__PURE__ */ createStyled("div", {
  target: "eu1gqac0"
})({
  name: "1rfie70",
  styles: "position:fixed;top:0;left:0;width:100%;height:100%;z-index:1001"
});
function BlocSelectorItem({
  definition,
  name,
  iconsUrl,
  onClick
}) {
  const icon = iconsUrl.replace("[name]", name);
  const title2 = definition.title;
  return /* @__PURE__ */ jsxs(Button, {
    onClick: prevent(onClick),
    children: [/* @__PURE__ */ jsx(ButtonImage, {
      children: /* @__PURE__ */ jsx("img", {
        src: icon,
        alt: ""
      })
    }), /* @__PURE__ */ jsx("div", {
      children: title2
    })]
  });
}
const Button = /* @__PURE__ */ createStyled("button", {
  target: "efqm8ui1"
})({
  name: "17pcvfx",
  styles: "background-color:transparent;border:none;display:flex;flex-direction:column;gap:1rem;font:inherit;font-weight:500;cursor:pointer;transition:.3s;&:hover, &:focus{outline:none;color:var(--contrast);& img{transform:translateY(-5px);}}"
});
const ButtonImage = /* @__PURE__ */ createStyled("div", {
  target: "efqm8ui0"
})({
  width: "100%",
  backgroundColor: "var(--color-light)",
  height: 107,
  display: "flex",
  alignItems: "center",
  justifyContent: "center",
  position: "relative",
  transition: ".3s",
  img: {
    width: 120,
    height: 80,
    objectFit: "contain",
    borderRadius: 4,
    transition: "transform .3s"
  },
  "&::after": {
    content: "''",
    position: "absolute",
    inset: 0,
    opacity: 0,
    background: "var(--contrast)",
    mixBlendMode: "saturation",
    borderRadius: 4,
    transition: "opacity .3s"
  },
  [`button:hover &::after, button:focus &::after`]: {
    opacity: 1
  },
  [`button:focus &`]: {
    transition: "none",
    border: "2px solid var(--contrast)"
  }
}, "");
const Wrapper$1 = /* @__PURE__ */ createStyled("div", {
  target: "e1ae8oe11"
})({
  name: "rmoj7r",
  styles: "position:relative;float:right;svg{position:absolute;left:1rem;top:50%;color:var(--color);transform:translateY(-50%);}"
});
const Input = /* @__PURE__ */ createStyled("input", {
  target: "e1ae8oe10"
})({
  height: 40,
  background: "var(--color-light)",
  borderRadius: 40,
  padding: "0 1rem 0 2.6rem",
  border: "1px solid transparent",
  font: "inherit",
  "&:focus": Styles.FocusState
}, "");
function BlocSelectorSearch({
  value,
  onChange
}) {
  return /* @__PURE__ */ jsxs(Wrapper$1, {
    children: [/* @__PURE__ */ jsx(Input, {
      type: "search",
      placeholder: t$2("searchComponent"),
      value,
      onChange: (e3) => onChange(e3.target.value)
    }), /* @__PURE__ */ jsx(IconSearch, {
      size: 14
    })]
  });
}
const BlocSelectorGrid = /* @__PURE__ */ createStyled(Tabs$1.Tab, {
  target: "egsohzr0"
})({
  name: "1qithdb",
  styles: "display:grid;grid-template-columns:repeat(auto-fit, 218px);gap:2rem;overflow:auto;max-height:calc(100vh - 300px);margin-top:2rem;align-content:flex-start;height:700px;&::-webkit-scrollbar{width:7px;height:7px;}&::-webkit-scrollbar-track{background:var(--color-light);padding:1px;}&::-webkit-scrollbar-thumb{background:var(--color);border-radius:4px;}&[hidden]{display:none;}"
});
const ALL_TAB = "Tous les blocs";
var _ref$5 = {
  name: "di48ht",
  styles: "margin:1.5rem 0"
};
function BlocSelector({
  iconsUrl
}) {
  const isVisible = useBlocSelectionVisible();
  const setBlockIndex = useSetBlockIndex();
  const [search, setSearch] = react.exports.useState("");
  const definitions = useFieldDefinitions();
  const hiddenCategories = useHiddenCategories();
  const addBlock = useAddBlock();
  const categories = react.exports.useMemo(() => {
    return [ALL_TAB, ...Object.values(definitions).filter((d4) => d4.category).filter((d4) => {
      var _a;
      return !hiddenCategories.includes((_a = d4.category) != null ? _a : "");
    }).reduce((acc, d4) => acc.includes(d4.category) ? acc : [...acc, d4.category], [])];
  }, [definitions]);
  react.exports.useEffect(() => {
    setSearch("");
  }, [isVisible]);
  if (!isVisible) {
    return null;
  }
  const handleVisibilityChange = (v2) => {
    setBlockIndex(null);
  };
  return /* @__PURE__ */ jsxs(Modal, {
    visible: isVisible,
    onVisibilityChange: handleVisibilityChange,
    title: t$2("addComponent"),
    children: [/* @__PURE__ */ jsx(BlocSelectorSearch, {
      value: search,
      onChange: setSearch
    }), /* @__PURE__ */ jsx(Tabs$1, {
      css: _ref$5,
      children: categories.map((category) => /* @__PURE__ */ jsx(BlocSelectorGrid, {
        title: category,
        children: Object.keys(definitions).filter((key) => {
          var _a;
          return !hiddenCategories.includes((_a = definitions[key].category) != null ? _a : "");
        }).filter(searchDefinition(search != null ? search : "", category, definitions)).map((key) => /* @__PURE__ */ jsx(BlocSelectorItem, {
          definition: definitions[key],
          name: key,
          iconsUrl,
          onClick: () => addBlock(key)
        }, key))
      }, category))
    })]
  });
}
function searchDefinition(search, category, definitions) {
  return (key) => {
    const categoryFilter = category === ALL_TAB ? true : definitions[key].category === category;
    const searchFilter = search === "" ? true : definitions[key].title.toLowerCase().includes(search.toLowerCase());
    return categoryFilter && searchFilter;
  };
}
function RollbackMessage() {
  const {
    message: rollbackMessage,
    rollback,
    voidRollback
  } = useRollbackMessage();
  return /* @__PURE__ */ jsx(Flash, {
    action: t$2("rollback"),
    onClick: rollback,
    duration: 3,
    onHide: voidRollback,
    children: rollbackMessage
  });
}
function Layout({
  data,
  previewUrl,
  onClose,
  iconsUrl
}) {
  const [sidebarCollapsed, toggleSidebar] = useToggle(false);
  const showResizeControl = !sidebarCollapsed;
  return /* @__PURE__ */ jsx(Fragment$1, {
    children: /* @__PURE__ */ jsxs(Wrapper, {
      withSidebar: !sidebarCollapsed,
      children: [/* @__PURE__ */ jsx(Sidebar, {
        data,
        onClose,
        css: /* @__PURE__ */ css$1({
          display: sidebarCollapsed ? "none" : void 0
        }, "", "")
      }), previewUrl && /* @__PURE__ */ jsx(Preview, {
        data,
        previewUrl
      }), showResizeControl && /* @__PURE__ */ jsx(ResizeBar, {}), /* @__PURE__ */ jsx(BlocSelector, {
        iconsUrl
      }), /* @__PURE__ */ jsx(RollbackMessage, {})]
    })
  });
}
function Wrapper(props) {
  const sidebarWidth2 = useSidebarWidth();
  return /* @__PURE__ */ jsx(StyledWrapper, {
    ...props,
    style: {
      "--sidebar": `${sidebarWidth2}vw`
    }
  });
}
const In$1 = keyframes({
  from: {
    backgroundColor: "rgba(255, 255, 255, 0)"
  },
  to: {
    backgroundColor: "var(--color)"
  }
});
const Out = keyframes({
  from: {
    backgroundColor: "var(--color)"
  },
  to: {
    backgroundColor: "rgba(255, 255, 255, 0)"
  }
});
const StyledWrapper = /* @__PURE__ */ createStyled("div", {
  target: "e1hanmhx0"
})({
  isolation: "isolate",
  zIndex: 9999,
  fontSize: "15px",
  "--sidebar": "600px",
  "--clampedSidebar": "clamp(450px, var(--sidebar), calc(100vw - 375px))",
  color: "var(--color)",
  transition: "background-color .3s",
  position: "fixed",
  inset: "0",
  width: "100%",
  height: "100%",
  display: "grid",
  backgroundColor: "var(--color)",
  animation: `${In$1} .7s cubic-bezier(0.19, 1, 0.22, 1) both`,
  '[hidden="hidden"] &': {
    animation: `${Out} .7s cubic-bezier(0.19, 1, 0.22, 1) both`
  },
  "& *": {
    "&::-webkit-scrollbar": {
      width: "7px",
      height: "7px"
    },
    "&::-webkit-scrollbar-track": {
      background: "transparent",
      padding: "1px"
    },
    "&::-webkit-scrollbar-thumb": {
      background: "var(--color)",
      borderRadius: "4px"
    }
  }
}, (props) => ({
  gridTemplateColumns: props.withSidebar ? "var(--clampedSidebar) 1fr" : "1fr"
}), "");
function useClipboardPaste(enabled) {
  const insertData = useInsertData();
  react.exports.useEffect(() => {
    if (!enabled) {
      return;
    }
    const listener = (event) => {
      try {
        let paste = (event.clipboardData || window.clipboardData).getData("text").trim();
        if (paste.startsWith("{")) {
          event.preventDefault();
          const data = JSON.parse(paste);
          if (data._name) {
            insertData(data._name, 0, indexify(data));
          }
        } else if (paste.startsWith("[")) {
          event.preventDefault();
          const data = JSON.parse(paste);
          if (data.length > 0) {
            for (let i3 = data.length - 1; i3 >= 0; i3--) {
              insertData(data[i3]._name, 0, indexify(data[i3]));
            }
          }
        }
      } catch (e3) {
      }
    };
    document.addEventListener("paste", listener);
    return () => {
      document.removeEventListener("paste", listener);
    };
  }, [insertData, enabled]);
}
var _ref$4 = {
  name: "1wa9kgz",
  styles: "editor-builder{display:block;}"
};
const BaseStyles = ({
  children,
  complete = true
}) => {
  return /* @__PURE__ */ jsxs(Fragment$1, {
    children: [/* @__PURE__ */ jsx(Global, {
      styles: _ref$4
    }), /* @__PURE__ */ jsx(Reset, {
      complete,
      children
    })]
  });
};
const Reset = /* @__PURE__ */ createStyled("div", {
  target: "eq7q1hq0"
})({
  name: "8asarj",
  styles: "font-size:16px;line-height:1.4;*,*::before,*::after{box-sizing:border-box;}"
}, (props) => props.complete ? `
  img,
  picture,
  video,
  canvas,
  svg {
    display: block;
    max-width: 100%;
  }

  input,
  button,
  textarea,
  select {
    font: inherit;
  }` : {}, "");
const Translations$1 = {
  unknownComponent: "Unknown component",
  deleteComponent: "Remove component",
  copyPage: "Copier le code de la page",
  copyComponent: "Copy the component",
  searchComponent: "Search a component",
  copySuccess: "The code has been copied",
  copyInstructions: "You can paste the component on another page (CTRL + V)",
  addComponent: "Add a component",
  responsiveView: "Responsive view",
  addItem: "Add an item",
  deleteItem: "Remove item",
  rollback: "Restore",
  deleteItemConfirm: "The component has been deleted",
  save: "Save",
  close: "Close",
  noContent: `You have no content yet`,
  useTemplate: "Use a template"
};
var style$1 = "";
function defineField(args) {
  return (name, options = {}) => {
    const fieldArgs = typeof args === "function" ? args() : args;
    return {
      ...genericFieldDefinition(fieldArgs, options),
      ...fieldArgs,
      options: {
        ...fieldArgs.defaultOptions,
        ...options
      },
      name,
      group: false
    };
  };
}
function defineFieldGroup(args) {
  return (fields, options = {}) => {
    return {
      ...genericFieldDefinition(args, options),
      group: true,
      fields,
      render: args.render
    };
  };
}
function defaultFieldProperties() {
  return {
    conditions: [],
    shouldRender(data) {
      return this.conditions.filter((condition) => !condition(data)).length === 0;
    },
    when(fieldName, expectedValue = true) {
      return {
        ...this,
        conditions: [...this.conditions, (data) => {
          if (typeof expectedValue === "function") {
            return expectedValue(data[fieldName]);
          }
          return cast(data[fieldName], expectedValue) === expectedValue;
        }]
      };
    }
  };
}
function genericFieldDefinition(args, options) {
  return {
    options: {
      ...args.defaultOptions,
      ...options
    },
    ...defaultFieldProperties()
  };
}
const Component$c = ({
  value,
  onChange,
  options
}) => {
  const id2 = useUniqId("textinput");
  return /* @__PURE__ */ jsx(Field$1, {
    label: options.label,
    type: options.multiline ? "textarea" : "text",
    id: id2,
    value,
    onInput: (e3) => onChange(e3.target.value),
    help: options.help
  });
};
const Text$2 = defineField({
  defaultOptions: {
    default: ""
  },
  render: Component$c
});
const checkbox = "_checkbox_2fzlz_1";
var Style$7 = {
  checkbox
};
const Component$b = ({
  value,
  onChange,
  options
}) => {
  const id2 = useUniqId("checkbox");
  return /* @__PURE__ */ jsx(Field$1, {
    help: options.help,
    children: /* @__PURE__ */ jsxs("div", {
      className: Style$7.checkbox,
      children: [/* @__PURE__ */ jsx("input", {
        className: `editor-checkbox-input`,
        type: "checkbox",
        id: id2,
        checked: value,
        onChange: () => onChange(!value)
      }), /* @__PURE__ */ jsx("label", {
        htmlFor: id2,
        children: options.label
      })]
    })
  });
};
const Checkbox = defineField({
  defaultOptions: {
    label: "",
    default: false
  },
  render: Component$b
});
const repeater = "_repeater_761bo_1";
const footer = "_footer_761bo_8";
const item$1 = "_item_761bo_14";
const body = "_body_761bo_23";
var Style$6 = {
  repeater,
  footer,
  item: item$1,
  body
};
const Component$a = ({
  value: valueProps,
  onChange,
  options
}) => {
  const value = valueProps != null ? valueProps : [];
  const canAdd = !options.max || value.length < options.max;
  const canRemove = !options.min || value.length > options.min;
  const [lastAdditionIndex, setLastAdditionIndex] = react.exports.useState(-1);
  const add2 = () => {
    onChange([...value, fillDefaults({
      _id: uniqId()
    }, options.fields)]);
    setLastAdditionIndex(value.length);
  };
  const remove = (line2) => {
    onChange(value.filter((v2) => v2 !== line2));
  };
  const updateProperty = (v2, path) => {
    onChange(deepSet(value, path, v2));
  };
  function handleMove(from3, to) {
    onChange(moveItem(value, from3, to));
  }
  return /* @__PURE__ */ jsx(Field$1, {
    label: options.label,
    children: /* @__PURE__ */ jsx(SortableWrapper, {
      items: value,
      onMove: handleMove,
      children: /* @__PURE__ */ jsxs("div", {
        className: Style$6.repeater,
        children: [value.map((line2, k3) => /* @__PURE__ */ jsx(FieldLine, {
          line: line2,
          index: k3,
          onUpdate: updateProperty,
          onRemove: canRemove ? remove : null,
          options,
          defaultCollapsed: lastAdditionIndex !== k3
        }, line2._id)), canAdd && /* @__PURE__ */ jsx("div", {
          className: Style$6.footer,
          children: /* @__PURE__ */ jsx(Button$1, {
            secondary: true,
            onClick: prevent(add2),
            icon: IconCirclePlus,
            children: options.addLabel
          })
        })]
      })
    })
  });
};
const FieldLine = ({
  line: line2,
  index: index2,
  onRemove,
  onUpdate,
  options,
  defaultCollapsed
}) => {
  const [collapsed, toggleCollapsed] = useToggle(defaultCollapsed);
  const title2 = options.collapsed ? line2[options.collapsed] : `#${index2 + 1}`;
  const escapedTitle = react.exports.useMemo(() => textContent(title2), [title2]);
  return /* @__PURE__ */ jsxs(Sortable, {
    className: Style$6.item,
    item: line2,
    children: [/* @__PURE__ */ jsxs(SidebarHeading, {
      onClick: prevent(toggleCollapsed),
      title: escapedTitle,
      children: [/* @__PURE__ */ jsx(SidebarHeading.Hover, {
        children: onRemove && /* @__PURE__ */ jsx(ButtonIcon, {
          danger: true,
          onClick: () => onRemove(line2),
          title: t$2("deleteItem"),
          children: /* @__PURE__ */ jsx(IconTrash, {
            size: 20
          })
        })
      }), /* @__PURE__ */ jsx(ButtonIcon, {
        rotate: collapsed ? -90 : 0,
        onClick: prevent(toggleCollapsed),
        children: /* @__PURE__ */ jsx(IconDown, {
          size: 24
        })
      })]
    }), !collapsed && /* @__PURE__ */ jsx("div", {
      className: Style$6.body,
      children: /* @__PURE__ */ jsx(FieldsRenderer, {
        fields: options.fields,
        data: line2,
        onUpdate,
        path: index2.toString()
      })
    })]
  });
};
const Repeater = defineField(() => ({
  defaultOptions: {
    addLabel: t$2("addItem"),
    fields: [],
    default: []
  },
  render: Component$a
}));
const imageURL = "_imageURL_cqgtc_1";
var Style$5 = {
  imageURL
};
var _ref$3 = {
  name: "18hed01",
  styles: "padding-right:40px"
};
const Component$9 = ({
  value,
  onChange,
  options
}) => {
  const id2 = useUniqId("imageinput");
  const handleBrowse = () => {
    options.onBrowse(value).then((v2) => {
      onChange(v2);
    }).catch((e3) => {
    });
  };
  return /* @__PURE__ */ jsx(Field$1, {
    id: id2,
    label: options.label,
    help: options.help,
    value,
    tooltip: value ? /* @__PURE__ */ jsx("img", {
      className: Style$5.imageURL,
      src: value,
      alt: ""
    }) : void 0,
    onChange: (e3) => onChange(e3.target.value),
    css: _ref$3,
    icon: options.onBrowse ? /* @__PURE__ */ jsx(ButtonIcon, {
      additionalStyle: {
        width: "32px",
        height: "32px"
      },
      onClick: prevent(handleBrowse),
      children: /* @__PURE__ */ jsx(IconFolder, {
        size: 16
      })
    }) : void 0
  });
};
const ImageUrl = defineField({
  defaultOptions: {
    default: ""
  },
  render: Component$9
});
function OrderedMap(content) {
  this.content = content;
}
OrderedMap.prototype = {
  constructor: OrderedMap,
  find: function(key) {
    for (var i3 = 0; i3 < this.content.length; i3 += 2)
      if (this.content[i3] === key)
        return i3;
    return -1;
  },
  get: function(key) {
    var found2 = this.find(key);
    return found2 == -1 ? void 0 : this.content[found2 + 1];
  },
  update: function(key, value, newKey) {
    var self2 = newKey && newKey != key ? this.remove(newKey) : this;
    var found2 = self2.find(key), content = self2.content.slice();
    if (found2 == -1) {
      content.push(newKey || key, value);
    } else {
      content[found2 + 1] = value;
      if (newKey)
        content[found2] = newKey;
    }
    return new OrderedMap(content);
  },
  remove: function(key) {
    var found2 = this.find(key);
    if (found2 == -1)
      return this;
    var content = this.content.slice();
    content.splice(found2, 2);
    return new OrderedMap(content);
  },
  addToStart: function(key, value) {
    return new OrderedMap([key, value].concat(this.remove(key).content));
  },
  addToEnd: function(key, value) {
    var content = this.remove(key).content.slice();
    content.push(key, value);
    return new OrderedMap(content);
  },
  addBefore: function(place, key, value) {
    var without = this.remove(key), content = without.content.slice();
    var found2 = without.find(place);
    content.splice(found2 == -1 ? content.length : found2, 0, key, value);
    return new OrderedMap(content);
  },
  forEach: function(f2) {
    for (var i3 = 0; i3 < this.content.length; i3 += 2)
      f2(this.content[i3], this.content[i3 + 1]);
  },
  prepend: function(map2) {
    map2 = OrderedMap.from(map2);
    if (!map2.size)
      return this;
    return new OrderedMap(map2.content.concat(this.subtract(map2).content));
  },
  append: function(map2) {
    map2 = OrderedMap.from(map2);
    if (!map2.size)
      return this;
    return new OrderedMap(this.subtract(map2).content.concat(map2.content));
  },
  subtract: function(map2) {
    var result = this;
    map2 = OrderedMap.from(map2);
    for (var i3 = 0; i3 < map2.content.length; i3 += 2)
      result = result.remove(map2.content[i3]);
    return result;
  },
  toObject: function() {
    var result = {};
    this.forEach(function(key, value) {
      result[key] = value;
    });
    return result;
  },
  get size() {
    return this.content.length >> 1;
  }
};
OrderedMap.from = function(value) {
  if (value instanceof OrderedMap)
    return value;
  var content = [];
  if (value)
    for (var prop in value)
      content.push(prop, value[prop]);
  return new OrderedMap(content);
};
function findDiffStart(a4, b3, pos) {
  for (let i3 = 0; ; i3++) {
    if (i3 == a4.childCount || i3 == b3.childCount)
      return a4.childCount == b3.childCount ? null : pos;
    let childA = a4.child(i3), childB = b3.child(i3);
    if (childA == childB) {
      pos += childA.nodeSize;
      continue;
    }
    if (!childA.sameMarkup(childB))
      return pos;
    if (childA.isText && childA.text != childB.text) {
      for (let j2 = 0; childA.text[j2] == childB.text[j2]; j2++)
        pos++;
      return pos;
    }
    if (childA.content.size || childB.content.size) {
      let inner = findDiffStart(childA.content, childB.content, pos + 1);
      if (inner != null)
        return inner;
    }
    pos += childA.nodeSize;
  }
}
function findDiffEnd(a4, b3, posA, posB) {
  for (let iA = a4.childCount, iB = b3.childCount; ; ) {
    if (iA == 0 || iB == 0)
      return iA == iB ? null : { a: posA, b: posB };
    let childA = a4.child(--iA), childB = b3.child(--iB), size = childA.nodeSize;
    if (childA == childB) {
      posA -= size;
      posB -= size;
      continue;
    }
    if (!childA.sameMarkup(childB))
      return { a: posA, b: posB };
    if (childA.isText && childA.text != childB.text) {
      let same = 0, minSize = Math.min(childA.text.length, childB.text.length);
      while (same < minSize && childA.text[childA.text.length - same - 1] == childB.text[childB.text.length - same - 1]) {
        same++;
        posA--;
        posB--;
      }
      return { a: posA, b: posB };
    }
    if (childA.content.size || childB.content.size) {
      let inner = findDiffEnd(childA.content, childB.content, posA - 1, posB - 1);
      if (inner)
        return inner;
    }
    posA -= size;
    posB -= size;
  }
}
class Fragment {
  constructor(content, size) {
    this.content = content;
    this.size = size || 0;
    if (size == null)
      for (let i3 = 0; i3 < content.length; i3++)
        this.size += content[i3].nodeSize;
  }
  nodesBetween(from3, to, f2, nodeStart = 0, parent) {
    for (let i3 = 0, pos = 0; pos < to; i3++) {
      let child = this.content[i3], end2 = pos + child.nodeSize;
      if (end2 > from3 && f2(child, nodeStart + pos, parent || null, i3) !== false && child.content.size) {
        let start2 = pos + 1;
        child.nodesBetween(Math.max(0, from3 - start2), Math.min(child.content.size, to - start2), f2, nodeStart + start2);
      }
      pos = end2;
    }
  }
  descendants(f2) {
    this.nodesBetween(0, this.size, f2);
  }
  textBetween(from3, to, blockSeparator, leafText) {
    let text2 = "", separated = true;
    this.nodesBetween(from3, to, (node2, pos) => {
      if (node2.isText) {
        text2 += node2.text.slice(Math.max(from3, pos) - pos, to - pos);
        separated = !blockSeparator;
      } else if (node2.isLeaf) {
        if (leafText) {
          text2 += typeof leafText === "function" ? leafText(node2) : leafText;
        } else if (node2.type.spec.leafText) {
          text2 += node2.type.spec.leafText(node2);
        }
        separated = !blockSeparator;
      } else if (!separated && node2.isBlock) {
        text2 += blockSeparator;
        separated = true;
      }
    }, 0);
    return text2;
  }
  append(other) {
    if (!other.size)
      return this;
    if (!this.size)
      return other;
    let last = this.lastChild, first2 = other.firstChild, content = this.content.slice(), i3 = 0;
    if (last.isText && last.sameMarkup(first2)) {
      content[content.length - 1] = last.withText(last.text + first2.text);
      i3 = 1;
    }
    for (; i3 < other.content.length; i3++)
      content.push(other.content[i3]);
    return new Fragment(content, this.size + other.size);
  }
  cut(from3, to = this.size) {
    if (from3 == 0 && to == this.size)
      return this;
    let result = [], size = 0;
    if (to > from3)
      for (let i3 = 0, pos = 0; pos < to; i3++) {
        let child = this.content[i3], end2 = pos + child.nodeSize;
        if (end2 > from3) {
          if (pos < from3 || end2 > to) {
            if (child.isText)
              child = child.cut(Math.max(0, from3 - pos), Math.min(child.text.length, to - pos));
            else
              child = child.cut(Math.max(0, from3 - pos - 1), Math.min(child.content.size, to - pos - 1));
          }
          result.push(child);
          size += child.nodeSize;
        }
        pos = end2;
      }
    return new Fragment(result, size);
  }
  cutByIndex(from3, to) {
    if (from3 == to)
      return Fragment.empty;
    if (from3 == 0 && to == this.content.length)
      return this;
    return new Fragment(this.content.slice(from3, to));
  }
  replaceChild(index2, node2) {
    let current = this.content[index2];
    if (current == node2)
      return this;
    let copy2 = this.content.slice();
    let size = this.size + node2.nodeSize - current.nodeSize;
    copy2[index2] = node2;
    return new Fragment(copy2, size);
  }
  addToStart(node2) {
    return new Fragment([node2].concat(this.content), this.size + node2.nodeSize);
  }
  addToEnd(node2) {
    return new Fragment(this.content.concat(node2), this.size + node2.nodeSize);
  }
  eq(other) {
    if (this.content.length != other.content.length)
      return false;
    for (let i3 = 0; i3 < this.content.length; i3++)
      if (!this.content[i3].eq(other.content[i3]))
        return false;
    return true;
  }
  get firstChild() {
    return this.content.length ? this.content[0] : null;
  }
  get lastChild() {
    return this.content.length ? this.content[this.content.length - 1] : null;
  }
  get childCount() {
    return this.content.length;
  }
  child(index2) {
    let found2 = this.content[index2];
    if (!found2)
      throw new RangeError("Index " + index2 + " out of range for " + this);
    return found2;
  }
  maybeChild(index2) {
    return this.content[index2] || null;
  }
  forEach(f2) {
    for (let i3 = 0, p2 = 0; i3 < this.content.length; i3++) {
      let child = this.content[i3];
      f2(child, p2, i3);
      p2 += child.nodeSize;
    }
  }
  findDiffStart(other, pos = 0) {
    return findDiffStart(this, other, pos);
  }
  findDiffEnd(other, pos = this.size, otherPos = other.size) {
    return findDiffEnd(this, other, pos, otherPos);
  }
  findIndex(pos, round2 = -1) {
    if (pos == 0)
      return retIndex(0, pos);
    if (pos == this.size)
      return retIndex(this.content.length, pos);
    if (pos > this.size || pos < 0)
      throw new RangeError(`Position ${pos} outside of fragment (${this})`);
    for (let i3 = 0, curPos = 0; ; i3++) {
      let cur = this.child(i3), end2 = curPos + cur.nodeSize;
      if (end2 >= pos) {
        if (end2 == pos || round2 > 0)
          return retIndex(i3 + 1, end2);
        return retIndex(i3, curPos);
      }
      curPos = end2;
    }
  }
  toString() {
    return "<" + this.toStringInner() + ">";
  }
  toStringInner() {
    return this.content.join(", ");
  }
  toJSON() {
    return this.content.length ? this.content.map((n2) => n2.toJSON()) : null;
  }
  static fromJSON(schema, value) {
    if (!value)
      return Fragment.empty;
    if (!Array.isArray(value))
      throw new RangeError("Invalid input for Fragment.fromJSON");
    return new Fragment(value.map(schema.nodeFromJSON));
  }
  static fromArray(array) {
    if (!array.length)
      return Fragment.empty;
    let joined, size = 0;
    for (let i3 = 0; i3 < array.length; i3++) {
      let node2 = array[i3];
      size += node2.nodeSize;
      if (i3 && node2.isText && array[i3 - 1].sameMarkup(node2)) {
        if (!joined)
          joined = array.slice(0, i3);
        joined[joined.length - 1] = node2.withText(joined[joined.length - 1].text + node2.text);
      } else if (joined) {
        joined.push(node2);
      }
    }
    return new Fragment(joined || array, size);
  }
  static from(nodes) {
    if (!nodes)
      return Fragment.empty;
    if (nodes instanceof Fragment)
      return nodes;
    if (Array.isArray(nodes))
      return this.fromArray(nodes);
    if (nodes.attrs)
      return new Fragment([nodes], nodes.nodeSize);
    throw new RangeError("Can not convert " + nodes + " to a Fragment" + (nodes.nodesBetween ? " (looks like multiple versions of prosemirror-model were loaded)" : ""));
  }
}
Fragment.empty = new Fragment([], 0);
const found = { index: 0, offset: 0 };
function retIndex(index2, offset2) {
  found.index = index2;
  found.offset = offset2;
  return found;
}
function compareDeep(a4, b3) {
  if (a4 === b3)
    return true;
  if (!(a4 && typeof a4 == "object") || !(b3 && typeof b3 == "object"))
    return false;
  let array = Array.isArray(a4);
  if (Array.isArray(b3) != array)
    return false;
  if (array) {
    if (a4.length != b3.length)
      return false;
    for (let i3 = 0; i3 < a4.length; i3++)
      if (!compareDeep(a4[i3], b3[i3]))
        return false;
  } else {
    for (let p2 in a4)
      if (!(p2 in b3) || !compareDeep(a4[p2], b3[p2]))
        return false;
    for (let p2 in b3)
      if (!(p2 in a4))
        return false;
  }
  return true;
}
class Mark$1 {
  constructor(type, attrs) {
    this.type = type;
    this.attrs = attrs;
  }
  addToSet(set2) {
    let copy2, placed = false;
    for (let i3 = 0; i3 < set2.length; i3++) {
      let other = set2[i3];
      if (this.eq(other))
        return set2;
      if (this.type.excludes(other.type)) {
        if (!copy2)
          copy2 = set2.slice(0, i3);
      } else if (other.type.excludes(this.type)) {
        return set2;
      } else {
        if (!placed && other.type.rank > this.type.rank) {
          if (!copy2)
            copy2 = set2.slice(0, i3);
          copy2.push(this);
          placed = true;
        }
        if (copy2)
          copy2.push(other);
      }
    }
    if (!copy2)
      copy2 = set2.slice();
    if (!placed)
      copy2.push(this);
    return copy2;
  }
  removeFromSet(set2) {
    for (let i3 = 0; i3 < set2.length; i3++)
      if (this.eq(set2[i3]))
        return set2.slice(0, i3).concat(set2.slice(i3 + 1));
    return set2;
  }
  isInSet(set2) {
    for (let i3 = 0; i3 < set2.length; i3++)
      if (this.eq(set2[i3]))
        return true;
    return false;
  }
  eq(other) {
    return this == other || this.type == other.type && compareDeep(this.attrs, other.attrs);
  }
  toJSON() {
    let obj = { type: this.type.name };
    for (let _2 in this.attrs) {
      obj.attrs = this.attrs;
      break;
    }
    return obj;
  }
  static fromJSON(schema, json) {
    if (!json)
      throw new RangeError("Invalid input for Mark.fromJSON");
    let type = schema.marks[json.type];
    if (!type)
      throw new RangeError(`There is no mark type ${json.type} in this schema`);
    return type.create(json.attrs);
  }
  static sameSet(a4, b3) {
    if (a4 == b3)
      return true;
    if (a4.length != b3.length)
      return false;
    for (let i3 = 0; i3 < a4.length; i3++)
      if (!a4[i3].eq(b3[i3]))
        return false;
    return true;
  }
  static setFrom(marks) {
    if (!marks || Array.isArray(marks) && marks.length == 0)
      return Mark$1.none;
    if (marks instanceof Mark$1)
      return [marks];
    let copy2 = marks.slice();
    copy2.sort((a4, b3) => a4.type.rank - b3.type.rank);
    return copy2;
  }
}
Mark$1.none = [];
class ReplaceError extends Error {
}
class Slice {
  constructor(content, openStart, openEnd) {
    this.content = content;
    this.openStart = openStart;
    this.openEnd = openEnd;
  }
  get size() {
    return this.content.size - this.openStart - this.openEnd;
  }
  insertAt(pos, fragment) {
    let content = insertInto(this.content, pos + this.openStart, fragment);
    return content && new Slice(content, this.openStart, this.openEnd);
  }
  removeBetween(from3, to) {
    return new Slice(removeRange(this.content, from3 + this.openStart, to + this.openStart), this.openStart, this.openEnd);
  }
  eq(other) {
    return this.content.eq(other.content) && this.openStart == other.openStart && this.openEnd == other.openEnd;
  }
  toString() {
    return this.content + "(" + this.openStart + "," + this.openEnd + ")";
  }
  toJSON() {
    if (!this.content.size)
      return null;
    let json = { content: this.content.toJSON() };
    if (this.openStart > 0)
      json.openStart = this.openStart;
    if (this.openEnd > 0)
      json.openEnd = this.openEnd;
    return json;
  }
  static fromJSON(schema, json) {
    if (!json)
      return Slice.empty;
    let openStart = json.openStart || 0, openEnd = json.openEnd || 0;
    if (typeof openStart != "number" || typeof openEnd != "number")
      throw new RangeError("Invalid input for Slice.fromJSON");
    return new Slice(Fragment.fromJSON(schema, json.content), openStart, openEnd);
  }
  static maxOpen(fragment, openIsolating = true) {
    let openStart = 0, openEnd = 0;
    for (let n2 = fragment.firstChild; n2 && !n2.isLeaf && (openIsolating || !n2.type.spec.isolating); n2 = n2.firstChild)
      openStart++;
    for (let n2 = fragment.lastChild; n2 && !n2.isLeaf && (openIsolating || !n2.type.spec.isolating); n2 = n2.lastChild)
      openEnd++;
    return new Slice(fragment, openStart, openEnd);
  }
}
Slice.empty = new Slice(Fragment.empty, 0, 0);
function removeRange(content, from3, to) {
  let { index: index2, offset: offset2 } = content.findIndex(from3), child = content.maybeChild(index2);
  let { index: indexTo, offset: offsetTo } = content.findIndex(to);
  if (offset2 == from3 || child.isText) {
    if (offsetTo != to && !content.child(indexTo).isText)
      throw new RangeError("Removing non-flat range");
    return content.cut(0, from3).append(content.cut(to));
  }
  if (index2 != indexTo)
    throw new RangeError("Removing non-flat range");
  return content.replaceChild(index2, child.copy(removeRange(child.content, from3 - offset2 - 1, to - offset2 - 1)));
}
function insertInto(content, dist, insert, parent) {
  let { index: index2, offset: offset2 } = content.findIndex(dist), child = content.maybeChild(index2);
  if (offset2 == dist || child.isText) {
    if (parent && !parent.canReplace(index2, index2, insert))
      return null;
    return content.cut(0, dist).append(insert).append(content.cut(dist));
  }
  let inner = insertInto(child.content, dist - offset2 - 1, insert);
  return inner && content.replaceChild(index2, child.copy(inner));
}
function replace($from, $to, slice3) {
  if (slice3.openStart > $from.depth)
    throw new ReplaceError("Inserted content deeper than insertion position");
  if ($from.depth - slice3.openStart != $to.depth - slice3.openEnd)
    throw new ReplaceError("Inconsistent open depths");
  return replaceOuter($from, $to, slice3, 0);
}
function replaceOuter($from, $to, slice3, depth) {
  let index2 = $from.index(depth), node2 = $from.node(depth);
  if (index2 == $to.index(depth) && depth < $from.depth - slice3.openStart) {
    let inner = replaceOuter($from, $to, slice3, depth + 1);
    return node2.copy(node2.content.replaceChild(index2, inner));
  } else if (!slice3.content.size) {
    return close(node2, replaceTwoWay($from, $to, depth));
  } else if (!slice3.openStart && !slice3.openEnd && $from.depth == depth && $to.depth == depth) {
    let parent = $from.parent, content = parent.content;
    return close(parent, content.cut(0, $from.parentOffset).append(slice3.content).append(content.cut($to.parentOffset)));
  } else {
    let { start: start2, end: end2 } = prepareSliceForReplace(slice3, $from);
    return close(node2, replaceThreeWay($from, start2, end2, $to, depth));
  }
}
function checkJoin(main2, sub) {
  if (!sub.type.compatibleContent(main2.type))
    throw new ReplaceError("Cannot join " + sub.type.name + " onto " + main2.type.name);
}
function joinable$1($before, $after, depth) {
  let node2 = $before.node(depth);
  checkJoin(node2, $after.node(depth));
  return node2;
}
function addNode(child, target) {
  let last = target.length - 1;
  if (last >= 0 && child.isText && child.sameMarkup(target[last]))
    target[last] = child.withText(target[last].text + child.text);
  else
    target.push(child);
}
function addRange($start, $end, depth, target) {
  let node2 = ($end || $start).node(depth);
  let startIndex2 = 0, endIndex2 = $end ? $end.index(depth) : node2.childCount;
  if ($start) {
    startIndex2 = $start.index(depth);
    if ($start.depth > depth) {
      startIndex2++;
    } else if ($start.textOffset) {
      addNode($start.nodeAfter, target);
      startIndex2++;
    }
  }
  for (let i3 = startIndex2; i3 < endIndex2; i3++)
    addNode(node2.child(i3), target);
  if ($end && $end.depth == depth && $end.textOffset)
    addNode($end.nodeBefore, target);
}
function close(node2, content) {
  node2.type.checkContent(content);
  return node2.copy(content);
}
function replaceThreeWay($from, $start, $end, $to, depth) {
  let openStart = $from.depth > depth && joinable$1($from, $start, depth + 1);
  let openEnd = $to.depth > depth && joinable$1($end, $to, depth + 1);
  let content = [];
  addRange(null, $from, depth, content);
  if (openStart && openEnd && $start.index(depth) == $end.index(depth)) {
    checkJoin(openStart, openEnd);
    addNode(close(openStart, replaceThreeWay($from, $start, $end, $to, depth + 1)), content);
  } else {
    if (openStart)
      addNode(close(openStart, replaceTwoWay($from, $start, depth + 1)), content);
    addRange($start, $end, depth, content);
    if (openEnd)
      addNode(close(openEnd, replaceTwoWay($end, $to, depth + 1)), content);
  }
  addRange($to, null, depth, content);
  return new Fragment(content);
}
function replaceTwoWay($from, $to, depth) {
  let content = [];
  addRange(null, $from, depth, content);
  if ($from.depth > depth) {
    let type = joinable$1($from, $to, depth + 1);
    addNode(close(type, replaceTwoWay($from, $to, depth + 1)), content);
  }
  addRange($to, null, depth, content);
  return new Fragment(content);
}
function prepareSliceForReplace(slice3, $along) {
  let extra = $along.depth - slice3.openStart, parent = $along.node(extra);
  let node2 = parent.copy(slice3.content);
  for (let i3 = extra - 1; i3 >= 0; i3--)
    node2 = $along.node(i3).copy(Fragment.from(node2));
  return {
    start: node2.resolveNoCache(slice3.openStart + extra),
    end: node2.resolveNoCache(node2.content.size - slice3.openEnd - extra)
  };
}
class ResolvedPos {
  constructor(pos, path, parentOffset) {
    this.pos = pos;
    this.path = path;
    this.parentOffset = parentOffset;
    this.depth = path.length / 3 - 1;
  }
  resolveDepth(val) {
    if (val == null)
      return this.depth;
    if (val < 0)
      return this.depth + val;
    return val;
  }
  get parent() {
    return this.node(this.depth);
  }
  get doc() {
    return this.node(0);
  }
  node(depth) {
    return this.path[this.resolveDepth(depth) * 3];
  }
  index(depth) {
    return this.path[this.resolveDepth(depth) * 3 + 1];
  }
  indexAfter(depth) {
    depth = this.resolveDepth(depth);
    return this.index(depth) + (depth == this.depth && !this.textOffset ? 0 : 1);
  }
  start(depth) {
    depth = this.resolveDepth(depth);
    return depth == 0 ? 0 : this.path[depth * 3 - 1] + 1;
  }
  end(depth) {
    depth = this.resolveDepth(depth);
    return this.start(depth) + this.node(depth).content.size;
  }
  before(depth) {
    depth = this.resolveDepth(depth);
    if (!depth)
      throw new RangeError("There is no position before the top-level node");
    return depth == this.depth + 1 ? this.pos : this.path[depth * 3 - 1];
  }
  after(depth) {
    depth = this.resolveDepth(depth);
    if (!depth)
      throw new RangeError("There is no position after the top-level node");
    return depth == this.depth + 1 ? this.pos : this.path[depth * 3 - 1] + this.path[depth * 3].nodeSize;
  }
  get textOffset() {
    return this.pos - this.path[this.path.length - 1];
  }
  get nodeAfter() {
    let parent = this.parent, index2 = this.index(this.depth);
    if (index2 == parent.childCount)
      return null;
    let dOff = this.pos - this.path[this.path.length - 1], child = parent.child(index2);
    return dOff ? parent.child(index2).cut(dOff) : child;
  }
  get nodeBefore() {
    let index2 = this.index(this.depth);
    let dOff = this.pos - this.path[this.path.length - 1];
    if (dOff)
      return this.parent.child(index2).cut(0, dOff);
    return index2 == 0 ? null : this.parent.child(index2 - 1);
  }
  posAtIndex(index2, depth) {
    depth = this.resolveDepth(depth);
    let node2 = this.path[depth * 3], pos = depth == 0 ? 0 : this.path[depth * 3 - 1] + 1;
    for (let i3 = 0; i3 < index2; i3++)
      pos += node2.child(i3).nodeSize;
    return pos;
  }
  marks() {
    let parent = this.parent, index2 = this.index();
    if (parent.content.size == 0)
      return Mark$1.none;
    if (this.textOffset)
      return parent.child(index2).marks;
    let main2 = parent.maybeChild(index2 - 1), other = parent.maybeChild(index2);
    if (!main2) {
      let tmp = main2;
      main2 = other;
      other = tmp;
    }
    let marks = main2.marks;
    for (var i3 = 0; i3 < marks.length; i3++)
      if (marks[i3].type.spec.inclusive === false && (!other || !marks[i3].isInSet(other.marks)))
        marks = marks[i3--].removeFromSet(marks);
    return marks;
  }
  marksAcross($end) {
    let after = this.parent.maybeChild(this.index());
    if (!after || !after.isInline)
      return null;
    let marks = after.marks, next2 = $end.parent.maybeChild($end.index());
    for (var i3 = 0; i3 < marks.length; i3++)
      if (marks[i3].type.spec.inclusive === false && (!next2 || !marks[i3].isInSet(next2.marks)))
        marks = marks[i3--].removeFromSet(marks);
    return marks;
  }
  sharedDepth(pos) {
    for (let depth = this.depth; depth > 0; depth--)
      if (this.start(depth) <= pos && this.end(depth) >= pos)
        return depth;
    return 0;
  }
  blockRange(other = this, pred) {
    if (other.pos < this.pos)
      return other.blockRange(this);
    for (let d4 = this.depth - (this.parent.inlineContent || this.pos == other.pos ? 1 : 0); d4 >= 0; d4--)
      if (other.pos <= this.end(d4) && (!pred || pred(this.node(d4))))
        return new NodeRange(this, other, d4);
    return null;
  }
  sameParent(other) {
    return this.pos - this.parentOffset == other.pos - other.parentOffset;
  }
  max(other) {
    return other.pos > this.pos ? other : this;
  }
  min(other) {
    return other.pos < this.pos ? other : this;
  }
  toString() {
    let str = "";
    for (let i3 = 1; i3 <= this.depth; i3++)
      str += (str ? "/" : "") + this.node(i3).type.name + "_" + this.index(i3 - 1);
    return str + ":" + this.parentOffset;
  }
  static resolve(doc2, pos) {
    if (!(pos >= 0 && pos <= doc2.content.size))
      throw new RangeError("Position " + pos + " out of range");
    let path = [];
    let start2 = 0, parentOffset = pos;
    for (let node2 = doc2; ; ) {
      let { index: index2, offset: offset2 } = node2.content.findIndex(parentOffset);
      let rem = parentOffset - offset2;
      path.push(node2, index2, start2 + offset2);
      if (!rem)
        break;
      node2 = node2.child(index2);
      if (node2.isText)
        break;
      parentOffset = rem - 1;
      start2 += offset2 + 1;
    }
    return new ResolvedPos(pos, path, parentOffset);
  }
  static resolveCached(doc2, pos) {
    for (let i3 = 0; i3 < resolveCache.length; i3++) {
      let cached = resolveCache[i3];
      if (cached.pos == pos && cached.doc == doc2)
        return cached;
    }
    let result = resolveCache[resolveCachePos] = ResolvedPos.resolve(doc2, pos);
    resolveCachePos = (resolveCachePos + 1) % resolveCacheSize;
    return result;
  }
}
let resolveCache = [], resolveCachePos = 0, resolveCacheSize = 12;
class NodeRange {
  constructor($from, $to, depth) {
    this.$from = $from;
    this.$to = $to;
    this.depth = depth;
  }
  get start() {
    return this.$from.before(this.depth + 1);
  }
  get end() {
    return this.$to.after(this.depth + 1);
  }
  get parent() {
    return this.$from.node(this.depth);
  }
  get startIndex() {
    return this.$from.index(this.depth);
  }
  get endIndex() {
    return this.$to.indexAfter(this.depth);
  }
}
const emptyAttrs = /* @__PURE__ */ Object.create(null);
class Node$2 {
  constructor(type, attrs, content, marks = Mark$1.none) {
    this.type = type;
    this.attrs = attrs;
    this.marks = marks;
    this.content = content || Fragment.empty;
  }
  get nodeSize() {
    return this.isLeaf ? 1 : 2 + this.content.size;
  }
  get childCount() {
    return this.content.childCount;
  }
  child(index2) {
    return this.content.child(index2);
  }
  maybeChild(index2) {
    return this.content.maybeChild(index2);
  }
  forEach(f2) {
    this.content.forEach(f2);
  }
  nodesBetween(from3, to, f2, startPos = 0) {
    this.content.nodesBetween(from3, to, f2, startPos, this);
  }
  descendants(f2) {
    this.nodesBetween(0, this.content.size, f2);
  }
  get textContent() {
    return this.isLeaf && this.type.spec.leafText ? this.type.spec.leafText(this) : this.textBetween(0, this.content.size, "");
  }
  textBetween(from3, to, blockSeparator, leafText) {
    return this.content.textBetween(from3, to, blockSeparator, leafText);
  }
  get firstChild() {
    return this.content.firstChild;
  }
  get lastChild() {
    return this.content.lastChild;
  }
  eq(other) {
    return this == other || this.sameMarkup(other) && this.content.eq(other.content);
  }
  sameMarkup(other) {
    return this.hasMarkup(other.type, other.attrs, other.marks);
  }
  hasMarkup(type, attrs, marks) {
    return this.type == type && compareDeep(this.attrs, attrs || type.defaultAttrs || emptyAttrs) && Mark$1.sameSet(this.marks, marks || Mark$1.none);
  }
  copy(content = null) {
    if (content == this.content)
      return this;
    return new Node$2(this.type, this.attrs, content, this.marks);
  }
  mark(marks) {
    return marks == this.marks ? this : new Node$2(this.type, this.attrs, this.content, marks);
  }
  cut(from3, to = this.content.size) {
    if (from3 == 0 && to == this.content.size)
      return this;
    return this.copy(this.content.cut(from3, to));
  }
  slice(from3, to = this.content.size, includeParents = false) {
    if (from3 == to)
      return Slice.empty;
    let $from = this.resolve(from3), $to = this.resolve(to);
    let depth = includeParents ? 0 : $from.sharedDepth(to);
    let start2 = $from.start(depth), node2 = $from.node(depth);
    let content = node2.content.cut($from.pos - start2, $to.pos - start2);
    return new Slice(content, $from.depth - depth, $to.depth - depth);
  }
  replace(from3, to, slice3) {
    return replace(this.resolve(from3), this.resolve(to), slice3);
  }
  nodeAt(pos) {
    for (let node2 = this; ; ) {
      let { index: index2, offset: offset2 } = node2.content.findIndex(pos);
      node2 = node2.maybeChild(index2);
      if (!node2)
        return null;
      if (offset2 == pos || node2.isText)
        return node2;
      pos -= offset2 + 1;
    }
  }
  childAfter(pos) {
    let { index: index2, offset: offset2 } = this.content.findIndex(pos);
    return { node: this.content.maybeChild(index2), index: index2, offset: offset2 };
  }
  childBefore(pos) {
    if (pos == 0)
      return { node: null, index: 0, offset: 0 };
    let { index: index2, offset: offset2 } = this.content.findIndex(pos);
    if (offset2 < pos)
      return { node: this.content.child(index2), index: index2, offset: offset2 };
    let node2 = this.content.child(index2 - 1);
    return { node: node2, index: index2 - 1, offset: offset2 - node2.nodeSize };
  }
  resolve(pos) {
    return ResolvedPos.resolveCached(this, pos);
  }
  resolveNoCache(pos) {
    return ResolvedPos.resolve(this, pos);
  }
  rangeHasMark(from3, to, type) {
    let found2 = false;
    if (to > from3)
      this.nodesBetween(from3, to, (node2) => {
        if (type.isInSet(node2.marks))
          found2 = true;
        return !found2;
      });
    return found2;
  }
  get isBlock() {
    return this.type.isBlock;
  }
  get isTextblock() {
    return this.type.isTextblock;
  }
  get inlineContent() {
    return this.type.inlineContent;
  }
  get isInline() {
    return this.type.isInline;
  }
  get isText() {
    return this.type.isText;
  }
  get isLeaf() {
    return this.type.isLeaf;
  }
  get isAtom() {
    return this.type.isAtom;
  }
  toString() {
    if (this.type.spec.toDebugString)
      return this.type.spec.toDebugString(this);
    let name = this.type.name;
    if (this.content.size)
      name += "(" + this.content.toStringInner() + ")";
    return wrapMarks(this.marks, name);
  }
  contentMatchAt(index2) {
    let match2 = this.type.contentMatch.matchFragment(this.content, 0, index2);
    if (!match2)
      throw new Error("Called contentMatchAt on a node with invalid content");
    return match2;
  }
  canReplace(from3, to, replacement = Fragment.empty, start2 = 0, end2 = replacement.childCount) {
    let one = this.contentMatchAt(from3).matchFragment(replacement, start2, end2);
    let two = one && one.matchFragment(this.content, to);
    if (!two || !two.validEnd)
      return false;
    for (let i3 = start2; i3 < end2; i3++)
      if (!this.type.allowsMarks(replacement.child(i3).marks))
        return false;
    return true;
  }
  canReplaceWith(from3, to, type, marks) {
    if (marks && !this.type.allowsMarks(marks))
      return false;
    let start2 = this.contentMatchAt(from3).matchType(type);
    let end2 = start2 && start2.matchFragment(this.content, to);
    return end2 ? end2.validEnd : false;
  }
  canAppend(other) {
    if (other.content.size)
      return this.canReplace(this.childCount, this.childCount, other.content);
    else
      return this.type.compatibleContent(other.type);
  }
  check() {
    this.type.checkContent(this.content);
    let copy2 = Mark$1.none;
    for (let i3 = 0; i3 < this.marks.length; i3++)
      copy2 = this.marks[i3].addToSet(copy2);
    if (!Mark$1.sameSet(copy2, this.marks))
      throw new RangeError(`Invalid collection of marks for node ${this.type.name}: ${this.marks.map((m4) => m4.type.name)}`);
    this.content.forEach((node2) => node2.check());
  }
  toJSON() {
    let obj = { type: this.type.name };
    for (let _2 in this.attrs) {
      obj.attrs = this.attrs;
      break;
    }
    if (this.content.size)
      obj.content = this.content.toJSON();
    if (this.marks.length)
      obj.marks = this.marks.map((n2) => n2.toJSON());
    return obj;
  }
  static fromJSON(schema, json) {
    if (!json)
      throw new RangeError("Invalid input for Node.fromJSON");
    let marks = null;
    if (json.marks) {
      if (!Array.isArray(json.marks))
        throw new RangeError("Invalid mark data for Node.fromJSON");
      marks = json.marks.map(schema.markFromJSON);
    }
    if (json.type == "text") {
      if (typeof json.text != "string")
        throw new RangeError("Invalid text node in JSON");
      return schema.text(json.text, marks);
    }
    let content = Fragment.fromJSON(schema, json.content);
    return schema.nodeType(json.type).create(json.attrs, content, marks);
  }
}
Node$2.prototype.text = void 0;
class TextNode extends Node$2 {
  constructor(type, attrs, content, marks) {
    super(type, attrs, null, marks);
    if (!content)
      throw new RangeError("Empty text nodes are not allowed");
    this.text = content;
  }
  toString() {
    if (this.type.spec.toDebugString)
      return this.type.spec.toDebugString(this);
    return wrapMarks(this.marks, JSON.stringify(this.text));
  }
  get textContent() {
    return this.text;
  }
  textBetween(from3, to) {
    return this.text.slice(from3, to);
  }
  get nodeSize() {
    return this.text.length;
  }
  mark(marks) {
    return marks == this.marks ? this : new TextNode(this.type, this.attrs, this.text, marks);
  }
  withText(text2) {
    if (text2 == this.text)
      return this;
    return new TextNode(this.type, this.attrs, text2, this.marks);
  }
  cut(from3 = 0, to = this.text.length) {
    if (from3 == 0 && to == this.text.length)
      return this;
    return this.withText(this.text.slice(from3, to));
  }
  eq(other) {
    return this.sameMarkup(other) && this.text == other.text;
  }
  toJSON() {
    let base2 = super.toJSON();
    base2.text = this.text;
    return base2;
  }
}
function wrapMarks(marks, str) {
  for (let i3 = marks.length - 1; i3 >= 0; i3--)
    str = marks[i3].type.name + "(" + str + ")";
  return str;
}
class ContentMatch {
  constructor(validEnd) {
    this.validEnd = validEnd;
    this.next = [];
    this.wrapCache = [];
  }
  static parse(string, nodeTypes) {
    let stream = new TokenStream(string, nodeTypes);
    if (stream.next == null)
      return ContentMatch.empty;
    let expr = parseExpr(stream);
    if (stream.next)
      stream.err("Unexpected trailing text");
    let match2 = dfa(nfa(expr));
    checkForDeadEnds(match2, stream);
    return match2;
  }
  matchType(type) {
    for (let i3 = 0; i3 < this.next.length; i3++)
      if (this.next[i3].type == type)
        return this.next[i3].next;
    return null;
  }
  matchFragment(frag, start2 = 0, end2 = frag.childCount) {
    let cur = this;
    for (let i3 = start2; cur && i3 < end2; i3++)
      cur = cur.matchType(frag.child(i3).type);
    return cur;
  }
  get inlineContent() {
    return this.next.length != 0 && this.next[0].type.isInline;
  }
  get defaultType() {
    for (let i3 = 0; i3 < this.next.length; i3++) {
      let { type } = this.next[i3];
      if (!(type.isText || type.hasRequiredAttrs()))
        return type;
    }
    return null;
  }
  compatible(other) {
    for (let i3 = 0; i3 < this.next.length; i3++)
      for (let j2 = 0; j2 < other.next.length; j2++)
        if (this.next[i3].type == other.next[j2].type)
          return true;
    return false;
  }
  fillBefore(after, toEnd = false, startIndex2 = 0) {
    let seen = [this];
    function search(match2, types) {
      let finished = match2.matchFragment(after, startIndex2);
      if (finished && (!toEnd || finished.validEnd))
        return Fragment.from(types.map((tp) => tp.createAndFill()));
      for (let i3 = 0; i3 < match2.next.length; i3++) {
        let { type, next: next2 } = match2.next[i3];
        if (!(type.isText || type.hasRequiredAttrs()) && seen.indexOf(next2) == -1) {
          seen.push(next2);
          let found2 = search(next2, types.concat(type));
          if (found2)
            return found2;
        }
      }
      return null;
    }
    return search(this, []);
  }
  findWrapping(target) {
    for (let i3 = 0; i3 < this.wrapCache.length; i3 += 2)
      if (this.wrapCache[i3] == target)
        return this.wrapCache[i3 + 1];
    let computed = this.computeWrapping(target);
    this.wrapCache.push(target, computed);
    return computed;
  }
  computeWrapping(target) {
    let seen = /* @__PURE__ */ Object.create(null), active = [{ match: this, type: null, via: null }];
    while (active.length) {
      let current = active.shift(), match2 = current.match;
      if (match2.matchType(target)) {
        let result = [];
        for (let obj = current; obj.type; obj = obj.via)
          result.push(obj.type);
        return result.reverse();
      }
      for (let i3 = 0; i3 < match2.next.length; i3++) {
        let { type, next: next2 } = match2.next[i3];
        if (!type.isLeaf && !type.hasRequiredAttrs() && !(type.name in seen) && (!current.type || next2.validEnd)) {
          active.push({ match: type.contentMatch, type, via: current });
          seen[type.name] = true;
        }
      }
    }
    return null;
  }
  get edgeCount() {
    return this.next.length;
  }
  edge(n2) {
    if (n2 >= this.next.length)
      throw new RangeError(`There's no ${n2}th edge in this content match`);
    return this.next[n2];
  }
  toString() {
    let seen = [];
    function scan(m4) {
      seen.push(m4);
      for (let i3 = 0; i3 < m4.next.length; i3++)
        if (seen.indexOf(m4.next[i3].next) == -1)
          scan(m4.next[i3].next);
    }
    scan(this);
    return seen.map((m4, i3) => {
      let out = i3 + (m4.validEnd ? "*" : " ") + " ";
      for (let i4 = 0; i4 < m4.next.length; i4++)
        out += (i4 ? ", " : "") + m4.next[i4].type.name + "->" + seen.indexOf(m4.next[i4].next);
      return out;
    }).join("\n");
  }
}
ContentMatch.empty = new ContentMatch(true);
class TokenStream {
  constructor(string, nodeTypes) {
    this.string = string;
    this.nodeTypes = nodeTypes;
    this.inline = null;
    this.pos = 0;
    this.tokens = string.split(/\s*(?=\b|\W|$)/);
    if (this.tokens[this.tokens.length - 1] == "")
      this.tokens.pop();
    if (this.tokens[0] == "")
      this.tokens.shift();
  }
  get next() {
    return this.tokens[this.pos];
  }
  eat(tok) {
    return this.next == tok && (this.pos++ || true);
  }
  err(str) {
    throw new SyntaxError(str + " (in content expression '" + this.string + "')");
  }
}
function parseExpr(stream) {
  let exprs = [];
  do {
    exprs.push(parseExprSeq(stream));
  } while (stream.eat("|"));
  return exprs.length == 1 ? exprs[0] : { type: "choice", exprs };
}
function parseExprSeq(stream) {
  let exprs = [];
  do {
    exprs.push(parseExprSubscript(stream));
  } while (stream.next && stream.next != ")" && stream.next != "|");
  return exprs.length == 1 ? exprs[0] : { type: "seq", exprs };
}
function parseExprSubscript(stream) {
  let expr = parseExprAtom(stream);
  for (; ; ) {
    if (stream.eat("+"))
      expr = { type: "plus", expr };
    else if (stream.eat("*"))
      expr = { type: "star", expr };
    else if (stream.eat("?"))
      expr = { type: "opt", expr };
    else if (stream.eat("{"))
      expr = parseExprRange(stream, expr);
    else
      break;
  }
  return expr;
}
function parseNum(stream) {
  if (/\D/.test(stream.next))
    stream.err("Expected number, got '" + stream.next + "'");
  let result = Number(stream.next);
  stream.pos++;
  return result;
}
function parseExprRange(stream, expr) {
  let min2 = parseNum(stream), max2 = min2;
  if (stream.eat(",")) {
    if (stream.next != "}")
      max2 = parseNum(stream);
    else
      max2 = -1;
  }
  if (!stream.eat("}"))
    stream.err("Unclosed braced range");
  return { type: "range", min: min2, max: max2, expr };
}
function resolveName(stream, name) {
  let types = stream.nodeTypes, type = types[name];
  if (type)
    return [type];
  let result = [];
  for (let typeName in types) {
    let type2 = types[typeName];
    if (type2.groups.indexOf(name) > -1)
      result.push(type2);
  }
  if (result.length == 0)
    stream.err("No node type or group '" + name + "' found");
  return result;
}
function parseExprAtom(stream) {
  if (stream.eat("(")) {
    let expr = parseExpr(stream);
    if (!stream.eat(")"))
      stream.err("Missing closing paren");
    return expr;
  } else if (!/\W/.test(stream.next)) {
    let exprs = resolveName(stream, stream.next).map((type) => {
      if (stream.inline == null)
        stream.inline = type.isInline;
      else if (stream.inline != type.isInline)
        stream.err("Mixing inline and block content");
      return { type: "name", value: type };
    });
    stream.pos++;
    return exprs.length == 1 ? exprs[0] : { type: "choice", exprs };
  } else {
    stream.err("Unexpected token '" + stream.next + "'");
  }
}
function nfa(expr) {
  let nfa2 = [[]];
  connect(compile2(expr, 0), node2());
  return nfa2;
  function node2() {
    return nfa2.push([]) - 1;
  }
  function edge(from3, to, term) {
    let edge2 = { term, to };
    nfa2[from3].push(edge2);
    return edge2;
  }
  function connect(edges, to) {
    edges.forEach((edge2) => edge2.to = to);
  }
  function compile2(expr2, from3) {
    if (expr2.type == "choice") {
      return expr2.exprs.reduce((out, expr3) => out.concat(compile2(expr3, from3)), []);
    } else if (expr2.type == "seq") {
      for (let i3 = 0; ; i3++) {
        let next2 = compile2(expr2.exprs[i3], from3);
        if (i3 == expr2.exprs.length - 1)
          return next2;
        connect(next2, from3 = node2());
      }
    } else if (expr2.type == "star") {
      let loop = node2();
      edge(from3, loop);
      connect(compile2(expr2.expr, loop), loop);
      return [edge(loop)];
    } else if (expr2.type == "plus") {
      let loop = node2();
      connect(compile2(expr2.expr, from3), loop);
      connect(compile2(expr2.expr, loop), loop);
      return [edge(loop)];
    } else if (expr2.type == "opt") {
      return [edge(from3)].concat(compile2(expr2.expr, from3));
    } else if (expr2.type == "range") {
      let cur = from3;
      for (let i3 = 0; i3 < expr2.min; i3++) {
        let next2 = node2();
        connect(compile2(expr2.expr, cur), next2);
        cur = next2;
      }
      if (expr2.max == -1) {
        connect(compile2(expr2.expr, cur), cur);
      } else {
        for (let i3 = expr2.min; i3 < expr2.max; i3++) {
          let next2 = node2();
          edge(cur, next2);
          connect(compile2(expr2.expr, cur), next2);
          cur = next2;
        }
      }
      return [edge(cur)];
    } else if (expr2.type == "name") {
      return [edge(from3, void 0, expr2.value)];
    } else {
      throw new Error("Unknown expr type");
    }
  }
}
function cmp(a4, b3) {
  return b3 - a4;
}
function nullFrom(nfa2, node2) {
  let result = [];
  scan(node2);
  return result.sort(cmp);
  function scan(node3) {
    let edges = nfa2[node3];
    if (edges.length == 1 && !edges[0].term)
      return scan(edges[0].to);
    result.push(node3);
    for (let i3 = 0; i3 < edges.length; i3++) {
      let { term, to } = edges[i3];
      if (!term && result.indexOf(to) == -1)
        scan(to);
    }
  }
}
function dfa(nfa2) {
  let labeled = /* @__PURE__ */ Object.create(null);
  return explore(nullFrom(nfa2, 0));
  function explore(states) {
    let out = [];
    states.forEach((node2) => {
      nfa2[node2].forEach(({ term, to }) => {
        if (!term)
          return;
        let set2;
        for (let i3 = 0; i3 < out.length; i3++)
          if (out[i3][0] == term)
            set2 = out[i3][1];
        nullFrom(nfa2, to).forEach((node3) => {
          if (!set2)
            out.push([term, set2 = []]);
          if (set2.indexOf(node3) == -1)
            set2.push(node3);
        });
      });
    });
    let state = labeled[states.join(",")] = new ContentMatch(states.indexOf(nfa2.length - 1) > -1);
    for (let i3 = 0; i3 < out.length; i3++) {
      let states2 = out[i3][1].sort(cmp);
      state.next.push({ type: out[i3][0], next: labeled[states2.join(",")] || explore(states2) });
    }
    return state;
  }
}
function checkForDeadEnds(match2, stream) {
  for (let i3 = 0, work = [match2]; i3 < work.length; i3++) {
    let state = work[i3], dead = !state.validEnd, nodes = [];
    for (let j2 = 0; j2 < state.next.length; j2++) {
      let { type, next: next2 } = state.next[j2];
      nodes.push(type.name);
      if (dead && !(type.isText || type.hasRequiredAttrs()))
        dead = false;
      if (work.indexOf(next2) == -1)
        work.push(next2);
    }
    if (dead)
      stream.err("Only non-generatable nodes (" + nodes.join(", ") + ") in a required position (see https://prosemirror.net/docs/guide/#generatable)");
  }
}
function defaultAttrs(attrs) {
  let defaults2 = /* @__PURE__ */ Object.create(null);
  for (let attrName in attrs) {
    let attr = attrs[attrName];
    if (!attr.hasDefault)
      return null;
    defaults2[attrName] = attr.default;
  }
  return defaults2;
}
function computeAttrs(attrs, value) {
  let built = /* @__PURE__ */ Object.create(null);
  for (let name in attrs) {
    let given = value && value[name];
    if (given === void 0) {
      let attr = attrs[name];
      if (attr.hasDefault)
        given = attr.default;
      else
        throw new RangeError("No value supplied for attribute " + name);
    }
    built[name] = given;
  }
  return built;
}
function initAttrs(attrs) {
  let result = /* @__PURE__ */ Object.create(null);
  if (attrs)
    for (let name in attrs)
      result[name] = new Attribute(attrs[name]);
  return result;
}
class NodeType$1 {
  constructor(name, schema, spec) {
    this.name = name;
    this.schema = schema;
    this.spec = spec;
    this.markSet = null;
    this.groups = spec.group ? spec.group.split(" ") : [];
    this.attrs = initAttrs(spec.attrs);
    this.defaultAttrs = defaultAttrs(this.attrs);
    this.contentMatch = null;
    this.inlineContent = null;
    this.isBlock = !(spec.inline || name == "text");
    this.isText = name == "text";
  }
  get isInline() {
    return !this.isBlock;
  }
  get isTextblock() {
    return this.isBlock && this.inlineContent;
  }
  get isLeaf() {
    return this.contentMatch == ContentMatch.empty;
  }
  get isAtom() {
    return this.isLeaf || !!this.spec.atom;
  }
  get whitespace() {
    return this.spec.whitespace || (this.spec.code ? "pre" : "normal");
  }
  hasRequiredAttrs() {
    for (let n2 in this.attrs)
      if (this.attrs[n2].isRequired)
        return true;
    return false;
  }
  compatibleContent(other) {
    return this == other || this.contentMatch.compatible(other.contentMatch);
  }
  computeAttrs(attrs) {
    if (!attrs && this.defaultAttrs)
      return this.defaultAttrs;
    else
      return computeAttrs(this.attrs, attrs);
  }
  create(attrs = null, content, marks) {
    if (this.isText)
      throw new Error("NodeType.create can't construct text nodes");
    return new Node$2(this, this.computeAttrs(attrs), Fragment.from(content), Mark$1.setFrom(marks));
  }
  createChecked(attrs = null, content, marks) {
    content = Fragment.from(content);
    this.checkContent(content);
    return new Node$2(this, this.computeAttrs(attrs), content, Mark$1.setFrom(marks));
  }
  createAndFill(attrs = null, content, marks) {
    attrs = this.computeAttrs(attrs);
    content = Fragment.from(content);
    if (content.size) {
      let before = this.contentMatch.fillBefore(content);
      if (!before)
        return null;
      content = before.append(content);
    }
    let matched = this.contentMatch.matchFragment(content);
    let after = matched && matched.fillBefore(Fragment.empty, true);
    if (!after)
      return null;
    return new Node$2(this, attrs, content.append(after), Mark$1.setFrom(marks));
  }
  validContent(content) {
    let result = this.contentMatch.matchFragment(content);
    if (!result || !result.validEnd)
      return false;
    for (let i3 = 0; i3 < content.childCount; i3++)
      if (!this.allowsMarks(content.child(i3).marks))
        return false;
    return true;
  }
  checkContent(content) {
    if (!this.validContent(content))
      throw new RangeError(`Invalid content for node ${this.name}: ${content.toString().slice(0, 50)}`);
  }
  allowsMarkType(markType) {
    return this.markSet == null || this.markSet.indexOf(markType) > -1;
  }
  allowsMarks(marks) {
    if (this.markSet == null)
      return true;
    for (let i3 = 0; i3 < marks.length; i3++)
      if (!this.allowsMarkType(marks[i3].type))
        return false;
    return true;
  }
  allowedMarks(marks) {
    if (this.markSet == null)
      return marks;
    let copy2;
    for (let i3 = 0; i3 < marks.length; i3++) {
      if (!this.allowsMarkType(marks[i3].type)) {
        if (!copy2)
          copy2 = marks.slice(0, i3);
      } else if (copy2) {
        copy2.push(marks[i3]);
      }
    }
    return !copy2 ? marks : copy2.length ? copy2 : Mark$1.none;
  }
  static compile(nodes, schema) {
    let result = /* @__PURE__ */ Object.create(null);
    nodes.forEach((name, spec) => result[name] = new NodeType$1(name, schema, spec));
    let topType = schema.spec.topNode || "doc";
    if (!result[topType])
      throw new RangeError("Schema is missing its top node type ('" + topType + "')");
    if (!result.text)
      throw new RangeError("Every schema needs a 'text' type");
    for (let _2 in result.text.attrs)
      throw new RangeError("The text node type should not have attributes");
    return result;
  }
}
class Attribute {
  constructor(options) {
    this.hasDefault = Object.prototype.hasOwnProperty.call(options, "default");
    this.default = options.default;
  }
  get isRequired() {
    return !this.hasDefault;
  }
}
class MarkType {
  constructor(name, rank, schema, spec) {
    this.name = name;
    this.rank = rank;
    this.schema = schema;
    this.spec = spec;
    this.attrs = initAttrs(spec.attrs);
    this.excluded = null;
    let defaults2 = defaultAttrs(this.attrs);
    this.instance = defaults2 ? new Mark$1(this, defaults2) : null;
  }
  create(attrs = null) {
    if (!attrs && this.instance)
      return this.instance;
    return new Mark$1(this, computeAttrs(this.attrs, attrs));
  }
  static compile(marks, schema) {
    let result = /* @__PURE__ */ Object.create(null), rank = 0;
    marks.forEach((name, spec) => result[name] = new MarkType(name, rank++, schema, spec));
    return result;
  }
  removeFromSet(set2) {
    for (var i3 = 0; i3 < set2.length; i3++)
      if (set2[i3].type == this) {
        set2 = set2.slice(0, i3).concat(set2.slice(i3 + 1));
        i3--;
      }
    return set2;
  }
  isInSet(set2) {
    for (let i3 = 0; i3 < set2.length; i3++)
      if (set2[i3].type == this)
        return set2[i3];
  }
  excludes(other) {
    return this.excluded.indexOf(other) > -1;
  }
}
class Schema {
  constructor(spec) {
    this.cached = /* @__PURE__ */ Object.create(null);
    let instanceSpec = this.spec = {};
    for (let prop in spec)
      instanceSpec[prop] = spec[prop];
    instanceSpec.nodes = OrderedMap.from(spec.nodes), instanceSpec.marks = OrderedMap.from(spec.marks || {}), this.nodes = NodeType$1.compile(this.spec.nodes, this);
    this.marks = MarkType.compile(this.spec.marks, this);
    let contentExprCache = /* @__PURE__ */ Object.create(null);
    for (let prop in this.nodes) {
      if (prop in this.marks)
        throw new RangeError(prop + " can not be both a node and a mark");
      let type = this.nodes[prop], contentExpr = type.spec.content || "", markExpr = type.spec.marks;
      type.contentMatch = contentExprCache[contentExpr] || (contentExprCache[contentExpr] = ContentMatch.parse(contentExpr, this.nodes));
      type.inlineContent = type.contentMatch.inlineContent;
      type.markSet = markExpr == "_" ? null : markExpr ? gatherMarks(this, markExpr.split(" ")) : markExpr == "" || !type.inlineContent ? [] : null;
    }
    for (let prop in this.marks) {
      let type = this.marks[prop], excl = type.spec.excludes;
      type.excluded = excl == null ? [type] : excl == "" ? [] : gatherMarks(this, excl.split(" "));
    }
    this.nodeFromJSON = this.nodeFromJSON.bind(this);
    this.markFromJSON = this.markFromJSON.bind(this);
    this.topNodeType = this.nodes[this.spec.topNode || "doc"];
    this.cached.wrappings = /* @__PURE__ */ Object.create(null);
  }
  node(type, attrs = null, content, marks) {
    if (typeof type == "string")
      type = this.nodeType(type);
    else if (!(type instanceof NodeType$1))
      throw new RangeError("Invalid node type: " + type);
    else if (type.schema != this)
      throw new RangeError("Node type from different schema used (" + type.name + ")");
    return type.createChecked(attrs, content, marks);
  }
  text(text2, marks) {
    let type = this.nodes.text;
    return new TextNode(type, type.defaultAttrs, text2, Mark$1.setFrom(marks));
  }
  mark(type, attrs) {
    if (typeof type == "string")
      type = this.marks[type];
    return type.create(attrs);
  }
  nodeFromJSON(json) {
    return Node$2.fromJSON(this, json);
  }
  markFromJSON(json) {
    return Mark$1.fromJSON(this, json);
  }
  nodeType(name) {
    let found2 = this.nodes[name];
    if (!found2)
      throw new RangeError("Unknown node type: " + name);
    return found2;
  }
}
function gatherMarks(schema, marks) {
  let found2 = [];
  for (let i3 = 0; i3 < marks.length; i3++) {
    let name = marks[i3], mark = schema.marks[name], ok2 = mark;
    if (mark) {
      found2.push(mark);
    } else {
      for (let prop in schema.marks) {
        let mark2 = schema.marks[prop];
        if (name == "_" || mark2.spec.group && mark2.spec.group.split(" ").indexOf(name) > -1)
          found2.push(ok2 = mark2);
      }
    }
    if (!ok2)
      throw new SyntaxError("Unknown mark type: '" + marks[i3] + "'");
  }
  return found2;
}
class DOMParser$1 {
  constructor(schema, rules) {
    this.schema = schema;
    this.rules = rules;
    this.tags = [];
    this.styles = [];
    rules.forEach((rule) => {
      if (rule.tag)
        this.tags.push(rule);
      else if (rule.style)
        this.styles.push(rule);
    });
    this.normalizeLists = !this.tags.some((r2) => {
      if (!/^(ul|ol)\b/.test(r2.tag) || !r2.node)
        return false;
      let node2 = schema.nodes[r2.node];
      return node2.contentMatch.matchType(node2);
    });
  }
  parse(dom, options = {}) {
    let context = new ParseContext(this, options, false);
    context.addAll(dom, options.from, options.to);
    return context.finish();
  }
  parseSlice(dom, options = {}) {
    let context = new ParseContext(this, options, true);
    context.addAll(dom, options.from, options.to);
    return Slice.maxOpen(context.finish());
  }
  matchTag(dom, context, after) {
    for (let i3 = after ? this.tags.indexOf(after) + 1 : 0; i3 < this.tags.length; i3++) {
      let rule = this.tags[i3];
      if (matches(dom, rule.tag) && (rule.namespace === void 0 || dom.namespaceURI == rule.namespace) && (!rule.context || context.matchesContext(rule.context))) {
        if (rule.getAttrs) {
          let result = rule.getAttrs(dom);
          if (result === false)
            continue;
          rule.attrs = result || void 0;
        }
        return rule;
      }
    }
  }
  matchStyle(prop, value, context, after) {
    for (let i3 = after ? this.styles.indexOf(after) + 1 : 0; i3 < this.styles.length; i3++) {
      let rule = this.styles[i3], style2 = rule.style;
      if (style2.indexOf(prop) != 0 || rule.context && !context.matchesContext(rule.context) || style2.length > prop.length && (style2.charCodeAt(prop.length) != 61 || style2.slice(prop.length + 1) != value))
        continue;
      if (rule.getAttrs) {
        let result = rule.getAttrs(value);
        if (result === false)
          continue;
        rule.attrs = result || void 0;
      }
      return rule;
    }
  }
  static schemaRules(schema) {
    let result = [];
    function insert(rule) {
      let priority = rule.priority == null ? 50 : rule.priority, i3 = 0;
      for (; i3 < result.length; i3++) {
        let next2 = result[i3], nextPriority = next2.priority == null ? 50 : next2.priority;
        if (nextPriority < priority)
          break;
      }
      result.splice(i3, 0, rule);
    }
    for (let name in schema.marks) {
      let rules = schema.marks[name].spec.parseDOM;
      if (rules)
        rules.forEach((rule) => {
          insert(rule = copy(rule));
          if (!(rule.mark || rule.ignore || rule.clearMark))
            rule.mark = name;
        });
    }
    for (let name in schema.nodes) {
      let rules = schema.nodes[name].spec.parseDOM;
      if (rules)
        rules.forEach((rule) => {
          insert(rule = copy(rule));
          if (!(rule.node || rule.ignore || rule.mark))
            rule.node = name;
        });
    }
    return result;
  }
  static fromSchema(schema) {
    return schema.cached.domParser || (schema.cached.domParser = new DOMParser$1(schema, DOMParser$1.schemaRules(schema)));
  }
}
const blockTags = {
  address: true,
  article: true,
  aside: true,
  blockquote: true,
  canvas: true,
  dd: true,
  div: true,
  dl: true,
  fieldset: true,
  figcaption: true,
  figure: true,
  footer: true,
  form: true,
  h1: true,
  h2: true,
  h3: true,
  h4: true,
  h5: true,
  h6: true,
  header: true,
  hgroup: true,
  hr: true,
  li: true,
  noscript: true,
  ol: true,
  output: true,
  p: true,
  pre: true,
  section: true,
  table: true,
  tfoot: true,
  ul: true
};
const ignoreTags = {
  head: true,
  noscript: true,
  object: true,
  script: true,
  style: true,
  title: true
};
const listTags = { ol: true, ul: true };
const OPT_PRESERVE_WS = 1, OPT_PRESERVE_WS_FULL = 2, OPT_OPEN_LEFT = 4;
function wsOptionsFor(type, preserveWhitespace, base2) {
  if (preserveWhitespace != null)
    return (preserveWhitespace ? OPT_PRESERVE_WS : 0) | (preserveWhitespace === "full" ? OPT_PRESERVE_WS_FULL : 0);
  return type && type.whitespace == "pre" ? OPT_PRESERVE_WS | OPT_PRESERVE_WS_FULL : base2 & ~OPT_OPEN_LEFT;
}
class NodeContext {
  constructor(type, attrs, marks, pendingMarks, solid, match2, options) {
    this.type = type;
    this.attrs = attrs;
    this.marks = marks;
    this.pendingMarks = pendingMarks;
    this.solid = solid;
    this.options = options;
    this.content = [];
    this.activeMarks = Mark$1.none;
    this.stashMarks = [];
    this.match = match2 || (options & OPT_OPEN_LEFT ? null : type.contentMatch);
  }
  findWrapping(node2) {
    if (!this.match) {
      if (!this.type)
        return [];
      let fill = this.type.contentMatch.fillBefore(Fragment.from(node2));
      if (fill) {
        this.match = this.type.contentMatch.matchFragment(fill);
      } else {
        let start2 = this.type.contentMatch, wrap2;
        if (wrap2 = start2.findWrapping(node2.type)) {
          this.match = start2;
          return wrap2;
        } else {
          return null;
        }
      }
    }
    return this.match.findWrapping(node2.type);
  }
  finish(openEnd) {
    if (!(this.options & OPT_PRESERVE_WS)) {
      let last = this.content[this.content.length - 1], m4;
      if (last && last.isText && (m4 = /[ \t\r\n\u000c]+$/.exec(last.text))) {
        let text2 = last;
        if (last.text.length == m4[0].length)
          this.content.pop();
        else
          this.content[this.content.length - 1] = text2.withText(text2.text.slice(0, text2.text.length - m4[0].length));
      }
    }
    let content = Fragment.from(this.content);
    if (!openEnd && this.match)
      content = content.append(this.match.fillBefore(Fragment.empty, true));
    return this.type ? this.type.create(this.attrs, content, this.marks) : content;
  }
  popFromStashMark(mark) {
    for (let i3 = this.stashMarks.length - 1; i3 >= 0; i3--)
      if (mark.eq(this.stashMarks[i3]))
        return this.stashMarks.splice(i3, 1)[0];
  }
  applyPending(nextType) {
    for (let i3 = 0, pending = this.pendingMarks; i3 < pending.length; i3++) {
      let mark = pending[i3];
      if ((this.type ? this.type.allowsMarkType(mark.type) : markMayApply(mark.type, nextType)) && !mark.isInSet(this.activeMarks)) {
        this.activeMarks = mark.addToSet(this.activeMarks);
        this.pendingMarks = mark.removeFromSet(this.pendingMarks);
      }
    }
  }
  inlineContext(node2) {
    if (this.type)
      return this.type.inlineContent;
    if (this.content.length)
      return this.content[0].isInline;
    return node2.parentNode && !blockTags.hasOwnProperty(node2.parentNode.nodeName.toLowerCase());
  }
}
class ParseContext {
  constructor(parser, options, isOpen) {
    this.parser = parser;
    this.options = options;
    this.isOpen = isOpen;
    this.open = 0;
    let topNode = options.topNode, topContext;
    let topOptions = wsOptionsFor(null, options.preserveWhitespace, 0) | (isOpen ? OPT_OPEN_LEFT : 0);
    if (topNode)
      topContext = new NodeContext(topNode.type, topNode.attrs, Mark$1.none, Mark$1.none, true, options.topMatch || topNode.type.contentMatch, topOptions);
    else if (isOpen)
      topContext = new NodeContext(null, null, Mark$1.none, Mark$1.none, true, null, topOptions);
    else
      topContext = new NodeContext(parser.schema.topNodeType, null, Mark$1.none, Mark$1.none, true, null, topOptions);
    this.nodes = [topContext];
    this.find = options.findPositions;
    this.needsBlock = false;
  }
  get top() {
    return this.nodes[this.open];
  }
  addDOM(dom) {
    if (dom.nodeType == 3) {
      this.addTextNode(dom);
    } else if (dom.nodeType == 1) {
      let style2 = dom.getAttribute("style");
      if (!style2) {
        this.addElement(dom);
      } else {
        let marks = this.readStyles(parseStyles(style2));
        if (!marks)
          return;
        let [addMarks, removeMarks] = marks, top2 = this.top;
        for (let i3 = 0; i3 < removeMarks.length; i3++)
          this.removePendingMark(removeMarks[i3], top2);
        for (let i3 = 0; i3 < addMarks.length; i3++)
          this.addPendingMark(addMarks[i3]);
        this.addElement(dom);
        for (let i3 = 0; i3 < addMarks.length; i3++)
          this.removePendingMark(addMarks[i3], top2);
        for (let i3 = 0; i3 < removeMarks.length; i3++)
          this.addPendingMark(removeMarks[i3]);
      }
    }
  }
  addTextNode(dom) {
    let value = dom.nodeValue;
    let top2 = this.top;
    if (top2.options & OPT_PRESERVE_WS_FULL || top2.inlineContext(dom) || /[^ \t\r\n\u000c]/.test(value)) {
      if (!(top2.options & OPT_PRESERVE_WS)) {
        value = value.replace(/[ \t\r\n\u000c]+/g, " ");
        if (/^[ \t\r\n\u000c]/.test(value) && this.open == this.nodes.length - 1) {
          let nodeBefore = top2.content[top2.content.length - 1];
          let domNodeBefore = dom.previousSibling;
          if (!nodeBefore || domNodeBefore && domNodeBefore.nodeName == "BR" || nodeBefore.isText && /[ \t\r\n\u000c]$/.test(nodeBefore.text))
            value = value.slice(1);
        }
      } else if (!(top2.options & OPT_PRESERVE_WS_FULL)) {
        value = value.replace(/\r?\n|\r/g, " ");
      } else {
        value = value.replace(/\r\n?/g, "\n");
      }
      if (value)
        this.insertNode(this.parser.schema.text(value));
      this.findInText(dom);
    } else {
      this.findInside(dom);
    }
  }
  addElement(dom, matchAfter) {
    let name = dom.nodeName.toLowerCase(), ruleID;
    if (listTags.hasOwnProperty(name) && this.parser.normalizeLists)
      normalizeList(dom);
    let rule = this.options.ruleFromNode && this.options.ruleFromNode(dom) || (ruleID = this.parser.matchTag(dom, this, matchAfter));
    if (rule ? rule.ignore : ignoreTags.hasOwnProperty(name)) {
      this.findInside(dom);
      this.ignoreFallback(dom);
    } else if (!rule || rule.skip || rule.closeParent) {
      if (rule && rule.closeParent)
        this.open = Math.max(0, this.open - 1);
      else if (rule && rule.skip.nodeType)
        dom = rule.skip;
      let sync2, top2 = this.top, oldNeedsBlock = this.needsBlock;
      if (blockTags.hasOwnProperty(name)) {
        if (top2.content.length && top2.content[0].isInline && this.open) {
          this.open--;
          top2 = this.top;
        }
        sync2 = true;
        if (!top2.type)
          this.needsBlock = true;
      } else if (!dom.firstChild) {
        this.leafFallback(dom);
        return;
      }
      this.addAll(dom);
      if (sync2)
        this.sync(top2);
      this.needsBlock = oldNeedsBlock;
    } else {
      this.addElementByRule(dom, rule, rule.consuming === false ? ruleID : void 0);
    }
  }
  leafFallback(dom) {
    if (dom.nodeName == "BR" && this.top.type && this.top.type.inlineContent)
      this.addTextNode(dom.ownerDocument.createTextNode("\n"));
  }
  ignoreFallback(dom) {
    if (dom.nodeName == "BR" && (!this.top.type || !this.top.type.inlineContent))
      this.findPlace(this.parser.schema.text("-"));
  }
  readStyles(styles) {
    let add2 = Mark$1.none, remove = Mark$1.none;
    style:
      for (let i3 = 0; i3 < styles.length; i3 += 2) {
        for (let after = void 0; ; ) {
          let rule = this.parser.matchStyle(styles[i3], styles[i3 + 1], this, after);
          if (!rule)
            continue style;
          if (rule.ignore)
            return null;
          if (rule.clearMark) {
            this.top.pendingMarks.forEach((m4) => {
              if (rule.clearMark(m4))
                remove = m4.addToSet(remove);
            });
          } else {
            add2 = this.parser.schema.marks[rule.mark].create(rule.attrs).addToSet(add2);
          }
          if (rule.consuming === false)
            after = rule;
          else
            break;
        }
      }
    return [add2, remove];
  }
  addElementByRule(dom, rule, continueAfter) {
    let sync2, nodeType, mark;
    if (rule.node) {
      nodeType = this.parser.schema.nodes[rule.node];
      if (!nodeType.isLeaf) {
        sync2 = this.enter(nodeType, rule.attrs || null, rule.preserveWhitespace);
      } else if (!this.insertNode(nodeType.create(rule.attrs))) {
        this.leafFallback(dom);
      }
    } else {
      let markType = this.parser.schema.marks[rule.mark];
      mark = markType.create(rule.attrs);
      this.addPendingMark(mark);
    }
    let startIn = this.top;
    if (nodeType && nodeType.isLeaf) {
      this.findInside(dom);
    } else if (continueAfter) {
      this.addElement(dom, continueAfter);
    } else if (rule.getContent) {
      this.findInside(dom);
      rule.getContent(dom, this.parser.schema).forEach((node2) => this.insertNode(node2));
    } else {
      let contentDOM = dom;
      if (typeof rule.contentElement == "string")
        contentDOM = dom.querySelector(rule.contentElement);
      else if (typeof rule.contentElement == "function")
        contentDOM = rule.contentElement(dom);
      else if (rule.contentElement)
        contentDOM = rule.contentElement;
      this.findAround(dom, contentDOM, true);
      this.addAll(contentDOM);
    }
    if (sync2 && this.sync(startIn))
      this.open--;
    if (mark)
      this.removePendingMark(mark, startIn);
  }
  addAll(parent, startIndex2, endIndex2) {
    let index2 = startIndex2 || 0;
    for (let dom = startIndex2 ? parent.childNodes[startIndex2] : parent.firstChild, end2 = endIndex2 == null ? null : parent.childNodes[endIndex2]; dom != end2; dom = dom.nextSibling, ++index2) {
      this.findAtPoint(parent, index2);
      this.addDOM(dom);
    }
    this.findAtPoint(parent, index2);
  }
  findPlace(node2) {
    let route, sync2;
    for (let depth = this.open; depth >= 0; depth--) {
      let cx = this.nodes[depth];
      let found2 = cx.findWrapping(node2);
      if (found2 && (!route || route.length > found2.length)) {
        route = found2;
        sync2 = cx;
        if (!found2.length)
          break;
      }
      if (cx.solid)
        break;
    }
    if (!route)
      return false;
    this.sync(sync2);
    for (let i3 = 0; i3 < route.length; i3++)
      this.enterInner(route[i3], null, false);
    return true;
  }
  insertNode(node2) {
    if (node2.isInline && this.needsBlock && !this.top.type) {
      let block = this.textblockFromContext();
      if (block)
        this.enterInner(block);
    }
    if (this.findPlace(node2)) {
      this.closeExtra();
      let top2 = this.top;
      top2.applyPending(node2.type);
      if (top2.match)
        top2.match = top2.match.matchType(node2.type);
      let marks = top2.activeMarks;
      for (let i3 = 0; i3 < node2.marks.length; i3++)
        if (!top2.type || top2.type.allowsMarkType(node2.marks[i3].type))
          marks = node2.marks[i3].addToSet(marks);
      top2.content.push(node2.mark(marks));
      return true;
    }
    return false;
  }
  enter(type, attrs, preserveWS) {
    let ok2 = this.findPlace(type.create(attrs));
    if (ok2)
      this.enterInner(type, attrs, true, preserveWS);
    return ok2;
  }
  enterInner(type, attrs = null, solid = false, preserveWS) {
    this.closeExtra();
    let top2 = this.top;
    top2.applyPending(type);
    top2.match = top2.match && top2.match.matchType(type);
    let options = wsOptionsFor(type, preserveWS, top2.options);
    if (top2.options & OPT_OPEN_LEFT && top2.content.length == 0)
      options |= OPT_OPEN_LEFT;
    this.nodes.push(new NodeContext(type, attrs, top2.activeMarks, top2.pendingMarks, solid, null, options));
    this.open++;
  }
  closeExtra(openEnd = false) {
    let i3 = this.nodes.length - 1;
    if (i3 > this.open) {
      for (; i3 > this.open; i3--)
        this.nodes[i3 - 1].content.push(this.nodes[i3].finish(openEnd));
      this.nodes.length = this.open + 1;
    }
  }
  finish() {
    this.open = 0;
    this.closeExtra(this.isOpen);
    return this.nodes[0].finish(this.isOpen || this.options.topOpen);
  }
  sync(to) {
    for (let i3 = this.open; i3 >= 0; i3--)
      if (this.nodes[i3] == to) {
        this.open = i3;
        return true;
      }
    return false;
  }
  get currentPos() {
    this.closeExtra();
    let pos = 0;
    for (let i3 = this.open; i3 >= 0; i3--) {
      let content = this.nodes[i3].content;
      for (let j2 = content.length - 1; j2 >= 0; j2--)
        pos += content[j2].nodeSize;
      if (i3)
        pos++;
    }
    return pos;
  }
  findAtPoint(parent, offset2) {
    if (this.find)
      for (let i3 = 0; i3 < this.find.length; i3++) {
        if (this.find[i3].node == parent && this.find[i3].offset == offset2)
          this.find[i3].pos = this.currentPos;
      }
  }
  findInside(parent) {
    if (this.find)
      for (let i3 = 0; i3 < this.find.length; i3++) {
        if (this.find[i3].pos == null && parent.nodeType == 1 && parent.contains(this.find[i3].node))
          this.find[i3].pos = this.currentPos;
      }
  }
  findAround(parent, content, before) {
    if (parent != content && this.find)
      for (let i3 = 0; i3 < this.find.length; i3++) {
        if (this.find[i3].pos == null && parent.nodeType == 1 && parent.contains(this.find[i3].node)) {
          let pos = content.compareDocumentPosition(this.find[i3].node);
          if (pos & (before ? 2 : 4))
            this.find[i3].pos = this.currentPos;
        }
      }
  }
  findInText(textNode) {
    if (this.find)
      for (let i3 = 0; i3 < this.find.length; i3++) {
        if (this.find[i3].node == textNode)
          this.find[i3].pos = this.currentPos - (textNode.nodeValue.length - this.find[i3].offset);
      }
  }
  matchesContext(context) {
    if (context.indexOf("|") > -1)
      return context.split(/\s*\|\s*/).some(this.matchesContext, this);
    let parts = context.split("/");
    let option2 = this.options.context;
    let useRoot = !this.isOpen && (!option2 || option2.parent.type == this.nodes[0].type);
    let minDepth = -(option2 ? option2.depth + 1 : 0) + (useRoot ? 0 : 1);
    let match2 = (i3, depth) => {
      for (; i3 >= 0; i3--) {
        let part = parts[i3];
        if (part == "") {
          if (i3 == parts.length - 1 || i3 == 0)
            continue;
          for (; depth >= minDepth; depth--)
            if (match2(i3 - 1, depth))
              return true;
          return false;
        } else {
          let next2 = depth > 0 || depth == 0 && useRoot ? this.nodes[depth].type : option2 && depth >= minDepth ? option2.node(depth - minDepth).type : null;
          if (!next2 || next2.name != part && next2.groups.indexOf(part) == -1)
            return false;
          depth--;
        }
      }
      return true;
    };
    return match2(parts.length - 1, this.open);
  }
  textblockFromContext() {
    let $context = this.options.context;
    if ($context)
      for (let d4 = $context.depth; d4 >= 0; d4--) {
        let deflt = $context.node(d4).contentMatchAt($context.indexAfter(d4)).defaultType;
        if (deflt && deflt.isTextblock && deflt.defaultAttrs)
          return deflt;
      }
    for (let name in this.parser.schema.nodes) {
      let type = this.parser.schema.nodes[name];
      if (type.isTextblock && type.defaultAttrs)
        return type;
    }
  }
  addPendingMark(mark) {
    let found2 = findSameMarkInSet(mark, this.top.pendingMarks);
    if (found2)
      this.top.stashMarks.push(found2);
    this.top.pendingMarks = mark.addToSet(this.top.pendingMarks);
  }
  removePendingMark(mark, upto) {
    for (let depth = this.open; depth >= 0; depth--) {
      let level = this.nodes[depth];
      let found2 = level.pendingMarks.lastIndexOf(mark);
      if (found2 > -1) {
        level.pendingMarks = mark.removeFromSet(level.pendingMarks);
      } else {
        level.activeMarks = mark.removeFromSet(level.activeMarks);
        let stashMark = level.popFromStashMark(mark);
        if (stashMark && level.type && level.type.allowsMarkType(stashMark.type))
          level.activeMarks = stashMark.addToSet(level.activeMarks);
      }
      if (level == upto)
        break;
    }
  }
}
function normalizeList(dom) {
  for (let child = dom.firstChild, prevItem = null; child; child = child.nextSibling) {
    let name = child.nodeType == 1 ? child.nodeName.toLowerCase() : null;
    if (name && listTags.hasOwnProperty(name) && prevItem) {
      prevItem.appendChild(child);
      child = prevItem;
    } else if (name == "li") {
      prevItem = child;
    } else if (name) {
      prevItem = null;
    }
  }
}
function matches(dom, selector) {
  return (dom.matches || dom.msMatchesSelector || dom.webkitMatchesSelector || dom.mozMatchesSelector).call(dom, selector);
}
function parseStyles(style2) {
  let re2 = /\s*([\w-]+)\s*:\s*([^;]+)/g, m4, result = [];
  while (m4 = re2.exec(style2))
    result.push(m4[1], m4[2].trim());
  return result;
}
function copy(obj) {
  let copy2 = {};
  for (let prop in obj)
    copy2[prop] = obj[prop];
  return copy2;
}
function markMayApply(markType, nodeType) {
  let nodes = nodeType.schema.nodes;
  for (let name in nodes) {
    let parent = nodes[name];
    if (!parent.allowsMarkType(markType))
      continue;
    let seen = [], scan = (match2) => {
      seen.push(match2);
      for (let i3 = 0; i3 < match2.edgeCount; i3++) {
        let { type, next: next2 } = match2.edge(i3);
        if (type == nodeType)
          return true;
        if (seen.indexOf(next2) < 0 && scan(next2))
          return true;
      }
    };
    if (scan(parent.contentMatch))
      return true;
  }
}
function findSameMarkInSet(mark, set2) {
  for (let i3 = 0; i3 < set2.length; i3++) {
    if (mark.eq(set2[i3]))
      return set2[i3];
  }
}
class DOMSerializer {
  constructor(nodes, marks) {
    this.nodes = nodes;
    this.marks = marks;
  }
  serializeFragment(fragment, options = {}, target) {
    if (!target)
      target = doc$1(options).createDocumentFragment();
    let top2 = target, active = [];
    fragment.forEach((node2) => {
      if (active.length || node2.marks.length) {
        let keep = 0, rendered = 0;
        while (keep < active.length && rendered < node2.marks.length) {
          let next2 = node2.marks[rendered];
          if (!this.marks[next2.type.name]) {
            rendered++;
            continue;
          }
          if (!next2.eq(active[keep][0]) || next2.type.spec.spanning === false)
            break;
          keep++;
          rendered++;
        }
        while (keep < active.length)
          top2 = active.pop()[1];
        while (rendered < node2.marks.length) {
          let add2 = node2.marks[rendered++];
          let markDOM = this.serializeMark(add2, node2.isInline, options);
          if (markDOM) {
            active.push([add2, top2]);
            top2.appendChild(markDOM.dom);
            top2 = markDOM.contentDOM || markDOM.dom;
          }
        }
      }
      top2.appendChild(this.serializeNodeInner(node2, options));
    });
    return target;
  }
  serializeNodeInner(node2, options) {
    let { dom, contentDOM } = DOMSerializer.renderSpec(doc$1(options), this.nodes[node2.type.name](node2));
    if (contentDOM) {
      if (node2.isLeaf)
        throw new RangeError("Content hole not allowed in a leaf node spec");
      this.serializeFragment(node2.content, options, contentDOM);
    }
    return dom;
  }
  serializeNode(node2, options = {}) {
    let dom = this.serializeNodeInner(node2, options);
    for (let i3 = node2.marks.length - 1; i3 >= 0; i3--) {
      let wrap2 = this.serializeMark(node2.marks[i3], node2.isInline, options);
      if (wrap2) {
        (wrap2.contentDOM || wrap2.dom).appendChild(dom);
        dom = wrap2.dom;
      }
    }
    return dom;
  }
  serializeMark(mark, inline, options = {}) {
    let toDOM = this.marks[mark.type.name];
    return toDOM && DOMSerializer.renderSpec(doc$1(options), toDOM(mark, inline));
  }
  static renderSpec(doc2, structure, xmlNS = null) {
    if (typeof structure == "string")
      return { dom: doc2.createTextNode(structure) };
    if (structure.nodeType != null)
      return { dom: structure };
    if (structure.dom && structure.dom.nodeType != null)
      return structure;
    let tagName = structure[0], space = tagName.indexOf(" ");
    if (space > 0) {
      xmlNS = tagName.slice(0, space);
      tagName = tagName.slice(space + 1);
    }
    let contentDOM;
    let dom = xmlNS ? doc2.createElementNS(xmlNS, tagName) : doc2.createElement(tagName);
    let attrs = structure[1], start2 = 1;
    if (attrs && typeof attrs == "object" && attrs.nodeType == null && !Array.isArray(attrs)) {
      start2 = 2;
      for (let name in attrs)
        if (attrs[name] != null) {
          let space2 = name.indexOf(" ");
          if (space2 > 0)
            dom.setAttributeNS(name.slice(0, space2), name.slice(space2 + 1), attrs[name]);
          else
            dom.setAttribute(name, attrs[name]);
        }
    }
    for (let i3 = start2; i3 < structure.length; i3++) {
      let child = structure[i3];
      if (child === 0) {
        if (i3 < structure.length - 1 || i3 > start2)
          throw new RangeError("Content hole must be the only child of its parent node");
        return { dom, contentDOM: dom };
      } else {
        let { dom: inner, contentDOM: innerContent } = DOMSerializer.renderSpec(doc2, child, xmlNS);
        dom.appendChild(inner);
        if (innerContent) {
          if (contentDOM)
            throw new RangeError("Multiple content holes");
          contentDOM = innerContent;
        }
      }
    }
    return { dom, contentDOM };
  }
  static fromSchema(schema) {
    return schema.cached.domSerializer || (schema.cached.domSerializer = new DOMSerializer(this.nodesFromSchema(schema), this.marksFromSchema(schema)));
  }
  static nodesFromSchema(schema) {
    let result = gatherToDOM(schema.nodes);
    if (!result.text)
      result.text = (node2) => node2.text;
    return result;
  }
  static marksFromSchema(schema) {
    return gatherToDOM(schema.marks);
  }
}
function gatherToDOM(obj) {
  let result = {};
  for (let name in obj) {
    let toDOM = obj[name].spec.toDOM;
    if (toDOM)
      result[name] = toDOM;
  }
  return result;
}
function doc$1(options) {
  return options.document || window.document;
}
const lower16 = 65535;
const factor16 = Math.pow(2, 16);
function makeRecover(index2, offset2) {
  return index2 + offset2 * factor16;
}
function recoverIndex(value) {
  return value & lower16;
}
function recoverOffset(value) {
  return (value - (value & lower16)) / factor16;
}
const DEL_BEFORE = 1, DEL_AFTER = 2, DEL_ACROSS = 4, DEL_SIDE = 8;
class MapResult {
  constructor(pos, delInfo, recover) {
    this.pos = pos;
    this.delInfo = delInfo;
    this.recover = recover;
  }
  get deleted() {
    return (this.delInfo & DEL_SIDE) > 0;
  }
  get deletedBefore() {
    return (this.delInfo & (DEL_BEFORE | DEL_ACROSS)) > 0;
  }
  get deletedAfter() {
    return (this.delInfo & (DEL_AFTER | DEL_ACROSS)) > 0;
  }
  get deletedAcross() {
    return (this.delInfo & DEL_ACROSS) > 0;
  }
}
class StepMap {
  constructor(ranges, inverted = false) {
    this.ranges = ranges;
    this.inverted = inverted;
    if (!ranges.length && StepMap.empty)
      return StepMap.empty;
  }
  recover(value) {
    let diff = 0, index2 = recoverIndex(value);
    if (!this.inverted)
      for (let i3 = 0; i3 < index2; i3++)
        diff += this.ranges[i3 * 3 + 2] - this.ranges[i3 * 3 + 1];
    return this.ranges[index2 * 3] + diff + recoverOffset(value);
  }
  mapResult(pos, assoc = 1) {
    return this._map(pos, assoc, false);
  }
  map(pos, assoc = 1) {
    return this._map(pos, assoc, true);
  }
  _map(pos, assoc, simple) {
    let diff = 0, oldIndex2 = this.inverted ? 2 : 1, newIndex2 = this.inverted ? 1 : 2;
    for (let i3 = 0; i3 < this.ranges.length; i3 += 3) {
      let start2 = this.ranges[i3] - (this.inverted ? diff : 0);
      if (start2 > pos)
        break;
      let oldSize = this.ranges[i3 + oldIndex2], newSize = this.ranges[i3 + newIndex2], end2 = start2 + oldSize;
      if (pos <= end2) {
        let side = !oldSize ? assoc : pos == start2 ? -1 : pos == end2 ? 1 : assoc;
        let result = start2 + diff + (side < 0 ? 0 : newSize);
        if (simple)
          return result;
        let recover = pos == (assoc < 0 ? start2 : end2) ? null : makeRecover(i3 / 3, pos - start2);
        let del = pos == start2 ? DEL_AFTER : pos == end2 ? DEL_BEFORE : DEL_ACROSS;
        if (assoc < 0 ? pos != start2 : pos != end2)
          del |= DEL_SIDE;
        return new MapResult(result, del, recover);
      }
      diff += newSize - oldSize;
    }
    return simple ? pos + diff : new MapResult(pos + diff, 0, null);
  }
  touches(pos, recover) {
    let diff = 0, index2 = recoverIndex(recover);
    let oldIndex2 = this.inverted ? 2 : 1, newIndex2 = this.inverted ? 1 : 2;
    for (let i3 = 0; i3 < this.ranges.length; i3 += 3) {
      let start2 = this.ranges[i3] - (this.inverted ? diff : 0);
      if (start2 > pos)
        break;
      let oldSize = this.ranges[i3 + oldIndex2], end2 = start2 + oldSize;
      if (pos <= end2 && i3 == index2 * 3)
        return true;
      diff += this.ranges[i3 + newIndex2] - oldSize;
    }
    return false;
  }
  forEach(f2) {
    let oldIndex2 = this.inverted ? 2 : 1, newIndex2 = this.inverted ? 1 : 2;
    for (let i3 = 0, diff = 0; i3 < this.ranges.length; i3 += 3) {
      let start2 = this.ranges[i3], oldStart = start2 - (this.inverted ? diff : 0), newStart = start2 + (this.inverted ? 0 : diff);
      let oldSize = this.ranges[i3 + oldIndex2], newSize = this.ranges[i3 + newIndex2];
      f2(oldStart, oldStart + oldSize, newStart, newStart + newSize);
      diff += newSize - oldSize;
    }
  }
  invert() {
    return new StepMap(this.ranges, !this.inverted);
  }
  toString() {
    return (this.inverted ? "-" : "") + JSON.stringify(this.ranges);
  }
  static offset(n2) {
    return n2 == 0 ? StepMap.empty : new StepMap(n2 < 0 ? [0, -n2, 0] : [0, 0, n2]);
  }
}
StepMap.empty = new StepMap([]);
class Mapping {
  constructor(maps = [], mirror, from3 = 0, to = maps.length) {
    this.maps = maps;
    this.mirror = mirror;
    this.from = from3;
    this.to = to;
  }
  slice(from3 = 0, to = this.maps.length) {
    return new Mapping(this.maps, this.mirror, from3, to);
  }
  copy() {
    return new Mapping(this.maps.slice(), this.mirror && this.mirror.slice(), this.from, this.to);
  }
  appendMap(map2, mirrors) {
    this.to = this.maps.push(map2);
    if (mirrors != null)
      this.setMirror(this.maps.length - 1, mirrors);
  }
  appendMapping(mapping) {
    for (let i3 = 0, startSize = this.maps.length; i3 < mapping.maps.length; i3++) {
      let mirr = mapping.getMirror(i3);
      this.appendMap(mapping.maps[i3], mirr != null && mirr < i3 ? startSize + mirr : void 0);
    }
  }
  getMirror(n2) {
    if (this.mirror) {
      for (let i3 = 0; i3 < this.mirror.length; i3++)
        if (this.mirror[i3] == n2)
          return this.mirror[i3 + (i3 % 2 ? -1 : 1)];
    }
  }
  setMirror(n2, m4) {
    if (!this.mirror)
      this.mirror = [];
    this.mirror.push(n2, m4);
  }
  appendMappingInverted(mapping) {
    for (let i3 = mapping.maps.length - 1, totalSize = this.maps.length + mapping.maps.length; i3 >= 0; i3--) {
      let mirr = mapping.getMirror(i3);
      this.appendMap(mapping.maps[i3].invert(), mirr != null && mirr > i3 ? totalSize - mirr - 1 : void 0);
    }
  }
  invert() {
    let inverse = new Mapping();
    inverse.appendMappingInverted(this);
    return inverse;
  }
  map(pos, assoc = 1) {
    if (this.mirror)
      return this._map(pos, assoc, true);
    for (let i3 = this.from; i3 < this.to; i3++)
      pos = this.maps[i3].map(pos, assoc);
    return pos;
  }
  mapResult(pos, assoc = 1) {
    return this._map(pos, assoc, false);
  }
  _map(pos, assoc, simple) {
    let delInfo = 0;
    for (let i3 = this.from; i3 < this.to; i3++) {
      let map2 = this.maps[i3], result = map2.mapResult(pos, assoc);
      if (result.recover != null) {
        let corr = this.getMirror(i3);
        if (corr != null && corr > i3 && corr < this.to) {
          i3 = corr;
          pos = this.maps[corr].recover(result.recover);
          continue;
        }
      }
      delInfo |= result.delInfo;
      pos = result.pos;
    }
    return simple ? pos : new MapResult(pos, delInfo, null);
  }
}
const stepsByID = /* @__PURE__ */ Object.create(null);
class Step {
  getMap() {
    return StepMap.empty;
  }
  merge(other) {
    return null;
  }
  static fromJSON(schema, json) {
    if (!json || !json.stepType)
      throw new RangeError("Invalid input for Step.fromJSON");
    let type = stepsByID[json.stepType];
    if (!type)
      throw new RangeError(`No step type ${json.stepType} defined`);
    return type.fromJSON(schema, json);
  }
  static jsonID(id2, stepClass) {
    if (id2 in stepsByID)
      throw new RangeError("Duplicate use of step JSON ID " + id2);
    stepsByID[id2] = stepClass;
    stepClass.prototype.jsonID = id2;
    return stepClass;
  }
}
class StepResult {
  constructor(doc2, failed) {
    this.doc = doc2;
    this.failed = failed;
  }
  static ok(doc2) {
    return new StepResult(doc2, null);
  }
  static fail(message) {
    return new StepResult(null, message);
  }
  static fromReplace(doc2, from3, to, slice3) {
    try {
      return StepResult.ok(doc2.replace(from3, to, slice3));
    } catch (e3) {
      if (e3 instanceof ReplaceError)
        return StepResult.fail(e3.message);
      throw e3;
    }
  }
}
function mapFragment(fragment, f2, parent) {
  let mapped = [];
  for (let i3 = 0; i3 < fragment.childCount; i3++) {
    let child = fragment.child(i3);
    if (child.content.size)
      child = child.copy(mapFragment(child.content, f2, child));
    if (child.isInline)
      child = f2(child, parent, i3);
    mapped.push(child);
  }
  return Fragment.fromArray(mapped);
}
class AddMarkStep extends Step {
  constructor(from3, to, mark) {
    super();
    this.from = from3;
    this.to = to;
    this.mark = mark;
  }
  apply(doc2) {
    let oldSlice = doc2.slice(this.from, this.to), $from = doc2.resolve(this.from);
    let parent = $from.node($from.sharedDepth(this.to));
    let slice3 = new Slice(mapFragment(oldSlice.content, (node2, parent2) => {
      if (!node2.isAtom || !parent2.type.allowsMarkType(this.mark.type))
        return node2;
      return node2.mark(this.mark.addToSet(node2.marks));
    }, parent), oldSlice.openStart, oldSlice.openEnd);
    return StepResult.fromReplace(doc2, this.from, this.to, slice3);
  }
  invert() {
    return new RemoveMarkStep(this.from, this.to, this.mark);
  }
  map(mapping) {
    let from3 = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);
    if (from3.deleted && to.deleted || from3.pos >= to.pos)
      return null;
    return new AddMarkStep(from3.pos, to.pos, this.mark);
  }
  merge(other) {
    if (other instanceof AddMarkStep && other.mark.eq(this.mark) && this.from <= other.to && this.to >= other.from)
      return new AddMarkStep(Math.min(this.from, other.from), Math.max(this.to, other.to), this.mark);
    return null;
  }
  toJSON() {
    return {
      stepType: "addMark",
      mark: this.mark.toJSON(),
      from: this.from,
      to: this.to
    };
  }
  static fromJSON(schema, json) {
    if (typeof json.from != "number" || typeof json.to != "number")
      throw new RangeError("Invalid input for AddMarkStep.fromJSON");
    return new AddMarkStep(json.from, json.to, schema.markFromJSON(json.mark));
  }
}
Step.jsonID("addMark", AddMarkStep);
class RemoveMarkStep extends Step {
  constructor(from3, to, mark) {
    super();
    this.from = from3;
    this.to = to;
    this.mark = mark;
  }
  apply(doc2) {
    let oldSlice = doc2.slice(this.from, this.to);
    let slice3 = new Slice(mapFragment(oldSlice.content, (node2) => {
      return node2.mark(this.mark.removeFromSet(node2.marks));
    }, doc2), oldSlice.openStart, oldSlice.openEnd);
    return StepResult.fromReplace(doc2, this.from, this.to, slice3);
  }
  invert() {
    return new AddMarkStep(this.from, this.to, this.mark);
  }
  map(mapping) {
    let from3 = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);
    if (from3.deleted && to.deleted || from3.pos >= to.pos)
      return null;
    return new RemoveMarkStep(from3.pos, to.pos, this.mark);
  }
  merge(other) {
    if (other instanceof RemoveMarkStep && other.mark.eq(this.mark) && this.from <= other.to && this.to >= other.from)
      return new RemoveMarkStep(Math.min(this.from, other.from), Math.max(this.to, other.to), this.mark);
    return null;
  }
  toJSON() {
    return {
      stepType: "removeMark",
      mark: this.mark.toJSON(),
      from: this.from,
      to: this.to
    };
  }
  static fromJSON(schema, json) {
    if (typeof json.from != "number" || typeof json.to != "number")
      throw new RangeError("Invalid input for RemoveMarkStep.fromJSON");
    return new RemoveMarkStep(json.from, json.to, schema.markFromJSON(json.mark));
  }
}
Step.jsonID("removeMark", RemoveMarkStep);
class AddNodeMarkStep extends Step {
  constructor(pos, mark) {
    super();
    this.pos = pos;
    this.mark = mark;
  }
  apply(doc2) {
    let node2 = doc2.nodeAt(this.pos);
    if (!node2)
      return StepResult.fail("No node at mark step's position");
    let updated = node2.type.create(node2.attrs, null, this.mark.addToSet(node2.marks));
    return StepResult.fromReplace(doc2, this.pos, this.pos + 1, new Slice(Fragment.from(updated), 0, node2.isLeaf ? 0 : 1));
  }
  invert(doc2) {
    let node2 = doc2.nodeAt(this.pos);
    if (node2) {
      let newSet = this.mark.addToSet(node2.marks);
      if (newSet.length == node2.marks.length) {
        for (let i3 = 0; i3 < node2.marks.length; i3++)
          if (!node2.marks[i3].isInSet(newSet))
            return new AddNodeMarkStep(this.pos, node2.marks[i3]);
        return new AddNodeMarkStep(this.pos, this.mark);
      }
    }
    return new RemoveNodeMarkStep(this.pos, this.mark);
  }
  map(mapping) {
    let pos = mapping.mapResult(this.pos, 1);
    return pos.deletedAfter ? null : new AddNodeMarkStep(pos.pos, this.mark);
  }
  toJSON() {
    return { stepType: "addNodeMark", pos: this.pos, mark: this.mark.toJSON() };
  }
  static fromJSON(schema, json) {
    if (typeof json.pos != "number")
      throw new RangeError("Invalid input for AddNodeMarkStep.fromJSON");
    return new AddNodeMarkStep(json.pos, schema.markFromJSON(json.mark));
  }
}
Step.jsonID("addNodeMark", AddNodeMarkStep);
class RemoveNodeMarkStep extends Step {
  constructor(pos, mark) {
    super();
    this.pos = pos;
    this.mark = mark;
  }
  apply(doc2) {
    let node2 = doc2.nodeAt(this.pos);
    if (!node2)
      return StepResult.fail("No node at mark step's position");
    let updated = node2.type.create(node2.attrs, null, this.mark.removeFromSet(node2.marks));
    return StepResult.fromReplace(doc2, this.pos, this.pos + 1, new Slice(Fragment.from(updated), 0, node2.isLeaf ? 0 : 1));
  }
  invert(doc2) {
    let node2 = doc2.nodeAt(this.pos);
    if (!node2 || !this.mark.isInSet(node2.marks))
      return this;
    return new AddNodeMarkStep(this.pos, this.mark);
  }
  map(mapping) {
    let pos = mapping.mapResult(this.pos, 1);
    return pos.deletedAfter ? null : new RemoveNodeMarkStep(pos.pos, this.mark);
  }
  toJSON() {
    return { stepType: "removeNodeMark", pos: this.pos, mark: this.mark.toJSON() };
  }
  static fromJSON(schema, json) {
    if (typeof json.pos != "number")
      throw new RangeError("Invalid input for RemoveNodeMarkStep.fromJSON");
    return new RemoveNodeMarkStep(json.pos, schema.markFromJSON(json.mark));
  }
}
Step.jsonID("removeNodeMark", RemoveNodeMarkStep);
class ReplaceStep extends Step {
  constructor(from3, to, slice3, structure = false) {
    super();
    this.from = from3;
    this.to = to;
    this.slice = slice3;
    this.structure = structure;
  }
  apply(doc2) {
    if (this.structure && contentBetween(doc2, this.from, this.to))
      return StepResult.fail("Structure replace would overwrite content");
    return StepResult.fromReplace(doc2, this.from, this.to, this.slice);
  }
  getMap() {
    return new StepMap([this.from, this.to - this.from, this.slice.size]);
  }
  invert(doc2) {
    return new ReplaceStep(this.from, this.from + this.slice.size, doc2.slice(this.from, this.to));
  }
  map(mapping) {
    let from3 = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);
    if (from3.deletedAcross && to.deletedAcross)
      return null;
    return new ReplaceStep(from3.pos, Math.max(from3.pos, to.pos), this.slice);
  }
  merge(other) {
    if (!(other instanceof ReplaceStep) || other.structure || this.structure)
      return null;
    if (this.from + this.slice.size == other.from && !this.slice.openEnd && !other.slice.openStart) {
      let slice3 = this.slice.size + other.slice.size == 0 ? Slice.empty : new Slice(this.slice.content.append(other.slice.content), this.slice.openStart, other.slice.openEnd);
      return new ReplaceStep(this.from, this.to + (other.to - other.from), slice3, this.structure);
    } else if (other.to == this.from && !this.slice.openStart && !other.slice.openEnd) {
      let slice3 = this.slice.size + other.slice.size == 0 ? Slice.empty : new Slice(other.slice.content.append(this.slice.content), other.slice.openStart, this.slice.openEnd);
      return new ReplaceStep(other.from, this.to, slice3, this.structure);
    } else {
      return null;
    }
  }
  toJSON() {
    let json = { stepType: "replace", from: this.from, to: this.to };
    if (this.slice.size)
      json.slice = this.slice.toJSON();
    if (this.structure)
      json.structure = true;
    return json;
  }
  static fromJSON(schema, json) {
    if (typeof json.from != "number" || typeof json.to != "number")
      throw new RangeError("Invalid input for ReplaceStep.fromJSON");
    return new ReplaceStep(json.from, json.to, Slice.fromJSON(schema, json.slice), !!json.structure);
  }
}
Step.jsonID("replace", ReplaceStep);
class ReplaceAroundStep extends Step {
  constructor(from3, to, gapFrom, gapTo, slice3, insert, structure = false) {
    super();
    this.from = from3;
    this.to = to;
    this.gapFrom = gapFrom;
    this.gapTo = gapTo;
    this.slice = slice3;
    this.insert = insert;
    this.structure = structure;
  }
  apply(doc2) {
    if (this.structure && (contentBetween(doc2, this.from, this.gapFrom) || contentBetween(doc2, this.gapTo, this.to)))
      return StepResult.fail("Structure gap-replace would overwrite content");
    let gap = doc2.slice(this.gapFrom, this.gapTo);
    if (gap.openStart || gap.openEnd)
      return StepResult.fail("Gap is not a flat range");
    let inserted = this.slice.insertAt(this.insert, gap.content);
    if (!inserted)
      return StepResult.fail("Content does not fit in gap");
    return StepResult.fromReplace(doc2, this.from, this.to, inserted);
  }
  getMap() {
    return new StepMap([
      this.from,
      this.gapFrom - this.from,
      this.insert,
      this.gapTo,
      this.to - this.gapTo,
      this.slice.size - this.insert
    ]);
  }
  invert(doc2) {
    let gap = this.gapTo - this.gapFrom;
    return new ReplaceAroundStep(this.from, this.from + this.slice.size + gap, this.from + this.insert, this.from + this.insert + gap, doc2.slice(this.from, this.to).removeBetween(this.gapFrom - this.from, this.gapTo - this.from), this.gapFrom - this.from, this.structure);
  }
  map(mapping) {
    let from3 = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);
    let gapFrom = mapping.map(this.gapFrom, -1), gapTo = mapping.map(this.gapTo, 1);
    if (from3.deletedAcross && to.deletedAcross || gapFrom < from3.pos || gapTo > to.pos)
      return null;
    return new ReplaceAroundStep(from3.pos, to.pos, gapFrom, gapTo, this.slice, this.insert, this.structure);
  }
  toJSON() {
    let json = {
      stepType: "replaceAround",
      from: this.from,
      to: this.to,
      gapFrom: this.gapFrom,
      gapTo: this.gapTo,
      insert: this.insert
    };
    if (this.slice.size)
      json.slice = this.slice.toJSON();
    if (this.structure)
      json.structure = true;
    return json;
  }
  static fromJSON(schema, json) {
    if (typeof json.from != "number" || typeof json.to != "number" || typeof json.gapFrom != "number" || typeof json.gapTo != "number" || typeof json.insert != "number")
      throw new RangeError("Invalid input for ReplaceAroundStep.fromJSON");
    return new ReplaceAroundStep(json.from, json.to, json.gapFrom, json.gapTo, Slice.fromJSON(schema, json.slice), json.insert, !!json.structure);
  }
}
Step.jsonID("replaceAround", ReplaceAroundStep);
function contentBetween(doc2, from3, to) {
  let $from = doc2.resolve(from3), dist = to - from3, depth = $from.depth;
  while (dist > 0 && depth > 0 && $from.indexAfter(depth) == $from.node(depth).childCount) {
    depth--;
    dist--;
  }
  if (dist > 0) {
    let next2 = $from.node(depth).maybeChild($from.indexAfter(depth));
    while (dist > 0) {
      if (!next2 || next2.isLeaf)
        return true;
      next2 = next2.firstChild;
      dist--;
    }
  }
  return false;
}
function addMark(tr, from3, to, mark) {
  let removed = [], added = [];
  let removing, adding;
  tr.doc.nodesBetween(from3, to, (node2, pos, parent) => {
    if (!node2.isInline)
      return;
    let marks = node2.marks;
    if (!mark.isInSet(marks) && parent.type.allowsMarkType(mark.type)) {
      let start2 = Math.max(pos, from3), end2 = Math.min(pos + node2.nodeSize, to);
      let newSet = mark.addToSet(marks);
      for (let i3 = 0; i3 < marks.length; i3++) {
        if (!marks[i3].isInSet(newSet)) {
          if (removing && removing.to == start2 && removing.mark.eq(marks[i3]))
            removing.to = end2;
          else
            removed.push(removing = new RemoveMarkStep(start2, end2, marks[i3]));
        }
      }
      if (adding && adding.to == start2)
        adding.to = end2;
      else
        added.push(adding = new AddMarkStep(start2, end2, mark));
    }
  });
  removed.forEach((s4) => tr.step(s4));
  added.forEach((s4) => tr.step(s4));
}
function removeMark(tr, from3, to, mark) {
  let matched = [], step = 0;
  tr.doc.nodesBetween(from3, to, (node2, pos) => {
    if (!node2.isInline)
      return;
    step++;
    let toRemove = null;
    if (mark instanceof MarkType) {
      let set2 = node2.marks, found2;
      while (found2 = mark.isInSet(set2)) {
        (toRemove || (toRemove = [])).push(found2);
        set2 = found2.removeFromSet(set2);
      }
    } else if (mark) {
      if (mark.isInSet(node2.marks))
        toRemove = [mark];
    } else {
      toRemove = node2.marks;
    }
    if (toRemove && toRemove.length) {
      let end2 = Math.min(pos + node2.nodeSize, to);
      for (let i3 = 0; i3 < toRemove.length; i3++) {
        let style2 = toRemove[i3], found2;
        for (let j2 = 0; j2 < matched.length; j2++) {
          let m4 = matched[j2];
          if (m4.step == step - 1 && style2.eq(matched[j2].style))
            found2 = m4;
        }
        if (found2) {
          found2.to = end2;
          found2.step = step;
        } else {
          matched.push({ style: style2, from: Math.max(pos, from3), to: end2, step });
        }
      }
    }
  });
  matched.forEach((m4) => tr.step(new RemoveMarkStep(m4.from, m4.to, m4.style)));
}
function clearIncompatible(tr, pos, parentType, match2 = parentType.contentMatch) {
  let node2 = tr.doc.nodeAt(pos);
  let delSteps = [], cur = pos + 1;
  for (let i3 = 0; i3 < node2.childCount; i3++) {
    let child = node2.child(i3), end2 = cur + child.nodeSize;
    let allowed = match2.matchType(child.type);
    if (!allowed) {
      delSteps.push(new ReplaceStep(cur, end2, Slice.empty));
    } else {
      match2 = allowed;
      for (let j2 = 0; j2 < child.marks.length; j2++)
        if (!parentType.allowsMarkType(child.marks[j2].type))
          tr.step(new RemoveMarkStep(cur, end2, child.marks[j2]));
    }
    cur = end2;
  }
  if (!match2.validEnd) {
    let fill = match2.fillBefore(Fragment.empty, true);
    tr.replace(cur, cur, new Slice(fill, 0, 0));
  }
  for (let i3 = delSteps.length - 1; i3 >= 0; i3--)
    tr.step(delSteps[i3]);
}
function canCut(node2, start2, end2) {
  return (start2 == 0 || node2.canReplace(start2, node2.childCount)) && (end2 == node2.childCount || node2.canReplace(0, end2));
}
function liftTarget(range2) {
  let parent = range2.parent;
  let content = parent.content.cutByIndex(range2.startIndex, range2.endIndex);
  for (let depth = range2.depth; ; --depth) {
    let node2 = range2.$from.node(depth);
    let index2 = range2.$from.index(depth), endIndex2 = range2.$to.indexAfter(depth);
    if (depth < range2.depth && node2.canReplace(index2, endIndex2, content))
      return depth;
    if (depth == 0 || node2.type.spec.isolating || !canCut(node2, index2, endIndex2))
      break;
  }
  return null;
}
function lift$2(tr, range2, target) {
  let { $from, $to, depth } = range2;
  let gapStart = $from.before(depth + 1), gapEnd = $to.after(depth + 1);
  let start2 = gapStart, end2 = gapEnd;
  let before = Fragment.empty, openStart = 0;
  for (let d4 = depth, splitting = false; d4 > target; d4--)
    if (splitting || $from.index(d4) > 0) {
      splitting = true;
      before = Fragment.from($from.node(d4).copy(before));
      openStart++;
    } else {
      start2--;
    }
  let after = Fragment.empty, openEnd = 0;
  for (let d4 = depth, splitting = false; d4 > target; d4--)
    if (splitting || $to.after(d4 + 1) < $to.end(d4)) {
      splitting = true;
      after = Fragment.from($to.node(d4).copy(after));
      openEnd++;
    } else {
      end2++;
    }
  tr.step(new ReplaceAroundStep(start2, end2, gapStart, gapEnd, new Slice(before.append(after), openStart, openEnd), before.size - openStart, true));
}
function findWrapping(range2, nodeType, attrs = null, innerRange = range2) {
  let around = findWrappingOutside(range2, nodeType);
  let inner = around && findWrappingInside(innerRange, nodeType);
  if (!inner)
    return null;
  return around.map(withAttrs).concat({ type: nodeType, attrs }).concat(inner.map(withAttrs));
}
function withAttrs(type) {
  return { type, attrs: null };
}
function findWrappingOutside(range2, type) {
  let { parent, startIndex: startIndex2, endIndex: endIndex2 } = range2;
  let around = parent.contentMatchAt(startIndex2).findWrapping(type);
  if (!around)
    return null;
  let outer = around.length ? around[0] : type;
  return parent.canReplaceWith(startIndex2, endIndex2, outer) ? around : null;
}
function findWrappingInside(range2, type) {
  let { parent, startIndex: startIndex2, endIndex: endIndex2 } = range2;
  let inner = parent.child(startIndex2);
  let inside = type.contentMatch.findWrapping(inner.type);
  if (!inside)
    return null;
  let lastType = inside.length ? inside[inside.length - 1] : type;
  let innerMatch = lastType.contentMatch;
  for (let i3 = startIndex2; innerMatch && i3 < endIndex2; i3++)
    innerMatch = innerMatch.matchType(parent.child(i3).type);
  if (!innerMatch || !innerMatch.validEnd)
    return null;
  return inside;
}
function wrap(tr, range2, wrappers) {
  let content = Fragment.empty;
  for (let i3 = wrappers.length - 1; i3 >= 0; i3--) {
    if (content.size) {
      let match2 = wrappers[i3].type.contentMatch.matchFragment(content);
      if (!match2 || !match2.validEnd)
        throw new RangeError("Wrapper type given to Transform.wrap does not form valid content of its parent wrapper");
    }
    content = Fragment.from(wrappers[i3].type.create(wrappers[i3].attrs, content));
  }
  let start2 = range2.start, end2 = range2.end;
  tr.step(new ReplaceAroundStep(start2, end2, start2, end2, new Slice(content, 0, 0), wrappers.length, true));
}
function setBlockType$1(tr, from3, to, type, attrs) {
  if (!type.isTextblock)
    throw new RangeError("Type given to setBlockType should be a textblock");
  let mapFrom = tr.steps.length;
  tr.doc.nodesBetween(from3, to, (node2, pos) => {
    if (node2.isTextblock && !node2.hasMarkup(type, attrs) && canChangeType(tr.doc, tr.mapping.slice(mapFrom).map(pos), type)) {
      tr.clearIncompatible(tr.mapping.slice(mapFrom).map(pos, 1), type);
      let mapping = tr.mapping.slice(mapFrom);
      let startM = mapping.map(pos, 1), endM = mapping.map(pos + node2.nodeSize, 1);
      tr.step(new ReplaceAroundStep(startM, endM, startM + 1, endM - 1, new Slice(Fragment.from(type.create(attrs, null, node2.marks)), 0, 0), 1, true));
      return false;
    }
  });
}
function canChangeType(doc2, pos, type) {
  let $pos = doc2.resolve(pos), index2 = $pos.index();
  return $pos.parent.canReplaceWith(index2, index2 + 1, type);
}
function setNodeMarkup(tr, pos, type, attrs, marks) {
  let node2 = tr.doc.nodeAt(pos);
  if (!node2)
    throw new RangeError("No node at given position");
  if (!type)
    type = node2.type;
  let newNode = type.create(attrs, null, marks || node2.marks);
  if (node2.isLeaf)
    return tr.replaceWith(pos, pos + node2.nodeSize, newNode);
  if (!type.validContent(node2.content))
    throw new RangeError("Invalid content for node type " + type.name);
  tr.step(new ReplaceAroundStep(pos, pos + node2.nodeSize, pos + 1, pos + node2.nodeSize - 1, new Slice(Fragment.from(newNode), 0, 0), 1, true));
}
function canSplit(doc2, pos, depth = 1, typesAfter) {
  let $pos = doc2.resolve(pos), base2 = $pos.depth - depth;
  let innerType = typesAfter && typesAfter[typesAfter.length - 1] || $pos.parent;
  if (base2 < 0 || $pos.parent.type.spec.isolating || !$pos.parent.canReplace($pos.index(), $pos.parent.childCount) || !innerType.type.validContent($pos.parent.content.cutByIndex($pos.index(), $pos.parent.childCount)))
    return false;
  for (let d4 = $pos.depth - 1, i3 = depth - 2; d4 > base2; d4--, i3--) {
    let node2 = $pos.node(d4), index3 = $pos.index(d4);
    if (node2.type.spec.isolating)
      return false;
    let rest = node2.content.cutByIndex(index3, node2.childCount);
    let after = typesAfter && typesAfter[i3] || node2;
    if (after != node2)
      rest = rest.replaceChild(0, after.type.create(after.attrs));
    if (!node2.canReplace(index3 + 1, node2.childCount) || !after.type.validContent(rest))
      return false;
  }
  let index2 = $pos.indexAfter(base2);
  let baseType = typesAfter && typesAfter[0];
  return $pos.node(base2).canReplaceWith(index2, index2, baseType ? baseType.type : $pos.node(base2 + 1).type);
}
function split(tr, pos, depth = 1, typesAfter) {
  let $pos = tr.doc.resolve(pos), before = Fragment.empty, after = Fragment.empty;
  for (let d4 = $pos.depth, e3 = $pos.depth - depth, i3 = depth - 1; d4 > e3; d4--, i3--) {
    before = Fragment.from($pos.node(d4).copy(before));
    let typeAfter = typesAfter && typesAfter[i3];
    after = Fragment.from(typeAfter ? typeAfter.type.create(typeAfter.attrs, after) : $pos.node(d4).copy(after));
  }
  tr.step(new ReplaceStep(pos, pos, new Slice(before.append(after), depth, depth), true));
}
function canJoin(doc2, pos) {
  let $pos = doc2.resolve(pos), index2 = $pos.index();
  return joinable($pos.nodeBefore, $pos.nodeAfter) && $pos.parent.canReplace(index2, index2 + 1);
}
function joinable(a4, b3) {
  return !!(a4 && b3 && !a4.isLeaf && a4.canAppend(b3));
}
function joinPoint(doc2, pos, dir = -1) {
  let $pos = doc2.resolve(pos);
  for (let d4 = $pos.depth; ; d4--) {
    let before, after, index2 = $pos.index(d4);
    if (d4 == $pos.depth) {
      before = $pos.nodeBefore;
      after = $pos.nodeAfter;
    } else if (dir > 0) {
      before = $pos.node(d4 + 1);
      index2++;
      after = $pos.node(d4).maybeChild(index2);
    } else {
      before = $pos.node(d4).maybeChild(index2 - 1);
      after = $pos.node(d4 + 1);
    }
    if (before && !before.isTextblock && joinable(before, after) && $pos.node(d4).canReplace(index2, index2 + 1))
      return pos;
    if (d4 == 0)
      break;
    pos = dir < 0 ? $pos.before(d4) : $pos.after(d4);
  }
}
function join(tr, pos, depth) {
  let step = new ReplaceStep(pos - depth, pos + depth, Slice.empty, true);
  tr.step(step);
}
function insertPoint(doc2, pos, nodeType) {
  let $pos = doc2.resolve(pos);
  if ($pos.parent.canReplaceWith($pos.index(), $pos.index(), nodeType))
    return pos;
  if ($pos.parentOffset == 0)
    for (let d4 = $pos.depth - 1; d4 >= 0; d4--) {
      let index2 = $pos.index(d4);
      if ($pos.node(d4).canReplaceWith(index2, index2, nodeType))
        return $pos.before(d4 + 1);
      if (index2 > 0)
        return null;
    }
  if ($pos.parentOffset == $pos.parent.content.size)
    for (let d4 = $pos.depth - 1; d4 >= 0; d4--) {
      let index2 = $pos.indexAfter(d4);
      if ($pos.node(d4).canReplaceWith(index2, index2, nodeType))
        return $pos.after(d4 + 1);
      if (index2 < $pos.node(d4).childCount)
        return null;
    }
  return null;
}
function dropPoint(doc2, pos, slice3) {
  let $pos = doc2.resolve(pos);
  if (!slice3.content.size)
    return pos;
  let content = slice3.content;
  for (let i3 = 0; i3 < slice3.openStart; i3++)
    content = content.firstChild.content;
  for (let pass = 1; pass <= (slice3.openStart == 0 && slice3.size ? 2 : 1); pass++) {
    for (let d4 = $pos.depth; d4 >= 0; d4--) {
      let bias = d4 == $pos.depth ? 0 : $pos.pos <= ($pos.start(d4 + 1) + $pos.end(d4 + 1)) / 2 ? -1 : 1;
      let insertPos = $pos.index(d4) + (bias > 0 ? 1 : 0);
      let parent = $pos.node(d4), fits = false;
      if (pass == 1) {
        fits = parent.canReplace(insertPos, insertPos, content);
      } else {
        let wrapping = parent.contentMatchAt(insertPos).findWrapping(content.firstChild.type);
        fits = wrapping && parent.canReplaceWith(insertPos, insertPos, wrapping[0]);
      }
      if (fits)
        return bias == 0 ? $pos.pos : bias < 0 ? $pos.before(d4 + 1) : $pos.after(d4 + 1);
    }
  }
  return null;
}
function replaceStep(doc2, from3, to = from3, slice3 = Slice.empty) {
  if (from3 == to && !slice3.size)
    return null;
  let $from = doc2.resolve(from3), $to = doc2.resolve(to);
  if (fitsTrivially($from, $to, slice3))
    return new ReplaceStep(from3, to, slice3);
  return new Fitter($from, $to, slice3).fit();
}
function fitsTrivially($from, $to, slice3) {
  return !slice3.openStart && !slice3.openEnd && $from.start() == $to.start() && $from.parent.canReplace($from.index(), $to.index(), slice3.content);
}
class Fitter {
  constructor($from, $to, unplaced) {
    this.$from = $from;
    this.$to = $to;
    this.unplaced = unplaced;
    this.frontier = [];
    this.placed = Fragment.empty;
    for (let i3 = 0; i3 <= $from.depth; i3++) {
      let node2 = $from.node(i3);
      this.frontier.push({
        type: node2.type,
        match: node2.contentMatchAt($from.indexAfter(i3))
      });
    }
    for (let i3 = $from.depth; i3 > 0; i3--)
      this.placed = Fragment.from($from.node(i3).copy(this.placed));
  }
  get depth() {
    return this.frontier.length - 1;
  }
  fit() {
    while (this.unplaced.size) {
      let fit = this.findFittable();
      if (fit)
        this.placeNodes(fit);
      else
        this.openMore() || this.dropNode();
    }
    let moveInline = this.mustMoveInline(), placedSize = this.placed.size - this.depth - this.$from.depth;
    let $from = this.$from, $to = this.close(moveInline < 0 ? this.$to : $from.doc.resolve(moveInline));
    if (!$to)
      return null;
    let content = this.placed, openStart = $from.depth, openEnd = $to.depth;
    while (openStart && openEnd && content.childCount == 1) {
      content = content.firstChild.content;
      openStart--;
      openEnd--;
    }
    let slice3 = new Slice(content, openStart, openEnd);
    if (moveInline > -1)
      return new ReplaceAroundStep($from.pos, moveInline, this.$to.pos, this.$to.end(), slice3, placedSize);
    if (slice3.size || $from.pos != this.$to.pos)
      return new ReplaceStep($from.pos, $to.pos, slice3);
    return null;
  }
  findFittable() {
    let startDepth = this.unplaced.openStart;
    for (let cur = this.unplaced.content, d4 = 0, openEnd = this.unplaced.openEnd; d4 < startDepth; d4++) {
      let node2 = cur.firstChild;
      if (cur.childCount > 1)
        openEnd = 0;
      if (node2.type.spec.isolating && openEnd <= d4) {
        startDepth = d4;
        break;
      }
      cur = node2.content;
    }
    for (let pass = 1; pass <= 2; pass++) {
      for (let sliceDepth = pass == 1 ? startDepth : this.unplaced.openStart; sliceDepth >= 0; sliceDepth--) {
        let fragment, parent = null;
        if (sliceDepth) {
          parent = contentAt(this.unplaced.content, sliceDepth - 1).firstChild;
          fragment = parent.content;
        } else {
          fragment = this.unplaced.content;
        }
        let first2 = fragment.firstChild;
        for (let frontierDepth = this.depth; frontierDepth >= 0; frontierDepth--) {
          let { type, match: match2 } = this.frontier[frontierDepth], wrap2, inject = null;
          if (pass == 1 && (first2 ? match2.matchType(first2.type) || (inject = match2.fillBefore(Fragment.from(first2), false)) : parent && type.compatibleContent(parent.type)))
            return { sliceDepth, frontierDepth, parent, inject };
          else if (pass == 2 && first2 && (wrap2 = match2.findWrapping(first2.type)))
            return { sliceDepth, frontierDepth, parent, wrap: wrap2 };
          if (parent && match2.matchType(parent.type))
            break;
        }
      }
    }
  }
  openMore() {
    let { content, openStart, openEnd } = this.unplaced;
    let inner = contentAt(content, openStart);
    if (!inner.childCount || inner.firstChild.isLeaf)
      return false;
    this.unplaced = new Slice(content, openStart + 1, Math.max(openEnd, inner.size + openStart >= content.size - openEnd ? openStart + 1 : 0));
    return true;
  }
  dropNode() {
    let { content, openStart, openEnd } = this.unplaced;
    let inner = contentAt(content, openStart);
    if (inner.childCount <= 1 && openStart > 0) {
      let openAtEnd = content.size - openStart <= openStart + inner.size;
      this.unplaced = new Slice(dropFromFragment(content, openStart - 1, 1), openStart - 1, openAtEnd ? openStart - 1 : openEnd);
    } else {
      this.unplaced = new Slice(dropFromFragment(content, openStart, 1), openStart, openEnd);
    }
  }
  placeNodes({ sliceDepth, frontierDepth, parent, inject, wrap: wrap2 }) {
    while (this.depth > frontierDepth)
      this.closeFrontierNode();
    if (wrap2)
      for (let i3 = 0; i3 < wrap2.length; i3++)
        this.openFrontierNode(wrap2[i3]);
    let slice3 = this.unplaced, fragment = parent ? parent.content : slice3.content;
    let openStart = slice3.openStart - sliceDepth;
    let taken = 0, add2 = [];
    let { match: match2, type } = this.frontier[frontierDepth];
    if (inject) {
      for (let i3 = 0; i3 < inject.childCount; i3++)
        add2.push(inject.child(i3));
      match2 = match2.matchFragment(inject);
    }
    let openEndCount = fragment.size + sliceDepth - (slice3.content.size - slice3.openEnd);
    while (taken < fragment.childCount) {
      let next2 = fragment.child(taken), matches2 = match2.matchType(next2.type);
      if (!matches2)
        break;
      taken++;
      if (taken > 1 || openStart == 0 || next2.content.size) {
        match2 = matches2;
        add2.push(closeNodeStart(next2.mark(type.allowedMarks(next2.marks)), taken == 1 ? openStart : 0, taken == fragment.childCount ? openEndCount : -1));
      }
    }
    let toEnd = taken == fragment.childCount;
    if (!toEnd)
      openEndCount = -1;
    this.placed = addToFragment(this.placed, frontierDepth, Fragment.from(add2));
    this.frontier[frontierDepth].match = match2;
    if (toEnd && openEndCount < 0 && parent && parent.type == this.frontier[this.depth].type && this.frontier.length > 1)
      this.closeFrontierNode();
    for (let i3 = 0, cur = fragment; i3 < openEndCount; i3++) {
      let node2 = cur.lastChild;
      this.frontier.push({ type: node2.type, match: node2.contentMatchAt(node2.childCount) });
      cur = node2.content;
    }
    this.unplaced = !toEnd ? new Slice(dropFromFragment(slice3.content, sliceDepth, taken), slice3.openStart, slice3.openEnd) : sliceDepth == 0 ? Slice.empty : new Slice(dropFromFragment(slice3.content, sliceDepth - 1, 1), sliceDepth - 1, openEndCount < 0 ? slice3.openEnd : sliceDepth - 1);
  }
  mustMoveInline() {
    if (!this.$to.parent.isTextblock)
      return -1;
    let top2 = this.frontier[this.depth], level;
    if (!top2.type.isTextblock || !contentAfterFits(this.$to, this.$to.depth, top2.type, top2.match, false) || this.$to.depth == this.depth && (level = this.findCloseLevel(this.$to)) && level.depth == this.depth)
      return -1;
    let { depth } = this.$to, after = this.$to.after(depth);
    while (depth > 1 && after == this.$to.end(--depth))
      ++after;
    return after;
  }
  findCloseLevel($to) {
    scan:
      for (let i3 = Math.min(this.depth, $to.depth); i3 >= 0; i3--) {
        let { match: match2, type } = this.frontier[i3];
        let dropInner = i3 < $to.depth && $to.end(i3 + 1) == $to.pos + ($to.depth - (i3 + 1));
        let fit = contentAfterFits($to, i3, type, match2, dropInner);
        if (!fit)
          continue;
        for (let d4 = i3 - 1; d4 >= 0; d4--) {
          let { match: match3, type: type2 } = this.frontier[d4];
          let matches2 = contentAfterFits($to, d4, type2, match3, true);
          if (!matches2 || matches2.childCount)
            continue scan;
        }
        return { depth: i3, fit, move: dropInner ? $to.doc.resolve($to.after(i3 + 1)) : $to };
      }
  }
  close($to) {
    let close2 = this.findCloseLevel($to);
    if (!close2)
      return null;
    while (this.depth > close2.depth)
      this.closeFrontierNode();
    if (close2.fit.childCount)
      this.placed = addToFragment(this.placed, close2.depth, close2.fit);
    $to = close2.move;
    for (let d4 = close2.depth + 1; d4 <= $to.depth; d4++) {
      let node2 = $to.node(d4), add2 = node2.type.contentMatch.fillBefore(node2.content, true, $to.index(d4));
      this.openFrontierNode(node2.type, node2.attrs, add2);
    }
    return $to;
  }
  openFrontierNode(type, attrs = null, content) {
    let top2 = this.frontier[this.depth];
    top2.match = top2.match.matchType(type);
    this.placed = addToFragment(this.placed, this.depth, Fragment.from(type.create(attrs, content)));
    this.frontier.push({ type, match: type.contentMatch });
  }
  closeFrontierNode() {
    let open = this.frontier.pop();
    let add2 = open.match.fillBefore(Fragment.empty, true);
    if (add2.childCount)
      this.placed = addToFragment(this.placed, this.frontier.length, add2);
  }
}
function dropFromFragment(fragment, depth, count) {
  if (depth == 0)
    return fragment.cutByIndex(count, fragment.childCount);
  return fragment.replaceChild(0, fragment.firstChild.copy(dropFromFragment(fragment.firstChild.content, depth - 1, count)));
}
function addToFragment(fragment, depth, content) {
  if (depth == 0)
    return fragment.append(content);
  return fragment.replaceChild(fragment.childCount - 1, fragment.lastChild.copy(addToFragment(fragment.lastChild.content, depth - 1, content)));
}
function contentAt(fragment, depth) {
  for (let i3 = 0; i3 < depth; i3++)
    fragment = fragment.firstChild.content;
  return fragment;
}
function closeNodeStart(node2, openStart, openEnd) {
  if (openStart <= 0)
    return node2;
  let frag = node2.content;
  if (openStart > 1)
    frag = frag.replaceChild(0, closeNodeStart(frag.firstChild, openStart - 1, frag.childCount == 1 ? openEnd - 1 : 0));
  if (openStart > 0) {
    frag = node2.type.contentMatch.fillBefore(frag).append(frag);
    if (openEnd <= 0)
      frag = frag.append(node2.type.contentMatch.matchFragment(frag).fillBefore(Fragment.empty, true));
  }
  return node2.copy(frag);
}
function contentAfterFits($to, depth, type, match2, open) {
  let node2 = $to.node(depth), index2 = open ? $to.indexAfter(depth) : $to.index(depth);
  if (index2 == node2.childCount && !type.compatibleContent(node2.type))
    return null;
  let fit = match2.fillBefore(node2.content, true, index2);
  return fit && !invalidMarks(type, node2.content, index2) ? fit : null;
}
function invalidMarks(type, fragment, start2) {
  for (let i3 = start2; i3 < fragment.childCount; i3++)
    if (!type.allowsMarks(fragment.child(i3).marks))
      return true;
  return false;
}
function definesContent(type) {
  return type.spec.defining || type.spec.definingForContent;
}
function replaceRange(tr, from3, to, slice3) {
  if (!slice3.size)
    return tr.deleteRange(from3, to);
  let $from = tr.doc.resolve(from3), $to = tr.doc.resolve(to);
  if (fitsTrivially($from, $to, slice3))
    return tr.step(new ReplaceStep(from3, to, slice3));
  let targetDepths = coveredDepths($from, tr.doc.resolve(to));
  if (targetDepths[targetDepths.length - 1] == 0)
    targetDepths.pop();
  let preferredTarget = -($from.depth + 1);
  targetDepths.unshift(preferredTarget);
  for (let d4 = $from.depth, pos = $from.pos - 1; d4 > 0; d4--, pos--) {
    let spec = $from.node(d4).type.spec;
    if (spec.defining || spec.definingAsContext || spec.isolating)
      break;
    if (targetDepths.indexOf(d4) > -1)
      preferredTarget = d4;
    else if ($from.before(d4) == pos)
      targetDepths.splice(1, 0, -d4);
  }
  let preferredTargetIndex = targetDepths.indexOf(preferredTarget);
  let leftNodes = [], preferredDepth = slice3.openStart;
  for (let content = slice3.content, i3 = 0; ; i3++) {
    let node2 = content.firstChild;
    leftNodes.push(node2);
    if (i3 == slice3.openStart)
      break;
    content = node2.content;
  }
  for (let d4 = preferredDepth - 1; d4 >= 0; d4--) {
    let type = leftNodes[d4].type, def = definesContent(type);
    if (def && $from.node(preferredTargetIndex).type != type)
      preferredDepth = d4;
    else if (def || !type.isTextblock)
      break;
  }
  for (let j2 = slice3.openStart; j2 >= 0; j2--) {
    let openDepth = (j2 + preferredDepth + 1) % (slice3.openStart + 1);
    let insert = leftNodes[openDepth];
    if (!insert)
      continue;
    for (let i3 = 0; i3 < targetDepths.length; i3++) {
      let targetDepth = targetDepths[(i3 + preferredTargetIndex) % targetDepths.length], expand = true;
      if (targetDepth < 0) {
        expand = false;
        targetDepth = -targetDepth;
      }
      let parent = $from.node(targetDepth - 1), index2 = $from.index(targetDepth - 1);
      if (parent.canReplaceWith(index2, index2, insert.type, insert.marks))
        return tr.replace($from.before(targetDepth), expand ? $to.after(targetDepth) : to, new Slice(closeFragment(slice3.content, 0, slice3.openStart, openDepth), openDepth, slice3.openEnd));
    }
  }
  let startSteps = tr.steps.length;
  for (let i3 = targetDepths.length - 1; i3 >= 0; i3--) {
    tr.replace(from3, to, slice3);
    if (tr.steps.length > startSteps)
      break;
    let depth = targetDepths[i3];
    if (depth < 0)
      continue;
    from3 = $from.before(depth);
    to = $to.after(depth);
  }
}
function closeFragment(fragment, depth, oldOpen, newOpen, parent) {
  if (depth < oldOpen) {
    let first2 = fragment.firstChild;
    fragment = fragment.replaceChild(0, first2.copy(closeFragment(first2.content, depth + 1, oldOpen, newOpen, first2)));
  }
  if (depth > newOpen) {
    let match2 = parent.contentMatchAt(0);
    let start2 = match2.fillBefore(fragment).append(fragment);
    fragment = start2.append(match2.matchFragment(start2).fillBefore(Fragment.empty, true));
  }
  return fragment;
}
function replaceRangeWith(tr, from3, to, node2) {
  if (!node2.isInline && from3 == to && tr.doc.resolve(from3).parent.content.size) {
    let point = insertPoint(tr.doc, from3, node2.type);
    if (point != null)
      from3 = to = point;
  }
  tr.replaceRange(from3, to, new Slice(Fragment.from(node2), 0, 0));
}
function deleteRange$1(tr, from3, to) {
  let $from = tr.doc.resolve(from3), $to = tr.doc.resolve(to);
  let covered = coveredDepths($from, $to);
  for (let i3 = 0; i3 < covered.length; i3++) {
    let depth = covered[i3], last = i3 == covered.length - 1;
    if (last && depth == 0 || $from.node(depth).type.contentMatch.validEnd)
      return tr.delete($from.start(depth), $to.end(depth));
    if (depth > 0 && (last || $from.node(depth - 1).canReplace($from.index(depth - 1), $to.indexAfter(depth - 1))))
      return tr.delete($from.before(depth), $to.after(depth));
  }
  for (let d4 = 1; d4 <= $from.depth && d4 <= $to.depth; d4++) {
    if (from3 - $from.start(d4) == $from.depth - d4 && to > $from.end(d4) && $to.end(d4) - to != $to.depth - d4)
      return tr.delete($from.before(d4), to);
  }
  tr.delete(from3, to);
}
function coveredDepths($from, $to) {
  let result = [], minDepth = Math.min($from.depth, $to.depth);
  for (let d4 = minDepth; d4 >= 0; d4--) {
    let start2 = $from.start(d4);
    if (start2 < $from.pos - ($from.depth - d4) || $to.end(d4) > $to.pos + ($to.depth - d4) || $from.node(d4).type.spec.isolating || $to.node(d4).type.spec.isolating)
      break;
    if (start2 == $to.start(d4) || d4 == $from.depth && d4 == $to.depth && $from.parent.inlineContent && $to.parent.inlineContent && d4 && $to.start(d4 - 1) == start2 - 1)
      result.push(d4);
  }
  return result;
}
class AttrStep extends Step {
  constructor(pos, attr, value) {
    super();
    this.pos = pos;
    this.attr = attr;
    this.value = value;
  }
  apply(doc2) {
    let node2 = doc2.nodeAt(this.pos);
    if (!node2)
      return StepResult.fail("No node at attribute step's position");
    let attrs = /* @__PURE__ */ Object.create(null);
    for (let name in node2.attrs)
      attrs[name] = node2.attrs[name];
    attrs[this.attr] = this.value;
    let updated = node2.type.create(attrs, null, node2.marks);
    return StepResult.fromReplace(doc2, this.pos, this.pos + 1, new Slice(Fragment.from(updated), 0, node2.isLeaf ? 0 : 1));
  }
  getMap() {
    return StepMap.empty;
  }
  invert(doc2) {
    return new AttrStep(this.pos, this.attr, doc2.nodeAt(this.pos).attrs[this.attr]);
  }
  map(mapping) {
    let pos = mapping.mapResult(this.pos, 1);
    return pos.deletedAfter ? null : new AttrStep(pos.pos, this.attr, this.value);
  }
  toJSON() {
    return { stepType: "attr", pos: this.pos, attr: this.attr, value: this.value };
  }
  static fromJSON(schema, json) {
    if (typeof json.pos != "number" || typeof json.attr != "string")
      throw new RangeError("Invalid input for AttrStep.fromJSON");
    return new AttrStep(json.pos, json.attr, json.value);
  }
}
Step.jsonID("attr", AttrStep);
let TransformError = class extends Error {
};
TransformError = function TransformError2(message) {
  let err = Error.call(this, message);
  err.__proto__ = TransformError2.prototype;
  return err;
};
TransformError.prototype = Object.create(Error.prototype);
TransformError.prototype.constructor = TransformError;
TransformError.prototype.name = "TransformError";
class Transform {
  constructor(doc2) {
    this.doc = doc2;
    this.steps = [];
    this.docs = [];
    this.mapping = new Mapping();
  }
  get before() {
    return this.docs.length ? this.docs[0] : this.doc;
  }
  step(step) {
    let result = this.maybeStep(step);
    if (result.failed)
      throw new TransformError(result.failed);
    return this;
  }
  maybeStep(step) {
    let result = step.apply(this.doc);
    if (!result.failed)
      this.addStep(step, result.doc);
    return result;
  }
  get docChanged() {
    return this.steps.length > 0;
  }
  addStep(step, doc2) {
    this.docs.push(this.doc);
    this.steps.push(step);
    this.mapping.appendMap(step.getMap());
    this.doc = doc2;
  }
  replace(from3, to = from3, slice3 = Slice.empty) {
    let step = replaceStep(this.doc, from3, to, slice3);
    if (step)
      this.step(step);
    return this;
  }
  replaceWith(from3, to, content) {
    return this.replace(from3, to, new Slice(Fragment.from(content), 0, 0));
  }
  delete(from3, to) {
    return this.replace(from3, to, Slice.empty);
  }
  insert(pos, content) {
    return this.replaceWith(pos, pos, content);
  }
  replaceRange(from3, to, slice3) {
    replaceRange(this, from3, to, slice3);
    return this;
  }
  replaceRangeWith(from3, to, node2) {
    replaceRangeWith(this, from3, to, node2);
    return this;
  }
  deleteRange(from3, to) {
    deleteRange$1(this, from3, to);
    return this;
  }
  lift(range2, target) {
    lift$2(this, range2, target);
    return this;
  }
  join(pos, depth = 1) {
    join(this, pos, depth);
    return this;
  }
  wrap(range2, wrappers) {
    wrap(this, range2, wrappers);
    return this;
  }
  setBlockType(from3, to = from3, type, attrs = null) {
    setBlockType$1(this, from3, to, type, attrs);
    return this;
  }
  setNodeMarkup(pos, type, attrs = null, marks) {
    setNodeMarkup(this, pos, type, attrs, marks);
    return this;
  }
  setNodeAttribute(pos, attr, value) {
    this.step(new AttrStep(pos, attr, value));
    return this;
  }
  addNodeMark(pos, mark) {
    this.step(new AddNodeMarkStep(pos, mark));
    return this;
  }
  removeNodeMark(pos, mark) {
    if (!(mark instanceof Mark$1)) {
      let node2 = this.doc.nodeAt(pos);
      if (!node2)
        throw new RangeError("No node at position " + pos);
      mark = mark.isInSet(node2.marks);
      if (!mark)
        return this;
    }
    this.step(new RemoveNodeMarkStep(pos, mark));
    return this;
  }
  split(pos, depth = 1, typesAfter) {
    split(this, pos, depth, typesAfter);
    return this;
  }
  addMark(from3, to, mark) {
    addMark(this, from3, to, mark);
    return this;
  }
  removeMark(from3, to, mark) {
    removeMark(this, from3, to, mark);
    return this;
  }
  clearIncompatible(pos, parentType, match2) {
    clearIncompatible(this, pos, parentType, match2);
    return this;
  }
}
const classesById = /* @__PURE__ */ Object.create(null);
class Selection {
  constructor($anchor, $head, ranges) {
    this.$anchor = $anchor;
    this.$head = $head;
    this.ranges = ranges || [new SelectionRange($anchor.min($head), $anchor.max($head))];
  }
  get anchor() {
    return this.$anchor.pos;
  }
  get head() {
    return this.$head.pos;
  }
  get from() {
    return this.$from.pos;
  }
  get to() {
    return this.$to.pos;
  }
  get $from() {
    return this.ranges[0].$from;
  }
  get $to() {
    return this.ranges[0].$to;
  }
  get empty() {
    let ranges = this.ranges;
    for (let i3 = 0; i3 < ranges.length; i3++)
      if (ranges[i3].$from.pos != ranges[i3].$to.pos)
        return false;
    return true;
  }
  content() {
    return this.$from.doc.slice(this.from, this.to, true);
  }
  replace(tr, content = Slice.empty) {
    let lastNode = content.content.lastChild, lastParent = null;
    for (let i3 = 0; i3 < content.openEnd; i3++) {
      lastParent = lastNode;
      lastNode = lastNode.lastChild;
    }
    let mapFrom = tr.steps.length, ranges = this.ranges;
    for (let i3 = 0; i3 < ranges.length; i3++) {
      let { $from, $to } = ranges[i3], mapping = tr.mapping.slice(mapFrom);
      tr.replaceRange(mapping.map($from.pos), mapping.map($to.pos), i3 ? Slice.empty : content);
      if (i3 == 0)
        selectionToInsertionEnd$1(tr, mapFrom, (lastNode ? lastNode.isInline : lastParent && lastParent.isTextblock) ? -1 : 1);
    }
  }
  replaceWith(tr, node2) {
    let mapFrom = tr.steps.length, ranges = this.ranges;
    for (let i3 = 0; i3 < ranges.length; i3++) {
      let { $from, $to } = ranges[i3], mapping = tr.mapping.slice(mapFrom);
      let from3 = mapping.map($from.pos), to = mapping.map($to.pos);
      if (i3) {
        tr.deleteRange(from3, to);
      } else {
        tr.replaceRangeWith(from3, to, node2);
        selectionToInsertionEnd$1(tr, mapFrom, node2.isInline ? -1 : 1);
      }
    }
  }
  static findFrom($pos, dir, textOnly = false) {
    let inner = $pos.parent.inlineContent ? new TextSelection($pos) : findSelectionIn($pos.node(0), $pos.parent, $pos.pos, $pos.index(), dir, textOnly);
    if (inner)
      return inner;
    for (let depth = $pos.depth - 1; depth >= 0; depth--) {
      let found2 = dir < 0 ? findSelectionIn($pos.node(0), $pos.node(depth), $pos.before(depth + 1), $pos.index(depth), dir, textOnly) : findSelectionIn($pos.node(0), $pos.node(depth), $pos.after(depth + 1), $pos.index(depth) + 1, dir, textOnly);
      if (found2)
        return found2;
    }
    return null;
  }
  static near($pos, bias = 1) {
    return this.findFrom($pos, bias) || this.findFrom($pos, -bias) || new AllSelection($pos.node(0));
  }
  static atStart(doc2) {
    return findSelectionIn(doc2, doc2, 0, 0, 1) || new AllSelection(doc2);
  }
  static atEnd(doc2) {
    return findSelectionIn(doc2, doc2, doc2.content.size, doc2.childCount, -1) || new AllSelection(doc2);
  }
  static fromJSON(doc2, json) {
    if (!json || !json.type)
      throw new RangeError("Invalid input for Selection.fromJSON");
    let cls = classesById[json.type];
    if (!cls)
      throw new RangeError(`No selection type ${json.type} defined`);
    return cls.fromJSON(doc2, json);
  }
  static jsonID(id2, selectionClass) {
    if (id2 in classesById)
      throw new RangeError("Duplicate use of selection JSON ID " + id2);
    classesById[id2] = selectionClass;
    selectionClass.prototype.jsonID = id2;
    return selectionClass;
  }
  getBookmark() {
    return TextSelection.between(this.$anchor, this.$head).getBookmark();
  }
}
Selection.prototype.visible = true;
class SelectionRange {
  constructor($from, $to) {
    this.$from = $from;
    this.$to = $to;
  }
}
let warnedAboutTextSelection = false;
function checkTextSelection($pos) {
  if (!warnedAboutTextSelection && !$pos.parent.inlineContent) {
    warnedAboutTextSelection = true;
    console["warn"]("TextSelection endpoint not pointing into a node with inline content (" + $pos.parent.type.name + ")");
  }
}
class TextSelection extends Selection {
  constructor($anchor, $head = $anchor) {
    checkTextSelection($anchor);
    checkTextSelection($head);
    super($anchor, $head);
  }
  get $cursor() {
    return this.$anchor.pos == this.$head.pos ? this.$head : null;
  }
  map(doc2, mapping) {
    let $head = doc2.resolve(mapping.map(this.head));
    if (!$head.parent.inlineContent)
      return Selection.near($head);
    let $anchor = doc2.resolve(mapping.map(this.anchor));
    return new TextSelection($anchor.parent.inlineContent ? $anchor : $head, $head);
  }
  replace(tr, content = Slice.empty) {
    super.replace(tr, content);
    if (content == Slice.empty) {
      let marks = this.$from.marksAcross(this.$to);
      if (marks)
        tr.ensureMarks(marks);
    }
  }
  eq(other) {
    return other instanceof TextSelection && other.anchor == this.anchor && other.head == this.head;
  }
  getBookmark() {
    return new TextBookmark(this.anchor, this.head);
  }
  toJSON() {
    return { type: "text", anchor: this.anchor, head: this.head };
  }
  static fromJSON(doc2, json) {
    if (typeof json.anchor != "number" || typeof json.head != "number")
      throw new RangeError("Invalid input for TextSelection.fromJSON");
    return new TextSelection(doc2.resolve(json.anchor), doc2.resolve(json.head));
  }
  static create(doc2, anchor, head = anchor) {
    let $anchor = doc2.resolve(anchor);
    return new this($anchor, head == anchor ? $anchor : doc2.resolve(head));
  }
  static between($anchor, $head, bias) {
    let dPos = $anchor.pos - $head.pos;
    if (!bias || dPos)
      bias = dPos >= 0 ? 1 : -1;
    if (!$head.parent.inlineContent) {
      let found2 = Selection.findFrom($head, bias, true) || Selection.findFrom($head, -bias, true);
      if (found2)
        $head = found2.$head;
      else
        return Selection.near($head, bias);
    }
    if (!$anchor.parent.inlineContent) {
      if (dPos == 0) {
        $anchor = $head;
      } else {
        $anchor = (Selection.findFrom($anchor, -bias, true) || Selection.findFrom($anchor, bias, true)).$anchor;
        if ($anchor.pos < $head.pos != dPos < 0)
          $anchor = $head;
      }
    }
    return new TextSelection($anchor, $head);
  }
}
Selection.jsonID("text", TextSelection);
class TextBookmark {
  constructor(anchor, head) {
    this.anchor = anchor;
    this.head = head;
  }
  map(mapping) {
    return new TextBookmark(mapping.map(this.anchor), mapping.map(this.head));
  }
  resolve(doc2) {
    return TextSelection.between(doc2.resolve(this.anchor), doc2.resolve(this.head));
  }
}
class NodeSelection extends Selection {
  constructor($pos) {
    let node2 = $pos.nodeAfter;
    let $end = $pos.node(0).resolve($pos.pos + node2.nodeSize);
    super($pos, $end);
    this.node = node2;
  }
  map(doc2, mapping) {
    let { deleted, pos } = mapping.mapResult(this.anchor);
    let $pos = doc2.resolve(pos);
    if (deleted)
      return Selection.near($pos);
    return new NodeSelection($pos);
  }
  content() {
    return new Slice(Fragment.from(this.node), 0, 0);
  }
  eq(other) {
    return other instanceof NodeSelection && other.anchor == this.anchor;
  }
  toJSON() {
    return { type: "node", anchor: this.anchor };
  }
  getBookmark() {
    return new NodeBookmark(this.anchor);
  }
  static fromJSON(doc2, json) {
    if (typeof json.anchor != "number")
      throw new RangeError("Invalid input for NodeSelection.fromJSON");
    return new NodeSelection(doc2.resolve(json.anchor));
  }
  static create(doc2, from3) {
    return new NodeSelection(doc2.resolve(from3));
  }
  static isSelectable(node2) {
    return !node2.isText && node2.type.spec.selectable !== false;
  }
}
NodeSelection.prototype.visible = false;
Selection.jsonID("node", NodeSelection);
class NodeBookmark {
  constructor(anchor) {
    this.anchor = anchor;
  }
  map(mapping) {
    let { deleted, pos } = mapping.mapResult(this.anchor);
    return deleted ? new TextBookmark(pos, pos) : new NodeBookmark(pos);
  }
  resolve(doc2) {
    let $pos = doc2.resolve(this.anchor), node2 = $pos.nodeAfter;
    if (node2 && NodeSelection.isSelectable(node2))
      return new NodeSelection($pos);
    return Selection.near($pos);
  }
}
class AllSelection extends Selection {
  constructor(doc2) {
    super(doc2.resolve(0), doc2.resolve(doc2.content.size));
  }
  replace(tr, content = Slice.empty) {
    if (content == Slice.empty) {
      tr.delete(0, tr.doc.content.size);
      let sel = Selection.atStart(tr.doc);
      if (!sel.eq(tr.selection))
        tr.setSelection(sel);
    } else {
      super.replace(tr, content);
    }
  }
  toJSON() {
    return { type: "all" };
  }
  static fromJSON(doc2) {
    return new AllSelection(doc2);
  }
  map(doc2) {
    return new AllSelection(doc2);
  }
  eq(other) {
    return other instanceof AllSelection;
  }
  getBookmark() {
    return AllBookmark;
  }
}
Selection.jsonID("all", AllSelection);
const AllBookmark = {
  map() {
    return this;
  },
  resolve(doc2) {
    return new AllSelection(doc2);
  }
};
function findSelectionIn(doc2, node2, pos, index2, dir, text2 = false) {
  if (node2.inlineContent)
    return TextSelection.create(doc2, pos);
  for (let i3 = index2 - (dir > 0 ? 0 : 1); dir > 0 ? i3 < node2.childCount : i3 >= 0; i3 += dir) {
    let child = node2.child(i3);
    if (!child.isAtom) {
      let inner = findSelectionIn(doc2, child, pos + dir, dir < 0 ? child.childCount : 0, dir, text2);
      if (inner)
        return inner;
    } else if (!text2 && NodeSelection.isSelectable(child)) {
      return NodeSelection.create(doc2, pos - (dir < 0 ? child.nodeSize : 0));
    }
    pos += child.nodeSize * dir;
  }
  return null;
}
function selectionToInsertionEnd$1(tr, startLen, bias) {
  let last = tr.steps.length - 1;
  if (last < startLen)
    return;
  let step = tr.steps[last];
  if (!(step instanceof ReplaceStep || step instanceof ReplaceAroundStep))
    return;
  let map2 = tr.mapping.maps[last], end2;
  map2.forEach((_from, _to, _newFrom, newTo) => {
    if (end2 == null)
      end2 = newTo;
  });
  tr.setSelection(Selection.near(tr.doc.resolve(end2), bias));
}
const UPDATED_SEL = 1, UPDATED_MARKS = 2, UPDATED_SCROLL = 4;
class Transaction extends Transform {
  constructor(state) {
    super(state.doc);
    this.curSelectionFor = 0;
    this.updated = 0;
    this.meta = /* @__PURE__ */ Object.create(null);
    this.time = Date.now();
    this.curSelection = state.selection;
    this.storedMarks = state.storedMarks;
  }
  get selection() {
    if (this.curSelectionFor < this.steps.length) {
      this.curSelection = this.curSelection.map(this.doc, this.mapping.slice(this.curSelectionFor));
      this.curSelectionFor = this.steps.length;
    }
    return this.curSelection;
  }
  setSelection(selection) {
    if (selection.$from.doc != this.doc)
      throw new RangeError("Selection passed to setSelection must point at the current document");
    this.curSelection = selection;
    this.curSelectionFor = this.steps.length;
    this.updated = (this.updated | UPDATED_SEL) & ~UPDATED_MARKS;
    this.storedMarks = null;
    return this;
  }
  get selectionSet() {
    return (this.updated & UPDATED_SEL) > 0;
  }
  setStoredMarks(marks) {
    this.storedMarks = marks;
    this.updated |= UPDATED_MARKS;
    return this;
  }
  ensureMarks(marks) {
    if (!Mark$1.sameSet(this.storedMarks || this.selection.$from.marks(), marks))
      this.setStoredMarks(marks);
    return this;
  }
  addStoredMark(mark) {
    return this.ensureMarks(mark.addToSet(this.storedMarks || this.selection.$head.marks()));
  }
  removeStoredMark(mark) {
    return this.ensureMarks(mark.removeFromSet(this.storedMarks || this.selection.$head.marks()));
  }
  get storedMarksSet() {
    return (this.updated & UPDATED_MARKS) > 0;
  }
  addStep(step, doc2) {
    super.addStep(step, doc2);
    this.updated = this.updated & ~UPDATED_MARKS;
    this.storedMarks = null;
  }
  setTime(time) {
    this.time = time;
    return this;
  }
  replaceSelection(slice3) {
    this.selection.replace(this, slice3);
    return this;
  }
  replaceSelectionWith(node2, inheritMarks = true) {
    let selection = this.selection;
    if (inheritMarks)
      node2 = node2.mark(this.storedMarks || (selection.empty ? selection.$from.marks() : selection.$from.marksAcross(selection.$to) || Mark$1.none));
    selection.replaceWith(this, node2);
    return this;
  }
  deleteSelection() {
    this.selection.replace(this);
    return this;
  }
  insertText(text2, from3, to) {
    let schema = this.doc.type.schema;
    if (from3 == null) {
      if (!text2)
        return this.deleteSelection();
      return this.replaceSelectionWith(schema.text(text2), true);
    } else {
      if (to == null)
        to = from3;
      to = to == null ? from3 : to;
      if (!text2)
        return this.deleteRange(from3, to);
      let marks = this.storedMarks;
      if (!marks) {
        let $from = this.doc.resolve(from3);
        marks = to == from3 ? $from.marks() : $from.marksAcross(this.doc.resolve(to));
      }
      this.replaceRangeWith(from3, to, schema.text(text2, marks));
      if (!this.selection.empty)
        this.setSelection(Selection.near(this.selection.$to));
      return this;
    }
  }
  setMeta(key, value) {
    this.meta[typeof key == "string" ? key : key.key] = value;
    return this;
  }
  getMeta(key) {
    return this.meta[typeof key == "string" ? key : key.key];
  }
  get isGeneric() {
    for (let _2 in this.meta)
      return false;
    return true;
  }
  scrollIntoView() {
    this.updated |= UPDATED_SCROLL;
    return this;
  }
  get scrolledIntoView() {
    return (this.updated & UPDATED_SCROLL) > 0;
  }
}
function bind(f2, self2) {
  return !self2 || !f2 ? f2 : f2.bind(self2);
}
class FieldDesc {
  constructor(name, desc, self2) {
    this.name = name;
    this.init = bind(desc.init, self2);
    this.apply = bind(desc.apply, self2);
  }
}
const baseFields = [
  new FieldDesc("doc", {
    init(config) {
      return config.doc || config.schema.topNodeType.createAndFill();
    },
    apply(tr) {
      return tr.doc;
    }
  }),
  new FieldDesc("selection", {
    init(config, instance) {
      return config.selection || Selection.atStart(instance.doc);
    },
    apply(tr) {
      return tr.selection;
    }
  }),
  new FieldDesc("storedMarks", {
    init(config) {
      return config.storedMarks || null;
    },
    apply(tr, _marks, _old, state) {
      return state.selection.$cursor ? tr.storedMarks : null;
    }
  }),
  new FieldDesc("scrollToSelection", {
    init() {
      return 0;
    },
    apply(tr, prev2) {
      return tr.scrolledIntoView ? prev2 + 1 : prev2;
    }
  })
];
class Configuration {
  constructor(schema, plugins2) {
    this.schema = schema;
    this.plugins = [];
    this.pluginsByKey = /* @__PURE__ */ Object.create(null);
    this.fields = baseFields.slice();
    if (plugins2)
      plugins2.forEach((plugin) => {
        if (this.pluginsByKey[plugin.key])
          throw new RangeError("Adding different instances of a keyed plugin (" + plugin.key + ")");
        this.plugins.push(plugin);
        this.pluginsByKey[plugin.key] = plugin;
        if (plugin.spec.state)
          this.fields.push(new FieldDesc(plugin.key, plugin.spec.state, plugin));
      });
  }
}
class EditorState {
  constructor(config) {
    this.config = config;
  }
  get schema() {
    return this.config.schema;
  }
  get plugins() {
    return this.config.plugins;
  }
  apply(tr) {
    return this.applyTransaction(tr).state;
  }
  filterTransaction(tr, ignore = -1) {
    for (let i3 = 0; i3 < this.config.plugins.length; i3++)
      if (i3 != ignore) {
        let plugin = this.config.plugins[i3];
        if (plugin.spec.filterTransaction && !plugin.spec.filterTransaction.call(plugin, tr, this))
          return false;
      }
    return true;
  }
  applyTransaction(rootTr) {
    if (!this.filterTransaction(rootTr))
      return { state: this, transactions: [] };
    let trs = [rootTr], newState = this.applyInner(rootTr), seen = null;
    for (; ; ) {
      let haveNew = false;
      for (let i3 = 0; i3 < this.config.plugins.length; i3++) {
        let plugin = this.config.plugins[i3];
        if (plugin.spec.appendTransaction) {
          let n2 = seen ? seen[i3].n : 0, oldState = seen ? seen[i3].state : this;
          let tr = n2 < trs.length && plugin.spec.appendTransaction.call(plugin, n2 ? trs.slice(n2) : trs, oldState, newState);
          if (tr && newState.filterTransaction(tr, i3)) {
            tr.setMeta("appendedTransaction", rootTr);
            if (!seen) {
              seen = [];
              for (let j2 = 0; j2 < this.config.plugins.length; j2++)
                seen.push(j2 < i3 ? { state: newState, n: trs.length } : { state: this, n: 0 });
            }
            trs.push(tr);
            newState = newState.applyInner(tr);
            haveNew = true;
          }
          if (seen)
            seen[i3] = { state: newState, n: trs.length };
        }
      }
      if (!haveNew)
        return { state: newState, transactions: trs };
    }
  }
  applyInner(tr) {
    if (!tr.before.eq(this.doc))
      throw new RangeError("Applying a mismatched transaction");
    let newInstance = new EditorState(this.config), fields = this.config.fields;
    for (let i3 = 0; i3 < fields.length; i3++) {
      let field = fields[i3];
      newInstance[field.name] = field.apply(tr, this[field.name], this, newInstance);
    }
    return newInstance;
  }
  get tr() {
    return new Transaction(this);
  }
  static create(config) {
    let $config = new Configuration(config.doc ? config.doc.type.schema : config.schema, config.plugins);
    let instance = new EditorState($config);
    for (let i3 = 0; i3 < $config.fields.length; i3++)
      instance[$config.fields[i3].name] = $config.fields[i3].init(config, instance);
    return instance;
  }
  reconfigure(config) {
    let $config = new Configuration(this.schema, config.plugins);
    let fields = $config.fields, instance = new EditorState($config);
    for (let i3 = 0; i3 < fields.length; i3++) {
      let name = fields[i3].name;
      instance[name] = this.hasOwnProperty(name) ? this[name] : fields[i3].init(config, instance);
    }
    return instance;
  }
  toJSON(pluginFields) {
    let result = { doc: this.doc.toJSON(), selection: this.selection.toJSON() };
    if (this.storedMarks)
      result.storedMarks = this.storedMarks.map((m4) => m4.toJSON());
    if (pluginFields && typeof pluginFields == "object")
      for (let prop in pluginFields) {
        if (prop == "doc" || prop == "selection")
          throw new RangeError("The JSON fields `doc` and `selection` are reserved");
        let plugin = pluginFields[prop], state = plugin.spec.state;
        if (state && state.toJSON)
          result[prop] = state.toJSON.call(plugin, this[plugin.key]);
      }
    return result;
  }
  static fromJSON(config, json, pluginFields) {
    if (!json)
      throw new RangeError("Invalid input for EditorState.fromJSON");
    if (!config.schema)
      throw new RangeError("Required config field 'schema' missing");
    let $config = new Configuration(config.schema, config.plugins);
    let instance = new EditorState($config);
    $config.fields.forEach((field) => {
      if (field.name == "doc") {
        instance.doc = Node$2.fromJSON(config.schema, json.doc);
      } else if (field.name == "selection") {
        instance.selection = Selection.fromJSON(instance.doc, json.selection);
      } else if (field.name == "storedMarks") {
        if (json.storedMarks)
          instance.storedMarks = json.storedMarks.map(config.schema.markFromJSON);
      } else {
        if (pluginFields)
          for (let prop in pluginFields) {
            let plugin = pluginFields[prop], state = plugin.spec.state;
            if (plugin.key == field.name && state && state.fromJSON && Object.prototype.hasOwnProperty.call(json, prop)) {
              instance[field.name] = state.fromJSON.call(plugin, config, json[prop], instance);
              return;
            }
          }
        instance[field.name] = field.init(config, instance);
      }
    });
    return instance;
  }
}
function bindProps(obj, self2, target) {
  for (let prop in obj) {
    let val = obj[prop];
    if (val instanceof Function)
      val = val.bind(self2);
    else if (prop == "handleDOMEvents")
      val = bindProps(val, self2, {});
    target[prop] = val;
  }
  return target;
}
class Plugin {
  constructor(spec) {
    this.spec = spec;
    this.props = {};
    if (spec.props)
      bindProps(spec.props, this, this.props);
    this.key = spec.key ? spec.key.key : createKey("plugin");
  }
  getState(state) {
    return state[this.key];
  }
}
const keys = /* @__PURE__ */ Object.create(null);
function createKey(name) {
  if (name in keys)
    return name + "$" + ++keys[name];
  keys[name] = 0;
  return name + "$";
}
class PluginKey {
  constructor(name = "key") {
    this.key = createKey(name);
  }
  get(state) {
    return state.config.pluginsByKey[this.key];
  }
  getState(state) {
    return state[this.key];
  }
}
const domIndex = function(node2) {
  for (var index2 = 0; ; index2++) {
    node2 = node2.previousSibling;
    if (!node2)
      return index2;
  }
};
const parentNode = function(node2) {
  let parent = node2.assignedSlot || node2.parentNode;
  return parent && parent.nodeType == 11 ? parent.host : parent;
};
let reusedRange = null;
const textRange = function(node2, from3, to) {
  let range2 = reusedRange || (reusedRange = document.createRange());
  range2.setEnd(node2, to == null ? node2.nodeValue.length : to);
  range2.setStart(node2, from3 || 0);
  return range2;
};
const isEquivalentPosition = function(node2, off2, targetNode, targetOff) {
  return targetNode && (scanFor(node2, off2, targetNode, targetOff, -1) || scanFor(node2, off2, targetNode, targetOff, 1));
};
const atomElements = /^(img|br|input|textarea|hr)$/i;
function scanFor(node2, off2, targetNode, targetOff, dir) {
  for (; ; ) {
    if (node2 == targetNode && off2 == targetOff)
      return true;
    if (off2 == (dir < 0 ? 0 : nodeSize(node2))) {
      let parent = node2.parentNode;
      if (!parent || parent.nodeType != 1 || hasBlockDesc(node2) || atomElements.test(node2.nodeName) || node2.contentEditable == "false")
        return false;
      off2 = domIndex(node2) + (dir < 0 ? 0 : 1);
      node2 = parent;
    } else if (node2.nodeType == 1) {
      node2 = node2.childNodes[off2 + (dir < 0 ? -1 : 0)];
      if (node2.contentEditable == "false")
        return false;
      off2 = dir < 0 ? nodeSize(node2) : 0;
    } else {
      return false;
    }
  }
}
function nodeSize(node2) {
  return node2.nodeType == 3 ? node2.nodeValue.length : node2.childNodes.length;
}
function isOnEdge(node2, offset2, parent) {
  for (let atStart = offset2 == 0, atEnd = offset2 == nodeSize(node2); atStart || atEnd; ) {
    if (node2 == parent)
      return true;
    let index2 = domIndex(node2);
    node2 = node2.parentNode;
    if (!node2)
      return false;
    atStart = atStart && index2 == 0;
    atEnd = atEnd && index2 == nodeSize(node2);
  }
}
function hasBlockDesc(dom) {
  let desc;
  for (let cur = dom; cur; cur = cur.parentNode)
    if (desc = cur.pmViewDesc)
      break;
  return desc && desc.node && desc.node.isBlock && (desc.dom == dom || desc.contentDOM == dom);
}
const selectionCollapsed = function(domSel) {
  return domSel.focusNode && isEquivalentPosition(domSel.focusNode, domSel.focusOffset, domSel.anchorNode, domSel.anchorOffset);
};
function keyEvent(keyCode, key) {
  let event = document.createEvent("Event");
  event.initEvent("keydown", true, true);
  event.keyCode = keyCode;
  event.key = event.code = key;
  return event;
}
function deepActiveElement(doc2) {
  let elt = doc2.activeElement;
  while (elt && elt.shadowRoot)
    elt = elt.shadowRoot.activeElement;
  return elt;
}
const nav = typeof navigator != "undefined" ? navigator : null;
const doc = typeof document != "undefined" ? document : null;
const agent = nav && nav.userAgent || "";
const ie_edge = /Edge\/(\d+)/.exec(agent);
const ie_upto10 = /MSIE \d/.exec(agent);
const ie_11up = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(agent);
const ie$1 = !!(ie_upto10 || ie_11up || ie_edge);
const ie_version = ie_upto10 ? document.documentMode : ie_11up ? +ie_11up[1] : ie_edge ? +ie_edge[1] : 0;
const gecko = !ie$1 && /gecko\/(\d+)/i.test(agent);
gecko && +(/Firefox\/(\d+)/.exec(agent) || [0, 0])[1];
const _chrome = !ie$1 && /Chrome\/(\d+)/.exec(agent);
const chrome$1 = !!_chrome;
const chrome_version = _chrome ? +_chrome[1] : 0;
const safari = !ie$1 && !!nav && /Apple Computer/.test(nav.vendor);
const ios = safari && (/Mobile\/\w+/.test(agent) || !!nav && nav.maxTouchPoints > 2);
const mac$2 = ios || (nav ? /Mac/.test(nav.platform) : false);
const android = /Android \d/.test(agent);
const webkit = !!doc && "webkitFontSmoothing" in doc.documentElement.style;
const webkit_version = webkit ? +(/\bAppleWebKit\/(\d+)/.exec(navigator.userAgent) || [0, 0])[1] : 0;
function windowRect(doc2) {
  return {
    left: 0,
    right: doc2.documentElement.clientWidth,
    top: 0,
    bottom: doc2.documentElement.clientHeight
  };
}
function getSide(value, side) {
  return typeof value == "number" ? value : value[side];
}
function clientRect(node2) {
  let rect = node2.getBoundingClientRect();
  let scaleX2 = rect.width / node2.offsetWidth || 1;
  let scaleY2 = rect.height / node2.offsetHeight || 1;
  return {
    left: rect.left,
    right: rect.left + node2.clientWidth * scaleX2,
    top: rect.top,
    bottom: rect.top + node2.clientHeight * scaleY2
  };
}
function scrollRectIntoView(view, rect, startDOM) {
  let scrollThreshold = view.someProp("scrollThreshold") || 0, scrollMargin = view.someProp("scrollMargin") || 5;
  let doc2 = view.dom.ownerDocument;
  for (let parent = startDOM || view.dom; ; parent = parentNode(parent)) {
    if (!parent)
      break;
    if (parent.nodeType != 1)
      continue;
    let elt = parent;
    let atTop = elt == doc2.body;
    let bounding = atTop ? windowRect(doc2) : clientRect(elt);
    let moveX = 0, moveY = 0;
    if (rect.top < bounding.top + getSide(scrollThreshold, "top"))
      moveY = -(bounding.top - rect.top + getSide(scrollMargin, "top"));
    else if (rect.bottom > bounding.bottom - getSide(scrollThreshold, "bottom"))
      moveY = rect.bottom - bounding.bottom + getSide(scrollMargin, "bottom");
    if (rect.left < bounding.left + getSide(scrollThreshold, "left"))
      moveX = -(bounding.left - rect.left + getSide(scrollMargin, "left"));
    else if (rect.right > bounding.right - getSide(scrollThreshold, "right"))
      moveX = rect.right - bounding.right + getSide(scrollMargin, "right");
    if (moveX || moveY) {
      if (atTop) {
        doc2.defaultView.scrollBy(moveX, moveY);
      } else {
        let startX = elt.scrollLeft, startY = elt.scrollTop;
        if (moveY)
          elt.scrollTop += moveY;
        if (moveX)
          elt.scrollLeft += moveX;
        let dX = elt.scrollLeft - startX, dY = elt.scrollTop - startY;
        rect = { left: rect.left - dX, top: rect.top - dY, right: rect.right - dX, bottom: rect.bottom - dY };
      }
    }
    if (atTop)
      break;
  }
}
function storeScrollPos(view) {
  let rect = view.dom.getBoundingClientRect(), startY = Math.max(0, rect.top);
  let refDOM, refTop;
  for (let x3 = (rect.left + rect.right) / 2, y4 = startY + 1; y4 < Math.min(innerHeight, rect.bottom); y4 += 5) {
    let dom = view.root.elementFromPoint(x3, y4);
    if (!dom || dom == view.dom || !view.dom.contains(dom))
      continue;
    let localRect = dom.getBoundingClientRect();
    if (localRect.top >= startY - 20) {
      refDOM = dom;
      refTop = localRect.top;
      break;
    }
  }
  return { refDOM, refTop, stack: scrollStack(view.dom) };
}
function scrollStack(dom) {
  let stack = [], doc2 = dom.ownerDocument;
  for (let cur = dom; cur; cur = parentNode(cur)) {
    stack.push({ dom: cur, top: cur.scrollTop, left: cur.scrollLeft });
    if (dom == doc2)
      break;
  }
  return stack;
}
function resetScrollPos({ refDOM, refTop, stack }) {
  let newRefTop = refDOM ? refDOM.getBoundingClientRect().top : 0;
  restoreScrollStack(stack, newRefTop == 0 ? 0 : newRefTop - refTop);
}
function restoreScrollStack(stack, dTop) {
  for (let i3 = 0; i3 < stack.length; i3++) {
    let { dom, top: top2, left: left2 } = stack[i3];
    if (dom.scrollTop != top2 + dTop)
      dom.scrollTop = top2 + dTop;
    if (dom.scrollLeft != left2)
      dom.scrollLeft = left2;
  }
}
let preventScrollSupported = null;
function focusPreventScroll(dom) {
  if (dom.setActive)
    return dom.setActive();
  if (preventScrollSupported)
    return dom.focus(preventScrollSupported);
  let stored = scrollStack(dom);
  dom.focus(preventScrollSupported == null ? {
    get preventScroll() {
      preventScrollSupported = { preventScroll: true };
      return true;
    }
  } : void 0);
  if (!preventScrollSupported) {
    preventScrollSupported = false;
    restoreScrollStack(stored, 0);
  }
}
function findOffsetInNode(node2, coords) {
  let closest2, dxClosest = 2e8, coordsClosest, offset2 = 0;
  let rowBot = coords.top, rowTop = coords.top;
  for (let child = node2.firstChild, childIndex = 0; child; child = child.nextSibling, childIndex++) {
    let rects;
    if (child.nodeType == 1)
      rects = child.getClientRects();
    else if (child.nodeType == 3)
      rects = textRange(child).getClientRects();
    else
      continue;
    for (let i3 = 0; i3 < rects.length; i3++) {
      let rect = rects[i3];
      if (rect.top <= rowBot && rect.bottom >= rowTop) {
        rowBot = Math.max(rect.bottom, rowBot);
        rowTop = Math.min(rect.top, rowTop);
        let dx = rect.left > coords.left ? rect.left - coords.left : rect.right < coords.left ? coords.left - rect.right : 0;
        if (dx < dxClosest) {
          closest2 = child;
          dxClosest = dx;
          coordsClosest = dx && closest2.nodeType == 3 ? {
            left: rect.right < coords.left ? rect.right : rect.left,
            top: coords.top
          } : coords;
          if (child.nodeType == 1 && dx)
            offset2 = childIndex + (coords.left >= (rect.left + rect.right) / 2 ? 1 : 0);
          continue;
        }
      }
      if (!closest2 && (coords.left >= rect.right && coords.top >= rect.top || coords.left >= rect.left && coords.top >= rect.bottom))
        offset2 = childIndex + 1;
    }
  }
  if (closest2 && closest2.nodeType == 3)
    return findOffsetInText(closest2, coordsClosest);
  if (!closest2 || dxClosest && closest2.nodeType == 1)
    return { node: node2, offset: offset2 };
  return findOffsetInNode(closest2, coordsClosest);
}
function findOffsetInText(node2, coords) {
  let len = node2.nodeValue.length;
  let range2 = document.createRange();
  for (let i3 = 0; i3 < len; i3++) {
    range2.setEnd(node2, i3 + 1);
    range2.setStart(node2, i3);
    let rect = singleRect(range2, 1);
    if (rect.top == rect.bottom)
      continue;
    if (inRect(coords, rect))
      return { node: node2, offset: i3 + (coords.left >= (rect.left + rect.right) / 2 ? 1 : 0) };
  }
  return { node: node2, offset: 0 };
}
function inRect(coords, rect) {
  return coords.left >= rect.left - 1 && coords.left <= rect.right + 1 && coords.top >= rect.top - 1 && coords.top <= rect.bottom + 1;
}
function targetKludge(dom, coords) {
  let parent = dom.parentNode;
  if (parent && /^li$/i.test(parent.nodeName) && coords.left < dom.getBoundingClientRect().left)
    return parent;
  return dom;
}
function posFromElement(view, elt, coords) {
  let { node: node2, offset: offset2 } = findOffsetInNode(elt, coords), bias = -1;
  if (node2.nodeType == 1 && !node2.firstChild) {
    let rect = node2.getBoundingClientRect();
    bias = rect.left != rect.right && coords.left > (rect.left + rect.right) / 2 ? 1 : -1;
  }
  return view.docView.posFromDOM(node2, offset2, bias);
}
function posFromCaret(view, node2, offset2, coords) {
  let outsideBlock = -1;
  for (let cur = node2; ; ) {
    if (cur == view.dom)
      break;
    let desc = view.docView.nearestDesc(cur, true);
    if (!desc)
      return null;
    if (desc.dom.nodeType == 1 && (desc.node.isBlock && desc.parent || !desc.contentDOM)) {
      let rect = desc.dom.getBoundingClientRect();
      if (desc.node.isBlock && desc.parent) {
        if (rect.left > coords.left || rect.top > coords.top)
          outsideBlock = desc.posBefore;
        else if (rect.right < coords.left || rect.bottom < coords.top)
          outsideBlock = desc.posAfter;
      }
      if (!desc.contentDOM && outsideBlock < 0) {
        let before = desc.node.isBlock ? coords.top < (rect.top + rect.bottom) / 2 : coords.left < (rect.left + rect.right) / 2;
        return before ? desc.posBefore : desc.posAfter;
      }
    }
    cur = desc.dom.parentNode;
  }
  return outsideBlock > -1 ? outsideBlock : view.docView.posFromDOM(node2, offset2, -1);
}
function elementFromPoint(element, coords, box) {
  let len = element.childNodes.length;
  if (len && box.top < box.bottom) {
    for (let startI = Math.max(0, Math.min(len - 1, Math.floor(len * (coords.top - box.top) / (box.bottom - box.top)) - 2)), i3 = startI; ; ) {
      let child = element.childNodes[i3];
      if (child.nodeType == 1) {
        let rects = child.getClientRects();
        for (let j2 = 0; j2 < rects.length; j2++) {
          let rect = rects[j2];
          if (inRect(coords, rect))
            return elementFromPoint(child, coords, rect);
        }
      }
      if ((i3 = (i3 + 1) % len) == startI)
        break;
    }
  }
  return element;
}
function posAtCoords(view, coords) {
  let doc2 = view.dom.ownerDocument, node2, offset2 = 0;
  if (doc2.caretPositionFromPoint) {
    try {
      let pos2 = doc2.caretPositionFromPoint(coords.left, coords.top);
      if (pos2)
        ({ offsetNode: node2, offset: offset2 } = pos2);
    } catch (_2) {
    }
  }
  if (!node2 && doc2.caretRangeFromPoint) {
    let range2 = doc2.caretRangeFromPoint(coords.left, coords.top);
    if (range2)
      ({ startContainer: node2, startOffset: offset2 } = range2);
  }
  let elt = (view.root.elementFromPoint ? view.root : doc2).elementFromPoint(coords.left, coords.top);
  let pos;
  if (!elt || !view.dom.contains(elt.nodeType != 1 ? elt.parentNode : elt)) {
    let box = view.dom.getBoundingClientRect();
    if (!inRect(coords, box))
      return null;
    elt = elementFromPoint(view.dom, coords, box);
    if (!elt)
      return null;
  }
  if (safari) {
    for (let p2 = elt; node2 && p2; p2 = parentNode(p2))
      if (p2.draggable)
        node2 = void 0;
  }
  elt = targetKludge(elt, coords);
  if (node2) {
    if (gecko && node2.nodeType == 1) {
      offset2 = Math.min(offset2, node2.childNodes.length);
      if (offset2 < node2.childNodes.length) {
        let next2 = node2.childNodes[offset2], box;
        if (next2.nodeName == "IMG" && (box = next2.getBoundingClientRect()).right <= coords.left && box.bottom > coords.top)
          offset2++;
      }
    }
    if (node2 == view.dom && offset2 == node2.childNodes.length - 1 && node2.lastChild.nodeType == 1 && coords.top > node2.lastChild.getBoundingClientRect().bottom)
      pos = view.state.doc.content.size;
    else if (offset2 == 0 || node2.nodeType != 1 || node2.childNodes[offset2 - 1].nodeName != "BR")
      pos = posFromCaret(view, node2, offset2, coords);
  }
  if (pos == null)
    pos = posFromElement(view, elt, coords);
  let desc = view.docView.nearestDesc(elt, true);
  return { pos, inside: desc ? desc.posAtStart - desc.border : -1 };
}
function singleRect(target, bias) {
  let rects = target.getClientRects();
  return !rects.length ? target.getBoundingClientRect() : rects[bias < 0 ? 0 : rects.length - 1];
}
const BIDI = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;
function coordsAtPos(view, pos, side) {
  let { node: node2, offset: offset2, atom } = view.docView.domFromPos(pos, side < 0 ? -1 : 1);
  let supportEmptyRange = webkit || gecko;
  if (node2.nodeType == 3) {
    if (supportEmptyRange && (BIDI.test(node2.nodeValue) || (side < 0 ? !offset2 : offset2 == node2.nodeValue.length))) {
      let rect = singleRect(textRange(node2, offset2, offset2), side);
      if (gecko && offset2 && /\s/.test(node2.nodeValue[offset2 - 1]) && offset2 < node2.nodeValue.length) {
        let rectBefore = singleRect(textRange(node2, offset2 - 1, offset2 - 1), -1);
        if (rectBefore.top == rect.top) {
          let rectAfter = singleRect(textRange(node2, offset2, offset2 + 1), -1);
          if (rectAfter.top != rect.top)
            return flattenV(rectAfter, rectAfter.left < rectBefore.left);
        }
      }
      return rect;
    } else {
      let from3 = offset2, to = offset2, takeSide = side < 0 ? 1 : -1;
      if (side < 0 && !offset2) {
        to++;
        takeSide = -1;
      } else if (side >= 0 && offset2 == node2.nodeValue.length) {
        from3--;
        takeSide = 1;
      } else if (side < 0) {
        from3--;
      } else {
        to++;
      }
      return flattenV(singleRect(textRange(node2, from3, to), 1), takeSide < 0);
    }
  }
  let $dom = view.state.doc.resolve(pos - (atom || 0));
  if (!$dom.parent.inlineContent) {
    if (atom == null && offset2 && (side < 0 || offset2 == nodeSize(node2))) {
      let before = node2.childNodes[offset2 - 1];
      if (before.nodeType == 1)
        return flattenH(before.getBoundingClientRect(), false);
    }
    if (atom == null && offset2 < nodeSize(node2)) {
      let after = node2.childNodes[offset2];
      if (after.nodeType == 1)
        return flattenH(after.getBoundingClientRect(), true);
    }
    return flattenH(node2.getBoundingClientRect(), side >= 0);
  }
  if (atom == null && offset2 && (side < 0 || offset2 == nodeSize(node2))) {
    let before = node2.childNodes[offset2 - 1];
    let target = before.nodeType == 3 ? textRange(before, nodeSize(before) - (supportEmptyRange ? 0 : 1)) : before.nodeType == 1 && (before.nodeName != "BR" || !before.nextSibling) ? before : null;
    if (target)
      return flattenV(singleRect(target, 1), false);
  }
  if (atom == null && offset2 < nodeSize(node2)) {
    let after = node2.childNodes[offset2];
    while (after.pmViewDesc && after.pmViewDesc.ignoreForCoords)
      after = after.nextSibling;
    let target = !after ? null : after.nodeType == 3 ? textRange(after, 0, supportEmptyRange ? 0 : 1) : after.nodeType == 1 ? after : null;
    if (target)
      return flattenV(singleRect(target, -1), true);
  }
  return flattenV(singleRect(node2.nodeType == 3 ? textRange(node2) : node2, -side), side >= 0);
}
function flattenV(rect, left2) {
  if (rect.width == 0)
    return rect;
  let x3 = left2 ? rect.left : rect.right;
  return { top: rect.top, bottom: rect.bottom, left: x3, right: x3 };
}
function flattenH(rect, top2) {
  if (rect.height == 0)
    return rect;
  let y4 = top2 ? rect.top : rect.bottom;
  return { top: y4, bottom: y4, left: rect.left, right: rect.right };
}
function withFlushedState(view, state, f2) {
  let viewState = view.state, active = view.root.activeElement;
  if (viewState != state)
    view.updateState(state);
  if (active != view.dom)
    view.focus();
  try {
    return f2();
  } finally {
    if (viewState != state)
      view.updateState(viewState);
    if (active != view.dom && active)
      active.focus();
  }
}
function endOfTextblockVertical(view, state, dir) {
  let sel = state.selection;
  let $pos = dir == "up" ? sel.$from : sel.$to;
  return withFlushedState(view, state, () => {
    let { node: dom } = view.docView.domFromPos($pos.pos, dir == "up" ? -1 : 1);
    for (; ; ) {
      let nearest = view.docView.nearestDesc(dom, true);
      if (!nearest)
        break;
      if (nearest.node.isBlock) {
        dom = nearest.contentDOM || nearest.dom;
        break;
      }
      dom = nearest.dom.parentNode;
    }
    let coords = coordsAtPos(view, $pos.pos, 1);
    for (let child = dom.firstChild; child; child = child.nextSibling) {
      let boxes;
      if (child.nodeType == 1)
        boxes = child.getClientRects();
      else if (child.nodeType == 3)
        boxes = textRange(child, 0, child.nodeValue.length).getClientRects();
      else
        continue;
      for (let i3 = 0; i3 < boxes.length; i3++) {
        let box = boxes[i3];
        if (box.bottom > box.top + 1 && (dir == "up" ? coords.top - box.top > (box.bottom - coords.top) * 2 : box.bottom - coords.bottom > (coords.bottom - box.top) * 2))
          return false;
      }
    }
    return true;
  });
}
const maybeRTL = /[\u0590-\u08ac]/;
function endOfTextblockHorizontal(view, state, dir) {
  let { $head } = state.selection;
  if (!$head.parent.isTextblock)
    return false;
  let offset2 = $head.parentOffset, atStart = !offset2, atEnd = offset2 == $head.parent.content.size;
  let sel = view.domSelection();
  if (!maybeRTL.test($head.parent.textContent) || !sel.modify)
    return dir == "left" || dir == "backward" ? atStart : atEnd;
  return withFlushedState(view, state, () => {
    let { focusNode: oldNode, focusOffset: oldOff, anchorNode, anchorOffset } = view.domSelectionRange();
    let oldBidiLevel = sel.caretBidiLevel;
    sel.modify("move", dir, "character");
    let parentDOM = $head.depth ? view.docView.domAfterPos($head.before()) : view.dom;
    let { focusNode: newNode, focusOffset: newOff } = view.domSelectionRange();
    let result = newNode && !parentDOM.contains(newNode.nodeType == 1 ? newNode : newNode.parentNode) || oldNode == newNode && oldOff == newOff;
    try {
      sel.collapse(anchorNode, anchorOffset);
      if (oldNode && (oldNode != anchorNode || oldOff != anchorOffset) && sel.extend)
        sel.extend(oldNode, oldOff);
    } catch (_2) {
    }
    if (oldBidiLevel != null)
      sel.caretBidiLevel = oldBidiLevel;
    return result;
  });
}
let cachedState = null;
let cachedDir = null;
let cachedResult = false;
function endOfTextblock(view, state, dir) {
  if (cachedState == state && cachedDir == dir)
    return cachedResult;
  cachedState = state;
  cachedDir = dir;
  return cachedResult = dir == "up" || dir == "down" ? endOfTextblockVertical(view, state, dir) : endOfTextblockHorizontal(view, state, dir);
}
const NOT_DIRTY = 0, CHILD_DIRTY = 1, CONTENT_DIRTY = 2, NODE_DIRTY = 3;
class ViewDesc {
  constructor(parent, children, dom, contentDOM) {
    this.parent = parent;
    this.children = children;
    this.dom = dom;
    this.contentDOM = contentDOM;
    this.dirty = NOT_DIRTY;
    dom.pmViewDesc = this;
  }
  matchesWidget(widget) {
    return false;
  }
  matchesMark(mark) {
    return false;
  }
  matchesNode(node2, outerDeco, innerDeco) {
    return false;
  }
  matchesHack(nodeName) {
    return false;
  }
  parseRule() {
    return null;
  }
  stopEvent(event) {
    return false;
  }
  get size() {
    let size = 0;
    for (let i3 = 0; i3 < this.children.length; i3++)
      size += this.children[i3].size;
    return size;
  }
  get border() {
    return 0;
  }
  destroy() {
    this.parent = void 0;
    if (this.dom.pmViewDesc == this)
      this.dom.pmViewDesc = void 0;
    for (let i3 = 0; i3 < this.children.length; i3++)
      this.children[i3].destroy();
  }
  posBeforeChild(child) {
    for (let i3 = 0, pos = this.posAtStart; ; i3++) {
      let cur = this.children[i3];
      if (cur == child)
        return pos;
      pos += cur.size;
    }
  }
  get posBefore() {
    return this.parent.posBeforeChild(this);
  }
  get posAtStart() {
    return this.parent ? this.parent.posBeforeChild(this) + this.border : 0;
  }
  get posAfter() {
    return this.posBefore + this.size;
  }
  get posAtEnd() {
    return this.posAtStart + this.size - 2 * this.border;
  }
  localPosFromDOM(dom, offset2, bias) {
    if (this.contentDOM && this.contentDOM.contains(dom.nodeType == 1 ? dom : dom.parentNode)) {
      if (bias < 0) {
        let domBefore, desc;
        if (dom == this.contentDOM) {
          domBefore = dom.childNodes[offset2 - 1];
        } else {
          while (dom.parentNode != this.contentDOM)
            dom = dom.parentNode;
          domBefore = dom.previousSibling;
        }
        while (domBefore && !((desc = domBefore.pmViewDesc) && desc.parent == this))
          domBefore = domBefore.previousSibling;
        return domBefore ? this.posBeforeChild(desc) + desc.size : this.posAtStart;
      } else {
        let domAfter, desc;
        if (dom == this.contentDOM) {
          domAfter = dom.childNodes[offset2];
        } else {
          while (dom.parentNode != this.contentDOM)
            dom = dom.parentNode;
          domAfter = dom.nextSibling;
        }
        while (domAfter && !((desc = domAfter.pmViewDesc) && desc.parent == this))
          domAfter = domAfter.nextSibling;
        return domAfter ? this.posBeforeChild(desc) : this.posAtEnd;
      }
    }
    let atEnd;
    if (dom == this.dom && this.contentDOM) {
      atEnd = offset2 > domIndex(this.contentDOM);
    } else if (this.contentDOM && this.contentDOM != this.dom && this.dom.contains(this.contentDOM)) {
      atEnd = dom.compareDocumentPosition(this.contentDOM) & 2;
    } else if (this.dom.firstChild) {
      if (offset2 == 0)
        for (let search = dom; ; search = search.parentNode) {
          if (search == this.dom) {
            atEnd = false;
            break;
          }
          if (search.previousSibling)
            break;
        }
      if (atEnd == null && offset2 == dom.childNodes.length)
        for (let search = dom; ; search = search.parentNode) {
          if (search == this.dom) {
            atEnd = true;
            break;
          }
          if (search.nextSibling)
            break;
        }
    }
    return (atEnd == null ? bias > 0 : atEnd) ? this.posAtEnd : this.posAtStart;
  }
  nearestDesc(dom, onlyNodes = false) {
    for (let first2 = true, cur = dom; cur; cur = cur.parentNode) {
      let desc = this.getDesc(cur), nodeDOM;
      if (desc && (!onlyNodes || desc.node)) {
        if (first2 && (nodeDOM = desc.nodeDOM) && !(nodeDOM.nodeType == 1 ? nodeDOM.contains(dom.nodeType == 1 ? dom : dom.parentNode) : nodeDOM == dom))
          first2 = false;
        else
          return desc;
      }
    }
  }
  getDesc(dom) {
    let desc = dom.pmViewDesc;
    for (let cur = desc; cur; cur = cur.parent)
      if (cur == this)
        return desc;
  }
  posFromDOM(dom, offset2, bias) {
    for (let scan = dom; scan; scan = scan.parentNode) {
      let desc = this.getDesc(scan);
      if (desc)
        return desc.localPosFromDOM(dom, offset2, bias);
    }
    return -1;
  }
  descAt(pos) {
    for (let i3 = 0, offset2 = 0; i3 < this.children.length; i3++) {
      let child = this.children[i3], end2 = offset2 + child.size;
      if (offset2 == pos && end2 != offset2) {
        while (!child.border && child.children.length)
          child = child.children[0];
        return child;
      }
      if (pos < end2)
        return child.descAt(pos - offset2 - child.border);
      offset2 = end2;
    }
  }
  domFromPos(pos, side) {
    if (!this.contentDOM)
      return { node: this.dom, offset: 0, atom: pos + 1 };
    let i3 = 0, offset2 = 0;
    for (let curPos = 0; i3 < this.children.length; i3++) {
      let child = this.children[i3], end2 = curPos + child.size;
      if (end2 > pos || child instanceof TrailingHackViewDesc) {
        offset2 = pos - curPos;
        break;
      }
      curPos = end2;
    }
    if (offset2)
      return this.children[i3].domFromPos(offset2 - this.children[i3].border, side);
    for (let prev2; i3 && !(prev2 = this.children[i3 - 1]).size && prev2 instanceof WidgetViewDesc && prev2.side >= 0; i3--) {
    }
    if (side <= 0) {
      let prev2, enter2 = true;
      for (; ; i3--, enter2 = false) {
        prev2 = i3 ? this.children[i3 - 1] : null;
        if (!prev2 || prev2.dom.parentNode == this.contentDOM)
          break;
      }
      if (prev2 && side && enter2 && !prev2.border && !prev2.domAtom)
        return prev2.domFromPos(prev2.size, side);
      return { node: this.contentDOM, offset: prev2 ? domIndex(prev2.dom) + 1 : 0 };
    } else {
      let next2, enter2 = true;
      for (; ; i3++, enter2 = false) {
        next2 = i3 < this.children.length ? this.children[i3] : null;
        if (!next2 || next2.dom.parentNode == this.contentDOM)
          break;
      }
      if (next2 && enter2 && !next2.border && !next2.domAtom)
        return next2.domFromPos(0, side);
      return { node: this.contentDOM, offset: next2 ? domIndex(next2.dom) : this.contentDOM.childNodes.length };
    }
  }
  parseRange(from3, to, base2 = 0) {
    if (this.children.length == 0)
      return { node: this.contentDOM, from: from3, to, fromOffset: 0, toOffset: this.contentDOM.childNodes.length };
    let fromOffset = -1, toOffset = -1;
    for (let offset2 = base2, i3 = 0; ; i3++) {
      let child = this.children[i3], end2 = offset2 + child.size;
      if (fromOffset == -1 && from3 <= end2) {
        let childBase = offset2 + child.border;
        if (from3 >= childBase && to <= end2 - child.border && child.node && child.contentDOM && this.contentDOM.contains(child.contentDOM))
          return child.parseRange(from3, to, childBase);
        from3 = offset2;
        for (let j2 = i3; j2 > 0; j2--) {
          let prev2 = this.children[j2 - 1];
          if (prev2.size && prev2.dom.parentNode == this.contentDOM && !prev2.emptyChildAt(1)) {
            fromOffset = domIndex(prev2.dom) + 1;
            break;
          }
          from3 -= prev2.size;
        }
        if (fromOffset == -1)
          fromOffset = 0;
      }
      if (fromOffset > -1 && (end2 > to || i3 == this.children.length - 1)) {
        to = end2;
        for (let j2 = i3 + 1; j2 < this.children.length; j2++) {
          let next2 = this.children[j2];
          if (next2.size && next2.dom.parentNode == this.contentDOM && !next2.emptyChildAt(-1)) {
            toOffset = domIndex(next2.dom);
            break;
          }
          to += next2.size;
        }
        if (toOffset == -1)
          toOffset = this.contentDOM.childNodes.length;
        break;
      }
      offset2 = end2;
    }
    return { node: this.contentDOM, from: from3, to, fromOffset, toOffset };
  }
  emptyChildAt(side) {
    if (this.border || !this.contentDOM || !this.children.length)
      return false;
    let child = this.children[side < 0 ? 0 : this.children.length - 1];
    return child.size == 0 || child.emptyChildAt(side);
  }
  domAfterPos(pos) {
    let { node: node2, offset: offset2 } = this.domFromPos(pos, 0);
    if (node2.nodeType != 1 || offset2 == node2.childNodes.length)
      throw new RangeError("No node after pos " + pos);
    return node2.childNodes[offset2];
  }
  setSelection(anchor, head, root2, force = false) {
    let from3 = Math.min(anchor, head), to = Math.max(anchor, head);
    for (let i3 = 0, offset2 = 0; i3 < this.children.length; i3++) {
      let child = this.children[i3], end2 = offset2 + child.size;
      if (from3 > offset2 && to < end2)
        return child.setSelection(anchor - offset2 - child.border, head - offset2 - child.border, root2, force);
      offset2 = end2;
    }
    let anchorDOM = this.domFromPos(anchor, anchor ? -1 : 1);
    let headDOM = head == anchor ? anchorDOM : this.domFromPos(head, head ? -1 : 1);
    let domSel = root2.getSelection();
    let brKludge = false;
    if ((gecko || safari) && anchor == head) {
      let { node: node2, offset: offset2 } = anchorDOM;
      if (node2.nodeType == 3) {
        brKludge = !!(offset2 && node2.nodeValue[offset2 - 1] == "\n");
        if (brKludge && offset2 == node2.nodeValue.length) {
          for (let scan = node2, after; scan; scan = scan.parentNode) {
            if (after = scan.nextSibling) {
              if (after.nodeName == "BR")
                anchorDOM = headDOM = { node: after.parentNode, offset: domIndex(after) + 1 };
              break;
            }
            let desc = scan.pmViewDesc;
            if (desc && desc.node && desc.node.isBlock)
              break;
          }
        }
      } else {
        let prev2 = node2.childNodes[offset2 - 1];
        brKludge = prev2 && (prev2.nodeName == "BR" || prev2.contentEditable == "false");
      }
    }
    if (gecko && domSel.focusNode && domSel.focusNode != headDOM.node && domSel.focusNode.nodeType == 1) {
      let after = domSel.focusNode.childNodes[domSel.focusOffset];
      if (after && after.contentEditable == "false")
        force = true;
    }
    if (!(force || brKludge && safari) && isEquivalentPosition(anchorDOM.node, anchorDOM.offset, domSel.anchorNode, domSel.anchorOffset) && isEquivalentPosition(headDOM.node, headDOM.offset, domSel.focusNode, domSel.focusOffset))
      return;
    let domSelExtended = false;
    if ((domSel.extend || anchor == head) && !brKludge) {
      domSel.collapse(anchorDOM.node, anchorDOM.offset);
      try {
        if (anchor != head)
          domSel.extend(headDOM.node, headDOM.offset);
        domSelExtended = true;
      } catch (_2) {
      }
    }
    if (!domSelExtended) {
      if (anchor > head) {
        let tmp = anchorDOM;
        anchorDOM = headDOM;
        headDOM = tmp;
      }
      let range2 = document.createRange();
      range2.setEnd(headDOM.node, headDOM.offset);
      range2.setStart(anchorDOM.node, anchorDOM.offset);
      domSel.removeAllRanges();
      domSel.addRange(range2);
    }
  }
  ignoreMutation(mutation) {
    return !this.contentDOM && mutation.type != "selection";
  }
  get contentLost() {
    return this.contentDOM && this.contentDOM != this.dom && !this.dom.contains(this.contentDOM);
  }
  markDirty(from3, to) {
    for (let offset2 = 0, i3 = 0; i3 < this.children.length; i3++) {
      let child = this.children[i3], end2 = offset2 + child.size;
      if (offset2 == end2 ? from3 <= end2 && to >= offset2 : from3 < end2 && to > offset2) {
        let startInside = offset2 + child.border, endInside = end2 - child.border;
        if (from3 >= startInside && to <= endInside) {
          this.dirty = from3 == offset2 || to == end2 ? CONTENT_DIRTY : CHILD_DIRTY;
          if (from3 == startInside && to == endInside && (child.contentLost || child.dom.parentNode != this.contentDOM))
            child.dirty = NODE_DIRTY;
          else
            child.markDirty(from3 - startInside, to - startInside);
          return;
        } else {
          child.dirty = child.dom == child.contentDOM && child.dom.parentNode == this.contentDOM && !child.children.length ? CONTENT_DIRTY : NODE_DIRTY;
        }
      }
      offset2 = end2;
    }
    this.dirty = CONTENT_DIRTY;
  }
  markParentsDirty() {
    let level = 1;
    for (let node2 = this.parent; node2; node2 = node2.parent, level++) {
      let dirty = level == 1 ? CONTENT_DIRTY : CHILD_DIRTY;
      if (node2.dirty < dirty)
        node2.dirty = dirty;
    }
  }
  get domAtom() {
    return false;
  }
  get ignoreForCoords() {
    return false;
  }
}
class WidgetViewDesc extends ViewDesc {
  constructor(parent, widget, view, pos) {
    let self2, dom = widget.type.toDOM;
    if (typeof dom == "function")
      dom = dom(view, () => {
        if (!self2)
          return pos;
        if (self2.parent)
          return self2.parent.posBeforeChild(self2);
      });
    if (!widget.type.spec.raw) {
      if (dom.nodeType != 1) {
        let wrap2 = document.createElement("span");
        wrap2.appendChild(dom);
        dom = wrap2;
      }
      dom.contentEditable = "false";
      dom.classList.add("ProseMirror-widget");
    }
    super(parent, [], dom, null);
    this.widget = widget;
    this.widget = widget;
    self2 = this;
  }
  matchesWidget(widget) {
    return this.dirty == NOT_DIRTY && widget.type.eq(this.widget.type);
  }
  parseRule() {
    return { ignore: true };
  }
  stopEvent(event) {
    let stop = this.widget.spec.stopEvent;
    return stop ? stop(event) : false;
  }
  ignoreMutation(mutation) {
    return mutation.type != "selection" || this.widget.spec.ignoreSelection;
  }
  destroy() {
    this.widget.type.destroy(this.dom);
    super.destroy();
  }
  get domAtom() {
    return true;
  }
  get side() {
    return this.widget.type.side;
  }
}
class CompositionViewDesc extends ViewDesc {
  constructor(parent, dom, textDOM, text2) {
    super(parent, [], dom, null);
    this.textDOM = textDOM;
    this.text = text2;
  }
  get size() {
    return this.text.length;
  }
  localPosFromDOM(dom, offset2) {
    if (dom != this.textDOM)
      return this.posAtStart + (offset2 ? this.size : 0);
    return this.posAtStart + offset2;
  }
  domFromPos(pos) {
    return { node: this.textDOM, offset: pos };
  }
  ignoreMutation(mut) {
    return mut.type === "characterData" && mut.target.nodeValue == mut.oldValue;
  }
}
class MarkViewDesc extends ViewDesc {
  constructor(parent, mark, dom, contentDOM) {
    super(parent, [], dom, contentDOM);
    this.mark = mark;
  }
  static create(parent, mark, inline, view) {
    let custom = view.nodeViews[mark.type.name];
    let spec = custom && custom(mark, view, inline);
    if (!spec || !spec.dom)
      spec = DOMSerializer.renderSpec(document, mark.type.spec.toDOM(mark, inline));
    return new MarkViewDesc(parent, mark, spec.dom, spec.contentDOM || spec.dom);
  }
  parseRule() {
    if (this.dirty & NODE_DIRTY || this.mark.type.spec.reparseInView)
      return null;
    return { mark: this.mark.type.name, attrs: this.mark.attrs, contentElement: this.contentDOM || void 0 };
  }
  matchesMark(mark) {
    return this.dirty != NODE_DIRTY && this.mark.eq(mark);
  }
  markDirty(from3, to) {
    super.markDirty(from3, to);
    if (this.dirty != NOT_DIRTY) {
      let parent = this.parent;
      while (!parent.node)
        parent = parent.parent;
      if (parent.dirty < this.dirty)
        parent.dirty = this.dirty;
      this.dirty = NOT_DIRTY;
    }
  }
  slice(from3, to, view) {
    let copy2 = MarkViewDesc.create(this.parent, this.mark, true, view);
    let nodes = this.children, size = this.size;
    if (to < size)
      nodes = replaceNodes(nodes, to, size, view);
    if (from3 > 0)
      nodes = replaceNodes(nodes, 0, from3, view);
    for (let i3 = 0; i3 < nodes.length; i3++)
      nodes[i3].parent = copy2;
    copy2.children = nodes;
    return copy2;
  }
}
class NodeViewDesc extends ViewDesc {
  constructor(parent, node2, outerDeco, innerDeco, dom, contentDOM, nodeDOM, view, pos) {
    super(parent, [], dom, contentDOM);
    this.node = node2;
    this.outerDeco = outerDeco;
    this.innerDeco = innerDeco;
    this.nodeDOM = nodeDOM;
    if (contentDOM)
      this.updateChildren(view, pos);
  }
  static create(parent, node2, outerDeco, innerDeco, view, pos) {
    let custom = view.nodeViews[node2.type.name], descObj;
    let spec = custom && custom(node2, view, () => {
      if (!descObj)
        return pos;
      if (descObj.parent)
        return descObj.parent.posBeforeChild(descObj);
    }, outerDeco, innerDeco);
    let dom = spec && spec.dom, contentDOM = spec && spec.contentDOM;
    if (node2.isText) {
      if (!dom)
        dom = document.createTextNode(node2.text);
      else if (dom.nodeType != 3)
        throw new RangeError("Text must be rendered as a DOM text node");
    } else if (!dom) {
      ({ dom, contentDOM } = DOMSerializer.renderSpec(document, node2.type.spec.toDOM(node2)));
    }
    if (!contentDOM && !node2.isText && dom.nodeName != "BR") {
      if (!dom.hasAttribute("contenteditable"))
        dom.contentEditable = "false";
      if (node2.type.spec.draggable)
        dom.draggable = true;
    }
    let nodeDOM = dom;
    dom = applyOuterDeco(dom, outerDeco, node2);
    if (spec)
      return descObj = new CustomNodeViewDesc(parent, node2, outerDeco, innerDeco, dom, contentDOM || null, nodeDOM, spec, view, pos + 1);
    else if (node2.isText)
      return new TextViewDesc(parent, node2, outerDeco, innerDeco, dom, nodeDOM, view);
    else
      return new NodeViewDesc(parent, node2, outerDeco, innerDeco, dom, contentDOM || null, nodeDOM, view, pos + 1);
  }
  parseRule() {
    if (this.node.type.spec.reparseInView)
      return null;
    let rule = { node: this.node.type.name, attrs: this.node.attrs };
    if (this.node.type.whitespace == "pre")
      rule.preserveWhitespace = "full";
    if (!this.contentDOM) {
      rule.getContent = () => this.node.content;
    } else if (!this.contentLost) {
      rule.contentElement = this.contentDOM;
    } else {
      for (let i3 = this.children.length - 1; i3 >= 0; i3--) {
        let child = this.children[i3];
        if (this.dom.contains(child.dom.parentNode)) {
          rule.contentElement = child.dom.parentNode;
          break;
        }
      }
      if (!rule.contentElement)
        rule.getContent = () => Fragment.empty;
    }
    return rule;
  }
  matchesNode(node2, outerDeco, innerDeco) {
    return this.dirty == NOT_DIRTY && node2.eq(this.node) && sameOuterDeco(outerDeco, this.outerDeco) && innerDeco.eq(this.innerDeco);
  }
  get size() {
    return this.node.nodeSize;
  }
  get border() {
    return this.node.isLeaf ? 0 : 1;
  }
  updateChildren(view, pos) {
    let inline = this.node.inlineContent, off2 = pos;
    let composition = view.composing ? this.localCompositionInfo(view, pos) : null;
    let localComposition = composition && composition.pos > -1 ? composition : null;
    let compositionInChild = composition && composition.pos < 0;
    let updater = new ViewTreeUpdater(this, localComposition && localComposition.node, view);
    iterDeco(this.node, this.innerDeco, (widget, i3, insideNode) => {
      if (widget.spec.marks)
        updater.syncToMarks(widget.spec.marks, inline, view);
      else if (widget.type.side >= 0 && !insideNode)
        updater.syncToMarks(i3 == this.node.childCount ? Mark$1.none : this.node.child(i3).marks, inline, view);
      updater.placeWidget(widget, view, off2);
    }, (child, outerDeco, innerDeco, i3) => {
      updater.syncToMarks(child.marks, inline, view);
      let compIndex;
      if (updater.findNodeMatch(child, outerDeco, innerDeco, i3))
        ;
      else if (compositionInChild && view.state.selection.from > off2 && view.state.selection.to < off2 + child.nodeSize && (compIndex = updater.findIndexWithChild(composition.node)) > -1 && updater.updateNodeAt(child, outerDeco, innerDeco, compIndex, view))
        ;
      else if (updater.updateNextNode(child, outerDeco, innerDeco, view, i3))
        ;
      else {
        updater.addNode(child, outerDeco, innerDeco, view, off2);
      }
      off2 += child.nodeSize;
    });
    updater.syncToMarks([], inline, view);
    if (this.node.isTextblock)
      updater.addTextblockHacks();
    updater.destroyRest();
    if (updater.changed || this.dirty == CONTENT_DIRTY) {
      if (localComposition)
        this.protectLocalComposition(view, localComposition);
      renderDescs(this.contentDOM, this.children, view);
      if (ios)
        iosHacks(this.dom);
    }
  }
  localCompositionInfo(view, pos) {
    let { from: from3, to } = view.state.selection;
    if (!(view.state.selection instanceof TextSelection) || from3 < pos || to > pos + this.node.content.size)
      return null;
    let sel = view.domSelectionRange();
    let textNode = nearbyTextNode(sel.focusNode, sel.focusOffset);
    if (!textNode || !this.dom.contains(textNode.parentNode))
      return null;
    if (this.node.inlineContent) {
      let text2 = textNode.nodeValue;
      let textPos = findTextInFragment(this.node.content, text2, from3 - pos, to - pos);
      return textPos < 0 ? null : { node: textNode, pos: textPos, text: text2 };
    } else {
      return { node: textNode, pos: -1, text: "" };
    }
  }
  protectLocalComposition(view, { node: node2, pos, text: text2 }) {
    if (this.getDesc(node2))
      return;
    let topNode = node2;
    for (; ; topNode = topNode.parentNode) {
      if (topNode.parentNode == this.contentDOM)
        break;
      while (topNode.previousSibling)
        topNode.parentNode.removeChild(topNode.previousSibling);
      while (topNode.nextSibling)
        topNode.parentNode.removeChild(topNode.nextSibling);
      if (topNode.pmViewDesc)
        topNode.pmViewDesc = void 0;
    }
    let desc = new CompositionViewDesc(this, topNode, node2, text2);
    view.input.compositionNodes.push(desc);
    this.children = replaceNodes(this.children, pos, pos + text2.length, view, desc);
  }
  update(node2, outerDeco, innerDeco, view) {
    if (this.dirty == NODE_DIRTY || !node2.sameMarkup(this.node))
      return false;
    this.updateInner(node2, outerDeco, innerDeco, view);
    return true;
  }
  updateInner(node2, outerDeco, innerDeco, view) {
    this.updateOuterDeco(outerDeco);
    this.node = node2;
    this.innerDeco = innerDeco;
    if (this.contentDOM)
      this.updateChildren(view, this.posAtStart);
    this.dirty = NOT_DIRTY;
  }
  updateOuterDeco(outerDeco) {
    if (sameOuterDeco(outerDeco, this.outerDeco))
      return;
    let needsWrap = this.nodeDOM.nodeType != 1;
    let oldDOM = this.dom;
    this.dom = patchOuterDeco(this.dom, this.nodeDOM, computeOuterDeco(this.outerDeco, this.node, needsWrap), computeOuterDeco(outerDeco, this.node, needsWrap));
    if (this.dom != oldDOM) {
      oldDOM.pmViewDesc = void 0;
      this.dom.pmViewDesc = this;
    }
    this.outerDeco = outerDeco;
  }
  selectNode() {
    if (this.nodeDOM.nodeType == 1)
      this.nodeDOM.classList.add("ProseMirror-selectednode");
    if (this.contentDOM || !this.node.type.spec.draggable)
      this.dom.draggable = true;
  }
  deselectNode() {
    if (this.nodeDOM.nodeType == 1)
      this.nodeDOM.classList.remove("ProseMirror-selectednode");
    if (this.contentDOM || !this.node.type.spec.draggable)
      this.dom.removeAttribute("draggable");
  }
  get domAtom() {
    return this.node.isAtom;
  }
}
function docViewDesc(doc2, outerDeco, innerDeco, dom, view) {
  applyOuterDeco(dom, outerDeco, doc2);
  return new NodeViewDesc(void 0, doc2, outerDeco, innerDeco, dom, dom, dom, view, 0);
}
class TextViewDesc extends NodeViewDesc {
  constructor(parent, node2, outerDeco, innerDeco, dom, nodeDOM, view) {
    super(parent, node2, outerDeco, innerDeco, dom, null, nodeDOM, view, 0);
  }
  parseRule() {
    let skip = this.nodeDOM.parentNode;
    while (skip && skip != this.dom && !skip.pmIsDeco)
      skip = skip.parentNode;
    return { skip: skip || true };
  }
  update(node2, outerDeco, innerDeco, view) {
    if (this.dirty == NODE_DIRTY || this.dirty != NOT_DIRTY && !this.inParent() || !node2.sameMarkup(this.node))
      return false;
    this.updateOuterDeco(outerDeco);
    if ((this.dirty != NOT_DIRTY || node2.text != this.node.text) && node2.text != this.nodeDOM.nodeValue) {
      this.nodeDOM.nodeValue = node2.text;
      if (view.trackWrites == this.nodeDOM)
        view.trackWrites = null;
    }
    this.node = node2;
    this.dirty = NOT_DIRTY;
    return true;
  }
  inParent() {
    let parentDOM = this.parent.contentDOM;
    for (let n2 = this.nodeDOM; n2; n2 = n2.parentNode)
      if (n2 == parentDOM)
        return true;
    return false;
  }
  domFromPos(pos) {
    return { node: this.nodeDOM, offset: pos };
  }
  localPosFromDOM(dom, offset2, bias) {
    if (dom == this.nodeDOM)
      return this.posAtStart + Math.min(offset2, this.node.text.length);
    return super.localPosFromDOM(dom, offset2, bias);
  }
  ignoreMutation(mutation) {
    return mutation.type != "characterData" && mutation.type != "selection";
  }
  slice(from3, to, view) {
    let node2 = this.node.cut(from3, to), dom = document.createTextNode(node2.text);
    return new TextViewDesc(this.parent, node2, this.outerDeco, this.innerDeco, dom, dom, view);
  }
  markDirty(from3, to) {
    super.markDirty(from3, to);
    if (this.dom != this.nodeDOM && (from3 == 0 || to == this.nodeDOM.nodeValue.length))
      this.dirty = NODE_DIRTY;
  }
  get domAtom() {
    return false;
  }
}
class TrailingHackViewDesc extends ViewDesc {
  parseRule() {
    return { ignore: true };
  }
  matchesHack(nodeName) {
    return this.dirty == NOT_DIRTY && this.dom.nodeName == nodeName;
  }
  get domAtom() {
    return true;
  }
  get ignoreForCoords() {
    return this.dom.nodeName == "IMG";
  }
}
class CustomNodeViewDesc extends NodeViewDesc {
  constructor(parent, node2, outerDeco, innerDeco, dom, contentDOM, nodeDOM, spec, view, pos) {
    super(parent, node2, outerDeco, innerDeco, dom, contentDOM, nodeDOM, view, pos);
    this.spec = spec;
  }
  update(node2, outerDeco, innerDeco, view) {
    if (this.dirty == NODE_DIRTY)
      return false;
    if (this.spec.update) {
      let result = this.spec.update(node2, outerDeco, innerDeco);
      if (result)
        this.updateInner(node2, outerDeco, innerDeco, view);
      return result;
    } else if (!this.contentDOM && !node2.isLeaf) {
      return false;
    } else {
      return super.update(node2, outerDeco, innerDeco, view);
    }
  }
  selectNode() {
    this.spec.selectNode ? this.spec.selectNode() : super.selectNode();
  }
  deselectNode() {
    this.spec.deselectNode ? this.spec.deselectNode() : super.deselectNode();
  }
  setSelection(anchor, head, root2, force) {
    this.spec.setSelection ? this.spec.setSelection(anchor, head, root2) : super.setSelection(anchor, head, root2, force);
  }
  destroy() {
    if (this.spec.destroy)
      this.spec.destroy();
    super.destroy();
  }
  stopEvent(event) {
    return this.spec.stopEvent ? this.spec.stopEvent(event) : false;
  }
  ignoreMutation(mutation) {
    return this.spec.ignoreMutation ? this.spec.ignoreMutation(mutation) : super.ignoreMutation(mutation);
  }
}
function renderDescs(parentDOM, descs, view) {
  let dom = parentDOM.firstChild, written = false;
  for (let i3 = 0; i3 < descs.length; i3++) {
    let desc = descs[i3], childDOM = desc.dom;
    if (childDOM.parentNode == parentDOM) {
      while (childDOM != dom) {
        dom = rm(dom);
        written = true;
      }
      dom = dom.nextSibling;
    } else {
      written = true;
      parentDOM.insertBefore(childDOM, dom);
    }
    if (desc instanceof MarkViewDesc) {
      let pos = dom ? dom.previousSibling : parentDOM.lastChild;
      renderDescs(desc.contentDOM, desc.children, view);
      dom = pos ? pos.nextSibling : parentDOM.firstChild;
    }
  }
  while (dom) {
    dom = rm(dom);
    written = true;
  }
  if (written && view.trackWrites == parentDOM)
    view.trackWrites = null;
}
const OuterDecoLevel = function(nodeName) {
  if (nodeName)
    this.nodeName = nodeName;
};
OuterDecoLevel.prototype = /* @__PURE__ */ Object.create(null);
const noDeco = [new OuterDecoLevel()];
function computeOuterDeco(outerDeco, node2, needsWrap) {
  if (outerDeco.length == 0)
    return noDeco;
  let top2 = needsWrap ? noDeco[0] : new OuterDecoLevel(), result = [top2];
  for (let i3 = 0; i3 < outerDeco.length; i3++) {
    let attrs = outerDeco[i3].type.attrs;
    if (!attrs)
      continue;
    if (attrs.nodeName)
      result.push(top2 = new OuterDecoLevel(attrs.nodeName));
    for (let name in attrs) {
      let val = attrs[name];
      if (val == null)
        continue;
      if (needsWrap && result.length == 1)
        result.push(top2 = new OuterDecoLevel(node2.isInline ? "span" : "div"));
      if (name == "class")
        top2.class = (top2.class ? top2.class + " " : "") + val;
      else if (name == "style")
        top2.style = (top2.style ? top2.style + ";" : "") + val;
      else if (name != "nodeName")
        top2[name] = val;
    }
  }
  return result;
}
function patchOuterDeco(outerDOM, nodeDOM, prevComputed, curComputed) {
  if (prevComputed == noDeco && curComputed == noDeco)
    return nodeDOM;
  let curDOM = nodeDOM;
  for (let i3 = 0; i3 < curComputed.length; i3++) {
    let deco = curComputed[i3], prev2 = prevComputed[i3];
    if (i3) {
      let parent;
      if (prev2 && prev2.nodeName == deco.nodeName && curDOM != outerDOM && (parent = curDOM.parentNode) && parent.nodeName.toLowerCase() == deco.nodeName) {
        curDOM = parent;
      } else {
        parent = document.createElement(deco.nodeName);
        parent.pmIsDeco = true;
        parent.appendChild(curDOM);
        prev2 = noDeco[0];
        curDOM = parent;
      }
    }
    patchAttributes(curDOM, prev2 || noDeco[0], deco);
  }
  return curDOM;
}
function patchAttributes(dom, prev2, cur) {
  for (let name in prev2)
    if (name != "class" && name != "style" && name != "nodeName" && !(name in cur))
      dom.removeAttribute(name);
  for (let name in cur)
    if (name != "class" && name != "style" && name != "nodeName" && cur[name] != prev2[name])
      dom.setAttribute(name, cur[name]);
  if (prev2.class != cur.class) {
    let prevList = prev2.class ? prev2.class.split(" ").filter(Boolean) : [];
    let curList = cur.class ? cur.class.split(" ").filter(Boolean) : [];
    for (let i3 = 0; i3 < prevList.length; i3++)
      if (curList.indexOf(prevList[i3]) == -1)
        dom.classList.remove(prevList[i3]);
    for (let i3 = 0; i3 < curList.length; i3++)
      if (prevList.indexOf(curList[i3]) == -1)
        dom.classList.add(curList[i3]);
    if (dom.classList.length == 0)
      dom.removeAttribute("class");
  }
  if (prev2.style != cur.style) {
    if (prev2.style) {
      let prop = /\s*([\w\-\xa1-\uffff]+)\s*:(?:"(?:\\.|[^"])*"|'(?:\\.|[^'])*'|\(.*?\)|[^;])*/g, m4;
      while (m4 = prop.exec(prev2.style))
        dom.style.removeProperty(m4[1]);
    }
    if (cur.style)
      dom.style.cssText += cur.style;
  }
}
function applyOuterDeco(dom, deco, node2) {
  return patchOuterDeco(dom, dom, noDeco, computeOuterDeco(deco, node2, dom.nodeType != 1));
}
function sameOuterDeco(a4, b3) {
  if (a4.length != b3.length)
    return false;
  for (let i3 = 0; i3 < a4.length; i3++)
    if (!a4[i3].type.eq(b3[i3].type))
      return false;
  return true;
}
function rm(dom) {
  let next2 = dom.nextSibling;
  dom.parentNode.removeChild(dom);
  return next2;
}
class ViewTreeUpdater {
  constructor(top2, lock, view) {
    this.lock = lock;
    this.view = view;
    this.index = 0;
    this.stack = [];
    this.changed = false;
    this.top = top2;
    this.preMatch = preMatch(top2.node.content, top2);
  }
  destroyBetween(start2, end2) {
    if (start2 == end2)
      return;
    for (let i3 = start2; i3 < end2; i3++)
      this.top.children[i3].destroy();
    this.top.children.splice(start2, end2 - start2);
    this.changed = true;
  }
  destroyRest() {
    this.destroyBetween(this.index, this.top.children.length);
  }
  syncToMarks(marks, inline, view) {
    let keep = 0, depth = this.stack.length >> 1;
    let maxKeep = Math.min(depth, marks.length);
    while (keep < maxKeep && (keep == depth - 1 ? this.top : this.stack[keep + 1 << 1]).matchesMark(marks[keep]) && marks[keep].type.spec.spanning !== false)
      keep++;
    while (keep < depth) {
      this.destroyRest();
      this.top.dirty = NOT_DIRTY;
      this.index = this.stack.pop();
      this.top = this.stack.pop();
      depth--;
    }
    while (depth < marks.length) {
      this.stack.push(this.top, this.index + 1);
      let found2 = -1;
      for (let i3 = this.index; i3 < Math.min(this.index + 3, this.top.children.length); i3++) {
        let next2 = this.top.children[i3];
        if (next2.matchesMark(marks[depth]) && !this.isLocked(next2.dom)) {
          found2 = i3;
          break;
        }
      }
      if (found2 > -1) {
        if (found2 > this.index) {
          this.changed = true;
          this.destroyBetween(this.index, found2);
        }
        this.top = this.top.children[this.index];
      } else {
        let markDesc = MarkViewDesc.create(this.top, marks[depth], inline, view);
        this.top.children.splice(this.index, 0, markDesc);
        this.top = markDesc;
        this.changed = true;
      }
      this.index = 0;
      depth++;
    }
  }
  findNodeMatch(node2, outerDeco, innerDeco, index2) {
    let found2 = -1, targetDesc;
    if (index2 >= this.preMatch.index && (targetDesc = this.preMatch.matches[index2 - this.preMatch.index]).parent == this.top && targetDesc.matchesNode(node2, outerDeco, innerDeco)) {
      found2 = this.top.children.indexOf(targetDesc, this.index);
    } else {
      for (let i3 = this.index, e3 = Math.min(this.top.children.length, i3 + 5); i3 < e3; i3++) {
        let child = this.top.children[i3];
        if (child.matchesNode(node2, outerDeco, innerDeco) && !this.preMatch.matched.has(child)) {
          found2 = i3;
          break;
        }
      }
    }
    if (found2 < 0)
      return false;
    this.destroyBetween(this.index, found2);
    this.index++;
    return true;
  }
  updateNodeAt(node2, outerDeco, innerDeco, index2, view) {
    let child = this.top.children[index2];
    if (child.dirty == NODE_DIRTY && child.dom == child.contentDOM)
      child.dirty = CONTENT_DIRTY;
    if (!child.update(node2, outerDeco, innerDeco, view))
      return false;
    this.destroyBetween(this.index, index2);
    this.index++;
    return true;
  }
  findIndexWithChild(domNode) {
    for (; ; ) {
      let parent = domNode.parentNode;
      if (!parent)
        return -1;
      if (parent == this.top.contentDOM) {
        let desc = domNode.pmViewDesc;
        if (desc)
          for (let i3 = this.index; i3 < this.top.children.length; i3++) {
            if (this.top.children[i3] == desc)
              return i3;
          }
        return -1;
      }
      domNode = parent;
    }
  }
  updateNextNode(node2, outerDeco, innerDeco, view, index2) {
    for (let i3 = this.index; i3 < this.top.children.length; i3++) {
      let next2 = this.top.children[i3];
      if (next2 instanceof NodeViewDesc) {
        let preMatch2 = this.preMatch.matched.get(next2);
        if (preMatch2 != null && preMatch2 != index2)
          return false;
        let nextDOM = next2.dom;
        let locked = this.isLocked(nextDOM) && !(node2.isText && next2.node && next2.node.isText && next2.nodeDOM.nodeValue == node2.text && next2.dirty != NODE_DIRTY && sameOuterDeco(outerDeco, next2.outerDeco));
        if (!locked && next2.update(node2, outerDeco, innerDeco, view)) {
          this.destroyBetween(this.index, i3);
          if (next2.dom != nextDOM)
            this.changed = true;
          this.index++;
          return true;
        }
        break;
      }
    }
    return false;
  }
  addNode(node2, outerDeco, innerDeco, view, pos) {
    this.top.children.splice(this.index++, 0, NodeViewDesc.create(this.top, node2, outerDeco, innerDeco, view, pos));
    this.changed = true;
  }
  placeWidget(widget, view, pos) {
    let next2 = this.index < this.top.children.length ? this.top.children[this.index] : null;
    if (next2 && next2.matchesWidget(widget) && (widget == next2.widget || !next2.widget.type.toDOM.parentNode)) {
      this.index++;
    } else {
      let desc = new WidgetViewDesc(this.top, widget, view, pos);
      this.top.children.splice(this.index++, 0, desc);
      this.changed = true;
    }
  }
  addTextblockHacks() {
    let lastChild2 = this.top.children[this.index - 1], parent = this.top;
    while (lastChild2 instanceof MarkViewDesc) {
      parent = lastChild2;
      lastChild2 = parent.children[parent.children.length - 1];
    }
    if (!lastChild2 || !(lastChild2 instanceof TextViewDesc) || /\n$/.test(lastChild2.node.text) || this.view.requiresGeckoHackNode && /\s$/.test(lastChild2.node.text)) {
      if ((safari || chrome$1) && lastChild2 && lastChild2.dom.contentEditable == "false")
        this.addHackNode("IMG", parent);
      this.addHackNode("BR", this.top);
    }
  }
  addHackNode(nodeName, parent) {
    if (parent == this.top && this.index < parent.children.length && parent.children[this.index].matchesHack(nodeName)) {
      this.index++;
    } else {
      let dom = document.createElement(nodeName);
      if (nodeName == "IMG") {
        dom.className = "ProseMirror-separator";
        dom.alt = "";
      }
      if (nodeName == "BR")
        dom.className = "ProseMirror-trailingBreak";
      let hack = new TrailingHackViewDesc(this.top, [], dom, null);
      if (parent != this.top)
        parent.children.push(hack);
      else
        parent.children.splice(this.index++, 0, hack);
      this.changed = true;
    }
  }
  isLocked(node2) {
    return this.lock && (node2 == this.lock || node2.nodeType == 1 && node2.contains(this.lock.parentNode));
  }
}
function preMatch(frag, parentDesc) {
  let curDesc = parentDesc, descI = curDesc.children.length;
  let fI = frag.childCount, matched = /* @__PURE__ */ new Map(), matches2 = [];
  outer:
    while (fI > 0) {
      let desc;
      for (; ; ) {
        if (descI) {
          let next2 = curDesc.children[descI - 1];
          if (next2 instanceof MarkViewDesc) {
            curDesc = next2;
            descI = next2.children.length;
          } else {
            desc = next2;
            descI--;
            break;
          }
        } else if (curDesc == parentDesc) {
          break outer;
        } else {
          descI = curDesc.parent.children.indexOf(curDesc);
          curDesc = curDesc.parent;
        }
      }
      let node2 = desc.node;
      if (!node2)
        continue;
      if (node2 != frag.child(fI - 1))
        break;
      --fI;
      matched.set(desc, fI);
      matches2.push(desc);
    }
  return { index: fI, matched, matches: matches2.reverse() };
}
function compareSide(a4, b3) {
  return a4.type.side - b3.type.side;
}
function iterDeco(parent, deco, onWidget, onNode) {
  let locals = deco.locals(parent), offset2 = 0;
  if (locals.length == 0) {
    for (let i3 = 0; i3 < parent.childCount; i3++) {
      let child = parent.child(i3);
      onNode(child, locals, deco.forChild(offset2, child), i3);
      offset2 += child.nodeSize;
    }
    return;
  }
  let decoIndex = 0, active = [], restNode = null;
  for (let parentIndex = 0; ; ) {
    if (decoIndex < locals.length && locals[decoIndex].to == offset2) {
      let widget = locals[decoIndex++], widgets;
      while (decoIndex < locals.length && locals[decoIndex].to == offset2)
        (widgets || (widgets = [widget])).push(locals[decoIndex++]);
      if (widgets) {
        widgets.sort(compareSide);
        for (let i3 = 0; i3 < widgets.length; i3++)
          onWidget(widgets[i3], parentIndex, !!restNode);
      } else {
        onWidget(widget, parentIndex, !!restNode);
      }
    }
    let child, index2;
    if (restNode) {
      index2 = -1;
      child = restNode;
      restNode = null;
    } else if (parentIndex < parent.childCount) {
      index2 = parentIndex;
      child = parent.child(parentIndex++);
    } else {
      break;
    }
    for (let i3 = 0; i3 < active.length; i3++)
      if (active[i3].to <= offset2)
        active.splice(i3--, 1);
    while (decoIndex < locals.length && locals[decoIndex].from <= offset2 && locals[decoIndex].to > offset2)
      active.push(locals[decoIndex++]);
    let end2 = offset2 + child.nodeSize;
    if (child.isText) {
      let cutAt = end2;
      if (decoIndex < locals.length && locals[decoIndex].from < cutAt)
        cutAt = locals[decoIndex].from;
      for (let i3 = 0; i3 < active.length; i3++)
        if (active[i3].to < cutAt)
          cutAt = active[i3].to;
      if (cutAt < end2) {
        restNode = child.cut(cutAt - offset2);
        child = child.cut(0, cutAt - offset2);
        end2 = cutAt;
        index2 = -1;
      }
    }
    let outerDeco = child.isInline && !child.isLeaf ? active.filter((d4) => !d4.inline) : active.slice();
    onNode(child, outerDeco, deco.forChild(offset2, child), index2);
    offset2 = end2;
  }
}
function iosHacks(dom) {
  if (dom.nodeName == "UL" || dom.nodeName == "OL") {
    let oldCSS = dom.style.cssText;
    dom.style.cssText = oldCSS + "; list-style: square !important";
    window.getComputedStyle(dom).listStyle;
    dom.style.cssText = oldCSS;
  }
}
function nearbyTextNode(node2, offset2) {
  for (; ; ) {
    if (node2.nodeType == 3)
      return node2;
    if (node2.nodeType == 1 && offset2 > 0) {
      if (node2.childNodes.length > offset2 && node2.childNodes[offset2].nodeType == 3)
        return node2.childNodes[offset2];
      node2 = node2.childNodes[offset2 - 1];
      offset2 = nodeSize(node2);
    } else if (node2.nodeType == 1 && offset2 < node2.childNodes.length) {
      node2 = node2.childNodes[offset2];
      offset2 = 0;
    } else {
      return null;
    }
  }
}
function findTextInFragment(frag, text2, from3, to) {
  for (let i3 = 0, pos = 0; i3 < frag.childCount && pos <= to; ) {
    let child = frag.child(i3++), childStart = pos;
    pos += child.nodeSize;
    if (!child.isText)
      continue;
    let str = child.text;
    while (i3 < frag.childCount) {
      let next2 = frag.child(i3++);
      pos += next2.nodeSize;
      if (!next2.isText)
        break;
      str += next2.text;
    }
    if (pos >= from3) {
      let found2 = childStart < to ? str.lastIndexOf(text2, to - childStart - 1) : -1;
      if (found2 >= 0 && found2 + text2.length + childStart >= from3)
        return childStart + found2;
      if (from3 == to && str.length >= to + text2.length - childStart && str.slice(to - childStart, to - childStart + text2.length) == text2)
        return to;
    }
  }
  return -1;
}
function replaceNodes(nodes, from3, to, view, replacement) {
  let result = [];
  for (let i3 = 0, off2 = 0; i3 < nodes.length; i3++) {
    let child = nodes[i3], start2 = off2, end2 = off2 += child.size;
    if (start2 >= to || end2 <= from3) {
      result.push(child);
    } else {
      if (start2 < from3)
        result.push(child.slice(0, from3 - start2, view));
      if (replacement) {
        result.push(replacement);
        replacement = void 0;
      }
      if (end2 > to)
        result.push(child.slice(to - start2, child.size, view));
    }
  }
  return result;
}
function selectionFromDOM(view, origin = null) {
  let domSel = view.domSelectionRange(), doc2 = view.state.doc;
  if (!domSel.focusNode)
    return null;
  let nearestDesc = view.docView.nearestDesc(domSel.focusNode), inWidget = nearestDesc && nearestDesc.size == 0;
  let head = view.docView.posFromDOM(domSel.focusNode, domSel.focusOffset, 1);
  if (head < 0)
    return null;
  let $head = doc2.resolve(head), $anchor, selection;
  if (selectionCollapsed(domSel)) {
    $anchor = $head;
    while (nearestDesc && !nearestDesc.node)
      nearestDesc = nearestDesc.parent;
    let nearestDescNode = nearestDesc.node;
    if (nearestDesc && nearestDescNode.isAtom && NodeSelection.isSelectable(nearestDescNode) && nearestDesc.parent && !(nearestDescNode.isInline && isOnEdge(domSel.focusNode, domSel.focusOffset, nearestDesc.dom))) {
      let pos = nearestDesc.posBefore;
      selection = new NodeSelection(head == pos ? $head : doc2.resolve(pos));
    }
  } else {
    let anchor = view.docView.posFromDOM(domSel.anchorNode, domSel.anchorOffset, 1);
    if (anchor < 0)
      return null;
    $anchor = doc2.resolve(anchor);
  }
  if (!selection) {
    let bias = origin == "pointer" || view.state.selection.head < $head.pos && !inWidget ? 1 : -1;
    selection = selectionBetween(view, $anchor, $head, bias);
  }
  return selection;
}
function editorOwnsSelection(view) {
  return view.editable ? view.hasFocus() : hasSelection(view) && document.activeElement && document.activeElement.contains(view.dom);
}
function selectionToDOM(view, force = false) {
  let sel = view.state.selection;
  syncNodeSelection(view, sel);
  if (!editorOwnsSelection(view))
    return;
  if (!force && view.input.mouseDown && view.input.mouseDown.allowDefault && chrome$1) {
    let domSel = view.domSelectionRange(), curSel = view.domObserver.currentSelection;
    if (domSel.anchorNode && curSel.anchorNode && isEquivalentPosition(domSel.anchorNode, domSel.anchorOffset, curSel.anchorNode, curSel.anchorOffset)) {
      view.input.mouseDown.delayedSelectionSync = true;
      view.domObserver.setCurSelection();
      return;
    }
  }
  view.domObserver.disconnectSelection();
  if (view.cursorWrapper) {
    selectCursorWrapper(view);
  } else {
    let { anchor, head } = sel, resetEditableFrom, resetEditableTo;
    if (brokenSelectBetweenUneditable && !(sel instanceof TextSelection)) {
      if (!sel.$from.parent.inlineContent)
        resetEditableFrom = temporarilyEditableNear(view, sel.from);
      if (!sel.empty && !sel.$from.parent.inlineContent)
        resetEditableTo = temporarilyEditableNear(view, sel.to);
    }
    view.docView.setSelection(anchor, head, view.root, force);
    if (brokenSelectBetweenUneditable) {
      if (resetEditableFrom)
        resetEditable(resetEditableFrom);
      if (resetEditableTo)
        resetEditable(resetEditableTo);
    }
    if (sel.visible) {
      view.dom.classList.remove("ProseMirror-hideselection");
    } else {
      view.dom.classList.add("ProseMirror-hideselection");
      if ("onselectionchange" in document)
        removeClassOnSelectionChange(view);
    }
  }
  view.domObserver.setCurSelection();
  view.domObserver.connectSelection();
}
const brokenSelectBetweenUneditable = safari || chrome$1 && chrome_version < 63;
function temporarilyEditableNear(view, pos) {
  let { node: node2, offset: offset2 } = view.docView.domFromPos(pos, 0);
  let after = offset2 < node2.childNodes.length ? node2.childNodes[offset2] : null;
  let before = offset2 ? node2.childNodes[offset2 - 1] : null;
  if (safari && after && after.contentEditable == "false")
    return setEditable(after);
  if ((!after || after.contentEditable == "false") && (!before || before.contentEditable == "false")) {
    if (after)
      return setEditable(after);
    else if (before)
      return setEditable(before);
  }
}
function setEditable(element) {
  element.contentEditable = "true";
  if (safari && element.draggable) {
    element.draggable = false;
    element.wasDraggable = true;
  }
  return element;
}
function resetEditable(element) {
  element.contentEditable = "false";
  if (element.wasDraggable) {
    element.draggable = true;
    element.wasDraggable = null;
  }
}
function removeClassOnSelectionChange(view) {
  let doc2 = view.dom.ownerDocument;
  doc2.removeEventListener("selectionchange", view.input.hideSelectionGuard);
  let domSel = view.domSelectionRange();
  let node2 = domSel.anchorNode, offset2 = domSel.anchorOffset;
  doc2.addEventListener("selectionchange", view.input.hideSelectionGuard = () => {
    if (domSel.anchorNode != node2 || domSel.anchorOffset != offset2) {
      doc2.removeEventListener("selectionchange", view.input.hideSelectionGuard);
      setTimeout(() => {
        if (!editorOwnsSelection(view) || view.state.selection.visible)
          view.dom.classList.remove("ProseMirror-hideselection");
      }, 20);
    }
  });
}
function selectCursorWrapper(view) {
  let domSel = view.domSelection(), range2 = document.createRange();
  let node2 = view.cursorWrapper.dom, img = node2.nodeName == "IMG";
  if (img)
    range2.setEnd(node2.parentNode, domIndex(node2) + 1);
  else
    range2.setEnd(node2, 0);
  range2.collapse(false);
  domSel.removeAllRanges();
  domSel.addRange(range2);
  if (!img && !view.state.selection.visible && ie$1 && ie_version <= 11) {
    node2.disabled = true;
    node2.disabled = false;
  }
}
function syncNodeSelection(view, sel) {
  if (sel instanceof NodeSelection) {
    let desc = view.docView.descAt(sel.from);
    if (desc != view.lastSelectedViewDesc) {
      clearNodeSelection(view);
      if (desc)
        desc.selectNode();
      view.lastSelectedViewDesc = desc;
    }
  } else {
    clearNodeSelection(view);
  }
}
function clearNodeSelection(view) {
  if (view.lastSelectedViewDesc) {
    if (view.lastSelectedViewDesc.parent)
      view.lastSelectedViewDesc.deselectNode();
    view.lastSelectedViewDesc = void 0;
  }
}
function selectionBetween(view, $anchor, $head, bias) {
  return view.someProp("createSelectionBetween", (f2) => f2(view, $anchor, $head)) || TextSelection.between($anchor, $head, bias);
}
function hasFocusAndSelection(view) {
  if (view.editable && !view.hasFocus())
    return false;
  return hasSelection(view);
}
function hasSelection(view) {
  let sel = view.domSelectionRange();
  if (!sel.anchorNode)
    return false;
  try {
    return view.dom.contains(sel.anchorNode.nodeType == 3 ? sel.anchorNode.parentNode : sel.anchorNode) && (view.editable || view.dom.contains(sel.focusNode.nodeType == 3 ? sel.focusNode.parentNode : sel.focusNode));
  } catch (_2) {
    return false;
  }
}
function anchorInRightPlace(view) {
  let anchorDOM = view.docView.domFromPos(view.state.selection.anchor, 0);
  let domSel = view.domSelectionRange();
  return isEquivalentPosition(anchorDOM.node, anchorDOM.offset, domSel.anchorNode, domSel.anchorOffset);
}
function moveSelectionBlock(state, dir) {
  let { $anchor, $head } = state.selection;
  let $side = dir > 0 ? $anchor.max($head) : $anchor.min($head);
  let $start = !$side.parent.inlineContent ? $side : $side.depth ? state.doc.resolve(dir > 0 ? $side.after() : $side.before()) : null;
  return $start && Selection.findFrom($start, dir);
}
function apply(view, sel) {
  view.dispatch(view.state.tr.setSelection(sel).scrollIntoView());
  return true;
}
function selectHorizontally(view, dir, mods) {
  let sel = view.state.selection;
  if (sel instanceof TextSelection) {
    if (!sel.empty || mods.indexOf("s") > -1) {
      return false;
    } else if (view.endOfTextblock(dir > 0 ? "right" : "left")) {
      let next2 = moveSelectionBlock(view.state, dir);
      if (next2 && next2 instanceof NodeSelection)
        return apply(view, next2);
      return false;
    } else if (!(mac$2 && mods.indexOf("m") > -1)) {
      let $head = sel.$head, node2 = $head.textOffset ? null : dir < 0 ? $head.nodeBefore : $head.nodeAfter, desc;
      if (!node2 || node2.isText)
        return false;
      let nodePos = dir < 0 ? $head.pos - node2.nodeSize : $head.pos;
      if (!(node2.isAtom || (desc = view.docView.descAt(nodePos)) && !desc.contentDOM))
        return false;
      if (NodeSelection.isSelectable(node2)) {
        return apply(view, new NodeSelection(dir < 0 ? view.state.doc.resolve($head.pos - node2.nodeSize) : $head));
      } else if (webkit) {
        return apply(view, new TextSelection(view.state.doc.resolve(dir < 0 ? nodePos : nodePos + node2.nodeSize)));
      } else {
        return false;
      }
    }
  } else if (sel instanceof NodeSelection && sel.node.isInline) {
    return apply(view, new TextSelection(dir > 0 ? sel.$to : sel.$from));
  } else {
    let next2 = moveSelectionBlock(view.state, dir);
    if (next2)
      return apply(view, next2);
    return false;
  }
}
function nodeLen(node2) {
  return node2.nodeType == 3 ? node2.nodeValue.length : node2.childNodes.length;
}
function isIgnorable(dom) {
  let desc = dom.pmViewDesc;
  return desc && desc.size == 0 && (dom.nextSibling || dom.nodeName != "BR");
}
function skipIgnoredNodesLeft(view) {
  let sel = view.domSelectionRange();
  let node2 = sel.focusNode, offset2 = sel.focusOffset;
  if (!node2)
    return;
  let moveNode, moveOffset, force = false;
  if (gecko && node2.nodeType == 1 && offset2 < nodeLen(node2) && isIgnorable(node2.childNodes[offset2]))
    force = true;
  for (; ; ) {
    if (offset2 > 0) {
      if (node2.nodeType != 1) {
        break;
      } else {
        let before = node2.childNodes[offset2 - 1];
        if (isIgnorable(before)) {
          moveNode = node2;
          moveOffset = --offset2;
        } else if (before.nodeType == 3) {
          node2 = before;
          offset2 = node2.nodeValue.length;
        } else
          break;
      }
    } else if (isBlockNode(node2)) {
      break;
    } else {
      let prev2 = node2.previousSibling;
      while (prev2 && isIgnorable(prev2)) {
        moveNode = node2.parentNode;
        moveOffset = domIndex(prev2);
        prev2 = prev2.previousSibling;
      }
      if (!prev2) {
        node2 = node2.parentNode;
        if (node2 == view.dom)
          break;
        offset2 = 0;
      } else {
        node2 = prev2;
        offset2 = nodeLen(node2);
      }
    }
  }
  if (force)
    setSelFocus(view, node2, offset2);
  else if (moveNode)
    setSelFocus(view, moveNode, moveOffset);
}
function skipIgnoredNodesRight(view) {
  let sel = view.domSelectionRange();
  let node2 = sel.focusNode, offset2 = sel.focusOffset;
  if (!node2)
    return;
  let len = nodeLen(node2);
  let moveNode, moveOffset;
  for (; ; ) {
    if (offset2 < len) {
      if (node2.nodeType != 1)
        break;
      let after = node2.childNodes[offset2];
      if (isIgnorable(after)) {
        moveNode = node2;
        moveOffset = ++offset2;
      } else
        break;
    } else if (isBlockNode(node2)) {
      break;
    } else {
      let next2 = node2.nextSibling;
      while (next2 && isIgnorable(next2)) {
        moveNode = next2.parentNode;
        moveOffset = domIndex(next2) + 1;
        next2 = next2.nextSibling;
      }
      if (!next2) {
        node2 = node2.parentNode;
        if (node2 == view.dom)
          break;
        offset2 = len = 0;
      } else {
        node2 = next2;
        offset2 = 0;
        len = nodeLen(node2);
      }
    }
  }
  if (moveNode)
    setSelFocus(view, moveNode, moveOffset);
}
function isBlockNode(dom) {
  let desc = dom.pmViewDesc;
  return desc && desc.node && desc.node.isBlock;
}
function setSelFocus(view, node2, offset2) {
  let sel = view.domSelection();
  if (selectionCollapsed(sel)) {
    let range2 = document.createRange();
    range2.setEnd(node2, offset2);
    range2.setStart(node2, offset2);
    sel.removeAllRanges();
    sel.addRange(range2);
  } else if (sel.extend) {
    sel.extend(node2, offset2);
  }
  view.domObserver.setCurSelection();
  let { state } = view;
  setTimeout(() => {
    if (view.state == state)
      selectionToDOM(view);
  }, 50);
}
function selectVertically(view, dir, mods) {
  let sel = view.state.selection;
  if (sel instanceof TextSelection && !sel.empty || mods.indexOf("s") > -1)
    return false;
  if (mac$2 && mods.indexOf("m") > -1)
    return false;
  let { $from, $to } = sel;
  if (!$from.parent.inlineContent || view.endOfTextblock(dir < 0 ? "up" : "down")) {
    let next2 = moveSelectionBlock(view.state, dir);
    if (next2 && next2 instanceof NodeSelection)
      return apply(view, next2);
  }
  if (!$from.parent.inlineContent) {
    let side = dir < 0 ? $from : $to;
    let beyond = sel instanceof AllSelection ? Selection.near(side, dir) : Selection.findFrom(side, dir);
    return beyond ? apply(view, beyond) : false;
  }
  return false;
}
function stopNativeHorizontalDelete(view, dir) {
  if (!(view.state.selection instanceof TextSelection))
    return true;
  let { $head, $anchor, empty: empty2 } = view.state.selection;
  if (!$head.sameParent($anchor))
    return true;
  if (!empty2)
    return false;
  if (view.endOfTextblock(dir > 0 ? "forward" : "backward"))
    return true;
  let nextNode = !$head.textOffset && (dir < 0 ? $head.nodeBefore : $head.nodeAfter);
  if (nextNode && !nextNode.isText) {
    let tr = view.state.tr;
    if (dir < 0)
      tr.delete($head.pos - nextNode.nodeSize, $head.pos);
    else
      tr.delete($head.pos, $head.pos + nextNode.nodeSize);
    view.dispatch(tr);
    return true;
  }
  return false;
}
function switchEditable(view, node2, state) {
  view.domObserver.stop();
  node2.contentEditable = state;
  view.domObserver.start();
}
function safariDownArrowBug(view) {
  if (!safari || view.state.selection.$head.parentOffset > 0)
    return false;
  let { focusNode, focusOffset } = view.domSelectionRange();
  if (focusNode && focusNode.nodeType == 1 && focusOffset == 0 && focusNode.firstChild && focusNode.firstChild.contentEditable == "false") {
    let child = focusNode.firstChild;
    switchEditable(view, child, "true");
    setTimeout(() => switchEditable(view, child, "false"), 20);
  }
  return false;
}
function getMods(event) {
  let result = "";
  if (event.ctrlKey)
    result += "c";
  if (event.metaKey)
    result += "m";
  if (event.altKey)
    result += "a";
  if (event.shiftKey)
    result += "s";
  return result;
}
function captureKeyDown(view, event) {
  let code = event.keyCode, mods = getMods(event);
  if (code == 8 || mac$2 && code == 72 && mods == "c") {
    return stopNativeHorizontalDelete(view, -1) || skipIgnoredNodesLeft(view);
  } else if (code == 46 || mac$2 && code == 68 && mods == "c") {
    return stopNativeHorizontalDelete(view, 1) || skipIgnoredNodesRight(view);
  } else if (code == 13 || code == 27) {
    return true;
  } else if (code == 37 || mac$2 && code == 66 && mods == "c") {
    return selectHorizontally(view, -1, mods) || skipIgnoredNodesLeft(view);
  } else if (code == 39 || mac$2 && code == 70 && mods == "c") {
    return selectHorizontally(view, 1, mods) || skipIgnoredNodesRight(view);
  } else if (code == 38 || mac$2 && code == 80 && mods == "c") {
    return selectVertically(view, -1, mods) || skipIgnoredNodesLeft(view);
  } else if (code == 40 || mac$2 && code == 78 && mods == "c") {
    return safariDownArrowBug(view) || selectVertically(view, 1, mods) || skipIgnoredNodesRight(view);
  } else if (mods == (mac$2 ? "m" : "c") && (code == 66 || code == 73 || code == 89 || code == 90)) {
    return true;
  }
  return false;
}
function serializeForClipboard(view, slice3) {
  view.someProp("transformCopied", (f2) => {
    slice3 = f2(slice3, view);
  });
  let context = [], { content, openStart, openEnd } = slice3;
  while (openStart > 1 && openEnd > 1 && content.childCount == 1 && content.firstChild.childCount == 1) {
    openStart--;
    openEnd--;
    let node2 = content.firstChild;
    context.push(node2.type.name, node2.attrs != node2.type.defaultAttrs ? node2.attrs : null);
    content = node2.content;
  }
  let serializer = view.someProp("clipboardSerializer") || DOMSerializer.fromSchema(view.state.schema);
  let doc2 = detachedDoc(), wrap2 = doc2.createElement("div");
  wrap2.appendChild(serializer.serializeFragment(content, { document: doc2 }));
  let firstChild = wrap2.firstChild, needsWrap, wrappers = 0;
  while (firstChild && firstChild.nodeType == 1 && (needsWrap = wrapMap[firstChild.nodeName.toLowerCase()])) {
    for (let i3 = needsWrap.length - 1; i3 >= 0; i3--) {
      let wrapper = doc2.createElement(needsWrap[i3]);
      while (wrap2.firstChild)
        wrapper.appendChild(wrap2.firstChild);
      wrap2.appendChild(wrapper);
      wrappers++;
    }
    firstChild = wrap2.firstChild;
  }
  if (firstChild && firstChild.nodeType == 1)
    firstChild.setAttribute("data-pm-slice", `${openStart} ${openEnd}${wrappers ? ` -${wrappers}` : ""} ${JSON.stringify(context)}`);
  let text2 = view.someProp("clipboardTextSerializer", (f2) => f2(slice3, view)) || slice3.content.textBetween(0, slice3.content.size, "\n\n");
  return { dom: wrap2, text: text2 };
}
function parseFromClipboard(view, text2, html, plainText, $context) {
  let inCode = $context.parent.type.spec.code;
  let dom, slice3;
  if (!html && !text2)
    return null;
  let asText = text2 && (plainText || inCode || !html);
  if (asText) {
    view.someProp("transformPastedText", (f2) => {
      text2 = f2(text2, inCode || plainText, view);
    });
    if (inCode)
      return text2 ? new Slice(Fragment.from(view.state.schema.text(text2.replace(/\r\n?/g, "\n"))), 0, 0) : Slice.empty;
    let parsed = view.someProp("clipboardTextParser", (f2) => f2(text2, $context, plainText, view));
    if (parsed) {
      slice3 = parsed;
    } else {
      let marks = $context.marks();
      let { schema } = view.state, serializer = DOMSerializer.fromSchema(schema);
      dom = document.createElement("div");
      text2.split(/(?:\r\n?|\n)+/).forEach((block) => {
        let p2 = dom.appendChild(document.createElement("p"));
        if (block)
          p2.appendChild(serializer.serializeNode(schema.text(block, marks)));
      });
    }
  } else {
    view.someProp("transformPastedHTML", (f2) => {
      html = f2(html, view);
    });
    dom = readHTML(html);
    if (webkit)
      restoreReplacedSpaces(dom);
  }
  let contextNode = dom && dom.querySelector("[data-pm-slice]");
  let sliceData = contextNode && /^(\d+) (\d+)(?: -(\d+))? (.*)/.exec(contextNode.getAttribute("data-pm-slice") || "");
  if (sliceData && sliceData[3])
    for (let i3 = +sliceData[3]; i3 > 0; i3--) {
      let child = dom.firstChild;
      while (child && child.nodeType != 1)
        child = child.nextSibling;
      if (!child)
        break;
      dom = child;
    }
  if (!slice3) {
    let parser = view.someProp("clipboardParser") || view.someProp("domParser") || DOMParser$1.fromSchema(view.state.schema);
    slice3 = parser.parseSlice(dom, {
      preserveWhitespace: !!(asText || sliceData),
      context: $context,
      ruleFromNode(dom2) {
        if (dom2.nodeName == "BR" && !dom2.nextSibling && dom2.parentNode && !inlineParents.test(dom2.parentNode.nodeName))
          return { ignore: true };
        return null;
      }
    });
  }
  if (sliceData) {
    slice3 = addContext(closeSlice(slice3, +sliceData[1], +sliceData[2]), sliceData[4]);
  } else {
    slice3 = Slice.maxOpen(normalizeSiblings(slice3.content, $context), true);
    if (slice3.openStart || slice3.openEnd) {
      let openStart = 0, openEnd = 0;
      for (let node2 = slice3.content.firstChild; openStart < slice3.openStart && !node2.type.spec.isolating; openStart++, node2 = node2.firstChild) {
      }
      for (let node2 = slice3.content.lastChild; openEnd < slice3.openEnd && !node2.type.spec.isolating; openEnd++, node2 = node2.lastChild) {
      }
      slice3 = closeSlice(slice3, openStart, openEnd);
    }
  }
  view.someProp("transformPasted", (f2) => {
    slice3 = f2(slice3, view);
  });
  return slice3;
}
const inlineParents = /^(a|abbr|acronym|b|cite|code|del|em|i|ins|kbd|label|output|q|ruby|s|samp|span|strong|sub|sup|time|u|tt|var)$/i;
function normalizeSiblings(fragment, $context) {
  if (fragment.childCount < 2)
    return fragment;
  for (let d4 = $context.depth; d4 >= 0; d4--) {
    let parent = $context.node(d4);
    let match2 = parent.contentMatchAt($context.index(d4));
    let lastWrap, result = [];
    fragment.forEach((node2) => {
      if (!result)
        return;
      let wrap2 = match2.findWrapping(node2.type), inLast;
      if (!wrap2)
        return result = null;
      if (inLast = result.length && lastWrap.length && addToSibling(wrap2, lastWrap, node2, result[result.length - 1], 0)) {
        result[result.length - 1] = inLast;
      } else {
        if (result.length)
          result[result.length - 1] = closeRight(result[result.length - 1], lastWrap.length);
        let wrapped = withWrappers(node2, wrap2);
        result.push(wrapped);
        match2 = match2.matchType(wrapped.type);
        lastWrap = wrap2;
      }
    });
    if (result)
      return Fragment.from(result);
  }
  return fragment;
}
function withWrappers(node2, wrap2, from3 = 0) {
  for (let i3 = wrap2.length - 1; i3 >= from3; i3--)
    node2 = wrap2[i3].create(null, Fragment.from(node2));
  return node2;
}
function addToSibling(wrap2, lastWrap, node2, sibling, depth) {
  if (depth < wrap2.length && depth < lastWrap.length && wrap2[depth] == lastWrap[depth]) {
    let inner = addToSibling(wrap2, lastWrap, node2, sibling.lastChild, depth + 1);
    if (inner)
      return sibling.copy(sibling.content.replaceChild(sibling.childCount - 1, inner));
    let match2 = sibling.contentMatchAt(sibling.childCount);
    if (match2.matchType(depth == wrap2.length - 1 ? node2.type : wrap2[depth + 1]))
      return sibling.copy(sibling.content.append(Fragment.from(withWrappers(node2, wrap2, depth + 1))));
  }
}
function closeRight(node2, depth) {
  if (depth == 0)
    return node2;
  let fragment = node2.content.replaceChild(node2.childCount - 1, closeRight(node2.lastChild, depth - 1));
  let fill = node2.contentMatchAt(node2.childCount).fillBefore(Fragment.empty, true);
  return node2.copy(fragment.append(fill));
}
function closeRange(fragment, side, from3, to, depth, openEnd) {
  let node2 = side < 0 ? fragment.firstChild : fragment.lastChild, inner = node2.content;
  if (depth < to - 1)
    inner = closeRange(inner, side, from3, to, depth + 1, openEnd);
  if (depth >= from3)
    inner = side < 0 ? node2.contentMatchAt(0).fillBefore(inner, fragment.childCount > 1 || openEnd <= depth).append(inner) : inner.append(node2.contentMatchAt(node2.childCount).fillBefore(Fragment.empty, true));
  return fragment.replaceChild(side < 0 ? 0 : fragment.childCount - 1, node2.copy(inner));
}
function closeSlice(slice3, openStart, openEnd) {
  if (openStart < slice3.openStart)
    slice3 = new Slice(closeRange(slice3.content, -1, openStart, slice3.openStart, 0, slice3.openEnd), openStart, slice3.openEnd);
  if (openEnd < slice3.openEnd)
    slice3 = new Slice(closeRange(slice3.content, 1, openEnd, slice3.openEnd, 0, 0), slice3.openStart, openEnd);
  return slice3;
}
const wrapMap = {
  thead: ["table"],
  tbody: ["table"],
  tfoot: ["table"],
  caption: ["table"],
  colgroup: ["table"],
  col: ["table", "colgroup"],
  tr: ["table", "tbody"],
  td: ["table", "tbody", "tr"],
  th: ["table", "tbody", "tr"]
};
let _detachedDoc = null;
function detachedDoc() {
  return _detachedDoc || (_detachedDoc = document.implementation.createHTMLDocument("title"));
}
function readHTML(html) {
  let metas = /^(\s*<meta [^>]*>)*/.exec(html);
  if (metas)
    html = html.slice(metas[0].length);
  let elt = detachedDoc().createElement("div");
  let firstTag = /<([a-z][^>\s]+)/i.exec(html), wrap2;
  if (wrap2 = firstTag && wrapMap[firstTag[1].toLowerCase()])
    html = wrap2.map((n2) => "<" + n2 + ">").join("") + html + wrap2.map((n2) => "</" + n2 + ">").reverse().join("");
  elt.innerHTML = html;
  if (wrap2)
    for (let i3 = 0; i3 < wrap2.length; i3++)
      elt = elt.querySelector(wrap2[i3]) || elt;
  return elt;
}
function restoreReplacedSpaces(dom) {
  let nodes = dom.querySelectorAll(chrome$1 ? "span:not([class]):not([style])" : "span.Apple-converted-space");
  for (let i3 = 0; i3 < nodes.length; i3++) {
    let node2 = nodes[i3];
    if (node2.childNodes.length == 1 && node2.textContent == "\xA0" && node2.parentNode)
      node2.parentNode.replaceChild(dom.ownerDocument.createTextNode(" "), node2);
  }
}
function addContext(slice3, context) {
  if (!slice3.size)
    return slice3;
  let schema = slice3.content.firstChild.type.schema, array;
  try {
    array = JSON.parse(context);
  } catch (e3) {
    return slice3;
  }
  let { content, openStart, openEnd } = slice3;
  for (let i3 = array.length - 2; i3 >= 0; i3 -= 2) {
    let type = schema.nodes[array[i3]];
    if (!type || type.hasRequiredAttrs())
      break;
    content = Fragment.from(type.create(array[i3 + 1], content));
    openStart++;
    openEnd++;
  }
  return new Slice(content, openStart, openEnd);
}
const handlers = {};
const editHandlers = {};
const passiveHandlers = { touchstart: true, touchmove: true };
class InputState {
  constructor() {
    this.shiftKey = false;
    this.mouseDown = null;
    this.lastKeyCode = null;
    this.lastKeyCodeTime = 0;
    this.lastClick = { time: 0, x: 0, y: 0, type: "" };
    this.lastSelectionOrigin = null;
    this.lastSelectionTime = 0;
    this.lastIOSEnter = 0;
    this.lastIOSEnterFallbackTimeout = -1;
    this.lastFocus = 0;
    this.lastTouch = 0;
    this.lastAndroidDelete = 0;
    this.composing = false;
    this.composingTimeout = -1;
    this.compositionNodes = [];
    this.compositionEndedAt = -2e8;
    this.domChangeCount = 0;
    this.eventHandlers = /* @__PURE__ */ Object.create(null);
    this.hideSelectionGuard = null;
  }
}
function initInput(view) {
  for (let event in handlers) {
    let handler = handlers[event];
    view.dom.addEventListener(event, view.input.eventHandlers[event] = (event2) => {
      if (eventBelongsToView(view, event2) && !runCustomHandler(view, event2) && (view.editable || !(event2.type in editHandlers)))
        handler(view, event2);
    }, passiveHandlers[event] ? { passive: true } : void 0);
  }
  if (safari)
    view.dom.addEventListener("input", () => null);
  ensureListeners(view);
}
function setSelectionOrigin(view, origin) {
  view.input.lastSelectionOrigin = origin;
  view.input.lastSelectionTime = Date.now();
}
function destroyInput(view) {
  view.domObserver.stop();
  for (let type in view.input.eventHandlers)
    view.dom.removeEventListener(type, view.input.eventHandlers[type]);
  clearTimeout(view.input.composingTimeout);
  clearTimeout(view.input.lastIOSEnterFallbackTimeout);
}
function ensureListeners(view) {
  view.someProp("handleDOMEvents", (currentHandlers) => {
    for (let type in currentHandlers)
      if (!view.input.eventHandlers[type])
        view.dom.addEventListener(type, view.input.eventHandlers[type] = (event) => runCustomHandler(view, event));
  });
}
function runCustomHandler(view, event) {
  return view.someProp("handleDOMEvents", (handlers2) => {
    let handler = handlers2[event.type];
    return handler ? handler(view, event) || event.defaultPrevented : false;
  });
}
function eventBelongsToView(view, event) {
  if (!event.bubbles)
    return true;
  if (event.defaultPrevented)
    return false;
  for (let node2 = event.target; node2 != view.dom; node2 = node2.parentNode)
    if (!node2 || node2.nodeType == 11 || node2.pmViewDesc && node2.pmViewDesc.stopEvent(event))
      return false;
  return true;
}
function dispatchEvent(view, event) {
  if (!runCustomHandler(view, event) && handlers[event.type] && (view.editable || !(event.type in editHandlers)))
    handlers[event.type](view, event);
}
editHandlers.keydown = (view, _event) => {
  let event = _event;
  view.input.shiftKey = event.keyCode == 16 || event.shiftKey;
  if (inOrNearComposition(view, event))
    return;
  view.input.lastKeyCode = event.keyCode;
  view.input.lastKeyCodeTime = Date.now();
  if (android && chrome$1 && event.keyCode == 13)
    return;
  if (event.keyCode != 229)
    view.domObserver.forceFlush();
  if (ios && event.keyCode == 13 && !event.ctrlKey && !event.altKey && !event.metaKey) {
    let now2 = Date.now();
    view.input.lastIOSEnter = now2;
    view.input.lastIOSEnterFallbackTimeout = setTimeout(() => {
      if (view.input.lastIOSEnter == now2) {
        view.someProp("handleKeyDown", (f2) => f2(view, keyEvent(13, "Enter")));
        view.input.lastIOSEnter = 0;
      }
    }, 200);
  } else if (view.someProp("handleKeyDown", (f2) => f2(view, event)) || captureKeyDown(view, event)) {
    event.preventDefault();
  } else {
    setSelectionOrigin(view, "key");
  }
};
editHandlers.keyup = (view, event) => {
  if (event.keyCode == 16)
    view.input.shiftKey = false;
};
editHandlers.keypress = (view, _event) => {
  let event = _event;
  if (inOrNearComposition(view, event) || !event.charCode || event.ctrlKey && !event.altKey || mac$2 && event.metaKey)
    return;
  if (view.someProp("handleKeyPress", (f2) => f2(view, event))) {
    event.preventDefault();
    return;
  }
  let sel = view.state.selection;
  if (!(sel instanceof TextSelection) || !sel.$from.sameParent(sel.$to)) {
    let text2 = String.fromCharCode(event.charCode);
    if (!/[\r\n]/.test(text2) && !view.someProp("handleTextInput", (f2) => f2(view, sel.$from.pos, sel.$to.pos, text2)))
      view.dispatch(view.state.tr.insertText(text2).scrollIntoView());
    event.preventDefault();
  }
};
function eventCoords(event) {
  return { left: event.clientX, top: event.clientY };
}
function isNear(event, click) {
  let dx = click.x - event.clientX, dy = click.y - event.clientY;
  return dx * dx + dy * dy < 100;
}
function runHandlerOnContext(view, propName, pos, inside, event) {
  if (inside == -1)
    return false;
  let $pos = view.state.doc.resolve(inside);
  for (let i3 = $pos.depth + 1; i3 > 0; i3--) {
    if (view.someProp(propName, (f2) => i3 > $pos.depth ? f2(view, pos, $pos.nodeAfter, $pos.before(i3), event, true) : f2(view, pos, $pos.node(i3), $pos.before(i3), event, false)))
      return true;
  }
  return false;
}
function updateSelection(view, selection, origin) {
  if (!view.focused)
    view.focus();
  let tr = view.state.tr.setSelection(selection);
  if (origin == "pointer")
    tr.setMeta("pointer", true);
  view.dispatch(tr);
}
function selectClickedLeaf(view, inside) {
  if (inside == -1)
    return false;
  let $pos = view.state.doc.resolve(inside), node2 = $pos.nodeAfter;
  if (node2 && node2.isAtom && NodeSelection.isSelectable(node2)) {
    updateSelection(view, new NodeSelection($pos), "pointer");
    return true;
  }
  return false;
}
function selectClickedNode(view, inside) {
  if (inside == -1)
    return false;
  let sel = view.state.selection, selectedNode, selectAt;
  if (sel instanceof NodeSelection)
    selectedNode = sel.node;
  let $pos = view.state.doc.resolve(inside);
  for (let i3 = $pos.depth + 1; i3 > 0; i3--) {
    let node2 = i3 > $pos.depth ? $pos.nodeAfter : $pos.node(i3);
    if (NodeSelection.isSelectable(node2)) {
      if (selectedNode && sel.$from.depth > 0 && i3 >= sel.$from.depth && $pos.before(sel.$from.depth + 1) == sel.$from.pos)
        selectAt = $pos.before(sel.$from.depth);
      else
        selectAt = $pos.before(i3);
      break;
    }
  }
  if (selectAt != null) {
    updateSelection(view, NodeSelection.create(view.state.doc, selectAt), "pointer");
    return true;
  } else {
    return false;
  }
}
function handleSingleClick(view, pos, inside, event, selectNode) {
  return runHandlerOnContext(view, "handleClickOn", pos, inside, event) || view.someProp("handleClick", (f2) => f2(view, pos, event)) || (selectNode ? selectClickedNode(view, inside) : selectClickedLeaf(view, inside));
}
function handleDoubleClick(view, pos, inside, event) {
  return runHandlerOnContext(view, "handleDoubleClickOn", pos, inside, event) || view.someProp("handleDoubleClick", (f2) => f2(view, pos, event));
}
function handleTripleClick(view, pos, inside, event) {
  return runHandlerOnContext(view, "handleTripleClickOn", pos, inside, event) || view.someProp("handleTripleClick", (f2) => f2(view, pos, event)) || defaultTripleClick(view, inside, event);
}
function defaultTripleClick(view, inside, event) {
  if (event.button != 0)
    return false;
  let doc2 = view.state.doc;
  if (inside == -1) {
    if (doc2.inlineContent) {
      updateSelection(view, TextSelection.create(doc2, 0, doc2.content.size), "pointer");
      return true;
    }
    return false;
  }
  let $pos = doc2.resolve(inside);
  for (let i3 = $pos.depth + 1; i3 > 0; i3--) {
    let node2 = i3 > $pos.depth ? $pos.nodeAfter : $pos.node(i3);
    let nodePos = $pos.before(i3);
    if (node2.inlineContent)
      updateSelection(view, TextSelection.create(doc2, nodePos + 1, nodePos + 1 + node2.content.size), "pointer");
    else if (NodeSelection.isSelectable(node2))
      updateSelection(view, NodeSelection.create(doc2, nodePos), "pointer");
    else
      continue;
    return true;
  }
}
function forceDOMFlush(view) {
  return endComposition(view);
}
const selectNodeModifier = mac$2 ? "metaKey" : "ctrlKey";
handlers.mousedown = (view, _event) => {
  let event = _event;
  view.input.shiftKey = event.shiftKey;
  let flushed = forceDOMFlush(view);
  let now2 = Date.now(), type = "singleClick";
  if (now2 - view.input.lastClick.time < 500 && isNear(event, view.input.lastClick) && !event[selectNodeModifier]) {
    if (view.input.lastClick.type == "singleClick")
      type = "doubleClick";
    else if (view.input.lastClick.type == "doubleClick")
      type = "tripleClick";
  }
  view.input.lastClick = { time: now2, x: event.clientX, y: event.clientY, type };
  let pos = view.posAtCoords(eventCoords(event));
  if (!pos)
    return;
  if (type == "singleClick") {
    if (view.input.mouseDown)
      view.input.mouseDown.done();
    view.input.mouseDown = new MouseDown(view, pos, event, !!flushed);
  } else if ((type == "doubleClick" ? handleDoubleClick : handleTripleClick)(view, pos.pos, pos.inside, event)) {
    event.preventDefault();
  } else {
    setSelectionOrigin(view, "pointer");
  }
};
class MouseDown {
  constructor(view, pos, event, flushed) {
    this.view = view;
    this.pos = pos;
    this.event = event;
    this.flushed = flushed;
    this.delayedSelectionSync = false;
    this.mightDrag = null;
    this.startDoc = view.state.doc;
    this.selectNode = !!event[selectNodeModifier];
    this.allowDefault = event.shiftKey;
    let targetNode, targetPos;
    if (pos.inside > -1) {
      targetNode = view.state.doc.nodeAt(pos.inside);
      targetPos = pos.inside;
    } else {
      let $pos = view.state.doc.resolve(pos.pos);
      targetNode = $pos.parent;
      targetPos = $pos.depth ? $pos.before() : 0;
    }
    const target = flushed ? null : event.target;
    const targetDesc = target ? view.docView.nearestDesc(target, true) : null;
    this.target = targetDesc ? targetDesc.dom : null;
    let { selection } = view.state;
    if (event.button == 0 && targetNode.type.spec.draggable && targetNode.type.spec.selectable !== false || selection instanceof NodeSelection && selection.from <= targetPos && selection.to > targetPos)
      this.mightDrag = {
        node: targetNode,
        pos: targetPos,
        addAttr: !!(this.target && !this.target.draggable),
        setUneditable: !!(this.target && gecko && !this.target.hasAttribute("contentEditable"))
      };
    if (this.target && this.mightDrag && (this.mightDrag.addAttr || this.mightDrag.setUneditable)) {
      this.view.domObserver.stop();
      if (this.mightDrag.addAttr)
        this.target.draggable = true;
      if (this.mightDrag.setUneditable)
        setTimeout(() => {
          if (this.view.input.mouseDown == this)
            this.target.setAttribute("contentEditable", "false");
        }, 20);
      this.view.domObserver.start();
    }
    view.root.addEventListener("mouseup", this.up = this.up.bind(this));
    view.root.addEventListener("mousemove", this.move = this.move.bind(this));
    setSelectionOrigin(view, "pointer");
  }
  done() {
    this.view.root.removeEventListener("mouseup", this.up);
    this.view.root.removeEventListener("mousemove", this.move);
    if (this.mightDrag && this.target) {
      this.view.domObserver.stop();
      if (this.mightDrag.addAttr)
        this.target.removeAttribute("draggable");
      if (this.mightDrag.setUneditable)
        this.target.removeAttribute("contentEditable");
      this.view.domObserver.start();
    }
    if (this.delayedSelectionSync)
      setTimeout(() => selectionToDOM(this.view));
    this.view.input.mouseDown = null;
  }
  up(event) {
    this.done();
    if (!this.view.dom.contains(event.target))
      return;
    let pos = this.pos;
    if (this.view.state.doc != this.startDoc)
      pos = this.view.posAtCoords(eventCoords(event));
    this.updateAllowDefault(event);
    if (this.allowDefault || !pos) {
      setSelectionOrigin(this.view, "pointer");
    } else if (handleSingleClick(this.view, pos.pos, pos.inside, event, this.selectNode)) {
      event.preventDefault();
    } else if (event.button == 0 && (this.flushed || safari && this.mightDrag && !this.mightDrag.node.isAtom || chrome$1 && !this.view.state.selection.visible && Math.min(Math.abs(pos.pos - this.view.state.selection.from), Math.abs(pos.pos - this.view.state.selection.to)) <= 2)) {
      updateSelection(this.view, Selection.near(this.view.state.doc.resolve(pos.pos)), "pointer");
      event.preventDefault();
    } else {
      setSelectionOrigin(this.view, "pointer");
    }
  }
  move(event) {
    this.updateAllowDefault(event);
    setSelectionOrigin(this.view, "pointer");
    if (event.buttons == 0)
      this.done();
  }
  updateAllowDefault(event) {
    if (!this.allowDefault && (Math.abs(this.event.x - event.clientX) > 4 || Math.abs(this.event.y - event.clientY) > 4))
      this.allowDefault = true;
  }
}
handlers.touchstart = (view) => {
  view.input.lastTouch = Date.now();
  forceDOMFlush(view);
  setSelectionOrigin(view, "pointer");
};
handlers.touchmove = (view) => {
  view.input.lastTouch = Date.now();
  setSelectionOrigin(view, "pointer");
};
handlers.contextmenu = (view) => forceDOMFlush(view);
function inOrNearComposition(view, event) {
  if (view.composing)
    return true;
  if (safari && Math.abs(event.timeStamp - view.input.compositionEndedAt) < 500) {
    view.input.compositionEndedAt = -2e8;
    return true;
  }
  return false;
}
const timeoutComposition = android ? 5e3 : -1;
editHandlers.compositionstart = editHandlers.compositionupdate = (view) => {
  if (!view.composing) {
    view.domObserver.flush();
    let { state } = view, $pos = state.selection.$from;
    if (state.selection.empty && (state.storedMarks || !$pos.textOffset && $pos.parentOffset && $pos.nodeBefore.marks.some((m4) => m4.type.spec.inclusive === false))) {
      view.markCursor = view.state.storedMarks || $pos.marks();
      endComposition(view, true);
      view.markCursor = null;
    } else {
      endComposition(view);
      if (gecko && state.selection.empty && $pos.parentOffset && !$pos.textOffset && $pos.nodeBefore.marks.length) {
        let sel = view.domSelectionRange();
        for (let node2 = sel.focusNode, offset2 = sel.focusOffset; node2 && node2.nodeType == 1 && offset2 != 0; ) {
          let before = offset2 < 0 ? node2.lastChild : node2.childNodes[offset2 - 1];
          if (!before)
            break;
          if (before.nodeType == 3) {
            view.domSelection().collapse(before, before.nodeValue.length);
            break;
          } else {
            node2 = before;
            offset2 = -1;
          }
        }
      }
    }
    view.input.composing = true;
  }
  scheduleComposeEnd(view, timeoutComposition);
};
editHandlers.compositionend = (view, event) => {
  if (view.composing) {
    view.input.composing = false;
    view.input.compositionEndedAt = event.timeStamp;
    scheduleComposeEnd(view, 20);
  }
};
function scheduleComposeEnd(view, delay) {
  clearTimeout(view.input.composingTimeout);
  if (delay > -1)
    view.input.composingTimeout = setTimeout(() => endComposition(view), delay);
}
function clearComposition(view) {
  if (view.composing) {
    view.input.composing = false;
    view.input.compositionEndedAt = timestampFromCustomEvent();
  }
  while (view.input.compositionNodes.length > 0)
    view.input.compositionNodes.pop().markParentsDirty();
}
function timestampFromCustomEvent() {
  let event = document.createEvent("Event");
  event.initEvent("event", true, true);
  return event.timeStamp;
}
function endComposition(view, forceUpdate = false) {
  if (android && view.domObserver.flushingSoon >= 0)
    return;
  view.domObserver.forceFlush();
  clearComposition(view);
  if (forceUpdate || view.docView && view.docView.dirty) {
    let sel = selectionFromDOM(view);
    if (sel && !sel.eq(view.state.selection))
      view.dispatch(view.state.tr.setSelection(sel));
    else
      view.updateState(view.state);
    return true;
  }
  return false;
}
function captureCopy(view, dom) {
  if (!view.dom.parentNode)
    return;
  let wrap2 = view.dom.parentNode.appendChild(document.createElement("div"));
  wrap2.appendChild(dom);
  wrap2.style.cssText = "position: fixed; left: -10000px; top: 10px";
  let sel = getSelection(), range2 = document.createRange();
  range2.selectNodeContents(dom);
  view.dom.blur();
  sel.removeAllRanges();
  sel.addRange(range2);
  setTimeout(() => {
    if (wrap2.parentNode)
      wrap2.parentNode.removeChild(wrap2);
    view.focus();
  }, 50);
}
const brokenClipboardAPI = ie$1 && ie_version < 15 || ios && webkit_version < 604;
handlers.copy = editHandlers.cut = (view, _event) => {
  let event = _event;
  let sel = view.state.selection, cut = event.type == "cut";
  if (sel.empty)
    return;
  let data = brokenClipboardAPI ? null : event.clipboardData;
  let slice3 = sel.content(), { dom, text: text2 } = serializeForClipboard(view, slice3);
  if (data) {
    event.preventDefault();
    data.clearData();
    data.setData("text/html", dom.innerHTML);
    data.setData("text/plain", text2);
  } else {
    captureCopy(view, dom);
  }
  if (cut)
    view.dispatch(view.state.tr.deleteSelection().scrollIntoView().setMeta("uiEvent", "cut"));
};
function sliceSingleNode(slice3) {
  return slice3.openStart == 0 && slice3.openEnd == 0 && slice3.content.childCount == 1 ? slice3.content.firstChild : null;
}
function capturePaste(view, event) {
  if (!view.dom.parentNode)
    return;
  let plainText = view.input.shiftKey || view.state.selection.$from.parent.type.spec.code;
  let target = view.dom.parentNode.appendChild(document.createElement(plainText ? "textarea" : "div"));
  if (!plainText)
    target.contentEditable = "true";
  target.style.cssText = "position: fixed; left: -10000px; top: 10px";
  target.focus();
  setTimeout(() => {
    view.focus();
    if (target.parentNode)
      target.parentNode.removeChild(target);
    if (plainText)
      doPaste(view, target.value, null, view.input.shiftKey, event);
    else
      doPaste(view, target.textContent, target.innerHTML, view.input.shiftKey, event);
  }, 50);
}
function doPaste(view, text2, html, preferPlain, event) {
  let slice3 = parseFromClipboard(view, text2, html, preferPlain, view.state.selection.$from);
  if (view.someProp("handlePaste", (f2) => f2(view, event, slice3 || Slice.empty)))
    return true;
  if (!slice3)
    return false;
  let singleNode = sliceSingleNode(slice3);
  let tr = singleNode ? view.state.tr.replaceSelectionWith(singleNode, view.input.shiftKey) : view.state.tr.replaceSelection(slice3);
  view.dispatch(tr.scrollIntoView().setMeta("paste", true).setMeta("uiEvent", "paste"));
  return true;
}
editHandlers.paste = (view, _event) => {
  let event = _event;
  if (view.composing && !android)
    return;
  let data = brokenClipboardAPI ? null : event.clipboardData;
  if (data && doPaste(view, data.getData("text/plain"), data.getData("text/html"), view.input.shiftKey, event))
    event.preventDefault();
  else
    capturePaste(view, event);
};
class Dragging {
  constructor(slice3, move) {
    this.slice = slice3;
    this.move = move;
  }
}
const dragCopyModifier = mac$2 ? "altKey" : "ctrlKey";
handlers.dragstart = (view, _event) => {
  let event = _event;
  let mouseDown = view.input.mouseDown;
  if (mouseDown)
    mouseDown.done();
  if (!event.dataTransfer)
    return;
  let sel = view.state.selection;
  let pos = sel.empty ? null : view.posAtCoords(eventCoords(event));
  if (pos && pos.pos >= sel.from && pos.pos <= (sel instanceof NodeSelection ? sel.to - 1 : sel.to))
    ;
  else if (mouseDown && mouseDown.mightDrag) {
    view.dispatch(view.state.tr.setSelection(NodeSelection.create(view.state.doc, mouseDown.mightDrag.pos)));
  } else if (event.target && event.target.nodeType == 1) {
    let desc = view.docView.nearestDesc(event.target, true);
    if (desc && desc.node.type.spec.draggable && desc != view.docView)
      view.dispatch(view.state.tr.setSelection(NodeSelection.create(view.state.doc, desc.posBefore)));
  }
  let slice3 = view.state.selection.content(), { dom, text: text2 } = serializeForClipboard(view, slice3);
  event.dataTransfer.clearData();
  event.dataTransfer.setData(brokenClipboardAPI ? "Text" : "text/html", dom.innerHTML);
  event.dataTransfer.effectAllowed = "copyMove";
  if (!brokenClipboardAPI)
    event.dataTransfer.setData("text/plain", text2);
  view.dragging = new Dragging(slice3, !event[dragCopyModifier]);
};
handlers.dragend = (view) => {
  let dragging = view.dragging;
  window.setTimeout(() => {
    if (view.dragging == dragging)
      view.dragging = null;
  }, 50);
};
editHandlers.dragover = editHandlers.dragenter = (_2, e3) => e3.preventDefault();
editHandlers.drop = (view, _event) => {
  let event = _event;
  let dragging = view.dragging;
  view.dragging = null;
  if (!event.dataTransfer)
    return;
  let eventPos = view.posAtCoords(eventCoords(event));
  if (!eventPos)
    return;
  let $mouse = view.state.doc.resolve(eventPos.pos);
  let slice3 = dragging && dragging.slice;
  if (slice3) {
    view.someProp("transformPasted", (f2) => {
      slice3 = f2(slice3, view);
    });
  } else {
    slice3 = parseFromClipboard(view, event.dataTransfer.getData(brokenClipboardAPI ? "Text" : "text/plain"), brokenClipboardAPI ? null : event.dataTransfer.getData("text/html"), false, $mouse);
  }
  let move = !!(dragging && !event[dragCopyModifier]);
  if (view.someProp("handleDrop", (f2) => f2(view, event, slice3 || Slice.empty, move))) {
    event.preventDefault();
    return;
  }
  if (!slice3)
    return;
  event.preventDefault();
  let insertPos = slice3 ? dropPoint(view.state.doc, $mouse.pos, slice3) : $mouse.pos;
  if (insertPos == null)
    insertPos = $mouse.pos;
  let tr = view.state.tr;
  if (move)
    tr.deleteSelection();
  let pos = tr.mapping.map(insertPos);
  let isNode2 = slice3.openStart == 0 && slice3.openEnd == 0 && slice3.content.childCount == 1;
  let beforeInsert = tr.doc;
  if (isNode2)
    tr.replaceRangeWith(pos, pos, slice3.content.firstChild);
  else
    tr.replaceRange(pos, pos, slice3);
  if (tr.doc.eq(beforeInsert))
    return;
  let $pos = tr.doc.resolve(pos);
  if (isNode2 && NodeSelection.isSelectable(slice3.content.firstChild) && $pos.nodeAfter && $pos.nodeAfter.sameMarkup(slice3.content.firstChild)) {
    tr.setSelection(new NodeSelection($pos));
  } else {
    let end2 = tr.mapping.map(insertPos);
    tr.mapping.maps[tr.mapping.maps.length - 1].forEach((_from, _to, _newFrom, newTo) => end2 = newTo);
    tr.setSelection(selectionBetween(view, $pos, tr.doc.resolve(end2)));
  }
  view.focus();
  view.dispatch(tr.setMeta("uiEvent", "drop"));
};
handlers.focus = (view) => {
  view.input.lastFocus = Date.now();
  if (!view.focused) {
    view.domObserver.stop();
    view.dom.classList.add("ProseMirror-focused");
    view.domObserver.start();
    view.focused = true;
    setTimeout(() => {
      if (view.docView && view.hasFocus() && !view.domObserver.currentSelection.eq(view.domSelectionRange()))
        selectionToDOM(view);
    }, 20);
  }
};
handlers.blur = (view, _event) => {
  let event = _event;
  if (view.focused) {
    view.domObserver.stop();
    view.dom.classList.remove("ProseMirror-focused");
    view.domObserver.start();
    if (event.relatedTarget && view.dom.contains(event.relatedTarget))
      view.domObserver.currentSelection.clear();
    view.focused = false;
  }
};
handlers.beforeinput = (view, _event) => {
  let event = _event;
  if (chrome$1 && android && event.inputType == "deleteContentBackward") {
    view.domObserver.flushSoon();
    let { domChangeCount } = view.input;
    setTimeout(() => {
      if (view.input.domChangeCount != domChangeCount)
        return;
      view.dom.blur();
      view.focus();
      if (view.someProp("handleKeyDown", (f2) => f2(view, keyEvent(8, "Backspace"))))
        return;
      let { $cursor } = view.state.selection;
      if ($cursor && $cursor.pos > 0)
        view.dispatch(view.state.tr.delete($cursor.pos - 1, $cursor.pos).scrollIntoView());
    }, 50);
  }
};
for (let prop in editHandlers)
  handlers[prop] = editHandlers[prop];
function compareObjs(a4, b3) {
  if (a4 == b3)
    return true;
  for (let p2 in a4)
    if (a4[p2] !== b3[p2])
      return false;
  for (let p2 in b3)
    if (!(p2 in a4))
      return false;
  return true;
}
class WidgetType {
  constructor(toDOM, spec) {
    this.toDOM = toDOM;
    this.spec = spec || noSpec;
    this.side = this.spec.side || 0;
  }
  map(mapping, span, offset2, oldOffset) {
    let { pos, deleted } = mapping.mapResult(span.from + oldOffset, this.side < 0 ? -1 : 1);
    return deleted ? null : new Decoration(pos - offset2, pos - offset2, this);
  }
  valid() {
    return true;
  }
  eq(other) {
    return this == other || other instanceof WidgetType && (this.spec.key && this.spec.key == other.spec.key || this.toDOM == other.toDOM && compareObjs(this.spec, other.spec));
  }
  destroy(node2) {
    if (this.spec.destroy)
      this.spec.destroy(node2);
  }
}
class InlineType {
  constructor(attrs, spec) {
    this.attrs = attrs;
    this.spec = spec || noSpec;
  }
  map(mapping, span, offset2, oldOffset) {
    let from3 = mapping.map(span.from + oldOffset, this.spec.inclusiveStart ? -1 : 1) - offset2;
    let to = mapping.map(span.to + oldOffset, this.spec.inclusiveEnd ? 1 : -1) - offset2;
    return from3 >= to ? null : new Decoration(from3, to, this);
  }
  valid(_2, span) {
    return span.from < span.to;
  }
  eq(other) {
    return this == other || other instanceof InlineType && compareObjs(this.attrs, other.attrs) && compareObjs(this.spec, other.spec);
  }
  static is(span) {
    return span.type instanceof InlineType;
  }
  destroy() {
  }
}
class NodeType {
  constructor(attrs, spec) {
    this.attrs = attrs;
    this.spec = spec || noSpec;
  }
  map(mapping, span, offset2, oldOffset) {
    let from3 = mapping.mapResult(span.from + oldOffset, 1);
    if (from3.deleted)
      return null;
    let to = mapping.mapResult(span.to + oldOffset, -1);
    if (to.deleted || to.pos <= from3.pos)
      return null;
    return new Decoration(from3.pos - offset2, to.pos - offset2, this);
  }
  valid(node2, span) {
    let { index: index2, offset: offset2 } = node2.content.findIndex(span.from), child;
    return offset2 == span.from && !(child = node2.child(index2)).isText && offset2 + child.nodeSize == span.to;
  }
  eq(other) {
    return this == other || other instanceof NodeType && compareObjs(this.attrs, other.attrs) && compareObjs(this.spec, other.spec);
  }
  destroy() {
  }
}
class Decoration {
  constructor(from3, to, type) {
    this.from = from3;
    this.to = to;
    this.type = type;
  }
  copy(from3, to) {
    return new Decoration(from3, to, this.type);
  }
  eq(other, offset2 = 0) {
    return this.type.eq(other.type) && this.from + offset2 == other.from && this.to + offset2 == other.to;
  }
  map(mapping, offset2, oldOffset) {
    return this.type.map(mapping, this, offset2, oldOffset);
  }
  static widget(pos, toDOM, spec) {
    return new Decoration(pos, pos, new WidgetType(toDOM, spec));
  }
  static inline(from3, to, attrs, spec) {
    return new Decoration(from3, to, new InlineType(attrs, spec));
  }
  static node(from3, to, attrs, spec) {
    return new Decoration(from3, to, new NodeType(attrs, spec));
  }
  get spec() {
    return this.type.spec;
  }
  get inline() {
    return this.type instanceof InlineType;
  }
}
const none = [], noSpec = {};
class DecorationSet {
  constructor(local, children) {
    this.local = local.length ? local : none;
    this.children = children.length ? children : none;
  }
  static create(doc2, decorations) {
    return decorations.length ? buildTree(decorations, doc2, 0, noSpec) : empty;
  }
  find(start2, end2, predicate) {
    let result = [];
    this.findInner(start2 == null ? 0 : start2, end2 == null ? 1e9 : end2, result, 0, predicate);
    return result;
  }
  findInner(start2, end2, result, offset2, predicate) {
    for (let i3 = 0; i3 < this.local.length; i3++) {
      let span = this.local[i3];
      if (span.from <= end2 && span.to >= start2 && (!predicate || predicate(span.spec)))
        result.push(span.copy(span.from + offset2, span.to + offset2));
    }
    for (let i3 = 0; i3 < this.children.length; i3 += 3) {
      if (this.children[i3] < end2 && this.children[i3 + 1] > start2) {
        let childOff = this.children[i3] + 1;
        this.children[i3 + 2].findInner(start2 - childOff, end2 - childOff, result, offset2 + childOff, predicate);
      }
    }
  }
  map(mapping, doc2, options) {
    if (this == empty || mapping.maps.length == 0)
      return this;
    return this.mapInner(mapping, doc2, 0, 0, options || noSpec);
  }
  mapInner(mapping, node2, offset2, oldOffset, options) {
    let newLocal;
    for (let i3 = 0; i3 < this.local.length; i3++) {
      let mapped = this.local[i3].map(mapping, offset2, oldOffset);
      if (mapped && mapped.type.valid(node2, mapped))
        (newLocal || (newLocal = [])).push(mapped);
      else if (options.onRemove)
        options.onRemove(this.local[i3].spec);
    }
    if (this.children.length)
      return mapChildren(this.children, newLocal || [], mapping, node2, offset2, oldOffset, options);
    else
      return newLocal ? new DecorationSet(newLocal.sort(byPos), none) : empty;
  }
  add(doc2, decorations) {
    if (!decorations.length)
      return this;
    if (this == empty)
      return DecorationSet.create(doc2, decorations);
    return this.addInner(doc2, decorations, 0);
  }
  addInner(doc2, decorations, offset2) {
    let children, childIndex = 0;
    doc2.forEach((childNode, childOffset) => {
      let baseOffset = childOffset + offset2, found2;
      if (!(found2 = takeSpansForNode(decorations, childNode, baseOffset)))
        return;
      if (!children)
        children = this.children.slice();
      while (childIndex < children.length && children[childIndex] < childOffset)
        childIndex += 3;
      if (children[childIndex] == childOffset)
        children[childIndex + 2] = children[childIndex + 2].addInner(childNode, found2, baseOffset + 1);
      else
        children.splice(childIndex, 0, childOffset, childOffset + childNode.nodeSize, buildTree(found2, childNode, baseOffset + 1, noSpec));
      childIndex += 3;
    });
    let local = moveSpans(childIndex ? withoutNulls(decorations) : decorations, -offset2);
    for (let i3 = 0; i3 < local.length; i3++)
      if (!local[i3].type.valid(doc2, local[i3]))
        local.splice(i3--, 1);
    return new DecorationSet(local.length ? this.local.concat(local).sort(byPos) : this.local, children || this.children);
  }
  remove(decorations) {
    if (decorations.length == 0 || this == empty)
      return this;
    return this.removeInner(decorations, 0);
  }
  removeInner(decorations, offset2) {
    let children = this.children, local = this.local;
    for (let i3 = 0; i3 < children.length; i3 += 3) {
      let found2;
      let from3 = children[i3] + offset2, to = children[i3 + 1] + offset2;
      for (let j2 = 0, span; j2 < decorations.length; j2++)
        if (span = decorations[j2]) {
          if (span.from > from3 && span.to < to) {
            decorations[j2] = null;
            (found2 || (found2 = [])).push(span);
          }
        }
      if (!found2)
        continue;
      if (children == this.children)
        children = this.children.slice();
      let removed = children[i3 + 2].removeInner(found2, from3 + 1);
      if (removed != empty) {
        children[i3 + 2] = removed;
      } else {
        children.splice(i3, 3);
        i3 -= 3;
      }
    }
    if (local.length) {
      for (let i3 = 0, span; i3 < decorations.length; i3++)
        if (span = decorations[i3]) {
          for (let j2 = 0; j2 < local.length; j2++)
            if (local[j2].eq(span, offset2)) {
              if (local == this.local)
                local = this.local.slice();
              local.splice(j2--, 1);
            }
        }
    }
    if (children == this.children && local == this.local)
      return this;
    return local.length || children.length ? new DecorationSet(local, children) : empty;
  }
  forChild(offset2, node2) {
    if (this == empty)
      return this;
    if (node2.isLeaf)
      return DecorationSet.empty;
    let child, local;
    for (let i3 = 0; i3 < this.children.length; i3 += 3)
      if (this.children[i3] >= offset2) {
        if (this.children[i3] == offset2)
          child = this.children[i3 + 2];
        break;
      }
    let start2 = offset2 + 1, end2 = start2 + node2.content.size;
    for (let i3 = 0; i3 < this.local.length; i3++) {
      let dec = this.local[i3];
      if (dec.from < end2 && dec.to > start2 && dec.type instanceof InlineType) {
        let from3 = Math.max(start2, dec.from) - start2, to = Math.min(end2, dec.to) - start2;
        if (from3 < to)
          (local || (local = [])).push(dec.copy(from3, to));
      }
    }
    if (local) {
      let localSet = new DecorationSet(local.sort(byPos), none);
      return child ? new DecorationGroup([localSet, child]) : localSet;
    }
    return child || empty;
  }
  eq(other) {
    if (this == other)
      return true;
    if (!(other instanceof DecorationSet) || this.local.length != other.local.length || this.children.length != other.children.length)
      return false;
    for (let i3 = 0; i3 < this.local.length; i3++)
      if (!this.local[i3].eq(other.local[i3]))
        return false;
    for (let i3 = 0; i3 < this.children.length; i3 += 3)
      if (this.children[i3] != other.children[i3] || this.children[i3 + 1] != other.children[i3 + 1] || !this.children[i3 + 2].eq(other.children[i3 + 2]))
        return false;
    return true;
  }
  locals(node2) {
    return removeOverlap(this.localsInner(node2));
  }
  localsInner(node2) {
    if (this == empty)
      return none;
    if (node2.inlineContent || !this.local.some(InlineType.is))
      return this.local;
    let result = [];
    for (let i3 = 0; i3 < this.local.length; i3++) {
      if (!(this.local[i3].type instanceof InlineType))
        result.push(this.local[i3]);
    }
    return result;
  }
}
DecorationSet.empty = new DecorationSet([], []);
DecorationSet.removeOverlap = removeOverlap;
const empty = DecorationSet.empty;
class DecorationGroup {
  constructor(members) {
    this.members = members;
  }
  map(mapping, doc2) {
    const mappedDecos = this.members.map((member) => member.map(mapping, doc2, noSpec));
    return DecorationGroup.from(mappedDecos);
  }
  forChild(offset2, child) {
    if (child.isLeaf)
      return DecorationSet.empty;
    let found2 = [];
    for (let i3 = 0; i3 < this.members.length; i3++) {
      let result = this.members[i3].forChild(offset2, child);
      if (result == empty)
        continue;
      if (result instanceof DecorationGroup)
        found2 = found2.concat(result.members);
      else
        found2.push(result);
    }
    return DecorationGroup.from(found2);
  }
  eq(other) {
    if (!(other instanceof DecorationGroup) || other.members.length != this.members.length)
      return false;
    for (let i3 = 0; i3 < this.members.length; i3++)
      if (!this.members[i3].eq(other.members[i3]))
        return false;
    return true;
  }
  locals(node2) {
    let result, sorted = true;
    for (let i3 = 0; i3 < this.members.length; i3++) {
      let locals = this.members[i3].localsInner(node2);
      if (!locals.length)
        continue;
      if (!result) {
        result = locals;
      } else {
        if (sorted) {
          result = result.slice();
          sorted = false;
        }
        for (let j2 = 0; j2 < locals.length; j2++)
          result.push(locals[j2]);
      }
    }
    return result ? removeOverlap(sorted ? result : result.sort(byPos)) : none;
  }
  static from(members) {
    switch (members.length) {
      case 0:
        return empty;
      case 1:
        return members[0];
      default:
        return new DecorationGroup(members.every((m4) => m4 instanceof DecorationSet) ? members : members.reduce((r2, m4) => r2.concat(m4 instanceof DecorationSet ? m4 : m4.members), []));
    }
  }
}
function mapChildren(oldChildren, newLocal, mapping, node2, offset2, oldOffset, options) {
  let children = oldChildren.slice();
  for (let i3 = 0, baseOffset = oldOffset; i3 < mapping.maps.length; i3++) {
    let moved2 = 0;
    mapping.maps[i3].forEach((oldStart, oldEnd, newStart, newEnd) => {
      let dSize = newEnd - newStart - (oldEnd - oldStart);
      for (let i4 = 0; i4 < children.length; i4 += 3) {
        let end2 = children[i4 + 1];
        if (end2 < 0 || oldStart > end2 + baseOffset - moved2)
          continue;
        let start2 = children[i4] + baseOffset - moved2;
        if (oldEnd >= start2) {
          children[i4 + 1] = oldStart <= start2 ? -2 : -1;
        } else if (newStart >= offset2 && dSize) {
          children[i4] += dSize;
          children[i4 + 1] += dSize;
        }
      }
      moved2 += dSize;
    });
    baseOffset = mapping.maps[i3].map(baseOffset, -1);
  }
  let mustRebuild = false;
  for (let i3 = 0; i3 < children.length; i3 += 3)
    if (children[i3 + 1] < 0) {
      if (children[i3 + 1] == -2) {
        mustRebuild = true;
        children[i3 + 1] = -1;
        continue;
      }
      let from3 = mapping.map(oldChildren[i3] + oldOffset), fromLocal = from3 - offset2;
      if (fromLocal < 0 || fromLocal >= node2.content.size) {
        mustRebuild = true;
        continue;
      }
      let to = mapping.map(oldChildren[i3 + 1] + oldOffset, -1), toLocal = to - offset2;
      let { index: index2, offset: childOffset } = node2.content.findIndex(fromLocal);
      let childNode = node2.maybeChild(index2);
      if (childNode && childOffset == fromLocal && childOffset + childNode.nodeSize == toLocal) {
        let mapped = children[i3 + 2].mapInner(mapping, childNode, from3 + 1, oldChildren[i3] + oldOffset + 1, options);
        if (mapped != empty) {
          children[i3] = fromLocal;
          children[i3 + 1] = toLocal;
          children[i3 + 2] = mapped;
        } else {
          children[i3 + 1] = -2;
          mustRebuild = true;
        }
      } else {
        mustRebuild = true;
      }
    }
  if (mustRebuild) {
    let decorations = mapAndGatherRemainingDecorations(children, oldChildren, newLocal, mapping, offset2, oldOffset, options);
    let built = buildTree(decorations, node2, 0, options);
    newLocal = built.local;
    for (let i3 = 0; i3 < children.length; i3 += 3)
      if (children[i3 + 1] < 0) {
        children.splice(i3, 3);
        i3 -= 3;
      }
    for (let i3 = 0, j2 = 0; i3 < built.children.length; i3 += 3) {
      let from3 = built.children[i3];
      while (j2 < children.length && children[j2] < from3)
        j2 += 3;
      children.splice(j2, 0, built.children[i3], built.children[i3 + 1], built.children[i3 + 2]);
    }
  }
  return new DecorationSet(newLocal.sort(byPos), children);
}
function moveSpans(spans, offset2) {
  if (!offset2 || !spans.length)
    return spans;
  let result = [];
  for (let i3 = 0; i3 < spans.length; i3++) {
    let span = spans[i3];
    result.push(new Decoration(span.from + offset2, span.to + offset2, span.type));
  }
  return result;
}
function mapAndGatherRemainingDecorations(children, oldChildren, decorations, mapping, offset2, oldOffset, options) {
  function gather(set2, oldOffset2) {
    for (let i3 = 0; i3 < set2.local.length; i3++) {
      let mapped = set2.local[i3].map(mapping, offset2, oldOffset2);
      if (mapped)
        decorations.push(mapped);
      else if (options.onRemove)
        options.onRemove(set2.local[i3].spec);
    }
    for (let i3 = 0; i3 < set2.children.length; i3 += 3)
      gather(set2.children[i3 + 2], set2.children[i3] + oldOffset2 + 1);
  }
  for (let i3 = 0; i3 < children.length; i3 += 3)
    if (children[i3 + 1] == -1)
      gather(children[i3 + 2], oldChildren[i3] + oldOffset + 1);
  return decorations;
}
function takeSpansForNode(spans, node2, offset2) {
  if (node2.isLeaf)
    return null;
  let end2 = offset2 + node2.nodeSize, found2 = null;
  for (let i3 = 0, span; i3 < spans.length; i3++) {
    if ((span = spans[i3]) && span.from > offset2 && span.to < end2) {
      (found2 || (found2 = [])).push(span);
      spans[i3] = null;
    }
  }
  return found2;
}
function withoutNulls(array) {
  let result = [];
  for (let i3 = 0; i3 < array.length; i3++)
    if (array[i3] != null)
      result.push(array[i3]);
  return result;
}
function buildTree(spans, node2, offset2, options) {
  let children = [], hasNulls = false;
  node2.forEach((childNode, localStart) => {
    let found2 = takeSpansForNode(spans, childNode, localStart + offset2);
    if (found2) {
      hasNulls = true;
      let subtree = buildTree(found2, childNode, offset2 + localStart + 1, options);
      if (subtree != empty)
        children.push(localStart, localStart + childNode.nodeSize, subtree);
    }
  });
  let locals = moveSpans(hasNulls ? withoutNulls(spans) : spans, -offset2).sort(byPos);
  for (let i3 = 0; i3 < locals.length; i3++)
    if (!locals[i3].type.valid(node2, locals[i3])) {
      if (options.onRemove)
        options.onRemove(locals[i3].spec);
      locals.splice(i3--, 1);
    }
  return locals.length || children.length ? new DecorationSet(locals, children) : empty;
}
function byPos(a4, b3) {
  return a4.from - b3.from || a4.to - b3.to;
}
function removeOverlap(spans) {
  let working = spans;
  for (let i3 = 0; i3 < working.length - 1; i3++) {
    let span = working[i3];
    if (span.from != span.to)
      for (let j2 = i3 + 1; j2 < working.length; j2++) {
        let next2 = working[j2];
        if (next2.from == span.from) {
          if (next2.to != span.to) {
            if (working == spans)
              working = spans.slice();
            working[j2] = next2.copy(next2.from, span.to);
            insertAhead(working, j2 + 1, next2.copy(span.to, next2.to));
          }
          continue;
        } else {
          if (next2.from < span.to) {
            if (working == spans)
              working = spans.slice();
            working[i3] = span.copy(span.from, next2.from);
            insertAhead(working, j2, span.copy(next2.from, span.to));
          }
          break;
        }
      }
  }
  return working;
}
function insertAhead(array, i3, deco) {
  while (i3 < array.length && byPos(deco, array[i3]) > 0)
    i3++;
  array.splice(i3, 0, deco);
}
function viewDecorations(view) {
  let found2 = [];
  view.someProp("decorations", (f2) => {
    let result = f2(view.state);
    if (result && result != empty)
      found2.push(result);
  });
  if (view.cursorWrapper)
    found2.push(DecorationSet.create(view.state.doc, [view.cursorWrapper.deco]));
  return DecorationGroup.from(found2);
}
const observeOptions = {
  childList: true,
  characterData: true,
  characterDataOldValue: true,
  attributes: true,
  attributeOldValue: true,
  subtree: true
};
const useCharData = ie$1 && ie_version <= 11;
class SelectionState {
  constructor() {
    this.anchorNode = null;
    this.anchorOffset = 0;
    this.focusNode = null;
    this.focusOffset = 0;
  }
  set(sel) {
    this.anchorNode = sel.anchorNode;
    this.anchorOffset = sel.anchorOffset;
    this.focusNode = sel.focusNode;
    this.focusOffset = sel.focusOffset;
  }
  clear() {
    this.anchorNode = this.focusNode = null;
  }
  eq(sel) {
    return sel.anchorNode == this.anchorNode && sel.anchorOffset == this.anchorOffset && sel.focusNode == this.focusNode && sel.focusOffset == this.focusOffset;
  }
}
class DOMObserver {
  constructor(view, handleDOMChange) {
    this.view = view;
    this.handleDOMChange = handleDOMChange;
    this.queue = [];
    this.flushingSoon = -1;
    this.observer = null;
    this.currentSelection = new SelectionState();
    this.onCharData = null;
    this.suppressingSelectionUpdates = false;
    this.observer = window.MutationObserver && new window.MutationObserver((mutations) => {
      for (let i3 = 0; i3 < mutations.length; i3++)
        this.queue.push(mutations[i3]);
      if (ie$1 && ie_version <= 11 && mutations.some((m4) => m4.type == "childList" && m4.removedNodes.length || m4.type == "characterData" && m4.oldValue.length > m4.target.nodeValue.length))
        this.flushSoon();
      else
        this.flush();
    });
    if (useCharData) {
      this.onCharData = (e3) => {
        this.queue.push({ target: e3.target, type: "characterData", oldValue: e3.prevValue });
        this.flushSoon();
      };
    }
    this.onSelectionChange = this.onSelectionChange.bind(this);
  }
  flushSoon() {
    if (this.flushingSoon < 0)
      this.flushingSoon = window.setTimeout(() => {
        this.flushingSoon = -1;
        this.flush();
      }, 20);
  }
  forceFlush() {
    if (this.flushingSoon > -1) {
      window.clearTimeout(this.flushingSoon);
      this.flushingSoon = -1;
      this.flush();
    }
  }
  start() {
    if (this.observer) {
      this.observer.takeRecords();
      this.observer.observe(this.view.dom, observeOptions);
    }
    if (this.onCharData)
      this.view.dom.addEventListener("DOMCharacterDataModified", this.onCharData);
    this.connectSelection();
  }
  stop() {
    if (this.observer) {
      let take = this.observer.takeRecords();
      if (take.length) {
        for (let i3 = 0; i3 < take.length; i3++)
          this.queue.push(take[i3]);
        window.setTimeout(() => this.flush(), 20);
      }
      this.observer.disconnect();
    }
    if (this.onCharData)
      this.view.dom.removeEventListener("DOMCharacterDataModified", this.onCharData);
    this.disconnectSelection();
  }
  connectSelection() {
    this.view.dom.ownerDocument.addEventListener("selectionchange", this.onSelectionChange);
  }
  disconnectSelection() {
    this.view.dom.ownerDocument.removeEventListener("selectionchange", this.onSelectionChange);
  }
  suppressSelectionUpdates() {
    this.suppressingSelectionUpdates = true;
    setTimeout(() => this.suppressingSelectionUpdates = false, 50);
  }
  onSelectionChange() {
    if (!hasFocusAndSelection(this.view))
      return;
    if (this.suppressingSelectionUpdates)
      return selectionToDOM(this.view);
    if (ie$1 && ie_version <= 11 && !this.view.state.selection.empty) {
      let sel = this.view.domSelectionRange();
      if (sel.focusNode && isEquivalentPosition(sel.focusNode, sel.focusOffset, sel.anchorNode, sel.anchorOffset))
        return this.flushSoon();
    }
    this.flush();
  }
  setCurSelection() {
    this.currentSelection.set(this.view.domSelectionRange());
  }
  ignoreSelectionChange(sel) {
    if (!sel.focusNode)
      return true;
    let ancestors = /* @__PURE__ */ new Set(), container;
    for (let scan = sel.focusNode; scan; scan = parentNode(scan))
      ancestors.add(scan);
    for (let scan = sel.anchorNode; scan; scan = parentNode(scan))
      if (ancestors.has(scan)) {
        container = scan;
        break;
      }
    let desc = container && this.view.docView.nearestDesc(container);
    if (desc && desc.ignoreMutation({
      type: "selection",
      target: container.nodeType == 3 ? container.parentNode : container
    })) {
      this.setCurSelection();
      return true;
    }
  }
  flush() {
    let { view } = this;
    if (!view.docView || this.flushingSoon > -1)
      return;
    let mutations = this.observer ? this.observer.takeRecords() : [];
    if (this.queue.length) {
      mutations = this.queue.concat(mutations);
      this.queue.length = 0;
    }
    let sel = view.domSelectionRange();
    let newSel = !this.suppressingSelectionUpdates && !this.currentSelection.eq(sel) && hasFocusAndSelection(view) && !this.ignoreSelectionChange(sel);
    let from3 = -1, to = -1, typeOver = false, added = [];
    if (view.editable) {
      for (let i3 = 0; i3 < mutations.length; i3++) {
        let result = this.registerMutation(mutations[i3], added);
        if (result) {
          from3 = from3 < 0 ? result.from : Math.min(result.from, from3);
          to = to < 0 ? result.to : Math.max(result.to, to);
          if (result.typeOver)
            typeOver = true;
        }
      }
    }
    if (gecko && added.length > 1) {
      let brs = added.filter((n2) => n2.nodeName == "BR");
      if (brs.length == 2) {
        let a4 = brs[0], b3 = brs[1];
        if (a4.parentNode && a4.parentNode.parentNode == b3.parentNode)
          b3.remove();
        else
          a4.remove();
      }
    }
    let readSel = null;
    if (from3 < 0 && newSel && view.input.lastFocus > Date.now() - 200 && Math.max(view.input.lastTouch, view.input.lastClick.time) < Date.now() - 300 && selectionCollapsed(sel) && (readSel = selectionFromDOM(view)) && readSel.eq(Selection.near(view.state.doc.resolve(0), 1))) {
      view.input.lastFocus = 0;
      selectionToDOM(view);
      this.currentSelection.set(sel);
      view.scrollToSelection();
    } else if (from3 > -1 || newSel) {
      if (from3 > -1) {
        view.docView.markDirty(from3, to);
        checkCSS(view);
      }
      this.handleDOMChange(from3, to, typeOver, added);
      if (view.docView && view.docView.dirty)
        view.updateState(view.state);
      else if (!this.currentSelection.eq(sel))
        selectionToDOM(view);
      this.currentSelection.set(sel);
    }
  }
  registerMutation(mut, added) {
    if (added.indexOf(mut.target) > -1)
      return null;
    let desc = this.view.docView.nearestDesc(mut.target);
    if (mut.type == "attributes" && (desc == this.view.docView || mut.attributeName == "contenteditable" || mut.attributeName == "style" && !mut.oldValue && !mut.target.getAttribute("style")))
      return null;
    if (!desc || desc.ignoreMutation(mut))
      return null;
    if (mut.type == "childList") {
      for (let i3 = 0; i3 < mut.addedNodes.length; i3++)
        added.push(mut.addedNodes[i3]);
      if (desc.contentDOM && desc.contentDOM != desc.dom && !desc.contentDOM.contains(mut.target))
        return { from: desc.posBefore, to: desc.posAfter };
      let prev2 = mut.previousSibling, next2 = mut.nextSibling;
      if (ie$1 && ie_version <= 11 && mut.addedNodes.length) {
        for (let i3 = 0; i3 < mut.addedNodes.length; i3++) {
          let { previousSibling, nextSibling } = mut.addedNodes[i3];
          if (!previousSibling || Array.prototype.indexOf.call(mut.addedNodes, previousSibling) < 0)
            prev2 = previousSibling;
          if (!nextSibling || Array.prototype.indexOf.call(mut.addedNodes, nextSibling) < 0)
            next2 = nextSibling;
        }
      }
      let fromOffset = prev2 && prev2.parentNode == mut.target ? domIndex(prev2) + 1 : 0;
      let from3 = desc.localPosFromDOM(mut.target, fromOffset, -1);
      let toOffset = next2 && next2.parentNode == mut.target ? domIndex(next2) : mut.target.childNodes.length;
      let to = desc.localPosFromDOM(mut.target, toOffset, 1);
      return { from: from3, to };
    } else if (mut.type == "attributes") {
      return { from: desc.posAtStart - desc.border, to: desc.posAtEnd + desc.border };
    } else {
      return {
        from: desc.posAtStart,
        to: desc.posAtEnd,
        typeOver: mut.target.nodeValue == mut.oldValue
      };
    }
  }
}
let cssChecked = /* @__PURE__ */ new WeakMap();
let cssCheckWarned = false;
function checkCSS(view) {
  if (cssChecked.has(view))
    return;
  cssChecked.set(view, null);
  if (["normal", "nowrap", "pre-line"].indexOf(getComputedStyle(view.dom).whiteSpace) !== -1) {
    view.requiresGeckoHackNode = gecko;
    if (cssCheckWarned)
      return;
    console["warn"]("ProseMirror expects the CSS white-space property to be set, preferably to 'pre-wrap'. It is recommended to load style/prosemirror.css from the prosemirror-view package.");
    cssCheckWarned = true;
  }
}
function safariShadowSelectionRange(view) {
  let found2;
  function read2(event) {
    event.preventDefault();
    event.stopImmediatePropagation();
    found2 = event.getTargetRanges()[0];
  }
  view.dom.addEventListener("beforeinput", read2, true);
  document.execCommand("indent");
  view.dom.removeEventListener("beforeinput", read2, true);
  let anchorNode = found2.startContainer, anchorOffset = found2.startOffset;
  let focusNode = found2.endContainer, focusOffset = found2.endOffset;
  let currentAnchor = view.domAtPos(view.state.selection.anchor);
  if (isEquivalentPosition(currentAnchor.node, currentAnchor.offset, focusNode, focusOffset))
    [anchorNode, anchorOffset, focusNode, focusOffset] = [focusNode, focusOffset, anchorNode, anchorOffset];
  return { anchorNode, anchorOffset, focusNode, focusOffset };
}
function parseBetween(view, from_, to_) {
  let { node: parent, fromOffset, toOffset, from: from3, to } = view.docView.parseRange(from_, to_);
  let domSel = view.domSelectionRange();
  let find2;
  let anchor = domSel.anchorNode;
  if (anchor && view.dom.contains(anchor.nodeType == 1 ? anchor : anchor.parentNode)) {
    find2 = [{ node: anchor, offset: domSel.anchorOffset }];
    if (!selectionCollapsed(domSel))
      find2.push({ node: domSel.focusNode, offset: domSel.focusOffset });
  }
  if (chrome$1 && view.input.lastKeyCode === 8) {
    for (let off2 = toOffset; off2 > fromOffset; off2--) {
      let node2 = parent.childNodes[off2 - 1], desc = node2.pmViewDesc;
      if (node2.nodeName == "BR" && !desc) {
        toOffset = off2;
        break;
      }
      if (!desc || desc.size)
        break;
    }
  }
  let startDoc = view.state.doc;
  let parser = view.someProp("domParser") || DOMParser$1.fromSchema(view.state.schema);
  let $from = startDoc.resolve(from3);
  let sel = null, doc2 = parser.parse(parent, {
    topNode: $from.parent,
    topMatch: $from.parent.contentMatchAt($from.index()),
    topOpen: true,
    from: fromOffset,
    to: toOffset,
    preserveWhitespace: $from.parent.type.whitespace == "pre" ? "full" : true,
    findPositions: find2,
    ruleFromNode,
    context: $from
  });
  if (find2 && find2[0].pos != null) {
    let anchor2 = find2[0].pos, head = find2[1] && find2[1].pos;
    if (head == null)
      head = anchor2;
    sel = { anchor: anchor2 + from3, head: head + from3 };
  }
  return { doc: doc2, sel, from: from3, to };
}
function ruleFromNode(dom) {
  let desc = dom.pmViewDesc;
  if (desc) {
    return desc.parseRule();
  } else if (dom.nodeName == "BR" && dom.parentNode) {
    if (safari && /^(ul|ol)$/i.test(dom.parentNode.nodeName)) {
      let skip = document.createElement("div");
      skip.appendChild(document.createElement("li"));
      return { skip };
    } else if (dom.parentNode.lastChild == dom || safari && /^(tr|table)$/i.test(dom.parentNode.nodeName)) {
      return { ignore: true };
    }
  } else if (dom.nodeName == "IMG" && dom.getAttribute("mark-placeholder")) {
    return { ignore: true };
  }
  return null;
}
function readDOMChange(view, from3, to, typeOver, addedNodes) {
  if (from3 < 0) {
    let origin = view.input.lastSelectionTime > Date.now() - 50 ? view.input.lastSelectionOrigin : null;
    let newSel = selectionFromDOM(view, origin);
    if (newSel && !view.state.selection.eq(newSel)) {
      if (chrome$1 && android && view.input.lastKeyCode === 13 && Date.now() - 100 < view.input.lastKeyCodeTime && view.someProp("handleKeyDown", (f2) => f2(view, keyEvent(13, "Enter"))))
        return;
      let tr2 = view.state.tr.setSelection(newSel);
      if (origin == "pointer")
        tr2.setMeta("pointer", true);
      else if (origin == "key")
        tr2.scrollIntoView();
      view.dispatch(tr2);
    }
    return;
  }
  let $before = view.state.doc.resolve(from3);
  let shared = $before.sharedDepth(to);
  from3 = $before.before(shared + 1);
  to = view.state.doc.resolve(to).after(shared + 1);
  let sel = view.state.selection;
  let parse2 = parseBetween(view, from3, to);
  let doc2 = view.state.doc, compare = doc2.slice(parse2.from, parse2.to);
  let preferredPos, preferredSide;
  if (view.input.lastKeyCode === 8 && Date.now() - 100 < view.input.lastKeyCodeTime) {
    preferredPos = view.state.selection.to;
    preferredSide = "end";
  } else {
    preferredPos = view.state.selection.from;
    preferredSide = "start";
  }
  view.input.lastKeyCode = null;
  let change = findDiff(compare.content, parse2.doc.content, parse2.from, preferredPos, preferredSide);
  if ((ios && view.input.lastIOSEnter > Date.now() - 225 || android) && addedNodes.some((n2) => n2.nodeName == "DIV" || n2.nodeName == "P" || n2.nodeName == "LI") && (!change || change.endA >= change.endB) && view.someProp("handleKeyDown", (f2) => f2(view, keyEvent(13, "Enter")))) {
    view.input.lastIOSEnter = 0;
    return;
  }
  if (!change) {
    if (typeOver && sel instanceof TextSelection && !sel.empty && sel.$head.sameParent(sel.$anchor) && !view.composing && !(parse2.sel && parse2.sel.anchor != parse2.sel.head)) {
      change = { start: sel.from, endA: sel.to, endB: sel.to };
    } else {
      if (parse2.sel) {
        let sel2 = resolveSelection(view, view.state.doc, parse2.sel);
        if (sel2 && !sel2.eq(view.state.selection))
          view.dispatch(view.state.tr.setSelection(sel2));
      }
      return;
    }
  }
  if (chrome$1 && view.cursorWrapper && parse2.sel && parse2.sel.anchor == view.cursorWrapper.deco.from && parse2.sel.head == parse2.sel.anchor) {
    let size = change.endB - change.start;
    parse2.sel = { anchor: parse2.sel.anchor + size, head: parse2.sel.anchor + size };
  }
  view.input.domChangeCount++;
  if (view.state.selection.from < view.state.selection.to && change.start == change.endB && view.state.selection instanceof TextSelection) {
    if (change.start > view.state.selection.from && change.start <= view.state.selection.from + 2 && view.state.selection.from >= parse2.from) {
      change.start = view.state.selection.from;
    } else if (change.endA < view.state.selection.to && change.endA >= view.state.selection.to - 2 && view.state.selection.to <= parse2.to) {
      change.endB += view.state.selection.to - change.endA;
      change.endA = view.state.selection.to;
    }
  }
  if (ie$1 && ie_version <= 11 && change.endB == change.start + 1 && change.endA == change.start && change.start > parse2.from && parse2.doc.textBetween(change.start - parse2.from - 1, change.start - parse2.from + 1) == " \xA0") {
    change.start--;
    change.endA--;
    change.endB--;
  }
  let $from = parse2.doc.resolveNoCache(change.start - parse2.from);
  let $to = parse2.doc.resolveNoCache(change.endB - parse2.from);
  let $fromA = doc2.resolve(change.start);
  let inlineChange = $from.sameParent($to) && $from.parent.inlineContent && $fromA.end() >= change.endA;
  let nextSel;
  if ((ios && view.input.lastIOSEnter > Date.now() - 225 && (!inlineChange || addedNodes.some((n2) => n2.nodeName == "DIV" || n2.nodeName == "P")) || !inlineChange && $from.pos < parse2.doc.content.size && (nextSel = Selection.findFrom(parse2.doc.resolve($from.pos + 1), 1, true)) && nextSel.head == $to.pos) && view.someProp("handleKeyDown", (f2) => f2(view, keyEvent(13, "Enter")))) {
    view.input.lastIOSEnter = 0;
    return;
  }
  if (view.state.selection.anchor > change.start && looksLikeJoin(doc2, change.start, change.endA, $from, $to) && view.someProp("handleKeyDown", (f2) => f2(view, keyEvent(8, "Backspace")))) {
    if (android && chrome$1)
      view.domObserver.suppressSelectionUpdates();
    return;
  }
  if (chrome$1 && android && change.endB == change.start)
    view.input.lastAndroidDelete = Date.now();
  if (android && !inlineChange && $from.start() != $to.start() && $to.parentOffset == 0 && $from.depth == $to.depth && parse2.sel && parse2.sel.anchor == parse2.sel.head && parse2.sel.head == change.endA) {
    change.endB -= 2;
    $to = parse2.doc.resolveNoCache(change.endB - parse2.from);
    setTimeout(() => {
      view.someProp("handleKeyDown", function(f2) {
        return f2(view, keyEvent(13, "Enter"));
      });
    }, 20);
  }
  let chFrom = change.start, chTo = change.endA;
  let tr, storedMarks, markChange;
  if (inlineChange) {
    if ($from.pos == $to.pos) {
      if (ie$1 && ie_version <= 11 && $from.parentOffset == 0) {
        view.domObserver.suppressSelectionUpdates();
        setTimeout(() => selectionToDOM(view), 20);
      }
      tr = view.state.tr.delete(chFrom, chTo);
      storedMarks = doc2.resolve(change.start).marksAcross(doc2.resolve(change.endA));
    } else if (change.endA == change.endB && (markChange = isMarkChange($from.parent.content.cut($from.parentOffset, $to.parentOffset), $fromA.parent.content.cut($fromA.parentOffset, change.endA - $fromA.start())))) {
      tr = view.state.tr;
      if (markChange.type == "add")
        tr.addMark(chFrom, chTo, markChange.mark);
      else
        tr.removeMark(chFrom, chTo, markChange.mark);
    } else if ($from.parent.child($from.index()).isText && $from.index() == $to.index() - ($to.textOffset ? 0 : 1)) {
      let text2 = $from.parent.textBetween($from.parentOffset, $to.parentOffset);
      if (view.someProp("handleTextInput", (f2) => f2(view, chFrom, chTo, text2)))
        return;
      tr = view.state.tr.insertText(text2, chFrom, chTo);
    }
  }
  if (!tr)
    tr = view.state.tr.replace(chFrom, chTo, parse2.doc.slice(change.start - parse2.from, change.endB - parse2.from));
  if (parse2.sel) {
    let sel2 = resolveSelection(view, tr.doc, parse2.sel);
    if (sel2 && !(chrome$1 && android && view.composing && sel2.empty && (change.start != change.endB || view.input.lastAndroidDelete < Date.now() - 100) && (sel2.head == chFrom || sel2.head == tr.mapping.map(chTo) - 1) || ie$1 && sel2.empty && sel2.head == chFrom))
      tr.setSelection(sel2);
  }
  if (storedMarks)
    tr.ensureMarks(storedMarks);
  view.dispatch(tr.scrollIntoView());
}
function resolveSelection(view, doc2, parsedSel) {
  if (Math.max(parsedSel.anchor, parsedSel.head) > doc2.content.size)
    return null;
  return selectionBetween(view, doc2.resolve(parsedSel.anchor), doc2.resolve(parsedSel.head));
}
function isMarkChange(cur, prev2) {
  let curMarks = cur.firstChild.marks, prevMarks = prev2.firstChild.marks;
  let added = curMarks, removed = prevMarks, type, mark, update;
  for (let i3 = 0; i3 < prevMarks.length; i3++)
    added = prevMarks[i3].removeFromSet(added);
  for (let i3 = 0; i3 < curMarks.length; i3++)
    removed = curMarks[i3].removeFromSet(removed);
  if (added.length == 1 && removed.length == 0) {
    mark = added[0];
    type = "add";
    update = (node2) => node2.mark(mark.addToSet(node2.marks));
  } else if (added.length == 0 && removed.length == 1) {
    mark = removed[0];
    type = "remove";
    update = (node2) => node2.mark(mark.removeFromSet(node2.marks));
  } else {
    return null;
  }
  let updated = [];
  for (let i3 = 0; i3 < prev2.childCount; i3++)
    updated.push(update(prev2.child(i3)));
  if (Fragment.from(updated).eq(cur))
    return { mark, type };
}
function looksLikeJoin(old, start2, end2, $newStart, $newEnd) {
  if (!$newStart.parent.isTextblock || end2 - start2 <= $newEnd.pos - $newStart.pos || skipClosingAndOpening($newStart, true, false) < $newEnd.pos)
    return false;
  let $start = old.resolve(start2);
  if ($start.parentOffset < $start.parent.content.size || !$start.parent.isTextblock)
    return false;
  let $next = old.resolve(skipClosingAndOpening($start, true, true));
  if (!$next.parent.isTextblock || $next.pos > end2 || skipClosingAndOpening($next, true, false) < end2)
    return false;
  return $newStart.parent.content.cut($newStart.parentOffset).eq($next.parent.content);
}
function skipClosingAndOpening($pos, fromEnd, mayOpen) {
  let depth = $pos.depth, end2 = fromEnd ? $pos.end() : $pos.pos;
  while (depth > 0 && (fromEnd || $pos.indexAfter(depth) == $pos.node(depth).childCount)) {
    depth--;
    end2++;
    fromEnd = false;
  }
  if (mayOpen) {
    let next2 = $pos.node(depth).maybeChild($pos.indexAfter(depth));
    while (next2 && !next2.isLeaf) {
      next2 = next2.firstChild;
      end2++;
    }
  }
  return end2;
}
function findDiff(a4, b3, pos, preferredPos, preferredSide) {
  let start2 = a4.findDiffStart(b3, pos);
  if (start2 == null)
    return null;
  let { a: endA, b: endB } = a4.findDiffEnd(b3, pos + a4.size, pos + b3.size);
  if (preferredSide == "end") {
    let adjust = Math.max(0, start2 - Math.min(endA, endB));
    preferredPos -= endA + adjust - start2;
  }
  if (endA < start2 && a4.size < b3.size) {
    let move = preferredPos <= start2 && preferredPos >= endA ? start2 - preferredPos : 0;
    start2 -= move;
    endB = start2 + (endB - endA);
    endA = start2;
  } else if (endB < start2) {
    let move = preferredPos <= start2 && preferredPos >= endB ? start2 - preferredPos : 0;
    start2 -= move;
    endA = start2 + (endA - endB);
    endB = start2;
  }
  return { start: start2, endA, endB };
}
class EditorView {
  constructor(place, props) {
    this._root = null;
    this.focused = false;
    this.trackWrites = null;
    this.mounted = false;
    this.markCursor = null;
    this.cursorWrapper = null;
    this.lastSelectedViewDesc = void 0;
    this.input = new InputState();
    this.prevDirectPlugins = [];
    this.pluginViews = [];
    this.requiresGeckoHackNode = false;
    this.dragging = null;
    this._props = props;
    this.state = props.state;
    this.directPlugins = props.plugins || [];
    this.directPlugins.forEach(checkStateComponent);
    this.dispatch = this.dispatch.bind(this);
    this.dom = place && place.mount || document.createElement("div");
    if (place) {
      if (place.appendChild)
        place.appendChild(this.dom);
      else if (typeof place == "function")
        place(this.dom);
      else if (place.mount)
        this.mounted = true;
    }
    this.editable = getEditable(this);
    updateCursorWrapper(this);
    this.nodeViews = buildNodeViews(this);
    this.docView = docViewDesc(this.state.doc, computeDocDeco(this), viewDecorations(this), this.dom, this);
    this.domObserver = new DOMObserver(this, (from3, to, typeOver, added) => readDOMChange(this, from3, to, typeOver, added));
    this.domObserver.start();
    initInput(this);
    this.updatePluginViews();
  }
  get composing() {
    return this.input.composing;
  }
  get props() {
    if (this._props.state != this.state) {
      let prev2 = this._props;
      this._props = {};
      for (let name in prev2)
        this._props[name] = prev2[name];
      this._props.state = this.state;
    }
    return this._props;
  }
  update(props) {
    if (props.handleDOMEvents != this._props.handleDOMEvents)
      ensureListeners(this);
    let prevProps = this._props;
    this._props = props;
    if (props.plugins) {
      props.plugins.forEach(checkStateComponent);
      this.directPlugins = props.plugins;
    }
    this.updateStateInner(props.state, prevProps);
  }
  setProps(props) {
    let updated = {};
    for (let name in this._props)
      updated[name] = this._props[name];
    updated.state = this.state;
    for (let name in props)
      updated[name] = props[name];
    this.update(updated);
  }
  updateState(state) {
    this.updateStateInner(state, this._props);
  }
  updateStateInner(state, prevProps) {
    let prev2 = this.state, redraw = false, updateSel = false;
    if (state.storedMarks && this.composing) {
      clearComposition(this);
      updateSel = true;
    }
    this.state = state;
    let pluginsChanged = prev2.plugins != state.plugins || this._props.plugins != prevProps.plugins;
    if (pluginsChanged || this._props.plugins != prevProps.plugins || this._props.nodeViews != prevProps.nodeViews) {
      let nodeViews = buildNodeViews(this);
      if (changedNodeViews(nodeViews, this.nodeViews)) {
        this.nodeViews = nodeViews;
        redraw = true;
      }
    }
    if (pluginsChanged || prevProps.handleDOMEvents != this._props.handleDOMEvents) {
      ensureListeners(this);
    }
    this.editable = getEditable(this);
    updateCursorWrapper(this);
    let innerDeco = viewDecorations(this), outerDeco = computeDocDeco(this);
    let scroll = prev2.plugins != state.plugins && !prev2.doc.eq(state.doc) ? "reset" : state.scrollToSelection > prev2.scrollToSelection ? "to selection" : "preserve";
    let updateDoc = redraw || !this.docView.matchesNode(state.doc, outerDeco, innerDeco);
    if (updateDoc || !state.selection.eq(prev2.selection))
      updateSel = true;
    let oldScrollPos = scroll == "preserve" && updateSel && this.dom.style.overflowAnchor == null && storeScrollPos(this);
    if (updateSel) {
      this.domObserver.stop();
      let forceSelUpdate = updateDoc && (ie$1 || chrome$1) && !this.composing && !prev2.selection.empty && !state.selection.empty && selectionContextChanged(prev2.selection, state.selection);
      if (updateDoc) {
        let chromeKludge = chrome$1 ? this.trackWrites = this.domSelectionRange().focusNode : null;
        if (redraw || !this.docView.update(state.doc, outerDeco, innerDeco, this)) {
          this.docView.updateOuterDeco([]);
          this.docView.destroy();
          this.docView = docViewDesc(state.doc, outerDeco, innerDeco, this.dom, this);
        }
        if (chromeKludge && !this.trackWrites)
          forceSelUpdate = true;
      }
      if (forceSelUpdate || !(this.input.mouseDown && this.domObserver.currentSelection.eq(this.domSelectionRange()) && anchorInRightPlace(this))) {
        selectionToDOM(this, forceSelUpdate);
      } else {
        syncNodeSelection(this, state.selection);
        this.domObserver.setCurSelection();
      }
      this.domObserver.start();
    }
    this.updatePluginViews(prev2);
    if (scroll == "reset") {
      this.dom.scrollTop = 0;
    } else if (scroll == "to selection") {
      this.scrollToSelection();
    } else if (oldScrollPos) {
      resetScrollPos(oldScrollPos);
    }
  }
  scrollToSelection() {
    let startDOM = this.domSelectionRange().focusNode;
    if (this.someProp("handleScrollToSelection", (f2) => f2(this)))
      ;
    else if (this.state.selection instanceof NodeSelection) {
      let target = this.docView.domAfterPos(this.state.selection.from);
      if (target.nodeType == 1)
        scrollRectIntoView(this, target.getBoundingClientRect(), startDOM);
    } else {
      scrollRectIntoView(this, this.coordsAtPos(this.state.selection.head, 1), startDOM);
    }
  }
  destroyPluginViews() {
    let view;
    while (view = this.pluginViews.pop())
      if (view.destroy)
        view.destroy();
  }
  updatePluginViews(prevState) {
    if (!prevState || prevState.plugins != this.state.plugins || this.directPlugins != this.prevDirectPlugins) {
      this.prevDirectPlugins = this.directPlugins;
      this.destroyPluginViews();
      for (let i3 = 0; i3 < this.directPlugins.length; i3++) {
        let plugin = this.directPlugins[i3];
        if (plugin.spec.view)
          this.pluginViews.push(plugin.spec.view(this));
      }
      for (let i3 = 0; i3 < this.state.plugins.length; i3++) {
        let plugin = this.state.plugins[i3];
        if (plugin.spec.view)
          this.pluginViews.push(plugin.spec.view(this));
      }
    } else {
      for (let i3 = 0; i3 < this.pluginViews.length; i3++) {
        let pluginView = this.pluginViews[i3];
        if (pluginView.update)
          pluginView.update(this, prevState);
      }
    }
  }
  someProp(propName, f2) {
    let prop = this._props && this._props[propName], value;
    if (prop != null && (value = f2 ? f2(prop) : prop))
      return value;
    for (let i3 = 0; i3 < this.directPlugins.length; i3++) {
      let prop2 = this.directPlugins[i3].props[propName];
      if (prop2 != null && (value = f2 ? f2(prop2) : prop2))
        return value;
    }
    let plugins2 = this.state.plugins;
    if (plugins2)
      for (let i3 = 0; i3 < plugins2.length; i3++) {
        let prop2 = plugins2[i3].props[propName];
        if (prop2 != null && (value = f2 ? f2(prop2) : prop2))
          return value;
      }
  }
  hasFocus() {
    if (ie$1) {
      let node2 = this.root.activeElement;
      if (node2 == this.dom)
        return true;
      if (!node2 || !this.dom.contains(node2))
        return false;
      while (node2 && this.dom != node2 && this.dom.contains(node2)) {
        if (node2.contentEditable == "false")
          return false;
        node2 = node2.parentElement;
      }
      return true;
    }
    return this.root.activeElement == this.dom;
  }
  focus() {
    this.domObserver.stop();
    if (this.editable)
      focusPreventScroll(this.dom);
    selectionToDOM(this);
    this.domObserver.start();
  }
  get root() {
    let cached = this._root;
    if (cached == null)
      for (let search = this.dom.parentNode; search; search = search.parentNode) {
        if (search.nodeType == 9 || search.nodeType == 11 && search.host) {
          if (!search.getSelection)
            Object.getPrototypeOf(search).getSelection = () => search.ownerDocument.getSelection();
          return this._root = search;
        }
      }
    return cached || document;
  }
  posAtCoords(coords) {
    return posAtCoords(this, coords);
  }
  coordsAtPos(pos, side = 1) {
    return coordsAtPos(this, pos, side);
  }
  domAtPos(pos, side = 0) {
    return this.docView.domFromPos(pos, side);
  }
  nodeDOM(pos) {
    let desc = this.docView.descAt(pos);
    return desc ? desc.nodeDOM : null;
  }
  posAtDOM(node2, offset2, bias = -1) {
    let pos = this.docView.posFromDOM(node2, offset2, bias);
    if (pos == null)
      throw new RangeError("DOM position not inside the editor");
    return pos;
  }
  endOfTextblock(dir, state) {
    return endOfTextblock(this, state || this.state, dir);
  }
  pasteHTML(html, event) {
    return doPaste(this, "", html, false, event || new ClipboardEvent("paste"));
  }
  pasteText(text2, event) {
    return doPaste(this, text2, null, true, event || new ClipboardEvent("paste"));
  }
  destroy() {
    if (!this.docView)
      return;
    destroyInput(this);
    this.destroyPluginViews();
    if (this.mounted) {
      this.docView.update(this.state.doc, [], viewDecorations(this), this);
      this.dom.textContent = "";
    } else if (this.dom.parentNode) {
      this.dom.parentNode.removeChild(this.dom);
    }
    this.docView.destroy();
    this.docView = null;
  }
  get isDestroyed() {
    return this.docView == null;
  }
  dispatchEvent(event) {
    return dispatchEvent(this, event);
  }
  dispatch(tr) {
    let dispatchTransaction = this._props.dispatchTransaction;
    if (dispatchTransaction)
      dispatchTransaction.call(this, tr);
    else
      this.updateState(this.state.apply(tr));
  }
  domSelectionRange() {
    return safari && this.root.nodeType === 11 && deepActiveElement(this.dom.ownerDocument) == this.dom ? safariShadowSelectionRange(this) : this.domSelection();
  }
  domSelection() {
    return this.root.getSelection();
  }
}
function computeDocDeco(view) {
  let attrs = /* @__PURE__ */ Object.create(null);
  attrs.class = "ProseMirror";
  attrs.contenteditable = String(view.editable);
  attrs.translate = "no";
  view.someProp("attributes", (value) => {
    if (typeof value == "function")
      value = value(view.state);
    if (value)
      for (let attr in value) {
        if (attr == "class")
          attrs.class += " " + value[attr];
        if (attr == "style") {
          attrs.style = (attrs.style ? attrs.style + ";" : "") + value[attr];
        } else if (!attrs[attr] && attr != "contenteditable" && attr != "nodeName")
          attrs[attr] = String(value[attr]);
      }
  });
  return [Decoration.node(0, view.state.doc.content.size, attrs)];
}
function updateCursorWrapper(view) {
  if (view.markCursor) {
    let dom = document.createElement("img");
    dom.className = "ProseMirror-separator";
    dom.setAttribute("mark-placeholder", "true");
    dom.setAttribute("alt", "");
    view.cursorWrapper = { dom, deco: Decoration.widget(view.state.selection.head, dom, { raw: true, marks: view.markCursor }) };
  } else {
    view.cursorWrapper = null;
  }
}
function getEditable(view) {
  return !view.someProp("editable", (value) => value(view.state) === false);
}
function selectionContextChanged(sel1, sel2) {
  let depth = Math.min(sel1.$anchor.sharedDepth(sel1.head), sel2.$anchor.sharedDepth(sel2.head));
  return sel1.$anchor.start(depth) != sel2.$anchor.start(depth);
}
function buildNodeViews(view) {
  let result = /* @__PURE__ */ Object.create(null);
  function add2(obj) {
    for (let prop in obj)
      if (!Object.prototype.hasOwnProperty.call(result, prop))
        result[prop] = obj[prop];
  }
  view.someProp("nodeViews", add2);
  view.someProp("markViews", add2);
  return result;
}
function changedNodeViews(a4, b3) {
  let nA = 0, nB = 0;
  for (let prop in a4) {
    if (a4[prop] != b3[prop])
      return true;
    nA++;
  }
  for (let _2 in b3)
    nB++;
  return nA != nB;
}
function checkStateComponent(plugin) {
  if (plugin.spec.state || plugin.spec.filterTransaction || plugin.spec.appendTransaction)
    throw new RangeError("Plugins passed directly to the view must not have a state component");
}
var base = {
  8: "Backspace",
  9: "Tab",
  10: "Enter",
  12: "NumLock",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  44: "PrintScreen",
  45: "Insert",
  46: "Delete",
  59: ";",
  61: "=",
  91: "Meta",
  92: "Meta",
  106: "*",
  107: "+",
  108: ",",
  109: "-",
  110: ".",
  111: "/",
  144: "NumLock",
  145: "ScrollLock",
  160: "Shift",
  161: "Shift",
  162: "Control",
  163: "Control",
  164: "Alt",
  165: "Alt",
  173: "-",
  186: ";",
  187: "=",
  188: ",",
  189: "-",
  190: ".",
  191: "/",
  192: "`",
  219: "[",
  220: "\\",
  221: "]",
  222: "'"
};
var shift = {
  48: ")",
  49: "!",
  50: "@",
  51: "#",
  52: "$",
  53: "%",
  54: "^",
  55: "&",
  56: "*",
  57: "(",
  59: ":",
  61: "+",
  173: "_",
  186: ":",
  187: "+",
  188: "<",
  189: "_",
  190: ">",
  191: "?",
  192: "~",
  219: "{",
  220: "|",
  221: "}",
  222: '"'
};
var chrome = typeof navigator != "undefined" && /Chrome\/(\d+)/.exec(navigator.userAgent);
typeof navigator != "undefined" && /Gecko\/\d+/.test(navigator.userAgent);
var mac$1 = typeof navigator != "undefined" && /Mac/.test(navigator.platform);
var ie = typeof navigator != "undefined" && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);
var brokenModifierNames = mac$1 || chrome && +chrome[1] < 57;
for (var i$1 = 0; i$1 < 10; i$1++)
  base[48 + i$1] = base[96 + i$1] = String(i$1);
for (var i$1 = 1; i$1 <= 24; i$1++)
  base[i$1 + 111] = "F" + i$1;
for (var i$1 = 65; i$1 <= 90; i$1++) {
  base[i$1] = String.fromCharCode(i$1 + 32);
  shift[i$1] = String.fromCharCode(i$1);
}
for (var code in base)
  if (!shift.hasOwnProperty(code))
    shift[code] = base[code];
function keyName(event) {
  var ignoreKey = brokenModifierNames && (event.ctrlKey || event.altKey || event.metaKey) || ie && event.shiftKey && event.key && event.key.length == 1 || event.key == "Unidentified";
  var name = !ignoreKey && event.key || (event.shiftKey ? shift : base)[event.keyCode] || event.key || "Unidentified";
  if (name == "Esc")
    name = "Escape";
  if (name == "Del")
    name = "Delete";
  if (name == "Left")
    name = "ArrowLeft";
  if (name == "Up")
    name = "ArrowUp";
  if (name == "Right")
    name = "ArrowRight";
  if (name == "Down")
    name = "ArrowDown";
  return name;
}
const mac = typeof navigator != "undefined" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform) : false;
function normalizeKeyName$1(name) {
  let parts = name.split(/-(?!$)/), result = parts[parts.length - 1];
  if (result == "Space")
    result = " ";
  let alt, ctrl, shift2, meta;
  for (let i3 = 0; i3 < parts.length - 1; i3++) {
    let mod = parts[i3];
    if (/^(cmd|meta|m)$/i.test(mod))
      meta = true;
    else if (/^a(lt)?$/i.test(mod))
      alt = true;
    else if (/^(c|ctrl|control)$/i.test(mod))
      ctrl = true;
    else if (/^s(hift)?$/i.test(mod))
      shift2 = true;
    else if (/^mod$/i.test(mod)) {
      if (mac)
        meta = true;
      else
        ctrl = true;
    } else
      throw new Error("Unrecognized modifier name: " + mod);
  }
  if (alt)
    result = "Alt-" + result;
  if (ctrl)
    result = "Ctrl-" + result;
  if (meta)
    result = "Meta-" + result;
  if (shift2)
    result = "Shift-" + result;
  return result;
}
function normalize(map2) {
  let copy2 = /* @__PURE__ */ Object.create(null);
  for (let prop in map2)
    copy2[normalizeKeyName$1(prop)] = map2[prop];
  return copy2;
}
function modifiers(name, event, shift2 = true) {
  if (event.altKey)
    name = "Alt-" + name;
  if (event.ctrlKey)
    name = "Ctrl-" + name;
  if (event.metaKey)
    name = "Meta-" + name;
  if (shift2 && event.shiftKey)
    name = "Shift-" + name;
  return name;
}
function keymap(bindings) {
  return new Plugin({ props: { handleKeyDown: keydownHandler(bindings) } });
}
function keydownHandler(bindings) {
  let map2 = normalize(bindings);
  return function(view, event) {
    let name = keyName(event), baseName, direct = map2[modifiers(name, event)];
    if (direct && direct(view.state, view.dispatch, view))
      return true;
    if (name.length == 1 && name != " ") {
      if (event.shiftKey) {
        let noShift = map2[modifiers(name, event, false)];
        if (noShift && noShift(view.state, view.dispatch, view))
          return true;
      }
      if ((event.shiftKey || event.altKey || event.metaKey || name.charCodeAt(0) > 127) && (baseName = base[event.keyCode]) && baseName != name) {
        let fromCode = map2[modifiers(baseName, event)];
        if (fromCode && fromCode(view.state, view.dispatch, view))
          return true;
      }
    }
    return false;
  };
}
const deleteSelection$1 = (state, dispatch) => {
  if (state.selection.empty)
    return false;
  if (dispatch)
    dispatch(state.tr.deleteSelection().scrollIntoView());
  return true;
};
function atBlockStart(state, view) {
  let { $cursor } = state.selection;
  if (!$cursor || (view ? !view.endOfTextblock("backward", state) : $cursor.parentOffset > 0))
    return null;
  return $cursor;
}
const joinBackward$1 = (state, dispatch, view) => {
  let $cursor = atBlockStart(state, view);
  if (!$cursor)
    return false;
  let $cut = findCutBefore($cursor);
  if (!$cut) {
    let range2 = $cursor.blockRange(), target = range2 && liftTarget(range2);
    if (target == null)
      return false;
    if (dispatch)
      dispatch(state.tr.lift(range2, target).scrollIntoView());
    return true;
  }
  let before = $cut.nodeBefore;
  if (!before.type.spec.isolating && deleteBarrier(state, $cut, dispatch))
    return true;
  if ($cursor.parent.content.size == 0 && (textblockAt(before, "end") || NodeSelection.isSelectable(before))) {
    let delStep = replaceStep(state.doc, $cursor.before(), $cursor.after(), Slice.empty);
    if (delStep && delStep.slice.size < delStep.to - delStep.from) {
      if (dispatch) {
        let tr = state.tr.step(delStep);
        tr.setSelection(textblockAt(before, "end") ? Selection.findFrom(tr.doc.resolve(tr.mapping.map($cut.pos, -1)), -1) : NodeSelection.create(tr.doc, $cut.pos - before.nodeSize));
        dispatch(tr.scrollIntoView());
      }
      return true;
    }
  }
  if (before.isAtom && $cut.depth == $cursor.depth - 1) {
    if (dispatch)
      dispatch(state.tr.delete($cut.pos - before.nodeSize, $cut.pos).scrollIntoView());
    return true;
  }
  return false;
};
function textblockAt(node2, side, only = false) {
  for (let scan = node2; scan; scan = side == "start" ? scan.firstChild : scan.lastChild) {
    if (scan.isTextblock)
      return true;
    if (only && scan.childCount != 1)
      return false;
  }
  return false;
}
const selectNodeBackward$1 = (state, dispatch, view) => {
  let { $head, empty: empty2 } = state.selection, $cut = $head;
  if (!empty2)
    return false;
  if ($head.parent.isTextblock) {
    if (view ? !view.endOfTextblock("backward", state) : $head.parentOffset > 0)
      return false;
    $cut = findCutBefore($head);
  }
  let node2 = $cut && $cut.nodeBefore;
  if (!node2 || !NodeSelection.isSelectable(node2))
    return false;
  if (dispatch)
    dispatch(state.tr.setSelection(NodeSelection.create(state.doc, $cut.pos - node2.nodeSize)).scrollIntoView());
  return true;
};
function findCutBefore($pos) {
  if (!$pos.parent.type.spec.isolating)
    for (let i3 = $pos.depth - 1; i3 >= 0; i3--) {
      if ($pos.index(i3) > 0)
        return $pos.doc.resolve($pos.before(i3 + 1));
      if ($pos.node(i3).type.spec.isolating)
        break;
    }
  return null;
}
function atBlockEnd(state, view) {
  let { $cursor } = state.selection;
  if (!$cursor || (view ? !view.endOfTextblock("forward", state) : $cursor.parentOffset < $cursor.parent.content.size))
    return null;
  return $cursor;
}
const joinForward$1 = (state, dispatch, view) => {
  let $cursor = atBlockEnd(state, view);
  if (!$cursor)
    return false;
  let $cut = findCutAfter($cursor);
  if (!$cut)
    return false;
  let after = $cut.nodeAfter;
  if (deleteBarrier(state, $cut, dispatch))
    return true;
  if ($cursor.parent.content.size == 0 && (textblockAt(after, "start") || NodeSelection.isSelectable(after))) {
    let delStep = replaceStep(state.doc, $cursor.before(), $cursor.after(), Slice.empty);
    if (delStep && delStep.slice.size < delStep.to - delStep.from) {
      if (dispatch) {
        let tr = state.tr.step(delStep);
        tr.setSelection(textblockAt(after, "start") ? Selection.findFrom(tr.doc.resolve(tr.mapping.map($cut.pos)), 1) : NodeSelection.create(tr.doc, tr.mapping.map($cut.pos)));
        dispatch(tr.scrollIntoView());
      }
      return true;
    }
  }
  if (after.isAtom && $cut.depth == $cursor.depth - 1) {
    if (dispatch)
      dispatch(state.tr.delete($cut.pos, $cut.pos + after.nodeSize).scrollIntoView());
    return true;
  }
  return false;
};
const selectNodeForward$1 = (state, dispatch, view) => {
  let { $head, empty: empty2 } = state.selection, $cut = $head;
  if (!empty2)
    return false;
  if ($head.parent.isTextblock) {
    if (view ? !view.endOfTextblock("forward", state) : $head.parentOffset < $head.parent.content.size)
      return false;
    $cut = findCutAfter($head);
  }
  let node2 = $cut && $cut.nodeAfter;
  if (!node2 || !NodeSelection.isSelectable(node2))
    return false;
  if (dispatch)
    dispatch(state.tr.setSelection(NodeSelection.create(state.doc, $cut.pos)).scrollIntoView());
  return true;
};
function findCutAfter($pos) {
  if (!$pos.parent.type.spec.isolating)
    for (let i3 = $pos.depth - 1; i3 >= 0; i3--) {
      let parent = $pos.node(i3);
      if ($pos.index(i3) + 1 < parent.childCount)
        return $pos.doc.resolve($pos.after(i3 + 1));
      if (parent.type.spec.isolating)
        break;
    }
  return null;
}
const joinUp$1 = (state, dispatch) => {
  let sel = state.selection, nodeSel = sel instanceof NodeSelection, point;
  if (nodeSel) {
    if (sel.node.isTextblock || !canJoin(state.doc, sel.from))
      return false;
    point = sel.from;
  } else {
    point = joinPoint(state.doc, sel.from, -1);
    if (point == null)
      return false;
  }
  if (dispatch) {
    let tr = state.tr.join(point);
    if (nodeSel)
      tr.setSelection(NodeSelection.create(tr.doc, point - state.doc.resolve(point).nodeBefore.nodeSize));
    dispatch(tr.scrollIntoView());
  }
  return true;
};
const joinDown$1 = (state, dispatch) => {
  let sel = state.selection, point;
  if (sel instanceof NodeSelection) {
    if (sel.node.isTextblock || !canJoin(state.doc, sel.to))
      return false;
    point = sel.to;
  } else {
    point = joinPoint(state.doc, sel.to, 1);
    if (point == null)
      return false;
  }
  if (dispatch)
    dispatch(state.tr.join(point).scrollIntoView());
  return true;
};
const lift$1 = (state, dispatch) => {
  let { $from, $to } = state.selection;
  let range2 = $from.blockRange($to), target = range2 && liftTarget(range2);
  if (target == null)
    return false;
  if (dispatch)
    dispatch(state.tr.lift(range2, target).scrollIntoView());
  return true;
};
const newlineInCode$1 = (state, dispatch) => {
  let { $head, $anchor } = state.selection;
  if (!$head.parent.type.spec.code || !$head.sameParent($anchor))
    return false;
  if (dispatch)
    dispatch(state.tr.insertText("\n").scrollIntoView());
  return true;
};
function defaultBlockAt$1(match2) {
  for (let i3 = 0; i3 < match2.edgeCount; i3++) {
    let { type } = match2.edge(i3);
    if (type.isTextblock && !type.hasRequiredAttrs())
      return type;
  }
  return null;
}
const exitCode$1 = (state, dispatch) => {
  let { $head, $anchor } = state.selection;
  if (!$head.parent.type.spec.code || !$head.sameParent($anchor))
    return false;
  let above = $head.node(-1), after = $head.indexAfter(-1), type = defaultBlockAt$1(above.contentMatchAt(after));
  if (!type || !above.canReplaceWith(after, after, type))
    return false;
  if (dispatch) {
    let pos = $head.after(), tr = state.tr.replaceWith(pos, pos, type.createAndFill());
    tr.setSelection(Selection.near(tr.doc.resolve(pos), 1));
    dispatch(tr.scrollIntoView());
  }
  return true;
};
const createParagraphNear$1 = (state, dispatch) => {
  let sel = state.selection, { $from, $to } = sel;
  if (sel instanceof AllSelection || $from.parent.inlineContent || $to.parent.inlineContent)
    return false;
  let type = defaultBlockAt$1($to.parent.contentMatchAt($to.indexAfter()));
  if (!type || !type.isTextblock)
    return false;
  if (dispatch) {
    let side = (!$from.parentOffset && $to.index() < $to.parent.childCount ? $from : $to).pos;
    let tr = state.tr.insert(side, type.createAndFill());
    tr.setSelection(TextSelection.create(tr.doc, side + 1));
    dispatch(tr.scrollIntoView());
  }
  return true;
};
const liftEmptyBlock$1 = (state, dispatch) => {
  let { $cursor } = state.selection;
  if (!$cursor || $cursor.parent.content.size)
    return false;
  if ($cursor.depth > 1 && $cursor.after() != $cursor.end(-1)) {
    let before = $cursor.before();
    if (canSplit(state.doc, before)) {
      if (dispatch)
        dispatch(state.tr.split(before).scrollIntoView());
      return true;
    }
  }
  let range2 = $cursor.blockRange(), target = range2 && liftTarget(range2);
  if (target == null)
    return false;
  if (dispatch)
    dispatch(state.tr.lift(range2, target).scrollIntoView());
  return true;
};
const selectParentNode$1 = (state, dispatch) => {
  let { $from, to } = state.selection, pos;
  let same = $from.sharedDepth(to);
  if (same == 0)
    return false;
  pos = $from.before(same);
  if (dispatch)
    dispatch(state.tr.setSelection(NodeSelection.create(state.doc, pos)));
  return true;
};
function joinMaybeClear(state, $pos, dispatch) {
  let before = $pos.nodeBefore, after = $pos.nodeAfter, index2 = $pos.index();
  if (!before || !after || !before.type.compatibleContent(after.type))
    return false;
  if (!before.content.size && $pos.parent.canReplace(index2 - 1, index2)) {
    if (dispatch)
      dispatch(state.tr.delete($pos.pos - before.nodeSize, $pos.pos).scrollIntoView());
    return true;
  }
  if (!$pos.parent.canReplace(index2, index2 + 1) || !(after.isTextblock || canJoin(state.doc, $pos.pos)))
    return false;
  if (dispatch)
    dispatch(state.tr.clearIncompatible($pos.pos, before.type, before.contentMatchAt(before.childCount)).join($pos.pos).scrollIntoView());
  return true;
}
function deleteBarrier(state, $cut, dispatch) {
  let before = $cut.nodeBefore, after = $cut.nodeAfter, conn, match2;
  if (before.type.spec.isolating || after.type.spec.isolating)
    return false;
  if (joinMaybeClear(state, $cut, dispatch))
    return true;
  let canDelAfter = $cut.parent.canReplace($cut.index(), $cut.index() + 1);
  if (canDelAfter && (conn = (match2 = before.contentMatchAt(before.childCount)).findWrapping(after.type)) && match2.matchType(conn[0] || after.type).validEnd) {
    if (dispatch) {
      let end2 = $cut.pos + after.nodeSize, wrap2 = Fragment.empty;
      for (let i3 = conn.length - 1; i3 >= 0; i3--)
        wrap2 = Fragment.from(conn[i3].create(null, wrap2));
      wrap2 = Fragment.from(before.copy(wrap2));
      let tr = state.tr.step(new ReplaceAroundStep($cut.pos - 1, end2, $cut.pos, end2, new Slice(wrap2, 1, 0), conn.length, true));
      let joinAt = end2 + 2 * conn.length;
      if (canJoin(tr.doc, joinAt))
        tr.join(joinAt);
      dispatch(tr.scrollIntoView());
    }
    return true;
  }
  let selAfter = Selection.findFrom($cut, 1);
  let range2 = selAfter && selAfter.$from.blockRange(selAfter.$to), target = range2 && liftTarget(range2);
  if (target != null && target >= $cut.depth) {
    if (dispatch)
      dispatch(state.tr.lift(range2, target).scrollIntoView());
    return true;
  }
  if (canDelAfter && textblockAt(after, "start", true) && textblockAt(before, "end")) {
    let at2 = before, wrap2 = [];
    for (; ; ) {
      wrap2.push(at2);
      if (at2.isTextblock)
        break;
      at2 = at2.lastChild;
    }
    let afterText = after, afterDepth = 1;
    for (; !afterText.isTextblock; afterText = afterText.firstChild)
      afterDepth++;
    if (at2.canReplace(at2.childCount, at2.childCount, afterText.content)) {
      if (dispatch) {
        let end2 = Fragment.empty;
        for (let i3 = wrap2.length - 1; i3 >= 0; i3--)
          end2 = Fragment.from(wrap2[i3].copy(end2));
        let tr = state.tr.step(new ReplaceAroundStep($cut.pos - wrap2.length, $cut.pos + after.nodeSize, $cut.pos + afterDepth, $cut.pos + after.nodeSize - afterDepth, new Slice(end2, wrap2.length, 0), 0, true));
        dispatch(tr.scrollIntoView());
      }
      return true;
    }
  }
  return false;
}
function selectTextblockSide(side) {
  return function(state, dispatch) {
    let sel = state.selection, $pos = side < 0 ? sel.$from : sel.$to;
    let depth = $pos.depth;
    while ($pos.node(depth).isInline) {
      if (!depth)
        return false;
      depth--;
    }
    if (!$pos.node(depth).isTextblock)
      return false;
    if (dispatch)
      dispatch(state.tr.setSelection(TextSelection.create(state.doc, side < 0 ? $pos.start(depth) : $pos.end(depth))));
    return true;
  };
}
const selectTextblockStart$1 = selectTextblockSide(-1);
const selectTextblockEnd$1 = selectTextblockSide(1);
function wrapIn$1(nodeType, attrs = null) {
  return function(state, dispatch) {
    let { $from, $to } = state.selection;
    let range2 = $from.blockRange($to), wrapping = range2 && findWrapping(range2, nodeType, attrs);
    if (!wrapping)
      return false;
    if (dispatch)
      dispatch(state.tr.wrap(range2, wrapping).scrollIntoView());
    return true;
  };
}
function setBlockType(nodeType, attrs = null) {
  return function(state, dispatch) {
    let applicable = false;
    for (let i3 = 0; i3 < state.selection.ranges.length && !applicable; i3++) {
      let { $from: { pos: from3 }, $to: { pos: to } } = state.selection.ranges[i3];
      state.doc.nodesBetween(from3, to, (node2, pos) => {
        if (applicable)
          return false;
        if (!node2.isTextblock || node2.hasMarkup(nodeType, attrs))
          return;
        if (node2.type == nodeType) {
          applicable = true;
        } else {
          let $pos = state.doc.resolve(pos), index2 = $pos.index();
          applicable = $pos.parent.canReplaceWith(index2, index2 + 1, nodeType);
        }
      });
    }
    if (!applicable)
      return false;
    if (dispatch) {
      let tr = state.tr;
      for (let i3 = 0; i3 < state.selection.ranges.length; i3++) {
        let { $from: { pos: from3 }, $to: { pos: to } } = state.selection.ranges[i3];
        tr.setBlockType(from3, to, nodeType, attrs);
      }
      dispatch(tr.scrollIntoView());
    }
    return true;
  };
}
typeof navigator != "undefined" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform) : typeof os != "undefined" && os.platform ? os.platform() == "darwin" : false;
function wrapInList$1(listType, attrs = null) {
  return function(state, dispatch) {
    let { $from, $to } = state.selection;
    let range2 = $from.blockRange($to), doJoin = false, outerRange = range2;
    if (!range2)
      return false;
    if (range2.depth >= 2 && $from.node(range2.depth - 1).type.compatibleContent(listType) && range2.startIndex == 0) {
      if ($from.index(range2.depth - 1) == 0)
        return false;
      let $insert = state.doc.resolve(range2.start - 2);
      outerRange = new NodeRange($insert, $insert, range2.depth);
      if (range2.endIndex < range2.parent.childCount)
        range2 = new NodeRange($from, state.doc.resolve($to.end(range2.depth)), range2.depth);
      doJoin = true;
    }
    let wrap2 = findWrapping(outerRange, listType, attrs, range2);
    if (!wrap2)
      return false;
    if (dispatch)
      dispatch(doWrapInList(state.tr, range2, wrap2, doJoin, listType).scrollIntoView());
    return true;
  };
}
function doWrapInList(tr, range2, wrappers, joinBefore, listType) {
  let content = Fragment.empty;
  for (let i3 = wrappers.length - 1; i3 >= 0; i3--)
    content = Fragment.from(wrappers[i3].type.create(wrappers[i3].attrs, content));
  tr.step(new ReplaceAroundStep(range2.start - (joinBefore ? 2 : 0), range2.end, range2.start, range2.end, new Slice(content, 0, 0), wrappers.length, true));
  let found2 = 0;
  for (let i3 = 0; i3 < wrappers.length; i3++)
    if (wrappers[i3].type == listType)
      found2 = i3 + 1;
  let splitDepth = wrappers.length - found2;
  let splitPos = range2.start + wrappers.length - (joinBefore ? 2 : 0), parent = range2.parent;
  for (let i3 = range2.startIndex, e3 = range2.endIndex, first2 = true; i3 < e3; i3++, first2 = false) {
    if (!first2 && canSplit(tr.doc, splitPos, splitDepth)) {
      tr.split(splitPos, splitDepth);
      splitPos += 2 * splitDepth;
    }
    splitPos += parent.child(i3).nodeSize;
  }
  return tr;
}
function liftListItem$1(itemType) {
  return function(state, dispatch) {
    let { $from, $to } = state.selection;
    let range2 = $from.blockRange($to, (node2) => node2.childCount > 0 && node2.firstChild.type == itemType);
    if (!range2)
      return false;
    if (!dispatch)
      return true;
    if ($from.node(range2.depth - 1).type == itemType)
      return liftToOuterList(state, dispatch, itemType, range2);
    else
      return liftOutOfList(state, dispatch, range2);
  };
}
function liftToOuterList(state, dispatch, itemType, range2) {
  let tr = state.tr, end2 = range2.end, endOfList = range2.$to.end(range2.depth);
  if (end2 < endOfList) {
    tr.step(new ReplaceAroundStep(end2 - 1, endOfList, end2, endOfList, new Slice(Fragment.from(itemType.create(null, range2.parent.copy())), 1, 0), 1, true));
    range2 = new NodeRange(tr.doc.resolve(range2.$from.pos), tr.doc.resolve(endOfList), range2.depth);
  }
  const target = liftTarget(range2);
  if (target == null)
    return false;
  tr.lift(range2, target);
  let after = tr.mapping.map(end2, -1) - 1;
  if (canJoin(tr.doc, after))
    tr.join(after);
  dispatch(tr.scrollIntoView());
  return true;
}
function liftOutOfList(state, dispatch, range2) {
  let tr = state.tr, list = range2.parent;
  for (let pos = range2.end, i3 = range2.endIndex - 1, e3 = range2.startIndex; i3 > e3; i3--) {
    pos -= list.child(i3).nodeSize;
    tr.delete(pos - 1, pos + 1);
  }
  let $start = tr.doc.resolve(range2.start), item2 = $start.nodeAfter;
  if (tr.mapping.map(range2.end) != range2.start + $start.nodeAfter.nodeSize)
    return false;
  let atStart = range2.startIndex == 0, atEnd = range2.endIndex == list.childCount;
  let parent = $start.node(-1), indexBefore = $start.index(-1);
  if (!parent.canReplace(indexBefore + (atStart ? 0 : 1), indexBefore + 1, item2.content.append(atEnd ? Fragment.empty : Fragment.from(list))))
    return false;
  let start2 = $start.pos, end2 = start2 + item2.nodeSize;
  tr.step(new ReplaceAroundStep(start2 - (atStart ? 1 : 0), end2 + (atEnd ? 1 : 0), start2 + 1, end2 - 1, new Slice((atStart ? Fragment.empty : Fragment.from(list.copy(Fragment.empty))).append(atEnd ? Fragment.empty : Fragment.from(list.copy(Fragment.empty))), atStart ? 0 : 1, atEnd ? 0 : 1), atStart ? 0 : 1));
  dispatch(tr.scrollIntoView());
  return true;
}
function sinkListItem$1(itemType) {
  return function(state, dispatch) {
    let { $from, $to } = state.selection;
    let range2 = $from.blockRange($to, (node2) => node2.childCount > 0 && node2.firstChild.type == itemType);
    if (!range2)
      return false;
    let startIndex2 = range2.startIndex;
    if (startIndex2 == 0)
      return false;
    let parent = range2.parent, nodeBefore = parent.child(startIndex2 - 1);
    if (nodeBefore.type != itemType)
      return false;
    if (dispatch) {
      let nestedBefore = nodeBefore.lastChild && nodeBefore.lastChild.type == parent.type;
      let inner = Fragment.from(nestedBefore ? itemType.create() : null);
      let slice3 = new Slice(Fragment.from(itemType.create(null, Fragment.from(parent.type.create(null, inner)))), nestedBefore ? 3 : 1, 0);
      let before = range2.start, after = range2.end;
      dispatch(state.tr.step(new ReplaceAroundStep(before - (nestedBefore ? 3 : 1), after, before, after, slice3, 1, true)).scrollIntoView());
    }
    return true;
  };
}
function createChainableState(config) {
  const { state, transaction } = config;
  let { selection } = transaction;
  let { doc: doc2 } = transaction;
  let { storedMarks } = transaction;
  return {
    ...state,
    apply: state.apply.bind(state),
    applyTransaction: state.applyTransaction.bind(state),
    filterTransaction: state.filterTransaction,
    plugins: state.plugins,
    schema: state.schema,
    reconfigure: state.reconfigure.bind(state),
    toJSON: state.toJSON.bind(state),
    get storedMarks() {
      return storedMarks;
    },
    get selection() {
      return selection;
    },
    get doc() {
      return doc2;
    },
    get tr() {
      selection = transaction.selection;
      doc2 = transaction.doc;
      storedMarks = transaction.storedMarks;
      return transaction;
    }
  };
}
class CommandManager {
  constructor(props) {
    this.editor = props.editor;
    this.rawCommands = this.editor.extensionManager.commands;
    this.customState = props.state;
  }
  get hasCustomState() {
    return !!this.customState;
  }
  get state() {
    return this.customState || this.editor.state;
  }
  get commands() {
    const { rawCommands, editor, state } = this;
    const { view } = editor;
    const { tr } = state;
    const props = this.buildProps(tr);
    return Object.fromEntries(Object.entries(rawCommands).map(([name, command2]) => {
      const method = (...args) => {
        const callback = command2(...args)(props);
        if (!tr.getMeta("preventDispatch") && !this.hasCustomState) {
          view.dispatch(tr);
        }
        return callback;
      };
      return [name, method];
    }));
  }
  get chain() {
    return () => this.createChain();
  }
  get can() {
    return () => this.createCan();
  }
  createChain(startTr, shouldDispatch = true) {
    const { rawCommands, editor, state } = this;
    const { view } = editor;
    const callbacks = [];
    const hasStartTransaction = !!startTr;
    const tr = startTr || state.tr;
    const run2 = () => {
      if (!hasStartTransaction && shouldDispatch && !tr.getMeta("preventDispatch") && !this.hasCustomState) {
        view.dispatch(tr);
      }
      return callbacks.every((callback) => callback === true);
    };
    const chain = {
      ...Object.fromEntries(Object.entries(rawCommands).map(([name, command2]) => {
        const chainedCommand = (...args) => {
          const props = this.buildProps(tr, shouldDispatch);
          const callback = command2(...args)(props);
          callbacks.push(callback);
          return chain;
        };
        return [name, chainedCommand];
      })),
      run: run2
    };
    return chain;
  }
  createCan(startTr) {
    const { rawCommands, state } = this;
    const dispatch = false;
    const tr = startTr || state.tr;
    const props = this.buildProps(tr, dispatch);
    const formattedCommands = Object.fromEntries(Object.entries(rawCommands).map(([name, command2]) => {
      return [name, (...args) => command2(...args)({ ...props, dispatch: void 0 })];
    }));
    return {
      ...formattedCommands,
      chain: () => this.createChain(tr, dispatch)
    };
  }
  buildProps(tr, shouldDispatch = true) {
    const { rawCommands, editor, state } = this;
    const { view } = editor;
    if (state.storedMarks) {
      tr.setStoredMarks(state.storedMarks);
    }
    const props = {
      tr,
      editor,
      view,
      state: createChainableState({
        state,
        transaction: tr
      }),
      dispatch: shouldDispatch ? () => void 0 : void 0,
      chain: () => this.createChain(tr),
      can: () => this.createCan(tr),
      get commands() {
        return Object.fromEntries(Object.entries(rawCommands).map(([name, command2]) => {
          return [name, (...args) => command2(...args)(props)];
        }));
      }
    };
    return props;
  }
}
class EventEmitter {
  constructor() {
    this.callbacks = {};
  }
  on(event, fn3) {
    if (!this.callbacks[event]) {
      this.callbacks[event] = [];
    }
    this.callbacks[event].push(fn3);
    return this;
  }
  emit(event, ...args) {
    const callbacks = this.callbacks[event];
    if (callbacks) {
      callbacks.forEach((callback) => callback.apply(this, args));
    }
    return this;
  }
  off(event, fn3) {
    const callbacks = this.callbacks[event];
    if (callbacks) {
      if (fn3) {
        this.callbacks[event] = callbacks.filter((callback) => callback !== fn3);
      } else {
        delete this.callbacks[event];
      }
    }
    return this;
  }
  removeAllListeners() {
    this.callbacks = {};
  }
}
function getExtensionField(extension, field, context) {
  if (extension.config[field] === void 0 && extension.parent) {
    return getExtensionField(extension.parent, field, context);
  }
  if (typeof extension.config[field] === "function") {
    const value = extension.config[field].bind({
      ...context,
      parent: extension.parent ? getExtensionField(extension.parent, field, context) : null
    });
    return value;
  }
  return extension.config[field];
}
function splitExtensions(extensions2) {
  const baseExtensions = extensions2.filter((extension) => extension.type === "extension");
  const nodeExtensions = extensions2.filter((extension) => extension.type === "node");
  const markExtensions = extensions2.filter((extension) => extension.type === "mark");
  return {
    baseExtensions,
    nodeExtensions,
    markExtensions
  };
}
function getAttributesFromExtensions(extensions2) {
  const extensionAttributes = [];
  const { nodeExtensions, markExtensions } = splitExtensions(extensions2);
  const nodeAndMarkExtensions = [...nodeExtensions, ...markExtensions];
  const defaultAttribute = {
    default: null,
    rendered: true,
    renderHTML: null,
    parseHTML: null,
    keepOnSplit: true,
    isRequired: false
  };
  extensions2.forEach((extension) => {
    const context = {
      name: extension.name,
      options: extension.options,
      storage: extension.storage
    };
    const addGlobalAttributes = getExtensionField(extension, "addGlobalAttributes", context);
    if (!addGlobalAttributes) {
      return;
    }
    const globalAttributes = addGlobalAttributes();
    globalAttributes.forEach((globalAttribute) => {
      globalAttribute.types.forEach((type) => {
        Object.entries(globalAttribute.attributes).forEach(([name, attribute]) => {
          extensionAttributes.push({
            type,
            name,
            attribute: {
              ...defaultAttribute,
              ...attribute
            }
          });
        });
      });
    });
  });
  nodeAndMarkExtensions.forEach((extension) => {
    const context = {
      name: extension.name,
      options: extension.options,
      storage: extension.storage
    };
    const addAttributes = getExtensionField(extension, "addAttributes", context);
    if (!addAttributes) {
      return;
    }
    const attributes = addAttributes();
    Object.entries(attributes).forEach(([name, attribute]) => {
      const mergedAttr = {
        ...defaultAttribute,
        ...attribute
      };
      if ((attribute === null || attribute === void 0 ? void 0 : attribute.isRequired) && (attribute === null || attribute === void 0 ? void 0 : attribute.default) === void 0) {
        delete mergedAttr.default;
      }
      extensionAttributes.push({
        type: extension.name,
        name,
        attribute: mergedAttr
      });
    });
  });
  return extensionAttributes;
}
function getNodeType(nameOrType, schema) {
  if (typeof nameOrType === "string") {
    if (!schema.nodes[nameOrType]) {
      throw Error(`There is no node type named '${nameOrType}'. Maybe you forgot to add the extension?`);
    }
    return schema.nodes[nameOrType];
  }
  return nameOrType;
}
function mergeAttributes(...objects) {
  return objects.filter((item2) => !!item2).reduce((items, item2) => {
    const mergedAttributes = { ...items };
    Object.entries(item2).forEach(([key, value]) => {
      const exists = mergedAttributes[key];
      if (!exists) {
        mergedAttributes[key] = value;
        return;
      }
      if (key === "class") {
        mergedAttributes[key] = [mergedAttributes[key], value].join(" ");
      } else if (key === "style") {
        mergedAttributes[key] = [mergedAttributes[key], value].join("; ");
      } else {
        mergedAttributes[key] = value;
      }
    });
    return mergedAttributes;
  }, {});
}
function getRenderedAttributes(nodeOrMark, extensionAttributes) {
  return extensionAttributes.filter((item2) => item2.attribute.rendered).map((item2) => {
    if (!item2.attribute.renderHTML) {
      return {
        [item2.name]: nodeOrMark.attrs[item2.name]
      };
    }
    return item2.attribute.renderHTML(nodeOrMark.attrs) || {};
  }).reduce((attributes, attribute) => mergeAttributes(attributes, attribute), {});
}
function isFunction(value) {
  return typeof value === "function";
}
function callOrReturn(value, context = void 0, ...props) {
  if (isFunction(value)) {
    if (context) {
      return value.bind(context)(...props);
    }
    return value(...props);
  }
  return value;
}
function isEmptyObject(value = {}) {
  return Object.keys(value).length === 0 && value.constructor === Object;
}
function fromString(value) {
  if (typeof value !== "string") {
    return value;
  }
  if (value.match(/^[+-]?(?:\d*\.)?\d+$/)) {
    return Number(value);
  }
  if (value === "true") {
    return true;
  }
  if (value === "false") {
    return false;
  }
  return value;
}
function injectExtensionAttributesToParseRule(parseRule, extensionAttributes) {
  if (parseRule.style) {
    return parseRule;
  }
  return {
    ...parseRule,
    getAttrs: (node2) => {
      const oldAttributes = parseRule.getAttrs ? parseRule.getAttrs(node2) : parseRule.attrs;
      if (oldAttributes === false) {
        return false;
      }
      const newAttributes = extensionAttributes.reduce((items, item2) => {
        const value = item2.attribute.parseHTML ? item2.attribute.parseHTML(node2) : fromString(node2.getAttribute(item2.name));
        if (value === null || value === void 0) {
          return items;
        }
        return {
          ...items,
          [item2.name]: value
        };
      }, {});
      return { ...oldAttributes, ...newAttributes };
    }
  };
}
function cleanUpSchemaItem(data) {
  return Object.fromEntries(Object.entries(data).filter(([key, value]) => {
    if (key === "attrs" && isEmptyObject(value)) {
      return false;
    }
    return value !== null && value !== void 0;
  }));
}
function getSchemaByResolvedExtensions(extensions2) {
  var _a;
  const allAttributes = getAttributesFromExtensions(extensions2);
  const { nodeExtensions, markExtensions } = splitExtensions(extensions2);
  const topNode = (_a = nodeExtensions.find((extension) => getExtensionField(extension, "topNode"))) === null || _a === void 0 ? void 0 : _a.name;
  const nodes = Object.fromEntries(nodeExtensions.map((extension) => {
    const extensionAttributes = allAttributes.filter((attribute) => attribute.type === extension.name);
    const context = {
      name: extension.name,
      options: extension.options,
      storage: extension.storage
    };
    const extraNodeFields = extensions2.reduce((fields, e3) => {
      const extendNodeSchema = getExtensionField(e3, "extendNodeSchema", context);
      return {
        ...fields,
        ...extendNodeSchema ? extendNodeSchema(extension) : {}
      };
    }, {});
    const schema = cleanUpSchemaItem({
      ...extraNodeFields,
      content: callOrReturn(getExtensionField(extension, "content", context)),
      marks: callOrReturn(getExtensionField(extension, "marks", context)),
      group: callOrReturn(getExtensionField(extension, "group", context)),
      inline: callOrReturn(getExtensionField(extension, "inline", context)),
      atom: callOrReturn(getExtensionField(extension, "atom", context)),
      selectable: callOrReturn(getExtensionField(extension, "selectable", context)),
      draggable: callOrReturn(getExtensionField(extension, "draggable", context)),
      code: callOrReturn(getExtensionField(extension, "code", context)),
      defining: callOrReturn(getExtensionField(extension, "defining", context)),
      isolating: callOrReturn(getExtensionField(extension, "isolating", context)),
      attrs: Object.fromEntries(extensionAttributes.map((extensionAttribute) => {
        var _a2;
        return [extensionAttribute.name, { default: (_a2 = extensionAttribute === null || extensionAttribute === void 0 ? void 0 : extensionAttribute.attribute) === null || _a2 === void 0 ? void 0 : _a2.default }];
      }))
    });
    const parseHTML = callOrReturn(getExtensionField(extension, "parseHTML", context));
    if (parseHTML) {
      schema.parseDOM = parseHTML.map((parseRule) => injectExtensionAttributesToParseRule(parseRule, extensionAttributes));
    }
    const renderHTML = getExtensionField(extension, "renderHTML", context);
    if (renderHTML) {
      schema.toDOM = (node2) => renderHTML({
        node: node2,
        HTMLAttributes: getRenderedAttributes(node2, extensionAttributes)
      });
    }
    const renderText = getExtensionField(extension, "renderText", context);
    if (renderText) {
      schema.toText = renderText;
    }
    return [extension.name, schema];
  }));
  const marks = Object.fromEntries(markExtensions.map((extension) => {
    const extensionAttributes = allAttributes.filter((attribute) => attribute.type === extension.name);
    const context = {
      name: extension.name,
      options: extension.options,
      storage: extension.storage
    };
    const extraMarkFields = extensions2.reduce((fields, e3) => {
      const extendMarkSchema = getExtensionField(e3, "extendMarkSchema", context);
      return {
        ...fields,
        ...extendMarkSchema ? extendMarkSchema(extension) : {}
      };
    }, {});
    const schema = cleanUpSchemaItem({
      ...extraMarkFields,
      inclusive: callOrReturn(getExtensionField(extension, "inclusive", context)),
      excludes: callOrReturn(getExtensionField(extension, "excludes", context)),
      group: callOrReturn(getExtensionField(extension, "group", context)),
      spanning: callOrReturn(getExtensionField(extension, "spanning", context)),
      code: callOrReturn(getExtensionField(extension, "code", context)),
      attrs: Object.fromEntries(extensionAttributes.map((extensionAttribute) => {
        var _a2;
        return [extensionAttribute.name, { default: (_a2 = extensionAttribute === null || extensionAttribute === void 0 ? void 0 : extensionAttribute.attribute) === null || _a2 === void 0 ? void 0 : _a2.default }];
      }))
    });
    const parseHTML = callOrReturn(getExtensionField(extension, "parseHTML", context));
    if (parseHTML) {
      schema.parseDOM = parseHTML.map((parseRule) => injectExtensionAttributesToParseRule(parseRule, extensionAttributes));
    }
    const renderHTML = getExtensionField(extension, "renderHTML", context);
    if (renderHTML) {
      schema.toDOM = (mark) => renderHTML({
        mark,
        HTMLAttributes: getRenderedAttributes(mark, extensionAttributes)
      });
    }
    return [extension.name, schema];
  }));
  return new Schema({
    topNode,
    nodes,
    marks
  });
}
function getSchemaTypeByName(name, schema) {
  return schema.nodes[name] || schema.marks[name] || null;
}
function isExtensionRulesEnabled(extension, enabled) {
  if (Array.isArray(enabled)) {
    return enabled.some((enabledExtension) => {
      const name = typeof enabledExtension === "string" ? enabledExtension : enabledExtension.name;
      return name === extension.name;
    });
  }
  return enabled;
}
const getTextContentFromNodes = ($from, maxMatch = 500) => {
  let textBefore = "";
  const sliceEndPos = $from.parentOffset;
  $from.parent.nodesBetween(Math.max(0, sliceEndPos - maxMatch), sliceEndPos, (node2, pos, parent, index2) => {
    var _a, _b;
    const chunk = ((_b = (_a = node2.type.spec).toText) === null || _b === void 0 ? void 0 : _b.call(_a, {
      node: node2,
      pos,
      parent,
      index: index2
    })) || node2.textContent || "%leaf%";
    textBefore += chunk.slice(0, Math.max(0, sliceEndPos - pos));
  });
  return textBefore;
};
function isRegExp(value) {
  return Object.prototype.toString.call(value) === "[object RegExp]";
}
class InputRule {
  constructor(config) {
    this.find = config.find;
    this.handler = config.handler;
  }
}
const inputRuleMatcherHandler = (text2, find2) => {
  if (isRegExp(find2)) {
    return find2.exec(text2);
  }
  const inputRuleMatch = find2(text2);
  if (!inputRuleMatch) {
    return null;
  }
  const result = [inputRuleMatch.text];
  result.index = inputRuleMatch.index;
  result.input = text2;
  result.data = inputRuleMatch.data;
  if (inputRuleMatch.replaceWith) {
    if (!inputRuleMatch.text.includes(inputRuleMatch.replaceWith)) {
      console.warn('[tiptap warn]: "inputRuleMatch.replaceWith" must be part of "inputRuleMatch.text".');
    }
    result.push(inputRuleMatch.replaceWith);
  }
  return result;
};
function run$1$1(config) {
  var _a;
  const { editor, from: from3, to, text: text2, rules, plugin } = config;
  const { view } = editor;
  if (view.composing) {
    return false;
  }
  const $from = view.state.doc.resolve(from3);
  if ($from.parent.type.spec.code || !!((_a = $from.nodeBefore || $from.nodeAfter) === null || _a === void 0 ? void 0 : _a.marks.find((mark) => mark.type.spec.code))) {
    return false;
  }
  let matched = false;
  const textBefore = getTextContentFromNodes($from) + text2;
  rules.forEach((rule) => {
    if (matched) {
      return;
    }
    const match2 = inputRuleMatcherHandler(textBefore, rule.find);
    if (!match2) {
      return;
    }
    const tr = view.state.tr;
    const state = createChainableState({
      state: view.state,
      transaction: tr
    });
    const range2 = {
      from: from3 - (match2[0].length - text2.length),
      to
    };
    const { commands: commands2, chain, can } = new CommandManager({
      editor,
      state
    });
    const handler = rule.handler({
      state,
      range: range2,
      match: match2,
      commands: commands2,
      chain,
      can
    });
    if (handler === null || !tr.steps.length) {
      return;
    }
    tr.setMeta(plugin, {
      transform: tr,
      from: from3,
      to,
      text: text2
    });
    view.dispatch(tr);
    matched = true;
  });
  return matched;
}
function inputRulesPlugin(props) {
  const { editor, rules } = props;
  const plugin = new Plugin({
    state: {
      init() {
        return null;
      },
      apply(tr, prev2) {
        const stored = tr.getMeta(plugin);
        if (stored) {
          return stored;
        }
        return tr.selectionSet || tr.docChanged ? null : prev2;
      }
    },
    props: {
      handleTextInput(view, from3, to, text2) {
        return run$1$1({
          editor,
          from: from3,
          to,
          text: text2,
          rules,
          plugin
        });
      },
      handleDOMEvents: {
        compositionend: (view) => {
          setTimeout(() => {
            const { $cursor } = view.state.selection;
            if ($cursor) {
              run$1$1({
                editor,
                from: $cursor.pos,
                to: $cursor.pos,
                text: "",
                rules,
                plugin
              });
            }
          });
          return false;
        }
      },
      handleKeyDown(view, event) {
        if (event.key !== "Enter") {
          return false;
        }
        const { $cursor } = view.state.selection;
        if ($cursor) {
          return run$1$1({
            editor,
            from: $cursor.pos,
            to: $cursor.pos,
            text: "\n",
            rules,
            plugin
          });
        }
        return false;
      }
    },
    isInputRules: true
  });
  return plugin;
}
function isNumber(value) {
  return typeof value === "number";
}
class PasteRule {
  constructor(config) {
    this.find = config.find;
    this.handler = config.handler;
  }
}
const pasteRuleMatcherHandler = (text2, find2) => {
  if (isRegExp(find2)) {
    return [...text2.matchAll(find2)];
  }
  const matches2 = find2(text2);
  if (!matches2) {
    return [];
  }
  return matches2.map((pasteRuleMatch) => {
    const result = [pasteRuleMatch.text];
    result.index = pasteRuleMatch.index;
    result.input = text2;
    result.data = pasteRuleMatch.data;
    if (pasteRuleMatch.replaceWith) {
      if (!pasteRuleMatch.text.includes(pasteRuleMatch.replaceWith)) {
        console.warn('[tiptap warn]: "pasteRuleMatch.replaceWith" must be part of "pasteRuleMatch.text".');
      }
      result.push(pasteRuleMatch.replaceWith);
    }
    return result;
  });
};
function run$2(config) {
  const { editor, state, from: from3, to, rule } = config;
  const { commands: commands2, chain, can } = new CommandManager({
    editor,
    state
  });
  const handlers2 = [];
  state.doc.nodesBetween(from3, to, (node2, pos) => {
    if (!node2.isTextblock || node2.type.spec.code) {
      return;
    }
    const resolvedFrom = Math.max(from3, pos);
    const resolvedTo = Math.min(to, pos + node2.content.size);
    const textToMatch = node2.textBetween(resolvedFrom - pos, resolvedTo - pos, void 0, "\uFFFC");
    const matches2 = pasteRuleMatcherHandler(textToMatch, rule.find);
    matches2.forEach((match2) => {
      if (match2.index === void 0) {
        return;
      }
      const start2 = resolvedFrom + match2.index + 1;
      const end2 = start2 + match2[0].length;
      const range2 = {
        from: state.tr.mapping.map(start2),
        to: state.tr.mapping.map(end2)
      };
      const handler = rule.handler({
        state,
        range: range2,
        match: match2,
        commands: commands2,
        chain,
        can
      });
      handlers2.push(handler);
    });
  });
  const success2 = handlers2.every((handler) => handler !== null);
  return success2;
}
function pasteRulesPlugin(props) {
  const { editor, rules } = props;
  let dragSourceElement = null;
  let isPastedFromProseMirror = false;
  let isDroppedFromProseMirror = false;
  const plugins2 = rules.map((rule) => {
    return new Plugin({
      view(view) {
        const handleDragstart = (event) => {
          var _a;
          dragSourceElement = ((_a = view.dom.parentElement) === null || _a === void 0 ? void 0 : _a.contains(event.target)) ? view.dom.parentElement : null;
        };
        window.addEventListener("dragstart", handleDragstart);
        return {
          destroy() {
            window.removeEventListener("dragstart", handleDragstart);
          }
        };
      },
      props: {
        handleDOMEvents: {
          drop: (view) => {
            isDroppedFromProseMirror = dragSourceElement === view.dom.parentElement;
            return false;
          },
          paste: (view, event) => {
            var _a;
            const html = (_a = event.clipboardData) === null || _a === void 0 ? void 0 : _a.getData("text/html");
            isPastedFromProseMirror = !!(html === null || html === void 0 ? void 0 : html.includes("data-pm-slice"));
            return false;
          }
        }
      },
      appendTransaction: (transactions, oldState, state) => {
        const transaction = transactions[0];
        const isPaste = transaction.getMeta("uiEvent") === "paste" && !isPastedFromProseMirror;
        const isDrop = transaction.getMeta("uiEvent") === "drop" && !isDroppedFromProseMirror;
        if (!isPaste && !isDrop) {
          return;
        }
        const from3 = oldState.doc.content.findDiffStart(state.doc.content);
        const to = oldState.doc.content.findDiffEnd(state.doc.content);
        if (!isNumber(from3) || !to || from3 === to.b) {
          return;
        }
        const tr = state.tr;
        const chainableState = createChainableState({
          state,
          transaction: tr
        });
        const handler = run$2({
          editor,
          state: chainableState,
          from: Math.max(from3 - 1, 0),
          to: to.b - 1,
          rule
        });
        if (!handler || !tr.steps.length) {
          return;
        }
        return tr;
      }
    });
  });
  return plugins2;
}
function findDuplicates(items) {
  const filtered = items.filter((el2, index2) => items.indexOf(el2) !== index2);
  return [...new Set(filtered)];
}
class ExtensionManager {
  constructor(extensions2, editor) {
    this.splittableMarks = [];
    this.editor = editor;
    this.extensions = ExtensionManager.resolve(extensions2);
    this.schema = getSchemaByResolvedExtensions(this.extensions);
    this.extensions.forEach((extension) => {
      var _a;
      this.editor.extensionStorage[extension.name] = extension.storage;
      const context = {
        name: extension.name,
        options: extension.options,
        storage: extension.storage,
        editor: this.editor,
        type: getSchemaTypeByName(extension.name, this.schema)
      };
      if (extension.type === "mark") {
        const keepOnSplit = (_a = callOrReturn(getExtensionField(extension, "keepOnSplit", context))) !== null && _a !== void 0 ? _a : true;
        if (keepOnSplit) {
          this.splittableMarks.push(extension.name);
        }
      }
      const onBeforeCreate = getExtensionField(extension, "onBeforeCreate", context);
      if (onBeforeCreate) {
        this.editor.on("beforeCreate", onBeforeCreate);
      }
      const onCreate2 = getExtensionField(extension, "onCreate", context);
      if (onCreate2) {
        this.editor.on("create", onCreate2);
      }
      const onUpdate = getExtensionField(extension, "onUpdate", context);
      if (onUpdate) {
        this.editor.on("update", onUpdate);
      }
      const onSelectionUpdate = getExtensionField(extension, "onSelectionUpdate", context);
      if (onSelectionUpdate) {
        this.editor.on("selectionUpdate", onSelectionUpdate);
      }
      const onTransaction = getExtensionField(extension, "onTransaction", context);
      if (onTransaction) {
        this.editor.on("transaction", onTransaction);
      }
      const onFocus = getExtensionField(extension, "onFocus", context);
      if (onFocus) {
        this.editor.on("focus", onFocus);
      }
      const onBlur = getExtensionField(extension, "onBlur", context);
      if (onBlur) {
        this.editor.on("blur", onBlur);
      }
      const onDestroy2 = getExtensionField(extension, "onDestroy", context);
      if (onDestroy2) {
        this.editor.on("destroy", onDestroy2);
      }
    });
  }
  static resolve(extensions2) {
    const resolvedExtensions = ExtensionManager.sort(ExtensionManager.flatten(extensions2));
    const duplicatedNames = findDuplicates(resolvedExtensions.map((extension) => extension.name));
    if (duplicatedNames.length) {
      console.warn(`[tiptap warn]: Duplicate extension names found: [${duplicatedNames.map((item2) => `'${item2}'`).join(", ")}]. This can lead to issues.`);
    }
    return resolvedExtensions;
  }
  static flatten(extensions2) {
    return extensions2.map((extension) => {
      const context = {
        name: extension.name,
        options: extension.options,
        storage: extension.storage
      };
      const addExtensions = getExtensionField(extension, "addExtensions", context);
      if (addExtensions) {
        return [extension, ...this.flatten(addExtensions())];
      }
      return extension;
    }).flat(10);
  }
  static sort(extensions2) {
    const defaultPriority = 100;
    return extensions2.sort((a4, b3) => {
      const priorityA = getExtensionField(a4, "priority") || defaultPriority;
      const priorityB = getExtensionField(b3, "priority") || defaultPriority;
      if (priorityA > priorityB) {
        return -1;
      }
      if (priorityA < priorityB) {
        return 1;
      }
      return 0;
    });
  }
  get commands() {
    return this.extensions.reduce((commands2, extension) => {
      const context = {
        name: extension.name,
        options: extension.options,
        storage: extension.storage,
        editor: this.editor,
        type: getSchemaTypeByName(extension.name, this.schema)
      };
      const addCommands = getExtensionField(extension, "addCommands", context);
      if (!addCommands) {
        return commands2;
      }
      return {
        ...commands2,
        ...addCommands()
      };
    }, {});
  }
  get plugins() {
    const { editor } = this;
    const extensions2 = ExtensionManager.sort([...this.extensions].reverse());
    const inputRules = [];
    const pasteRules = [];
    const allPlugins = extensions2.map((extension) => {
      const context = {
        name: extension.name,
        options: extension.options,
        storage: extension.storage,
        editor,
        type: getSchemaTypeByName(extension.name, this.schema)
      };
      const plugins2 = [];
      const addKeyboardShortcuts = getExtensionField(extension, "addKeyboardShortcuts", context);
      let defaultBindings = {};
      if (extension.type === "mark" && extension.config.exitable) {
        defaultBindings.ArrowRight = () => Mark.handleExit({ editor, mark: extension });
      }
      if (addKeyboardShortcuts) {
        const bindings = Object.fromEntries(Object.entries(addKeyboardShortcuts()).map(([shortcut, method]) => {
          return [shortcut, () => method({ editor })];
        }));
        defaultBindings = { ...defaultBindings, ...bindings };
      }
      const keyMapPlugin = keymap(defaultBindings);
      plugins2.push(keyMapPlugin);
      const addInputRules = getExtensionField(extension, "addInputRules", context);
      if (isExtensionRulesEnabled(extension, editor.options.enableInputRules) && addInputRules) {
        inputRules.push(...addInputRules());
      }
      const addPasteRules = getExtensionField(extension, "addPasteRules", context);
      if (isExtensionRulesEnabled(extension, editor.options.enablePasteRules) && addPasteRules) {
        pasteRules.push(...addPasteRules());
      }
      const addProseMirrorPlugins = getExtensionField(extension, "addProseMirrorPlugins", context);
      if (addProseMirrorPlugins) {
        const proseMirrorPlugins = addProseMirrorPlugins();
        plugins2.push(...proseMirrorPlugins);
      }
      return plugins2;
    }).flat();
    return [
      inputRulesPlugin({
        editor,
        rules: inputRules
      }),
      ...pasteRulesPlugin({
        editor,
        rules: pasteRules
      }),
      ...allPlugins
    ];
  }
  get attributes() {
    return getAttributesFromExtensions(this.extensions);
  }
  get nodeViews() {
    const { editor } = this;
    const { nodeExtensions } = splitExtensions(this.extensions);
    return Object.fromEntries(nodeExtensions.filter((extension) => !!getExtensionField(extension, "addNodeView")).map((extension) => {
      const extensionAttributes = this.attributes.filter((attribute) => attribute.type === extension.name);
      const context = {
        name: extension.name,
        options: extension.options,
        storage: extension.storage,
        editor,
        type: getNodeType(extension.name, this.schema)
      };
      const addNodeView = getExtensionField(extension, "addNodeView", context);
      if (!addNodeView) {
        return [];
      }
      const nodeview = (node2, view, getPos, decorations) => {
        const HTMLAttributes = getRenderedAttributes(node2, extensionAttributes);
        return addNodeView()({
          editor,
          node: node2,
          getPos,
          decorations,
          HTMLAttributes,
          extension
        });
      };
      return [extension.name, nodeview];
    }));
  }
}
function getType(value) {
  return Object.prototype.toString.call(value).slice(8, -1);
}
function isPlainObject(value) {
  if (getType(value) !== "Object") {
    return false;
  }
  return value.constructor === Object && Object.getPrototypeOf(value) === Object.prototype;
}
function mergeDeep(target, source) {
  const output = { ...target };
  if (isPlainObject(target) && isPlainObject(source)) {
    Object.keys(source).forEach((key) => {
      if (isPlainObject(source[key])) {
        if (!(key in target)) {
          Object.assign(output, { [key]: source[key] });
        } else {
          output[key] = mergeDeep(target[key], source[key]);
        }
      } else {
        Object.assign(output, { [key]: source[key] });
      }
    });
  }
  return output;
}
class Extension {
  constructor(config = {}) {
    this.type = "extension";
    this.name = "extension";
    this.parent = null;
    this.child = null;
    this.config = {
      name: this.name,
      defaultOptions: {}
    };
    this.config = {
      ...this.config,
      ...config
    };
    this.name = this.config.name;
    if (config.defaultOptions) {
      console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${this.name}".`);
    }
    this.options = this.config.defaultOptions;
    if (this.config.addOptions) {
      this.options = callOrReturn(getExtensionField(this, "addOptions", {
        name: this.name
      }));
    }
    this.storage = callOrReturn(getExtensionField(this, "addStorage", {
      name: this.name,
      options: this.options
    })) || {};
  }
  static create(config = {}) {
    return new Extension(config);
  }
  configure(options = {}) {
    const extension = this.extend();
    extension.options = mergeDeep(this.options, options);
    extension.storage = callOrReturn(getExtensionField(extension, "addStorage", {
      name: extension.name,
      options: extension.options
    }));
    return extension;
  }
  extend(extendedConfig = {}) {
    const extension = new Extension(extendedConfig);
    extension.parent = this;
    this.child = extension;
    extension.name = extendedConfig.name ? extendedConfig.name : extension.parent.name;
    if (extendedConfig.defaultOptions) {
      console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${extension.name}".`);
    }
    extension.options = callOrReturn(getExtensionField(extension, "addOptions", {
      name: extension.name
    }));
    extension.storage = callOrReturn(getExtensionField(extension, "addStorage", {
      name: extension.name,
      options: extension.options
    }));
    return extension;
  }
}
function getTextBetween(startNode, range2, options) {
  const { from: from3, to } = range2;
  const { blockSeparator = "\n\n", textSerializers = {} } = options || {};
  let text2 = "";
  let separated = true;
  startNode.nodesBetween(from3, to, (node2, pos, parent, index2) => {
    var _a;
    const textSerializer = textSerializers === null || textSerializers === void 0 ? void 0 : textSerializers[node2.type.name];
    if (textSerializer) {
      if (node2.isBlock && !separated) {
        text2 += blockSeparator;
        separated = true;
      }
      if (parent) {
        text2 += textSerializer({
          node: node2,
          pos,
          parent,
          index: index2,
          range: range2
        });
      }
    } else if (node2.isText) {
      text2 += (_a = node2 === null || node2 === void 0 ? void 0 : node2.text) === null || _a === void 0 ? void 0 : _a.slice(Math.max(from3, pos) - pos, to - pos);
      separated = false;
    } else if (node2.isBlock && !separated) {
      text2 += blockSeparator;
      separated = true;
    }
  });
  return text2;
}
function getTextSerializersFromSchema(schema) {
  return Object.fromEntries(Object.entries(schema.nodes).filter(([, node2]) => node2.spec.toText).map(([name, node2]) => [name, node2.spec.toText]));
}
const ClipboardTextSerializer = Extension.create({
  name: "clipboardTextSerializer",
  addProseMirrorPlugins() {
    return [
      new Plugin({
        key: new PluginKey("clipboardTextSerializer"),
        props: {
          clipboardTextSerializer: () => {
            const { editor } = this;
            const { state, schema } = editor;
            const { doc: doc2, selection } = state;
            const { ranges } = selection;
            const from3 = Math.min(...ranges.map((range3) => range3.$from.pos));
            const to = Math.max(...ranges.map((range3) => range3.$to.pos));
            const textSerializers = getTextSerializersFromSchema(schema);
            const range2 = { from: from3, to };
            return getTextBetween(doc2, range2, {
              textSerializers
            });
          }
        }
      })
    ];
  }
});
const blur = () => ({ editor, view }) => {
  requestAnimationFrame(() => {
    var _a;
    if (!editor.isDestroyed) {
      view.dom.blur();
      (_a = window === null || window === void 0 ? void 0 : window.getSelection()) === null || _a === void 0 ? void 0 : _a.removeAllRanges();
    }
  });
  return true;
};
const clearContent = (emitUpdate = false) => ({ commands: commands2 }) => {
  return commands2.setContent("", emitUpdate);
};
const clearNodes = () => ({ state, tr, dispatch }) => {
  const { selection } = tr;
  const { ranges } = selection;
  if (!dispatch) {
    return true;
  }
  ranges.forEach(({ $from, $to }) => {
    state.doc.nodesBetween($from.pos, $to.pos, (node2, pos) => {
      if (node2.type.isText) {
        return;
      }
      const { doc: doc2, mapping } = tr;
      const $mappedFrom = doc2.resolve(mapping.map(pos));
      const $mappedTo = doc2.resolve(mapping.map(pos + node2.nodeSize));
      const nodeRange = $mappedFrom.blockRange($mappedTo);
      if (!nodeRange) {
        return;
      }
      const targetLiftDepth = liftTarget(nodeRange);
      if (node2.type.isTextblock) {
        const { defaultType } = $mappedFrom.parent.contentMatchAt($mappedFrom.index());
        tr.setNodeMarkup(nodeRange.start, defaultType);
      }
      if (targetLiftDepth || targetLiftDepth === 0) {
        tr.lift(nodeRange, targetLiftDepth);
      }
    });
  });
  return true;
};
const command = (fn3) => (props) => {
  return fn3(props);
};
const createParagraphNear = () => ({ state, dispatch }) => {
  return createParagraphNear$1(state, dispatch);
};
const deleteCurrentNode = () => ({ tr, dispatch }) => {
  const { selection } = tr;
  const currentNode = selection.$anchor.node();
  if (currentNode.content.size > 0) {
    return false;
  }
  const $pos = tr.selection.$anchor;
  for (let depth = $pos.depth; depth > 0; depth -= 1) {
    const node2 = $pos.node(depth);
    if (node2.type === currentNode.type) {
      if (dispatch) {
        const from3 = $pos.before(depth);
        const to = $pos.after(depth);
        tr.delete(from3, to).scrollIntoView();
      }
      return true;
    }
  }
  return false;
};
const deleteNode = (typeOrName) => ({ tr, state, dispatch }) => {
  const type = getNodeType(typeOrName, state.schema);
  const $pos = tr.selection.$anchor;
  for (let depth = $pos.depth; depth > 0; depth -= 1) {
    const node2 = $pos.node(depth);
    if (node2.type === type) {
      if (dispatch) {
        const from3 = $pos.before(depth);
        const to = $pos.after(depth);
        tr.delete(from3, to).scrollIntoView();
      }
      return true;
    }
  }
  return false;
};
const deleteRange = (range2) => ({ tr, dispatch }) => {
  const { from: from3, to } = range2;
  if (dispatch) {
    tr.delete(from3, to);
  }
  return true;
};
const deleteSelection = () => ({ state, dispatch }) => {
  return deleteSelection$1(state, dispatch);
};
const enter = () => ({ commands: commands2 }) => {
  return commands2.keyboardShortcut("Enter");
};
const exitCode = () => ({ state, dispatch }) => {
  return exitCode$1(state, dispatch);
};
function objectIncludes(object1, object2, options = { strict: true }) {
  const keys2 = Object.keys(object2);
  if (!keys2.length) {
    return true;
  }
  return keys2.every((key) => {
    if (options.strict) {
      return object2[key] === object1[key];
    }
    if (isRegExp(object2[key])) {
      return object2[key].test(object1[key]);
    }
    return object2[key] === object1[key];
  });
}
function findMarkInSet(marks, type, attributes = {}) {
  return marks.find((item2) => {
    return item2.type === type && objectIncludes(item2.attrs, attributes);
  });
}
function isMarkInSet(marks, type, attributes = {}) {
  return !!findMarkInSet(marks, type, attributes);
}
function getMarkRange($pos, type, attributes = {}) {
  if (!$pos || !type) {
    return;
  }
  let start2 = $pos.parent.childAfter($pos.parentOffset);
  if ($pos.parentOffset === start2.offset && start2.offset !== 0) {
    start2 = $pos.parent.childBefore($pos.parentOffset);
  }
  if (!start2.node) {
    return;
  }
  const mark = findMarkInSet([...start2.node.marks], type, attributes);
  if (!mark) {
    return;
  }
  let startIndex2 = start2.index;
  let startPos = $pos.start() + start2.offset;
  let endIndex2 = startIndex2 + 1;
  let endPos = startPos + start2.node.nodeSize;
  findMarkInSet([...start2.node.marks], type, attributes);
  while (startIndex2 > 0 && mark.isInSet($pos.parent.child(startIndex2 - 1).marks)) {
    startIndex2 -= 1;
    startPos -= $pos.parent.child(startIndex2).nodeSize;
  }
  while (endIndex2 < $pos.parent.childCount && isMarkInSet([...$pos.parent.child(endIndex2).marks], type, attributes)) {
    endPos += $pos.parent.child(endIndex2).nodeSize;
    endIndex2 += 1;
  }
  return {
    from: startPos,
    to: endPos
  };
}
function getMarkType(nameOrType, schema) {
  if (typeof nameOrType === "string") {
    if (!schema.marks[nameOrType]) {
      throw Error(`There is no mark type named '${nameOrType}'. Maybe you forgot to add the extension?`);
    }
    return schema.marks[nameOrType];
  }
  return nameOrType;
}
const extendMarkRange = (typeOrName, attributes = {}) => ({ tr, state, dispatch }) => {
  const type = getMarkType(typeOrName, state.schema);
  const { doc: doc2, selection } = tr;
  const { $from, from: from3, to } = selection;
  if (dispatch) {
    const range2 = getMarkRange($from, type, attributes);
    if (range2 && range2.from <= from3 && range2.to >= to) {
      const newSelection = TextSelection.create(doc2, range2.from, range2.to);
      tr.setSelection(newSelection);
    }
  }
  return true;
};
const first = (commands2) => (props) => {
  const items = typeof commands2 === "function" ? commands2(props) : commands2;
  for (let i3 = 0; i3 < items.length; i3 += 1) {
    if (items[i3](props)) {
      return true;
    }
  }
  return false;
};
function isTextSelection(value) {
  return value instanceof TextSelection;
}
function minMax(value = 0, min2 = 0, max2 = 0) {
  return Math.min(Math.max(value, min2), max2);
}
function resolveFocusPosition(doc2, position2 = null) {
  if (!position2) {
    return null;
  }
  const selectionAtStart = Selection.atStart(doc2);
  const selectionAtEnd = Selection.atEnd(doc2);
  if (position2 === "start" || position2 === true) {
    return selectionAtStart;
  }
  if (position2 === "end") {
    return selectionAtEnd;
  }
  const minPos = selectionAtStart.from;
  const maxPos = selectionAtEnd.to;
  if (position2 === "all") {
    return TextSelection.create(doc2, minMax(0, minPos, maxPos), minMax(doc2.content.size, minPos, maxPos));
  }
  return TextSelection.create(doc2, minMax(position2, minPos, maxPos), minMax(position2, minPos, maxPos));
}
function isiOS() {
  return [
    "iPad Simulator",
    "iPhone Simulator",
    "iPod Simulator",
    "iPad",
    "iPhone",
    "iPod"
  ].includes(navigator.platform) || navigator.userAgent.includes("Mac") && "ontouchend" in document;
}
const focus = (position2 = null, options = {}) => ({ editor, view, tr, dispatch }) => {
  options = {
    scrollIntoView: true,
    ...options
  };
  const delayedFocus = () => {
    if (isiOS()) {
      view.dom.focus();
    }
    requestAnimationFrame(() => {
      if (!editor.isDestroyed) {
        view.focus();
        if (options === null || options === void 0 ? void 0 : options.scrollIntoView) {
          editor.commands.scrollIntoView();
        }
      }
    });
  };
  if (view.hasFocus() && position2 === null || position2 === false) {
    return true;
  }
  if (dispatch && position2 === null && !isTextSelection(editor.state.selection)) {
    delayedFocus();
    return true;
  }
  const selection = resolveFocusPosition(tr.doc, position2) || editor.state.selection;
  const isSameSelection = editor.state.selection.eq(selection);
  if (dispatch) {
    if (!isSameSelection) {
      tr.setSelection(selection);
    }
    if (isSameSelection && tr.storedMarks) {
      tr.setStoredMarks(tr.storedMarks);
    }
    delayedFocus();
  }
  return true;
};
const forEach = (items, fn3) => (props) => {
  return items.every((item2, index2) => fn3(item2, { ...props, index: index2 }));
};
const insertContent = (value, options) => ({ tr, commands: commands2 }) => {
  return commands2.insertContentAt({ from: tr.selection.from, to: tr.selection.to }, value, options);
};
function elementFromString(value) {
  const wrappedValue = `<body>${value}</body>`;
  return new window.DOMParser().parseFromString(wrappedValue, "text/html").body;
}
function createNodeFromContent(content, schema, options) {
  options = {
    slice: true,
    parseOptions: {},
    ...options
  };
  if (typeof content === "object" && content !== null) {
    try {
      if (Array.isArray(content)) {
        return Fragment.fromArray(content.map((item2) => schema.nodeFromJSON(item2)));
      }
      return schema.nodeFromJSON(content);
    } catch (error) {
      console.warn("[tiptap warn]: Invalid content.", "Passed value:", content, "Error:", error);
      return createNodeFromContent("", schema, options);
    }
  }
  if (typeof content === "string") {
    const parser = DOMParser$1.fromSchema(schema);
    return options.slice ? parser.parseSlice(elementFromString(content), options.parseOptions).content : parser.parse(elementFromString(content), options.parseOptions);
  }
  return createNodeFromContent("", schema, options);
}
function selectionToInsertionEnd(tr, startLen, bias) {
  const last = tr.steps.length - 1;
  if (last < startLen) {
    return;
  }
  const step = tr.steps[last];
  if (!(step instanceof ReplaceStep || step instanceof ReplaceAroundStep)) {
    return;
  }
  const map2 = tr.mapping.maps[last];
  let end2 = 0;
  map2.forEach((_from, _to, _newFrom, newTo) => {
    if (end2 === 0) {
      end2 = newTo;
    }
  });
  tr.setSelection(Selection.near(tr.doc.resolve(end2), bias));
}
const isFragment = (nodeOrFragment) => {
  return nodeOrFragment.toString().startsWith("<");
};
const insertContentAt = (position2, value, options) => ({ tr, dispatch, editor }) => {
  if (dispatch) {
    options = {
      parseOptions: {},
      updateSelection: true,
      ...options
    };
    const content = createNodeFromContent(value, editor.schema, {
      parseOptions: {
        preserveWhitespace: "full",
        ...options.parseOptions
      }
    });
    if (content.toString() === "<>") {
      return true;
    }
    let { from: from3, to } = typeof position2 === "number" ? { from: position2, to: position2 } : position2;
    let isOnlyTextContent = true;
    let isOnlyBlockContent = true;
    const nodes = isFragment(content) ? content : [content];
    nodes.forEach((node2) => {
      node2.check();
      isOnlyTextContent = isOnlyTextContent ? node2.isText && node2.marks.length === 0 : false;
      isOnlyBlockContent = isOnlyBlockContent ? node2.isBlock : false;
    });
    if (from3 === to && isOnlyBlockContent) {
      const { parent } = tr.doc.resolve(from3);
      const isEmptyTextBlock = parent.isTextblock && !parent.type.spec.code && !parent.childCount;
      if (isEmptyTextBlock) {
        from3 -= 1;
        to += 1;
      }
    }
    if (isOnlyTextContent) {
      tr.insertText(value, from3, to);
    } else {
      tr.replaceWith(from3, to, content);
    }
    if (options.updateSelection) {
      selectionToInsertionEnd(tr, tr.steps.length - 1, -1);
    }
  }
  return true;
};
const joinUp = () => ({ state, dispatch }) => {
  return joinUp$1(state, dispatch);
};
const joinDown = () => ({ state, dispatch }) => {
  return joinDown$1(state, dispatch);
};
const joinBackward = () => ({ state, dispatch }) => {
  return joinBackward$1(state, dispatch);
};
const joinForward = () => ({ state, dispatch }) => {
  return joinForward$1(state, dispatch);
};
function isMacOS() {
  return typeof navigator !== "undefined" ? /Mac/.test(navigator.platform) : false;
}
function normalizeKeyName(name) {
  const parts = name.split(/-(?!$)/);
  let result = parts[parts.length - 1];
  if (result === "Space") {
    result = " ";
  }
  let alt;
  let ctrl;
  let shift2;
  let meta;
  for (let i3 = 0; i3 < parts.length - 1; i3 += 1) {
    const mod = parts[i3];
    if (/^(cmd|meta|m)$/i.test(mod)) {
      meta = true;
    } else if (/^a(lt)?$/i.test(mod)) {
      alt = true;
    } else if (/^(c|ctrl|control)$/i.test(mod)) {
      ctrl = true;
    } else if (/^s(hift)?$/i.test(mod)) {
      shift2 = true;
    } else if (/^mod$/i.test(mod)) {
      if (isiOS() || isMacOS()) {
        meta = true;
      } else {
        ctrl = true;
      }
    } else {
      throw new Error(`Unrecognized modifier name: ${mod}`);
    }
  }
  if (alt) {
    result = `Alt-${result}`;
  }
  if (ctrl) {
    result = `Ctrl-${result}`;
  }
  if (meta) {
    result = `Meta-${result}`;
  }
  if (shift2) {
    result = `Shift-${result}`;
  }
  return result;
}
const keyboardShortcut = (name) => ({ editor, view, tr, dispatch }) => {
  const keys2 = normalizeKeyName(name).split(/-(?!$)/);
  const key = keys2.find((item2) => !["Alt", "Ctrl", "Meta", "Shift"].includes(item2));
  const event = new KeyboardEvent("keydown", {
    key: key === "Space" ? " " : key,
    altKey: keys2.includes("Alt"),
    ctrlKey: keys2.includes("Ctrl"),
    metaKey: keys2.includes("Meta"),
    shiftKey: keys2.includes("Shift"),
    bubbles: true,
    cancelable: true
  });
  const capturedTransaction = editor.captureTransaction(() => {
    view.someProp("handleKeyDown", (f2) => f2(view, event));
  });
  capturedTransaction === null || capturedTransaction === void 0 ? void 0 : capturedTransaction.steps.forEach((step) => {
    const newStep = step.map(tr.mapping);
    if (newStep && dispatch) {
      tr.maybeStep(newStep);
    }
  });
  return true;
};
function isNodeActive(state, typeOrName, attributes = {}) {
  const { from: from3, to, empty: empty2 } = state.selection;
  const type = typeOrName ? getNodeType(typeOrName, state.schema) : null;
  const nodeRanges = [];
  state.doc.nodesBetween(from3, to, (node2, pos) => {
    if (node2.isText) {
      return;
    }
    const relativeFrom = Math.max(from3, pos);
    const relativeTo = Math.min(to, pos + node2.nodeSize);
    nodeRanges.push({
      node: node2,
      from: relativeFrom,
      to: relativeTo
    });
  });
  const selectionRange = to - from3;
  const matchedNodeRanges = nodeRanges.filter((nodeRange) => {
    if (!type) {
      return true;
    }
    return type.name === nodeRange.node.type.name;
  }).filter((nodeRange) => objectIncludes(nodeRange.node.attrs, attributes, { strict: false }));
  if (empty2) {
    return !!matchedNodeRanges.length;
  }
  const range2 = matchedNodeRanges.reduce((sum, nodeRange) => sum + nodeRange.to - nodeRange.from, 0);
  return range2 >= selectionRange;
}
const lift = (typeOrName, attributes = {}) => ({ state, dispatch }) => {
  const type = getNodeType(typeOrName, state.schema);
  const isActive2 = isNodeActive(state, type, attributes);
  if (!isActive2) {
    return false;
  }
  return lift$1(state, dispatch);
};
const liftEmptyBlock = () => ({ state, dispatch }) => {
  return liftEmptyBlock$1(state, dispatch);
};
const liftListItem = (typeOrName) => ({ state, dispatch }) => {
  const type = getNodeType(typeOrName, state.schema);
  return liftListItem$1(type)(state, dispatch);
};
const newlineInCode = () => ({ state, dispatch }) => {
  return newlineInCode$1(state, dispatch);
};
function getSchemaTypeNameByName(name, schema) {
  if (schema.nodes[name]) {
    return "node";
  }
  if (schema.marks[name]) {
    return "mark";
  }
  return null;
}
function deleteProps(obj, propOrProps) {
  const props = typeof propOrProps === "string" ? [propOrProps] : propOrProps;
  return Object.keys(obj).reduce((newObj, prop) => {
    if (!props.includes(prop)) {
      newObj[prop] = obj[prop];
    }
    return newObj;
  }, {});
}
const resetAttributes = (typeOrName, attributes) => ({ tr, state, dispatch }) => {
  let nodeType = null;
  let markType = null;
  const schemaType = getSchemaTypeNameByName(typeof typeOrName === "string" ? typeOrName : typeOrName.name, state.schema);
  if (!schemaType) {
    return false;
  }
  if (schemaType === "node") {
    nodeType = getNodeType(typeOrName, state.schema);
  }
  if (schemaType === "mark") {
    markType = getMarkType(typeOrName, state.schema);
  }
  if (dispatch) {
    tr.selection.ranges.forEach((range2) => {
      state.doc.nodesBetween(range2.$from.pos, range2.$to.pos, (node2, pos) => {
        if (nodeType && nodeType === node2.type) {
          tr.setNodeMarkup(pos, void 0, deleteProps(node2.attrs, attributes));
        }
        if (markType && node2.marks.length) {
          node2.marks.forEach((mark) => {
            if (markType === mark.type) {
              tr.addMark(pos, pos + node2.nodeSize, markType.create(deleteProps(mark.attrs, attributes)));
            }
          });
        }
      });
    });
  }
  return true;
};
const scrollIntoView = () => ({ tr, dispatch }) => {
  if (dispatch) {
    tr.scrollIntoView();
  }
  return true;
};
const selectAll = () => ({ tr, commands: commands2 }) => {
  return commands2.setTextSelection({
    from: 0,
    to: tr.doc.content.size
  });
};
const selectNodeBackward = () => ({ state, dispatch }) => {
  return selectNodeBackward$1(state, dispatch);
};
const selectNodeForward = () => ({ state, dispatch }) => {
  return selectNodeForward$1(state, dispatch);
};
const selectParentNode = () => ({ state, dispatch }) => {
  return selectParentNode$1(state, dispatch);
};
const selectTextblockEnd = () => ({ state, dispatch }) => {
  return selectTextblockEnd$1(state, dispatch);
};
const selectTextblockStart = () => ({ state, dispatch }) => {
  return selectTextblockStart$1(state, dispatch);
};
function createDocument(content, schema, parseOptions = {}) {
  return createNodeFromContent(content, schema, { slice: false, parseOptions });
}
const setContent = (content, emitUpdate = false, parseOptions = {}) => ({ tr, editor, dispatch }) => {
  const { doc: doc2 } = tr;
  const document2 = createDocument(content, editor.schema, parseOptions);
  if (dispatch) {
    tr.replaceWith(0, doc2.content.size, document2).setMeta("preventUpdate", !emitUpdate);
  }
  return true;
};
function combineTransactionSteps(oldDoc, transactions) {
  const transform = new Transform(oldDoc);
  transactions.forEach((transaction) => {
    transaction.steps.forEach((step) => {
      transform.step(step);
    });
  });
  return transform;
}
function defaultBlockAt(match2) {
  for (let i3 = 0; i3 < match2.edgeCount; i3 += 1) {
    const { type } = match2.edge(i3);
    if (type.isTextblock && !type.hasRequiredAttrs()) {
      return type;
    }
  }
  return null;
}
function findChildrenInRange(node2, range2, predicate) {
  const nodesWithPos = [];
  node2.nodesBetween(range2.from, range2.to, (child, pos) => {
    if (predicate(child)) {
      nodesWithPos.push({
        node: child,
        pos
      });
    }
  });
  return nodesWithPos;
}
function findParentNodeClosestToPos($pos, predicate) {
  for (let i3 = $pos.depth; i3 > 0; i3 -= 1) {
    const node2 = $pos.node(i3);
    if (predicate(node2)) {
      return {
        pos: i3 > 0 ? $pos.before(i3) : 0,
        start: $pos.start(i3),
        depth: i3,
        node: node2
      };
    }
  }
}
function findParentNode(predicate) {
  return (selection) => findParentNodeClosestToPos(selection.$from, predicate);
}
function getHTMLFromFragment(fragment, schema) {
  const documentFragment = DOMSerializer.fromSchema(schema).serializeFragment(fragment);
  const temporaryDocument = document.implementation.createHTMLDocument();
  const container = temporaryDocument.createElement("div");
  container.appendChild(documentFragment);
  return container.innerHTML;
}
function getText(node2, options) {
  const range2 = {
    from: 0,
    to: node2.content.size
  };
  return getTextBetween(node2, range2, options);
}
function getMarkAttributes(state, typeOrName) {
  const type = getMarkType(typeOrName, state.schema);
  const { from: from3, to, empty: empty2 } = state.selection;
  const marks = [];
  if (empty2) {
    if (state.storedMarks) {
      marks.push(...state.storedMarks);
    }
    marks.push(...state.selection.$head.marks());
  } else {
    state.doc.nodesBetween(from3, to, (node2) => {
      marks.push(...node2.marks);
    });
  }
  const mark = marks.find((markItem) => markItem.type.name === type.name);
  if (!mark) {
    return {};
  }
  return { ...mark.attrs };
}
function getNodeAttributes(state, typeOrName) {
  const type = getNodeType(typeOrName, state.schema);
  const { from: from3, to } = state.selection;
  const nodes = [];
  state.doc.nodesBetween(from3, to, (node3) => {
    nodes.push(node3);
  });
  const node2 = nodes.reverse().find((nodeItem) => nodeItem.type.name === type.name);
  if (!node2) {
    return {};
  }
  return { ...node2.attrs };
}
function getAttributes(state, typeOrName) {
  const schemaType = getSchemaTypeNameByName(typeof typeOrName === "string" ? typeOrName : typeOrName.name, state.schema);
  if (schemaType === "node") {
    return getNodeAttributes(state, typeOrName);
  }
  if (schemaType === "mark") {
    return getMarkAttributes(state, typeOrName);
  }
  return {};
}
function removeDuplicates(array, by = JSON.stringify) {
  const seen = {};
  return array.filter((item2) => {
    const key = by(item2);
    return Object.prototype.hasOwnProperty.call(seen, key) ? false : seen[key] = true;
  });
}
function simplifyChangedRanges(changes) {
  const uniqueChanges = removeDuplicates(changes);
  return uniqueChanges.length === 1 ? uniqueChanges : uniqueChanges.filter((change, index2) => {
    const rest = uniqueChanges.filter((_2, i3) => i3 !== index2);
    return !rest.some((otherChange) => {
      return change.oldRange.from >= otherChange.oldRange.from && change.oldRange.to <= otherChange.oldRange.to && change.newRange.from >= otherChange.newRange.from && change.newRange.to <= otherChange.newRange.to;
    });
  });
}
function getChangedRanges(transform) {
  const { mapping, steps: steps2 } = transform;
  const changes = [];
  mapping.maps.forEach((stepMap, index2) => {
    const ranges = [];
    if (!stepMap.ranges.length) {
      const { from: from3, to } = steps2[index2];
      if (from3 === void 0 || to === void 0) {
        return;
      }
      ranges.push({ from: from3, to });
    } else {
      stepMap.forEach((from3, to) => {
        ranges.push({ from: from3, to });
      });
    }
    ranges.forEach(({ from: from3, to }) => {
      const newStart = mapping.slice(index2).map(from3, -1);
      const newEnd = mapping.slice(index2).map(to);
      const oldStart = mapping.invert().map(newStart, -1);
      const oldEnd = mapping.invert().map(newEnd);
      changes.push({
        oldRange: {
          from: oldStart,
          to: oldEnd
        },
        newRange: {
          from: newStart,
          to: newEnd
        }
      });
    });
  });
  return simplifyChangedRanges(changes);
}
function getMarksBetween(from3, to, doc2) {
  const marks = [];
  if (from3 === to) {
    doc2.resolve(from3).marks().forEach((mark) => {
      const $pos = doc2.resolve(from3 - 1);
      const range2 = getMarkRange($pos, mark.type);
      if (!range2) {
        return;
      }
      marks.push({
        mark,
        ...range2
      });
    });
  } else {
    doc2.nodesBetween(from3, to, (node2, pos) => {
      marks.push(...node2.marks.map((mark) => ({
        from: pos,
        to: pos + node2.nodeSize,
        mark
      })));
    });
  }
  return marks;
}
function isMarkActive(state, typeOrName, attributes = {}) {
  const { empty: empty2, ranges } = state.selection;
  const type = typeOrName ? getMarkType(typeOrName, state.schema) : null;
  if (empty2) {
    return !!(state.storedMarks || state.selection.$from.marks()).filter((mark) => {
      if (!type) {
        return true;
      }
      return type.name === mark.type.name;
    }).find((mark) => objectIncludes(mark.attrs, attributes, { strict: false }));
  }
  let selectionRange = 0;
  const markRanges = [];
  ranges.forEach(({ $from, $to }) => {
    const from3 = $from.pos;
    const to = $to.pos;
    state.doc.nodesBetween(from3, to, (node2, pos) => {
      if (!node2.isText && !node2.marks.length) {
        return;
      }
      const relativeFrom = Math.max(from3, pos);
      const relativeTo = Math.min(to, pos + node2.nodeSize);
      const range3 = relativeTo - relativeFrom;
      selectionRange += range3;
      markRanges.push(...node2.marks.map((mark) => ({
        mark,
        from: relativeFrom,
        to: relativeTo
      })));
    });
  });
  if (selectionRange === 0) {
    return false;
  }
  const matchedRange = markRanges.filter((markRange) => {
    if (!type) {
      return true;
    }
    return type.name === markRange.mark.type.name;
  }).filter((markRange) => objectIncludes(markRange.mark.attrs, attributes, { strict: false })).reduce((sum, markRange) => sum + markRange.to - markRange.from, 0);
  const excludedRange = markRanges.filter((markRange) => {
    if (!type) {
      return true;
    }
    return markRange.mark.type !== type && markRange.mark.type.excludes(type);
  }).reduce((sum, markRange) => sum + markRange.to - markRange.from, 0);
  const range2 = matchedRange > 0 ? matchedRange + excludedRange : matchedRange;
  return range2 >= selectionRange;
}
function isActive(state, name, attributes = {}) {
  if (!name) {
    return isNodeActive(state, null, attributes) || isMarkActive(state, null, attributes);
  }
  const schemaType = getSchemaTypeNameByName(name, state.schema);
  if (schemaType === "node") {
    return isNodeActive(state, name, attributes);
  }
  if (schemaType === "mark") {
    return isMarkActive(state, name, attributes);
  }
  return false;
}
function isList(name, extensions2) {
  const { nodeExtensions } = splitExtensions(extensions2);
  const extension = nodeExtensions.find((item2) => item2.name === name);
  if (!extension) {
    return false;
  }
  const context = {
    name: extension.name,
    options: extension.options,
    storage: extension.storage
  };
  const group = callOrReturn(getExtensionField(extension, "group", context));
  if (typeof group !== "string") {
    return false;
  }
  return group.split(" ").includes("list");
}
function isNodeEmpty(node2) {
  var _a;
  const defaultContent = (_a = node2.type.createAndFill()) === null || _a === void 0 ? void 0 : _a.toJSON();
  const content = node2.toJSON();
  return JSON.stringify(defaultContent) === JSON.stringify(content);
}
function isNodeSelection(value) {
  return value instanceof NodeSelection;
}
function posToDOMRect(view, from3, to) {
  const minPos = 0;
  const maxPos = view.state.doc.content.size;
  const resolvedFrom = minMax(from3, minPos, maxPos);
  const resolvedEnd = minMax(to, minPos, maxPos);
  const start2 = view.coordsAtPos(resolvedFrom);
  const end2 = view.coordsAtPos(resolvedEnd, -1);
  const top2 = Math.min(start2.top, end2.top);
  const bottom2 = Math.max(start2.bottom, end2.bottom);
  const left2 = Math.min(start2.left, end2.left);
  const right2 = Math.max(start2.right, end2.right);
  const width = right2 - left2;
  const height = bottom2 - top2;
  const x3 = left2;
  const y4 = top2;
  const data = {
    top: top2,
    bottom: bottom2,
    left: left2,
    right: right2,
    width,
    height,
    x: x3,
    y: y4
  };
  return {
    ...data,
    toJSON: () => data
  };
}
function canSetMark(state, tr, newMarkType) {
  var _a;
  const { selection } = tr;
  let cursor2 = null;
  if (isTextSelection(selection)) {
    cursor2 = selection.$cursor;
  }
  if (cursor2) {
    const currentMarks = (_a = state.storedMarks) !== null && _a !== void 0 ? _a : cursor2.marks();
    return !!newMarkType.isInSet(currentMarks) || !currentMarks.some((mark) => mark.type.excludes(newMarkType));
  }
  const { ranges } = selection;
  return ranges.some(({ $from, $to }) => {
    let someNodeSupportsMark = $from.depth === 0 ? state.doc.inlineContent && state.doc.type.allowsMarkType(newMarkType) : false;
    state.doc.nodesBetween($from.pos, $to.pos, (node2, _pos, parent) => {
      if (someNodeSupportsMark) {
        return false;
      }
      if (node2.isInline) {
        const parentAllowsMarkType = !parent || parent.type.allowsMarkType(newMarkType);
        const currentMarksAllowMarkType = !!newMarkType.isInSet(node2.marks) || !node2.marks.some((otherMark) => otherMark.type.excludes(newMarkType));
        someNodeSupportsMark = parentAllowsMarkType && currentMarksAllowMarkType;
      }
      return !someNodeSupportsMark;
    });
    return someNodeSupportsMark;
  });
}
const setMark = (typeOrName, attributes = {}) => ({ tr, state, dispatch }) => {
  const { selection } = tr;
  const { empty: empty2, ranges } = selection;
  const type = getMarkType(typeOrName, state.schema);
  if (dispatch) {
    if (empty2) {
      const oldAttributes = getMarkAttributes(state, type);
      tr.addStoredMark(type.create({
        ...oldAttributes,
        ...attributes
      }));
    } else {
      ranges.forEach((range2) => {
        const from3 = range2.$from.pos;
        const to = range2.$to.pos;
        state.doc.nodesBetween(from3, to, (node2, pos) => {
          const trimmedFrom = Math.max(pos, from3);
          const trimmedTo = Math.min(pos + node2.nodeSize, to);
          const someHasMark = node2.marks.find((mark) => mark.type === type);
          if (someHasMark) {
            node2.marks.forEach((mark) => {
              if (type === mark.type) {
                tr.addMark(trimmedFrom, trimmedTo, type.create({
                  ...mark.attrs,
                  ...attributes
                }));
              }
            });
          } else {
            tr.addMark(trimmedFrom, trimmedTo, type.create(attributes));
          }
        });
      });
    }
  }
  return canSetMark(state, tr, type);
};
const setMeta = (key, value) => ({ tr }) => {
  tr.setMeta(key, value);
  return true;
};
const setNode = (typeOrName, attributes = {}) => ({ state, dispatch, chain }) => {
  const type = getNodeType(typeOrName, state.schema);
  if (!type.isTextblock) {
    console.warn('[tiptap warn]: Currently "setNode()" only supports text block nodes.');
    return false;
  }
  return chain().command(({ commands: commands2 }) => {
    const canSetBlock = setBlockType(type, attributes)(state);
    if (canSetBlock) {
      return true;
    }
    return commands2.clearNodes();
  }).command(({ state: updatedState }) => {
    return setBlockType(type, attributes)(updatedState, dispatch);
  }).run();
};
const setNodeSelection = (position2) => ({ tr, dispatch }) => {
  if (dispatch) {
    const { doc: doc2 } = tr;
    const from3 = minMax(position2, 0, doc2.content.size);
    const selection = NodeSelection.create(doc2, from3);
    tr.setSelection(selection);
  }
  return true;
};
const setTextSelection = (position2) => ({ tr, dispatch }) => {
  if (dispatch) {
    const { doc: doc2 } = tr;
    const { from: from3, to } = typeof position2 === "number" ? { from: position2, to: position2 } : position2;
    const minPos = TextSelection.atStart(doc2).from;
    const maxPos = TextSelection.atEnd(doc2).to;
    const resolvedFrom = minMax(from3, minPos, maxPos);
    const resolvedEnd = minMax(to, minPos, maxPos);
    const selection = TextSelection.create(doc2, resolvedFrom, resolvedEnd);
    tr.setSelection(selection);
  }
  return true;
};
const sinkListItem = (typeOrName) => ({ state, dispatch }) => {
  const type = getNodeType(typeOrName, state.schema);
  return sinkListItem$1(type)(state, dispatch);
};
function getSplittedAttributes(extensionAttributes, typeName, attributes) {
  return Object.fromEntries(Object.entries(attributes).filter(([name]) => {
    const extensionAttribute = extensionAttributes.find((item2) => {
      return item2.type === typeName && item2.name === name;
    });
    if (!extensionAttribute) {
      return false;
    }
    return extensionAttribute.attribute.keepOnSplit;
  }));
}
function ensureMarks(state, splittableMarks) {
  const marks = state.storedMarks || state.selection.$to.parentOffset && state.selection.$from.marks();
  if (marks) {
    const filteredMarks = marks.filter((mark) => splittableMarks === null || splittableMarks === void 0 ? void 0 : splittableMarks.includes(mark.type.name));
    state.tr.ensureMarks(filteredMarks);
  }
}
const splitBlock = ({ keepMarks = true } = {}) => ({ tr, state, dispatch, editor }) => {
  const { selection, doc: doc2 } = tr;
  const { $from, $to } = selection;
  const extensionAttributes = editor.extensionManager.attributes;
  const newAttributes = getSplittedAttributes(extensionAttributes, $from.node().type.name, $from.node().attrs);
  if (selection instanceof NodeSelection && selection.node.isBlock) {
    if (!$from.parentOffset || !canSplit(doc2, $from.pos)) {
      return false;
    }
    if (dispatch) {
      if (keepMarks) {
        ensureMarks(state, editor.extensionManager.splittableMarks);
      }
      tr.split($from.pos).scrollIntoView();
    }
    return true;
  }
  if (!$from.parent.isBlock) {
    return false;
  }
  if (dispatch) {
    const atEnd = $to.parentOffset === $to.parent.content.size;
    if (selection instanceof TextSelection) {
      tr.deleteSelection();
    }
    const deflt = $from.depth === 0 ? void 0 : defaultBlockAt($from.node(-1).contentMatchAt($from.indexAfter(-1)));
    let types = atEnd && deflt ? [
      {
        type: deflt,
        attrs: newAttributes
      }
    ] : void 0;
    let can = canSplit(tr.doc, tr.mapping.map($from.pos), 1, types);
    if (!types && !can && canSplit(tr.doc, tr.mapping.map($from.pos), 1, deflt ? [{ type: deflt }] : void 0)) {
      can = true;
      types = deflt ? [
        {
          type: deflt,
          attrs: newAttributes
        }
      ] : void 0;
    }
    if (can) {
      tr.split(tr.mapping.map($from.pos), 1, types);
      if (deflt && !atEnd && !$from.parentOffset && $from.parent.type !== deflt) {
        const first2 = tr.mapping.map($from.before());
        const $first = tr.doc.resolve(first2);
        if ($from.node(-1).canReplaceWith($first.index(), $first.index() + 1, deflt)) {
          tr.setNodeMarkup(tr.mapping.map($from.before()), deflt);
        }
      }
    }
    if (keepMarks) {
      ensureMarks(state, editor.extensionManager.splittableMarks);
    }
    tr.scrollIntoView();
  }
  return true;
};
const splitListItem = (typeOrName) => ({ tr, state, dispatch, editor }) => {
  var _a;
  const type = getNodeType(typeOrName, state.schema);
  const { $from, $to } = state.selection;
  const node2 = state.selection.node;
  if (node2 && node2.isBlock || $from.depth < 2 || !$from.sameParent($to)) {
    return false;
  }
  const grandParent = $from.node(-1);
  if (grandParent.type !== type) {
    return false;
  }
  const extensionAttributes = editor.extensionManager.attributes;
  if ($from.parent.content.size === 0 && $from.node(-1).childCount === $from.indexAfter(-1)) {
    if ($from.depth === 2 || $from.node(-3).type !== type || $from.index(-2) !== $from.node(-2).childCount - 1) {
      return false;
    }
    if (dispatch) {
      let wrap2 = Fragment.empty;
      const depthBefore = $from.index(-1) ? 1 : $from.index(-2) ? 2 : 3;
      for (let d4 = $from.depth - depthBefore; d4 >= $from.depth - 3; d4 -= 1) {
        wrap2 = Fragment.from($from.node(d4).copy(wrap2));
      }
      const depthAfter = $from.indexAfter(-1) < $from.node(-2).childCount ? 1 : $from.indexAfter(-2) < $from.node(-3).childCount ? 2 : 3;
      const newNextTypeAttributes2 = getSplittedAttributes(extensionAttributes, $from.node().type.name, $from.node().attrs);
      const nextType2 = ((_a = type.contentMatch.defaultType) === null || _a === void 0 ? void 0 : _a.createAndFill(newNextTypeAttributes2)) || void 0;
      wrap2 = wrap2.append(Fragment.from(type.createAndFill(null, nextType2) || void 0));
      const start2 = $from.before($from.depth - (depthBefore - 1));
      tr.replace(start2, $from.after(-depthAfter), new Slice(wrap2, 4 - depthBefore, 0));
      let sel = -1;
      tr.doc.nodesBetween(start2, tr.doc.content.size, (n2, pos) => {
        if (sel > -1) {
          return false;
        }
        if (n2.isTextblock && n2.content.size === 0) {
          sel = pos + 1;
        }
      });
      if (sel > -1) {
        tr.setSelection(TextSelection.near(tr.doc.resolve(sel)));
      }
      tr.scrollIntoView();
    }
    return true;
  }
  const nextType = $to.pos === $from.end() ? grandParent.contentMatchAt(0).defaultType : null;
  const newTypeAttributes = getSplittedAttributes(extensionAttributes, grandParent.type.name, grandParent.attrs);
  const newNextTypeAttributes = getSplittedAttributes(extensionAttributes, $from.node().type.name, $from.node().attrs);
  tr.delete($from.pos, $to.pos);
  const types = nextType ? [
    { type, attrs: newTypeAttributes },
    { type: nextType, attrs: newNextTypeAttributes }
  ] : [{ type, attrs: newTypeAttributes }];
  if (!canSplit(tr.doc, $from.pos, 2)) {
    return false;
  }
  if (dispatch) {
    tr.split($from.pos, 2, types).scrollIntoView();
  }
  return true;
};
const joinListBackwards = (tr, listType) => {
  const list = findParentNode((node2) => node2.type === listType)(tr.selection);
  if (!list) {
    return true;
  }
  const before = tr.doc.resolve(Math.max(0, list.pos - 1)).before(list.depth);
  if (before === void 0) {
    return true;
  }
  const nodeBefore = tr.doc.nodeAt(before);
  const canJoinBackwards = list.node.type === (nodeBefore === null || nodeBefore === void 0 ? void 0 : nodeBefore.type) && canJoin(tr.doc, list.pos);
  if (!canJoinBackwards) {
    return true;
  }
  tr.join(list.pos);
  return true;
};
const joinListForwards = (tr, listType) => {
  const list = findParentNode((node2) => node2.type === listType)(tr.selection);
  if (!list) {
    return true;
  }
  const after = tr.doc.resolve(list.start).after(list.depth);
  if (after === void 0) {
    return true;
  }
  const nodeAfter = tr.doc.nodeAt(after);
  const canJoinForwards = list.node.type === (nodeAfter === null || nodeAfter === void 0 ? void 0 : nodeAfter.type) && canJoin(tr.doc, after);
  if (!canJoinForwards) {
    return true;
  }
  tr.join(after);
  return true;
};
const toggleList = (listTypeOrName, itemTypeOrName) => ({ editor, tr, state, dispatch, chain, commands: commands2, can }) => {
  const { extensions: extensions2 } = editor.extensionManager;
  const listType = getNodeType(listTypeOrName, state.schema);
  const itemType = getNodeType(itemTypeOrName, state.schema);
  const { selection } = state;
  const { $from, $to } = selection;
  const range2 = $from.blockRange($to);
  if (!range2) {
    return false;
  }
  const parentList = findParentNode((node2) => isList(node2.type.name, extensions2))(selection);
  if (range2.depth >= 1 && parentList && range2.depth - parentList.depth <= 1) {
    if (parentList.node.type === listType) {
      return commands2.liftListItem(itemType);
    }
    if (isList(parentList.node.type.name, extensions2) && listType.validContent(parentList.node.content) && dispatch) {
      return chain().command(() => {
        tr.setNodeMarkup(parentList.pos, listType);
        return true;
      }).command(() => joinListBackwards(tr, listType)).command(() => joinListForwards(tr, listType)).run();
    }
  }
  return chain().command(() => {
    const canWrapInList = can().wrapInList(listType);
    if (canWrapInList) {
      return true;
    }
    return commands2.clearNodes();
  }).wrapInList(listType).command(() => joinListBackwards(tr, listType)).command(() => joinListForwards(tr, listType)).run();
};
const toggleMark = (typeOrName, attributes = {}, options = {}) => ({ state, commands: commands2 }) => {
  const { extendEmptyMarkRange = false } = options;
  const type = getMarkType(typeOrName, state.schema);
  const isActive2 = isMarkActive(state, type, attributes);
  if (isActive2) {
    return commands2.unsetMark(type, { extendEmptyMarkRange });
  }
  return commands2.setMark(type, attributes);
};
const toggleNode = (typeOrName, toggleTypeOrName, attributes = {}) => ({ state, commands: commands2 }) => {
  const type = getNodeType(typeOrName, state.schema);
  const toggleType = getNodeType(toggleTypeOrName, state.schema);
  const isActive2 = isNodeActive(state, type, attributes);
  if (isActive2) {
    return commands2.setNode(toggleType);
  }
  return commands2.setNode(type, attributes);
};
const toggleWrap = (typeOrName, attributes = {}) => ({ state, commands: commands2 }) => {
  const type = getNodeType(typeOrName, state.schema);
  const isActive2 = isNodeActive(state, type, attributes);
  if (isActive2) {
    return commands2.lift(type);
  }
  return commands2.wrapIn(type, attributes);
};
const undoInputRule = () => ({ state, dispatch }) => {
  const plugins2 = state.plugins;
  for (let i3 = 0; i3 < plugins2.length; i3 += 1) {
    const plugin = plugins2[i3];
    let undoable;
    if (plugin.spec.isInputRules && (undoable = plugin.getState(state))) {
      if (dispatch) {
        const tr = state.tr;
        const toUndo = undoable.transform;
        for (let j2 = toUndo.steps.length - 1; j2 >= 0; j2 -= 1) {
          tr.step(toUndo.steps[j2].invert(toUndo.docs[j2]));
        }
        if (undoable.text) {
          const marks = tr.doc.resolve(undoable.from).marks();
          tr.replaceWith(undoable.from, undoable.to, state.schema.text(undoable.text, marks));
        } else {
          tr.delete(undoable.from, undoable.to);
        }
      }
      return true;
    }
  }
  return false;
};
const unsetAllMarks = () => ({ tr, dispatch }) => {
  const { selection } = tr;
  const { empty: empty2, ranges } = selection;
  if (empty2) {
    return true;
  }
  if (dispatch) {
    ranges.forEach((range2) => {
      tr.removeMark(range2.$from.pos, range2.$to.pos);
    });
  }
  return true;
};
const unsetMark = (typeOrName, options = {}) => ({ tr, state, dispatch }) => {
  var _a;
  const { extendEmptyMarkRange = false } = options;
  const { selection } = tr;
  const type = getMarkType(typeOrName, state.schema);
  const { $from, empty: empty2, ranges } = selection;
  if (!dispatch) {
    return true;
  }
  if (empty2 && extendEmptyMarkRange) {
    let { from: from3, to } = selection;
    const attrs = (_a = $from.marks().find((mark) => mark.type === type)) === null || _a === void 0 ? void 0 : _a.attrs;
    const range2 = getMarkRange($from, type, attrs);
    if (range2) {
      from3 = range2.from;
      to = range2.to;
    }
    tr.removeMark(from3, to, type);
  } else {
    ranges.forEach((range2) => {
      tr.removeMark(range2.$from.pos, range2.$to.pos, type);
    });
  }
  tr.removeStoredMark(type);
  return true;
};
const updateAttributes = (typeOrName, attributes = {}) => ({ tr, state, dispatch }) => {
  let nodeType = null;
  let markType = null;
  const schemaType = getSchemaTypeNameByName(typeof typeOrName === "string" ? typeOrName : typeOrName.name, state.schema);
  if (!schemaType) {
    return false;
  }
  if (schemaType === "node") {
    nodeType = getNodeType(typeOrName, state.schema);
  }
  if (schemaType === "mark") {
    markType = getMarkType(typeOrName, state.schema);
  }
  if (dispatch) {
    tr.selection.ranges.forEach((range2) => {
      const from3 = range2.$from.pos;
      const to = range2.$to.pos;
      state.doc.nodesBetween(from3, to, (node2, pos) => {
        if (nodeType && nodeType === node2.type) {
          tr.setNodeMarkup(pos, void 0, {
            ...node2.attrs,
            ...attributes
          });
        }
        if (markType && node2.marks.length) {
          node2.marks.forEach((mark) => {
            if (markType === mark.type) {
              const trimmedFrom = Math.max(pos, from3);
              const trimmedTo = Math.min(pos + node2.nodeSize, to);
              tr.addMark(trimmedFrom, trimmedTo, markType.create({
                ...mark.attrs,
                ...attributes
              }));
            }
          });
        }
      });
    });
  }
  return true;
};
const wrapIn = (typeOrName, attributes = {}) => ({ state, dispatch }) => {
  const type = getNodeType(typeOrName, state.schema);
  return wrapIn$1(type, attributes)(state, dispatch);
};
const wrapInList = (typeOrName, attributes = {}) => ({ state, dispatch }) => {
  const type = getNodeType(typeOrName, state.schema);
  return wrapInList$1(type, attributes)(state, dispatch);
};
var commands = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  blur,
  clearContent,
  clearNodes,
  command,
  createParagraphNear,
  deleteCurrentNode,
  deleteNode,
  deleteRange,
  deleteSelection,
  enter,
  exitCode,
  extendMarkRange,
  first,
  focus,
  forEach,
  insertContent,
  insertContentAt,
  joinUp,
  joinDown,
  joinBackward,
  joinForward,
  keyboardShortcut,
  lift,
  liftEmptyBlock,
  liftListItem,
  newlineInCode,
  resetAttributes,
  scrollIntoView,
  selectAll,
  selectNodeBackward,
  selectNodeForward,
  selectParentNode,
  selectTextblockEnd,
  selectTextblockStart,
  setContent,
  setMark,
  setMeta,
  setNode,
  setNodeSelection,
  setTextSelection,
  sinkListItem,
  splitBlock,
  splitListItem,
  toggleList,
  toggleMark,
  toggleNode,
  toggleWrap,
  undoInputRule,
  unsetAllMarks,
  unsetMark,
  updateAttributes,
  wrapIn,
  wrapInList
});
const Commands = Extension.create({
  name: "commands",
  addCommands() {
    return {
      ...commands
    };
  }
});
const Editable = Extension.create({
  name: "editable",
  addProseMirrorPlugins() {
    return [
      new Plugin({
        key: new PluginKey("editable"),
        props: {
          editable: () => this.editor.options.editable
        }
      })
    ];
  }
});
const FocusEvents = Extension.create({
  name: "focusEvents",
  addProseMirrorPlugins() {
    const { editor } = this;
    return [
      new Plugin({
        key: new PluginKey("focusEvents"),
        props: {
          handleDOMEvents: {
            focus: (view, event) => {
              editor.isFocused = true;
              const transaction = editor.state.tr.setMeta("focus", { event }).setMeta("addToHistory", false);
              view.dispatch(transaction);
              return false;
            },
            blur: (view, event) => {
              editor.isFocused = false;
              const transaction = editor.state.tr.setMeta("blur", { event }).setMeta("addToHistory", false);
              view.dispatch(transaction);
              return false;
            }
          }
        }
      })
    ];
  }
});
const Keymap = Extension.create({
  name: "keymap",
  addKeyboardShortcuts() {
    const handleBackspace = () => this.editor.commands.first(({ commands: commands2 }) => [
      () => commands2.undoInputRule(),
      () => commands2.command(({ tr }) => {
        const { selection, doc: doc2 } = tr;
        const { empty: empty2, $anchor } = selection;
        const { pos, parent } = $anchor;
        const isAtStart = Selection.atStart(doc2).from === pos;
        if (!empty2 || !isAtStart || !parent.type.isTextblock || parent.textContent.length) {
          return false;
        }
        return commands2.clearNodes();
      }),
      () => commands2.deleteSelection(),
      () => commands2.joinBackward(),
      () => commands2.selectNodeBackward()
    ]);
    const handleDelete = () => this.editor.commands.first(({ commands: commands2 }) => [
      () => commands2.deleteSelection(),
      () => commands2.deleteCurrentNode(),
      () => commands2.joinForward(),
      () => commands2.selectNodeForward()
    ]);
    const handleEnter = () => this.editor.commands.first(({ commands: commands2 }) => [
      () => commands2.newlineInCode(),
      () => commands2.createParagraphNear(),
      () => commands2.liftEmptyBlock(),
      () => commands2.splitBlock()
    ]);
    const baseKeymap = {
      Enter: handleEnter,
      "Mod-Enter": () => this.editor.commands.exitCode(),
      Backspace: handleBackspace,
      "Mod-Backspace": handleBackspace,
      "Shift-Backspace": handleBackspace,
      Delete: handleDelete,
      "Mod-Delete": handleDelete,
      "Mod-a": () => this.editor.commands.selectAll()
    };
    const pcKeymap = {
      ...baseKeymap
    };
    const macKeymap = {
      ...baseKeymap,
      "Ctrl-h": handleBackspace,
      "Alt-Backspace": handleBackspace,
      "Ctrl-d": handleDelete,
      "Ctrl-Alt-Backspace": handleDelete,
      "Alt-Delete": handleDelete,
      "Alt-d": handleDelete,
      "Ctrl-a": () => this.editor.commands.selectTextblockStart(),
      "Ctrl-e": () => this.editor.commands.selectTextblockEnd()
    };
    if (isiOS() || isMacOS()) {
      return macKeymap;
    }
    return pcKeymap;
  },
  addProseMirrorPlugins() {
    return [
      new Plugin({
        key: new PluginKey("clearDocument"),
        appendTransaction: (transactions, oldState, newState) => {
          const docChanges = transactions.some((transaction) => transaction.docChanged) && !oldState.doc.eq(newState.doc);
          if (!docChanges) {
            return;
          }
          const { empty: empty2, from: from3, to } = oldState.selection;
          const allFrom = Selection.atStart(oldState.doc).from;
          const allEnd = Selection.atEnd(oldState.doc).to;
          const allWasSelected = from3 === allFrom && to === allEnd;
          const isEmpty = newState.doc.textBetween(0, newState.doc.content.size, " ", " ").length === 0;
          if (empty2 || !allWasSelected || !isEmpty) {
            return;
          }
          const tr = newState.tr;
          const state = createChainableState({
            state: newState,
            transaction: tr
          });
          const { commands: commands2 } = new CommandManager({
            editor: this.editor,
            state
          });
          commands2.clearNodes();
          if (!tr.steps.length) {
            return;
          }
          return tr;
        }
      })
    ];
  }
});
const Tabindex = Extension.create({
  name: "tabindex",
  addProseMirrorPlugins() {
    return [
      new Plugin({
        key: new PluginKey("tabindex"),
        props: {
          attributes: this.editor.isEditable ? { tabindex: "0" } : {}
        }
      })
    ];
  }
});
var extensions = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  ClipboardTextSerializer,
  Commands,
  Editable,
  FocusEvents,
  Keymap,
  Tabindex
});
const style = `.ProseMirror {
  position: relative;
}

.ProseMirror {
  word-wrap: break-word;
  white-space: pre-wrap;
  white-space: break-spaces;
  -webkit-font-variant-ligatures: none;
  font-variant-ligatures: none;
  font-feature-settings: "liga" 0; /* the above doesn't seem to work in Edge */
}

.ProseMirror [contenteditable="false"] {
  white-space: normal;
}

.ProseMirror [contenteditable="false"] [contenteditable="true"] {
  white-space: pre-wrap;
}

.ProseMirror pre {
  white-space: pre-wrap;
}

img.ProseMirror-separator {
  display: inline !important;
  border: none !important;
  margin: 0 !important;
  width: 1px !important;
  height: 1px !important;
}

.ProseMirror-gapcursor {
  display: none;
  pointer-events: none;
  position: absolute;
  margin: 0;
}

.ProseMirror-gapcursor:after {
  content: "";
  display: block;
  position: absolute;
  top: -2px;
  width: 20px;
  border-top: 1px solid black;
  animation: ProseMirror-cursor-blink 1.1s steps(2, start) infinite;
}

@keyframes ProseMirror-cursor-blink {
  to {
    visibility: hidden;
  }
}

.ProseMirror-hideselection *::selection {
  background: transparent;
}

.ProseMirror-hideselection *::-moz-selection {
  background: transparent;
}

.ProseMirror-hideselection * {
  caret-color: transparent;
}

.ProseMirror-focused .ProseMirror-gapcursor {
  display: block;
}

.tippy-box[data-animation=fade][data-state=hidden] {
  opacity: 0
}`;
function createStyleTag(style2, nonce) {
  const tipTapStyleTag = document.querySelector("style[data-tiptap-style]");
  if (tipTapStyleTag !== null) {
    return tipTapStyleTag;
  }
  const styleNode = document.createElement("style");
  if (nonce) {
    styleNode.setAttribute("nonce", nonce);
  }
  styleNode.setAttribute("data-tiptap-style", "");
  styleNode.innerHTML = style2;
  document.getElementsByTagName("head")[0].appendChild(styleNode);
  return styleNode;
}
class Editor$2 extends EventEmitter {
  constructor(options = {}) {
    super();
    this.isFocused = false;
    this.extensionStorage = {};
    this.options = {
      element: document.createElement("div"),
      content: "",
      injectCSS: true,
      injectNonce: void 0,
      extensions: [],
      autofocus: false,
      editable: true,
      editorProps: {},
      parseOptions: {},
      enableInputRules: true,
      enablePasteRules: true,
      enableCoreExtensions: true,
      onBeforeCreate: () => null,
      onCreate: () => null,
      onUpdate: () => null,
      onSelectionUpdate: () => null,
      onTransaction: () => null,
      onFocus: () => null,
      onBlur: () => null,
      onDestroy: () => null
    };
    this.isCapturingTransaction = false;
    this.capturedTransaction = null;
    this.setOptions(options);
    this.createExtensionManager();
    this.createCommandManager();
    this.createSchema();
    this.on("beforeCreate", this.options.onBeforeCreate);
    this.emit("beforeCreate", { editor: this });
    this.createView();
    this.injectCSS();
    this.on("create", this.options.onCreate);
    this.on("update", this.options.onUpdate);
    this.on("selectionUpdate", this.options.onSelectionUpdate);
    this.on("transaction", this.options.onTransaction);
    this.on("focus", this.options.onFocus);
    this.on("blur", this.options.onBlur);
    this.on("destroy", this.options.onDestroy);
    window.setTimeout(() => {
      if (this.isDestroyed) {
        return;
      }
      this.commands.focus(this.options.autofocus);
      this.emit("create", { editor: this });
    }, 0);
  }
  get storage() {
    return this.extensionStorage;
  }
  get commands() {
    return this.commandManager.commands;
  }
  chain() {
    return this.commandManager.chain();
  }
  can() {
    return this.commandManager.can();
  }
  injectCSS() {
    if (this.options.injectCSS && document) {
      this.css = createStyleTag(style, this.options.injectNonce);
    }
  }
  setOptions(options = {}) {
    this.options = {
      ...this.options,
      ...options
    };
    if (!this.view || !this.state || this.isDestroyed) {
      return;
    }
    if (this.options.editorProps) {
      this.view.setProps(this.options.editorProps);
    }
    this.view.updateState(this.state);
  }
  setEditable(editable, emitUpdate = true) {
    this.setOptions({ editable });
    if (emitUpdate) {
      this.emit("update", { editor: this, transaction: this.state.tr });
    }
  }
  get isEditable() {
    return this.options.editable && this.view && this.view.editable;
  }
  get state() {
    return this.view.state;
  }
  registerPlugin(plugin, handlePlugins) {
    const plugins2 = isFunction(handlePlugins) ? handlePlugins(plugin, [...this.state.plugins]) : [...this.state.plugins, plugin];
    const state = this.state.reconfigure({ plugins: plugins2 });
    this.view.updateState(state);
  }
  unregisterPlugin(nameOrPluginKey) {
    if (this.isDestroyed) {
      return;
    }
    const name = typeof nameOrPluginKey === "string" ? `${nameOrPluginKey}$` : nameOrPluginKey.key;
    const state = this.state.reconfigure({
      plugins: this.state.plugins.filter((plugin) => !plugin.key.startsWith(name))
    });
    this.view.updateState(state);
  }
  createExtensionManager() {
    const coreExtensions = this.options.enableCoreExtensions ? Object.values(extensions) : [];
    const allExtensions = [...coreExtensions, ...this.options.extensions].filter((extension) => {
      return ["extension", "node", "mark"].includes(extension === null || extension === void 0 ? void 0 : extension.type);
    });
    this.extensionManager = new ExtensionManager(allExtensions, this);
  }
  createCommandManager() {
    this.commandManager = new CommandManager({
      editor: this
    });
  }
  createSchema() {
    this.schema = this.extensionManager.schema;
  }
  createView() {
    const doc2 = createDocument(this.options.content, this.schema, this.options.parseOptions);
    const selection = resolveFocusPosition(doc2, this.options.autofocus);
    this.view = new EditorView(this.options.element, {
      ...this.options.editorProps,
      dispatchTransaction: this.dispatchTransaction.bind(this),
      state: EditorState.create({
        doc: doc2,
        selection: selection || void 0
      })
    });
    const newState = this.state.reconfigure({
      plugins: this.extensionManager.plugins
    });
    this.view.updateState(newState);
    this.createNodeViews();
    const dom = this.view.dom;
    dom.editor = this;
  }
  createNodeViews() {
    this.view.setProps({
      nodeViews: this.extensionManager.nodeViews
    });
  }
  captureTransaction(fn3) {
    this.isCapturingTransaction = true;
    fn3();
    this.isCapturingTransaction = false;
    const tr = this.capturedTransaction;
    this.capturedTransaction = null;
    return tr;
  }
  dispatchTransaction(transaction) {
    if (this.isCapturingTransaction) {
      if (!this.capturedTransaction) {
        this.capturedTransaction = transaction;
        return;
      }
      transaction.steps.forEach((step) => {
        var _a;
        return (_a = this.capturedTransaction) === null || _a === void 0 ? void 0 : _a.step(step);
      });
      return;
    }
    const state = this.state.apply(transaction);
    const selectionHasChanged = !this.state.selection.eq(state.selection);
    this.view.updateState(state);
    this.emit("transaction", {
      editor: this,
      transaction
    });
    if (selectionHasChanged) {
      this.emit("selectionUpdate", {
        editor: this,
        transaction
      });
    }
    const focus2 = transaction.getMeta("focus");
    const blur2 = transaction.getMeta("blur");
    if (focus2) {
      this.emit("focus", {
        editor: this,
        event: focus2.event,
        transaction
      });
    }
    if (blur2) {
      this.emit("blur", {
        editor: this,
        event: blur2.event,
        transaction
      });
    }
    if (!transaction.docChanged || transaction.getMeta("preventUpdate")) {
      return;
    }
    this.emit("update", {
      editor: this,
      transaction
    });
  }
  getAttributes(nameOrType) {
    return getAttributes(this.state, nameOrType);
  }
  isActive(nameOrAttributes, attributesOrUndefined) {
    const name = typeof nameOrAttributes === "string" ? nameOrAttributes : null;
    const attributes = typeof nameOrAttributes === "string" ? attributesOrUndefined : nameOrAttributes;
    return isActive(this.state, name, attributes);
  }
  getJSON() {
    return this.state.doc.toJSON();
  }
  getHTML() {
    return getHTMLFromFragment(this.state.doc.content, this.schema);
  }
  getText(options) {
    const { blockSeparator = "\n\n", textSerializers = {} } = options || {};
    return getText(this.state.doc, {
      blockSeparator,
      textSerializers: {
        ...textSerializers,
        ...getTextSerializersFromSchema(this.schema)
      }
    });
  }
  get isEmpty() {
    return isNodeEmpty(this.state.doc);
  }
  getCharacterCount() {
    console.warn('[tiptap warn]: "editor.getCharacterCount()" is deprecated. Please use "editor.storage.characterCount.characters()" instead.');
    return this.state.doc.content.size - 2;
  }
  destroy() {
    this.emit("destroy");
    if (this.view) {
      this.view.destroy();
    }
    this.removeAllListeners();
  }
  get isDestroyed() {
    var _a;
    return !((_a = this.view) === null || _a === void 0 ? void 0 : _a.docView);
  }
}
function markInputRule(config) {
  return new InputRule({
    find: config.find,
    handler: ({ state, range: range2, match: match2 }) => {
      const attributes = callOrReturn(config.getAttributes, void 0, match2);
      if (attributes === false || attributes === null) {
        return null;
      }
      const { tr } = state;
      const captureGroup = match2[match2.length - 1];
      const fullMatch = match2[0];
      let markEnd = range2.to;
      if (captureGroup) {
        const startSpaces = fullMatch.search(/\S/);
        const textStart = range2.from + fullMatch.indexOf(captureGroup);
        const textEnd = textStart + captureGroup.length;
        const excludedMarks = getMarksBetween(range2.from, range2.to, state.doc).filter((item2) => {
          const excluded = item2.mark.type.excluded;
          return excluded.find((type) => type === config.type && type !== item2.mark.type);
        }).filter((item2) => item2.to > textStart);
        if (excludedMarks.length) {
          return null;
        }
        if (textEnd < range2.to) {
          tr.delete(textEnd, range2.to);
        }
        if (textStart > range2.from) {
          tr.delete(range2.from + startSpaces, textStart);
        }
        markEnd = range2.from + startSpaces + captureGroup.length;
        tr.addMark(range2.from + startSpaces, markEnd, config.type.create(attributes || {}));
        tr.removeStoredMark(config.type);
      }
    }
  });
}
function textblockTypeInputRule(config) {
  return new InputRule({
    find: config.find,
    handler: ({ state, range: range2, match: match2 }) => {
      const $start = state.doc.resolve(range2.from);
      const attributes = callOrReturn(config.getAttributes, void 0, match2) || {};
      if (!$start.node(-1).canReplaceWith($start.index(-1), $start.indexAfter(-1), config.type)) {
        return null;
      }
      state.tr.delete(range2.from, range2.to).setBlockType(range2.from, range2.from, config.type, attributes);
    }
  });
}
function wrappingInputRule(config) {
  return new InputRule({
    find: config.find,
    handler: ({ state, range: range2, match: match2 }) => {
      const attributes = callOrReturn(config.getAttributes, void 0, match2) || {};
      const tr = state.tr.delete(range2.from, range2.to);
      const $start = tr.doc.resolve(range2.from);
      const blockRange = $start.blockRange();
      const wrapping = blockRange && findWrapping(blockRange, config.type, attributes);
      if (!wrapping) {
        return null;
      }
      tr.wrap(blockRange, wrapping);
      const before = tr.doc.resolve(range2.from - 1).nodeBefore;
      if (before && before.type === config.type && canJoin(tr.doc, range2.from - 1) && (!config.joinPredicate || config.joinPredicate(match2, before))) {
        tr.join(range2.from - 1);
      }
    }
  });
}
class Mark {
  constructor(config = {}) {
    this.type = "mark";
    this.name = "mark";
    this.parent = null;
    this.child = null;
    this.config = {
      name: this.name,
      defaultOptions: {}
    };
    this.config = {
      ...this.config,
      ...config
    };
    this.name = this.config.name;
    if (config.defaultOptions) {
      console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${this.name}".`);
    }
    this.options = this.config.defaultOptions;
    if (this.config.addOptions) {
      this.options = callOrReturn(getExtensionField(this, "addOptions", {
        name: this.name
      }));
    }
    this.storage = callOrReturn(getExtensionField(this, "addStorage", {
      name: this.name,
      options: this.options
    })) || {};
  }
  static create(config = {}) {
    return new Mark(config);
  }
  configure(options = {}) {
    const extension = this.extend();
    extension.options = mergeDeep(this.options, options);
    extension.storage = callOrReturn(getExtensionField(extension, "addStorage", {
      name: extension.name,
      options: extension.options
    }));
    return extension;
  }
  extend(extendedConfig = {}) {
    const extension = new Mark(extendedConfig);
    extension.parent = this;
    this.child = extension;
    extension.name = extendedConfig.name ? extendedConfig.name : extension.parent.name;
    if (extendedConfig.defaultOptions) {
      console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${extension.name}".`);
    }
    extension.options = callOrReturn(getExtensionField(extension, "addOptions", {
      name: extension.name
    }));
    extension.storage = callOrReturn(getExtensionField(extension, "addStorage", {
      name: extension.name,
      options: extension.options
    }));
    return extension;
  }
  static handleExit({ editor, mark }) {
    const { tr } = editor.state;
    const currentPos = editor.state.selection.$from;
    const isAtEnd = currentPos.pos === currentPos.end();
    if (isAtEnd) {
      const currentMarks = currentPos.marks();
      const isInMark = !!currentMarks.find((m4) => (m4 === null || m4 === void 0 ? void 0 : m4.type.name) === mark.name);
      if (!isInMark) {
        return false;
      }
      const removeMark2 = currentMarks.find((m4) => (m4 === null || m4 === void 0 ? void 0 : m4.type.name) === mark.name);
      if (removeMark2) {
        tr.removeStoredMark(removeMark2);
      }
      tr.insertText(" ", currentPos.pos);
      editor.view.dispatch(tr);
      return true;
    }
    return false;
  }
}
class Node$1 {
  constructor(config = {}) {
    this.type = "node";
    this.name = "node";
    this.parent = null;
    this.child = null;
    this.config = {
      name: this.name,
      defaultOptions: {}
    };
    this.config = {
      ...this.config,
      ...config
    };
    this.name = this.config.name;
    if (config.defaultOptions) {
      console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${this.name}".`);
    }
    this.options = this.config.defaultOptions;
    if (this.config.addOptions) {
      this.options = callOrReturn(getExtensionField(this, "addOptions", {
        name: this.name
      }));
    }
    this.storage = callOrReturn(getExtensionField(this, "addStorage", {
      name: this.name,
      options: this.options
    })) || {};
  }
  static create(config = {}) {
    return new Node$1(config);
  }
  configure(options = {}) {
    const extension = this.extend();
    extension.options = mergeDeep(this.options, options);
    extension.storage = callOrReturn(getExtensionField(extension, "addStorage", {
      name: extension.name,
      options: extension.options
    }));
    return extension;
  }
  extend(extendedConfig = {}) {
    const extension = new Node$1(extendedConfig);
    extension.parent = this;
    this.child = extension;
    extension.name = extendedConfig.name ? extendedConfig.name : extension.parent.name;
    if (extendedConfig.defaultOptions) {
      console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${extension.name}".`);
    }
    extension.options = callOrReturn(getExtensionField(extension, "addOptions", {
      name: extension.name
    }));
    extension.storage = callOrReturn(getExtensionField(extension, "addStorage", {
      name: extension.name,
      options: extension.options
    }));
    return extension;
  }
}
function markPasteRule(config) {
  return new PasteRule({
    find: config.find,
    handler: ({ state, range: range2, match: match2 }) => {
      const attributes = callOrReturn(config.getAttributes, void 0, match2);
      if (attributes === false || attributes === null) {
        return null;
      }
      const { tr } = state;
      const captureGroup = match2[match2.length - 1];
      const fullMatch = match2[0];
      let markEnd = range2.to;
      if (captureGroup) {
        const startSpaces = fullMatch.search(/\S/);
        const textStart = range2.from + fullMatch.indexOf(captureGroup);
        const textEnd = textStart + captureGroup.length;
        const excludedMarks = getMarksBetween(range2.from, range2.to, state.doc).filter((item2) => {
          const excluded = item2.mark.type.excluded;
          return excluded.find((type) => type === config.type && type !== item2.mark.type);
        }).filter((item2) => item2.to > textStart);
        if (excludedMarks.length) {
          return null;
        }
        if (textEnd < range2.to) {
          tr.delete(textEnd, range2.to);
        }
        if (textStart > range2.from) {
          tr.delete(range2.from + startSpaces, textStart);
        }
        markEnd = range2.from + startSpaces + captureGroup.length;
        tr.addMark(range2.from + startSpaces, markEnd, config.type.create(attributes || {}));
        tr.removeStoredMark(config.type);
      }
    }
  });
}
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function isObject$2(value) {
  var type = typeof value;
  return value != null && (type == "object" || type == "function");
}
var isObject_1 = isObject$2;
var freeGlobal$1 = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
var _freeGlobal = freeGlobal$1;
var freeGlobal = _freeGlobal;
var freeSelf = typeof self == "object" && self && self.Object === Object && self;
var root$2 = freeGlobal || freeSelf || Function("return this")();
var _root = root$2;
var root$1 = _root;
var now$1 = function() {
  return root$1.Date.now();
};
var now_1 = now$1;
var reWhitespace = /\s/;
function trimmedEndIndex$1(string) {
  var index2 = string.length;
  while (index2-- && reWhitespace.test(string.charAt(index2))) {
  }
  return index2;
}
var _trimmedEndIndex = trimmedEndIndex$1;
var trimmedEndIndex = _trimmedEndIndex;
var reTrimStart = /^\s+/;
function baseTrim$1(string) {
  return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, "") : string;
}
var _baseTrim = baseTrim$1;
var root = _root;
var Symbol$2 = root.Symbol;
var _Symbol = Symbol$2;
var Symbol$1 = _Symbol;
var objectProto$1 = Object.prototype;
var hasOwnProperty = objectProto$1.hasOwnProperty;
var nativeObjectToString$1 = objectProto$1.toString;
var symToStringTag$1 = Symbol$1 ? Symbol$1.toStringTag : void 0;
function getRawTag$1(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag$1), tag = value[symToStringTag$1];
  try {
    value[symToStringTag$1] = void 0;
    var unmasked = true;
  } catch (e3) {
  }
  var result = nativeObjectToString$1.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag$1] = tag;
    } else {
      delete value[symToStringTag$1];
    }
  }
  return result;
}
var _getRawTag = getRawTag$1;
var objectProto = Object.prototype;
var nativeObjectToString = objectProto.toString;
function objectToString$1(value) {
  return nativeObjectToString.call(value);
}
var _objectToString = objectToString$1;
var Symbol$3 = _Symbol, getRawTag = _getRawTag, objectToString = _objectToString;
var nullTag = "[object Null]", undefinedTag = "[object Undefined]";
var symToStringTag = Symbol$3 ? Symbol$3.toStringTag : void 0;
function baseGetTag$1(value) {
  if (value == null) {
    return value === void 0 ? undefinedTag : nullTag;
  }
  return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
}
var _baseGetTag = baseGetTag$1;
function isObjectLike$1(value) {
  return value != null && typeof value == "object";
}
var isObjectLike_1 = isObjectLike$1;
var baseGetTag = _baseGetTag, isObjectLike = isObjectLike_1;
var symbolTag = "[object Symbol]";
function isSymbol$1(value) {
  return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;
}
var isSymbol_1 = isSymbol$1;
var baseTrim = _baseTrim, isObject$1 = isObject_1, isSymbol = isSymbol_1;
var NAN = 0 / 0;
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
var reIsBinary = /^0b[01]+$/i;
var reIsOctal = /^0o[0-7]+$/i;
var freeParseInt = parseInt;
function toNumber$1(value) {
  if (typeof value == "number") {
    return value;
  }
  if (isSymbol(value)) {
    return NAN;
  }
  if (isObject$1(value)) {
    var other = typeof value.valueOf == "function" ? value.valueOf() : value;
    value = isObject$1(other) ? other + "" : other;
  }
  if (typeof value != "string") {
    return value === 0 ? value : +value;
  }
  value = baseTrim(value);
  var isBinary = reIsBinary.test(value);
  return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
}
var toNumber_1 = toNumber$1;
var isObject = isObject_1, now = now_1, toNumber = toNumber_1;
var FUNC_ERROR_TEXT = "Expected a function";
var nativeMax = Math.max, nativeMin = Math.min;
function debounce(func, wait, options) {
  var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
  if (typeof func != "function") {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  wait = toNumber(wait) || 0;
  if (isObject(options)) {
    leading = !!options.leading;
    maxing = "maxWait" in options;
    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
    trailing = "trailing" in options ? !!options.trailing : trailing;
  }
  function invokeFunc(time) {
    var args = lastArgs, thisArg = lastThis;
    lastArgs = lastThis = void 0;
    lastInvokeTime = time;
    result = func.apply(thisArg, args);
    return result;
  }
  function leadingEdge(time) {
    lastInvokeTime = time;
    timerId = setTimeout(timerExpired, wait);
    return leading ? invokeFunc(time) : result;
  }
  function remainingWait(time) {
    var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
    return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
  }
  function shouldInvoke(time) {
    var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
    return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
  }
  function timerExpired() {
    var time = now();
    if (shouldInvoke(time)) {
      return trailingEdge(time);
    }
    timerId = setTimeout(timerExpired, remainingWait(time));
  }
  function trailingEdge(time) {
    timerId = void 0;
    if (trailing && lastArgs) {
      return invokeFunc(time);
    }
    lastArgs = lastThis = void 0;
    return result;
  }
  function cancel() {
    if (timerId !== void 0) {
      clearTimeout(timerId);
    }
    lastInvokeTime = 0;
    lastArgs = lastCallTime = lastThis = timerId = void 0;
  }
  function flush() {
    return timerId === void 0 ? result : trailingEdge(now());
  }
  function debounced() {
    var time = now(), isInvoking = shouldInvoke(time);
    lastArgs = arguments;
    lastThis = this;
    lastCallTime = time;
    if (isInvoking) {
      if (timerId === void 0) {
        return leadingEdge(lastCallTime);
      }
      if (maxing) {
        clearTimeout(timerId);
        timerId = setTimeout(timerExpired, wait);
        return invokeFunc(lastCallTime);
      }
    }
    if (timerId === void 0) {
      timerId = setTimeout(timerExpired, wait);
    }
    return result;
  }
  debounced.cancel = cancel;
  debounced.flush = flush;
  return debounced;
}
var debounce_1 = debounce;
class BubbleMenuView {
  constructor({ editor, element, view, tippyOptions = {}, updateDelay = 250, shouldShow }) {
    this.preventHide = false;
    this.shouldShow = ({ view: view2, state, from: from3, to }) => {
      const { doc: doc2, selection } = state;
      const { empty: empty2 } = selection;
      const isEmptyTextBlock = !doc2.textBetween(from3, to).length && isTextSelection(state.selection);
      const isChildOfMenu = this.element.contains(document.activeElement);
      const hasEditorFocus = view2.hasFocus() || isChildOfMenu;
      if (!hasEditorFocus || empty2 || isEmptyTextBlock || !this.editor.isEditable) {
        return false;
      }
      return true;
    };
    this.mousedownHandler = () => {
      this.preventHide = true;
    };
    this.dragstartHandler = () => {
      this.hide();
    };
    this.focusHandler = () => {
      setTimeout(() => this.update(this.editor.view));
    };
    this.blurHandler = ({ event }) => {
      var _a;
      if (this.preventHide) {
        this.preventHide = false;
        return;
      }
      if ((event === null || event === void 0 ? void 0 : event.relatedTarget) && ((_a = this.element.parentNode) === null || _a === void 0 ? void 0 : _a.contains(event.relatedTarget))) {
        return;
      }
      this.hide();
    };
    this.tippyBlurHandler = (event) => {
      this.blurHandler({ event });
    };
    this.updateHandler = (view2, oldState) => {
      var _a, _b, _c;
      const { state, composing } = view2;
      const { doc: doc2, selection } = state;
      const isSame = oldState && oldState.doc.eq(doc2) && oldState.selection.eq(selection);
      if (composing || isSame) {
        return;
      }
      this.createTooltip();
      const { ranges } = selection;
      const from3 = Math.min(...ranges.map((range2) => range2.$from.pos));
      const to = Math.max(...ranges.map((range2) => range2.$to.pos));
      const shouldShow2 = (_a = this.shouldShow) === null || _a === void 0 ? void 0 : _a.call(this, {
        editor: this.editor,
        view: view2,
        state,
        oldState,
        from: from3,
        to
      });
      if (!shouldShow2) {
        this.hide();
        return;
      }
      (_b = this.tippy) === null || _b === void 0 ? void 0 : _b.setProps({
        getReferenceClientRect: ((_c = this.tippyOptions) === null || _c === void 0 ? void 0 : _c.getReferenceClientRect) || (() => {
          if (isNodeSelection(state.selection)) {
            const node2 = view2.nodeDOM(from3);
            if (node2) {
              return node2.getBoundingClientRect();
            }
          }
          return posToDOMRect(view2, from3, to);
        })
      });
      this.show();
    };
    this.editor = editor;
    this.element = element;
    this.view = view;
    this.updateDelay = updateDelay;
    if (shouldShow) {
      this.shouldShow = shouldShow;
    }
    this.element.addEventListener("mousedown", this.mousedownHandler, { capture: true });
    this.view.dom.addEventListener("dragstart", this.dragstartHandler);
    this.editor.on("focus", this.focusHandler);
    this.editor.on("blur", this.blurHandler);
    this.tippyOptions = tippyOptions;
    this.element.remove();
    this.element.style.visibility = "visible";
  }
  createTooltip() {
    const { element: editorElement } = this.editor.options;
    const editorIsAttached = !!editorElement.parentElement;
    if (this.tippy || !editorIsAttached) {
      return;
    }
    this.tippy = tippy(editorElement, {
      duration: 0,
      getReferenceClientRect: null,
      content: this.element,
      interactive: true,
      trigger: "manual",
      placement: "top",
      hideOnClick: "toggle",
      ...this.tippyOptions
    });
    if (this.tippy.popper.firstChild) {
      this.tippy.popper.firstChild.addEventListener("blur", this.tippyBlurHandler);
    }
  }
  update(view, oldState) {
    const { state } = view;
    const hasValidSelection = state.selection.$from.pos !== state.selection.$to.pos;
    if (this.updateDelay > 0 && hasValidSelection) {
      debounce_1(this.updateHandler, this.updateDelay)(view, oldState);
    } else {
      this.updateHandler(view, oldState);
    }
  }
  show() {
    var _a;
    (_a = this.tippy) === null || _a === void 0 ? void 0 : _a.show();
  }
  hide() {
    var _a;
    (_a = this.tippy) === null || _a === void 0 ? void 0 : _a.hide();
  }
  destroy() {
    var _a, _b;
    if ((_a = this.tippy) === null || _a === void 0 ? void 0 : _a.popper.firstChild) {
      this.tippy.popper.firstChild.removeEventListener("blur", this.tippyBlurHandler);
    }
    (_b = this.tippy) === null || _b === void 0 ? void 0 : _b.destroy();
    this.element.removeEventListener("mousedown", this.mousedownHandler, { capture: true });
    this.view.dom.removeEventListener("dragstart", this.dragstartHandler);
    this.editor.off("focus", this.focusHandler);
    this.editor.off("blur", this.blurHandler);
  }
}
const BubbleMenuPlugin = (options) => {
  return new Plugin({
    key: typeof options.pluginKey === "string" ? new PluginKey(options.pluginKey) : options.pluginKey,
    view: (view) => new BubbleMenuView({ view, ...options })
  });
};
Extension.create({
  name: "bubbleMenu",
  addOptions() {
    return {
      element: null,
      tippyOptions: {},
      pluginKey: "bubbleMenu",
      updateDelay: void 0,
      shouldShow: null
    };
  },
  addProseMirrorPlugins() {
    if (!this.options.element) {
      return [];
    }
    return [
      BubbleMenuPlugin({
        pluginKey: this.options.pluginKey,
        editor: this.editor,
        element: this.options.element,
        tippyOptions: this.options.tippyOptions,
        updateDelay: this.options.updateDelay,
        shouldShow: this.options.shouldShow
      })
    ];
  }
});
const BubbleMenu = (props) => {
  const [element, setElement] = react.exports.useState(null);
  react.exports.useEffect(() => {
    if (!element) {
      return;
    }
    if (props.editor.isDestroyed) {
      return;
    }
    const {
      pluginKey = "bubbleMenu",
      editor,
      tippyOptions = {},
      updateDelay,
      shouldShow = null
    } = props;
    const plugin = BubbleMenuPlugin({
      updateDelay,
      editor,
      element,
      pluginKey,
      shouldShow,
      tippyOptions
    });
    editor.registerPlugin(plugin);
    return () => editor.unregisterPlugin(pluginKey);
  }, [props.editor, element]);
  return /* @__PURE__ */ jsx("div", {
    ref: setElement,
    className: props.className,
    style: {
      visibility: "hidden"
    },
    children: props.children
  });
};
class Editor$1 extends Editor$2 {
  constructor() {
    super(...arguments);
    this.contentComponent = null;
  }
}
const Portals = ({
  renderers
}) => {
  return /* @__PURE__ */ jsx(Fragment$1, {
    children: Object.entries(renderers).map(([key, renderer]) => {
      return ae.createPortal(renderer.reactElement, renderer.element, key);
    })
  });
};
class PureEditorContent extends e$3.Component {
  constructor(props) {
    super(props);
    this.editorContentRef = e$3.createRef();
    this.initialized = false;
    this.state = {
      renderers: {}
    };
  }
  componentDidMount() {
    this.init();
  }
  componentDidUpdate() {
    this.init();
  }
  init() {
    const {
      editor
    } = this.props;
    if (editor && editor.options.element) {
      if (editor.contentComponent) {
        return;
      }
      const element = this.editorContentRef.current;
      element.append(...editor.options.element.childNodes);
      editor.setOptions({
        element
      });
      editor.contentComponent = this;
      editor.createNodeViews();
      this.initialized = true;
    }
  }
  maybeFlushSync(fn3) {
    if (this.initialized) {
      reactDom.exports.flushSync(fn3);
    } else {
      fn3();
    }
  }
  setRenderer(id2, renderer) {
    this.maybeFlushSync(() => {
      this.setState(({
        renderers
      }) => ({
        renderers: {
          ...renderers,
          [id2]: renderer
        }
      }));
    });
  }
  removeRenderer(id2) {
    this.maybeFlushSync(() => {
      this.setState(({
        renderers
      }) => {
        const nextRenderers = {
          ...renderers
        };
        delete nextRenderers[id2];
        return {
          renderers: nextRenderers
        };
      });
    });
  }
  componentWillUnmount() {
    const {
      editor
    } = this.props;
    if (!editor) {
      return;
    }
    if (!editor.isDestroyed) {
      editor.view.setProps({
        nodeViews: {}
      });
    }
    editor.contentComponent = null;
    if (!editor.options.element.firstChild) {
      return;
    }
    const newElement = document.createElement("div");
    newElement.append(...editor.options.element.childNodes);
    editor.setOptions({
      element: newElement
    });
  }
  render() {
    const {
      editor,
      ...rest
    } = this.props;
    return /* @__PURE__ */ jsxs(Fragment$1, {
      children: [/* @__PURE__ */ jsx("div", {
        ref: this.editorContentRef,
        ...rest
      }), /* @__PURE__ */ jsx(Portals, {
        renderers: this.state.renderers
      })]
    });
  }
}
const EditorContent = e$3.memo(PureEditorContent);
const ReactNodeViewContext = react.exports.createContext({
  onDragStart: void 0
});
const useReactNodeView = () => react.exports.useContext(ReactNodeViewContext);
e$3.forwardRef((props, ref) => {
  const {
    onDragStart
  } = useReactNodeView();
  const Tag = props.as || "div";
  return /* @__PURE__ */ jsx(Tag, {
    ...props,
    ref,
    "data-node-view-wrapper": "",
    onDragStart,
    style: {
      whiteSpace: "normal",
      ...props.style
    }
  });
});
function useForceUpdate() {
  const [, setValue] = react.exports.useState(0);
  return () => setValue((value) => value + 1);
}
const useEditor = (options = {}, deps = []) => {
  const [editor, setEditor] = react.exports.useState(null);
  const forceUpdate = useForceUpdate();
  react.exports.useEffect(() => {
    let isMounted = true;
    const instance = new Editor$1(options);
    setEditor(instance);
    instance.on("transaction", () => {
      requestAnimationFrame(() => {
        requestAnimationFrame(() => {
          if (isMounted) {
            forceUpdate();
          }
        });
      });
    });
    return () => {
      instance.destroy();
      isMounted = false;
    };
  }, deps);
  return editor;
};
const Text$1 = Node$1.create({
  name: "text",
  group: "inline"
});
const starInputRegex$1 = /(?:^|\s)((?:\*\*)((?:[^*]+))(?:\*\*))$/;
const starPasteRegex$1 = /(?:^|\s)((?:\*\*)((?:[^*]+))(?:\*\*))/g;
const underscoreInputRegex$1 = /(?:^|\s)((?:__)((?:[^__]+))(?:__))$/;
const underscorePasteRegex$1 = /(?:^|\s)((?:__)((?:[^__]+))(?:__))/g;
const Bold = Mark.create({
  name: "bold",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "strong"
      },
      {
        tag: "b",
        getAttrs: (node2) => node2.style.fontWeight !== "normal" && null
      },
      {
        style: "font-weight",
        getAttrs: (value) => /^(bold(er)?|[5-9]\d{2,})$/.test(value) && null
      }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["strong", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addCommands() {
    return {
      setBold: () => ({ commands: commands2 }) => {
        return commands2.setMark(this.name);
      },
      toggleBold: () => ({ commands: commands2 }) => {
        return commands2.toggleMark(this.name);
      },
      unsetBold: () => ({ commands: commands2 }) => {
        return commands2.unsetMark(this.name);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-b": () => this.editor.commands.toggleBold(),
      "Mod-B": () => this.editor.commands.toggleBold()
    };
  },
  addInputRules() {
    return [
      markInputRule({
        find: starInputRegex$1,
        type: this.type
      }),
      markInputRule({
        find: underscoreInputRegex$1,
        type: this.type
      })
    ];
  },
  addPasteRules() {
    return [
      markPasteRule({
        find: starPasteRegex$1,
        type: this.type
      }),
      markPasteRule({
        find: underscorePasteRegex$1,
        type: this.type
      })
    ];
  }
});
const starInputRegex = /(?:^|\s)((?:\*)((?:[^*]+))(?:\*))$/;
const starPasteRegex = /(?:^|\s)((?:\*)((?:[^*]+))(?:\*))/g;
const underscoreInputRegex = /(?:^|\s)((?:_)((?:[^_]+))(?:_))$/;
const underscorePasteRegex = /(?:^|\s)((?:_)((?:[^_]+))(?:_))/g;
const Italic = Mark.create({
  name: "italic",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "em"
      },
      {
        tag: "i",
        getAttrs: (node2) => node2.style.fontStyle !== "normal" && null
      },
      {
        style: "font-style=italic"
      }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["em", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addCommands() {
    return {
      setItalic: () => ({ commands: commands2 }) => {
        return commands2.setMark(this.name);
      },
      toggleItalic: () => ({ commands: commands2 }) => {
        return commands2.toggleMark(this.name);
      },
      unsetItalic: () => ({ commands: commands2 }) => {
        return commands2.unsetMark(this.name);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-i": () => this.editor.commands.toggleItalic(),
      "Mod-I": () => this.editor.commands.toggleItalic()
    };
  },
  addInputRules() {
    return [
      markInputRule({
        find: starInputRegex,
        type: this.type
      }),
      markInputRule({
        find: underscoreInputRegex,
        type: this.type
      })
    ];
  },
  addPasteRules() {
    return [
      markPasteRule({
        find: starPasteRegex,
        type: this.type
      }),
      markPasteRule({
        find: underscorePasteRegex,
        type: this.type
      })
    ];
  }
});
function State(token2) {
  this.j = {};
  this.jr = [];
  this.jd = null;
  this.t = token2;
}
State.prototype = {
  accepts: function accepts() {
    return !!this.t;
  },
  tt: function tt(input, tokenOrState) {
    if (tokenOrState && tokenOrState.j) {
      this.j[input] = tokenOrState;
      return tokenOrState;
    }
    var token2 = tokenOrState;
    var nextState = this.j[input];
    if (nextState) {
      if (token2) {
        nextState.t = token2;
      }
      return nextState;
    }
    nextState = makeState();
    var templateState = takeT(this, input);
    if (templateState) {
      Object.assign(nextState.j, templateState.j);
      nextState.jr.append(templateState.jr);
      nextState.jr = templateState.jd;
      nextState.t = token2 || templateState.t;
    } else {
      nextState.t = token2;
    }
    this.j[input] = nextState;
    return nextState;
  }
};
var makeState = function makeState2() {
  return new State();
};
var makeAcceptingState = function makeAcceptingState2(token2) {
  return new State(token2);
};
var makeT = function makeT2(startState, input, nextState) {
  if (!startState.j[input]) {
    startState.j[input] = nextState;
  }
};
var makeRegexT = function makeRegexT2(startState, regex, nextState) {
  startState.jr.push([regex, nextState]);
};
var takeT = function takeT2(state, input) {
  var nextState = state.j[input];
  if (nextState) {
    return nextState;
  }
  for (var i3 = 0; i3 < state.jr.length; i3++) {
    var regex = state.jr[i3][0];
    var _nextState = state.jr[i3][1];
    if (regex.test(input)) {
      return _nextState;
    }
  }
  return state.jd;
};
var makeMultiT = function makeMultiT2(startState, chars, nextState) {
  for (var i3 = 0; i3 < chars.length; i3++) {
    makeT(startState, chars[i3], nextState);
  }
};
var makeBatchT = function makeBatchT2(startState, transitions) {
  for (var i3 = 0; i3 < transitions.length; i3++) {
    var input = transitions[i3][0];
    var nextState = transitions[i3][1];
    makeT(startState, input, nextState);
  }
};
var makeChainT = function makeChainT2(state, str, endState, defaultStateFactory) {
  var i3 = 0, len = str.length, nextState;
  while (i3 < len && (nextState = state.j[str[i3]])) {
    state = nextState;
    i3++;
  }
  if (i3 >= len) {
    return [];
  }
  while (i3 < len - 1) {
    nextState = defaultStateFactory();
    makeT(state, str[i3], nextState);
    state = nextState;
    i3++;
  }
  makeT(state, str[len - 1], endState);
};
var DOMAIN = "DOMAIN";
var LOCALHOST = "LOCALHOST";
var TLD = "TLD";
var NUM = "NUM";
var PROTOCOL = "PROTOCOL";
var MAILTO = "MAILTO";
var WS = "WS";
var NL = "NL";
var OPENBRACE = "OPENBRACE";
var OPENBRACKET = "OPENBRACKET";
var OPENANGLEBRACKET = "OPENANGLEBRACKET";
var OPENPAREN = "OPENPAREN";
var CLOSEBRACE = "CLOSEBRACE";
var CLOSEBRACKET = "CLOSEBRACKET";
var CLOSEANGLEBRACKET = "CLOSEANGLEBRACKET";
var CLOSEPAREN = "CLOSEPAREN";
var AMPERSAND = "AMPERSAND";
var APOSTROPHE = "APOSTROPHE";
var ASTERISK = "ASTERISK";
var AT = "AT";
var BACKSLASH = "BACKSLASH";
var BACKTICK = "BACKTICK";
var CARET = "CARET";
var COLON = "COLON";
var COMMA = "COMMA";
var DOLLAR = "DOLLAR";
var DOT = "DOT";
var EQUALS = "EQUALS";
var EXCLAMATION = "EXCLAMATION";
var HYPHEN = "HYPHEN";
var PERCENT = "PERCENT";
var PIPE = "PIPE";
var PLUS = "PLUS";
var POUND = "POUND";
var QUERY = "QUERY";
var QUOTE = "QUOTE";
var SEMI = "SEMI";
var SLASH = "SLASH";
var TILDE = "TILDE";
var UNDERSCORE = "UNDERSCORE";
var SYM = "SYM";
var text = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  DOMAIN,
  LOCALHOST,
  TLD,
  NUM,
  PROTOCOL,
  MAILTO,
  WS,
  NL,
  OPENBRACE,
  OPENBRACKET,
  OPENANGLEBRACKET,
  OPENPAREN,
  CLOSEBRACE,
  CLOSEBRACKET,
  CLOSEANGLEBRACKET,
  CLOSEPAREN,
  AMPERSAND,
  APOSTROPHE,
  ASTERISK,
  AT,
  BACKSLASH,
  BACKTICK,
  CARET,
  COLON,
  COMMA,
  DOLLAR,
  DOT,
  EQUALS,
  EXCLAMATION,
  HYPHEN,
  PERCENT,
  PIPE,
  PLUS,
  POUND,
  QUERY,
  QUOTE,
  SEMI,
  SLASH,
  TILDE,
  UNDERSCORE,
  SYM
});
var tlds = "aaa aarp abarth abb abbott abbvie abc able abogado abudhabi ac academy accenture accountant accountants aco actor ad adac ads adult ae aeg aero aetna af afamilycompany afl africa ag agakhan agency ai aig airbus airforce airtel akdn al alfaromeo alibaba alipay allfinanz allstate ally alsace alstom am amazon americanexpress americanfamily amex amfam amica amsterdam analytics android anquan anz ao aol apartments app apple aq aquarelle ar arab aramco archi army arpa art arte as asda asia associates at athleta attorney au auction audi audible audio auspost author auto autos avianca aw aws ax axa az azure ba baby baidu banamex bananarepublic band bank bar barcelona barclaycard barclays barefoot bargains baseball basketball bauhaus bayern bb bbc bbt bbva bcg bcn bd be beats beauty beer bentley berlin best bestbuy bet bf bg bh bharti bi bible bid bike bing bingo bio biz bj black blackfriday blockbuster blog bloomberg blue bm bms bmw bn bnpparibas bo boats boehringer bofa bom bond boo book booking bosch bostik boston bot boutique box br bradesco bridgestone broadway broker brother brussels bs bt budapest bugatti build builders business buy buzz bv bw by bz bzh ca cab cafe cal call calvinklein cam camera camp cancerresearch canon capetown capital capitalone car caravan cards care career careers cars casa case cash casino cat catering catholic cba cbn cbre cbs cc cd center ceo cern cf cfa cfd cg ch chanel channel charity chase chat cheap chintai christmas chrome church ci cipriani circle cisco citadel citi citic city cityeats ck cl claims cleaning click clinic clinique clothing cloud club clubmed cm cn co coach codes coffee college cologne com comcast commbank community company compare computer comsec condos construction consulting contact contractors cooking cookingchannel cool coop corsica country coupon coupons courses cpa cr credit creditcard creditunion cricket crown crs cruise cruises csc cu cuisinella cv cw cx cy cymru cyou cz dabur dad dance data date dating datsun day dclk dds de deal dealer deals degree delivery dell deloitte delta democrat dental dentist desi design dev dhl diamonds diet digital direct directory discount discover dish diy dj dk dm dnp do docs doctor dog domains dot download drive dtv dubai duck dunlop dupont durban dvag dvr dz earth eat ec eco edeka edu education ee eg email emerck energy engineer engineering enterprises epson equipment er ericsson erni es esq estate et etisalat eu eurovision eus events exchange expert exposed express extraspace fage fail fairwinds faith family fan fans farm farmers fashion fast fedex feedback ferrari ferrero fi fiat fidelity fido film final finance financial fire firestone firmdale fish fishing fit fitness fj fk flickr flights flir florist flowers fly fm fo foo food foodnetwork football ford forex forsale forum foundation fox fr free fresenius frl frogans frontdoor frontier ftr fujitsu fujixerox fun fund furniture futbol fyi ga gal gallery gallo gallup game games gap garden gay gb gbiz gd gdn ge gea gent genting george gf gg ggee gh gi gift gifts gives giving gl glade glass gle global globo gm gmail gmbh gmo gmx gn godaddy gold goldpoint golf goo goodyear goog google gop got gov gp gq gr grainger graphics gratis green gripe grocery group gs gt gu guardian gucci guge guide guitars guru gw gy hair hamburg hangout haus hbo hdfc hdfcbank health healthcare help helsinki here hermes hgtv hiphop hisamitsu hitachi hiv hk hkt hm hn hockey holdings holiday homedepot homegoods homes homesense honda horse hospital host hosting hot hoteles hotels hotmail house how hr hsbc ht hu hughes hyatt hyundai ibm icbc ice icu id ie ieee ifm ikano il im imamat imdb immo immobilien in inc industries infiniti info ing ink institute insurance insure int international intuit investments io ipiranga iq ir irish is ismaili ist istanbul it itau itv iveco jaguar java jcb je jeep jetzt jewelry jio jll jm jmp jnj jo jobs joburg jot joy jp jpmorgan jprs juegos juniper kaufen kddi ke kerryhotels kerrylogistics kerryproperties kfh kg kh ki kia kim kinder kindle kitchen kiwi km kn koeln komatsu kosher kp kpmg kpn kr krd kred kuokgroup kw ky kyoto kz la lacaixa lamborghini lamer lancaster lancia land landrover lanxess lasalle lat latino latrobe law lawyer lb lc lds lease leclerc lefrak legal lego lexus lgbt li lidl life lifeinsurance lifestyle lighting like lilly limited limo lincoln linde link lipsy live living lixil lk llc llp loan loans locker locus loft lol london lotte lotto love lpl lplfinancial lr ls lt ltd ltda lu lundbeck luxe luxury lv ly ma macys madrid maif maison makeup man management mango map market marketing markets marriott marshalls maserati mattel mba mc mckinsey md me med media meet melbourne meme memorial men menu merckmsd mg mh miami microsoft mil mini mint mit mitsubishi mk ml mlb mls mm mma mn mo mobi mobile moda moe moi mom monash money monster mormon mortgage moscow moto motorcycles mov movie mp mq mr ms msd mt mtn mtr mu museum mutual mv mw mx my mz na nab nagoya name nationwide natura navy nba nc ne nec net netbank netflix network neustar new news next nextdirect nexus nf nfl ng ngo nhk ni nico nike nikon ninja nissan nissay nl no nokia northwesternmutual norton now nowruz nowtv np nr nra nrw ntt nu nyc nz obi observer off office okinawa olayan olayangroup oldnavy ollo om omega one ong onl online onyourside ooo open oracle orange org organic origins osaka otsuka ott ovh pa page panasonic paris pars partners parts party passagens pay pccw pe pet pf pfizer pg ph pharmacy phd philips phone photo photography photos physio pics pictet pictures pid pin ping pink pioneer pizza pk pl place play playstation plumbing plus pm pn pnc pohl poker politie porn post pr pramerica praxi press prime pro prod productions prof progressive promo properties property protection pru prudential ps pt pub pw pwc py qa qpon quebec quest qvc racing radio raid re read realestate realtor realty recipes red redstone redumbrella rehab reise reisen reit reliance ren rent rentals repair report republican rest restaurant review reviews rexroth rich richardli ricoh ril rio rip rmit ro rocher rocks rodeo rogers room rs rsvp ru rugby ruhr run rw rwe ryukyu sa saarland safe safety sakura sale salon samsclub samsung sandvik sandvikcoromant sanofi sap sarl sas save saxo sb sbi sbs sc sca scb schaeffler schmidt scholarships school schule schwarz science scjohnson scot sd se search seat secure security seek select sener services ses seven sew sex sexy sfr sg sh shangrila sharp shaw shell shia shiksha shoes shop shopping shouji show showtime si silk sina singles site sj sk ski skin sky skype sl sling sm smart smile sn sncf so soccer social softbank software sohu solar solutions song sony soy spa space sport spot spreadbetting sr srl ss st stada staples star statebank statefarm stc stcgroup stockholm storage store stream studio study style su sucks supplies supply support surf surgery suzuki sv swatch swiftcover swiss sx sy sydney systems sz tab taipei talk taobao target tatamotors tatar tattoo tax taxi tc tci td tdk team tech technology tel temasek tennis teva tf tg th thd theater theatre tiaa tickets tienda tiffany tips tires tirol tj tjmaxx tjx tk tkmaxx tl tm tmall tn to today tokyo tools top toray toshiba total tours town toyota toys tr trade trading training travel travelchannel travelers travelersinsurance trust trv tt tube tui tunes tushu tv tvs tw tz ua ubank ubs ug uk unicom university uno uol ups us uy uz va vacations vana vanguard vc ve vegas ventures verisign versicherung vet vg vi viajes video vig viking villas vin vip virgin visa vision viva vivo vlaanderen vn vodka volkswagen volvo vote voting voto voyage vu vuelos wales walmart walter wang wanggou watch watches weather weatherchannel webcam weber website wed wedding weibo weir wf whoswho wien wiki williamhill win windows wine winners wme wolterskluwer woodside work works world wow ws wtc wtf xbox xerox xfinity xihuan xin xxx xyz yachts yahoo yamaxun yandex ye yodobashi yoga yokohama you youtube yt yun za zappos zara zero zip zm zone zuerich zw verm\xF6gensberater-ctb verm\xF6gensberatung-pwb \u03B5\u03BB \u03B5\u03C5 \u0431\u0433 \u0431\u0435\u043B \u0434\u0435\u0442\u0438 \u0435\u044E \u043A\u0430\u0442\u043E\u043B\u0438\u043A \u043A\u043E\u043C \u049B\u0430\u0437 \u043C\u043A\u0434 \u043C\u043E\u043D \u043C\u043E\u0441\u043A\u0432\u0430 \u043E\u043D\u043B\u0430\u0439\u043D \u043E\u0440\u0433 \u0440\u0443\u0441 \u0440\u0444 \u0441\u0430\u0439\u0442 \u0441\u0440\u0431 \u0443\u043A\u0440 \u10D2\u10D4 \u0570\u0561\u0575 \u05D9\u05E9\u05E8\u05D0\u05DC \u05E7\u05D5\u05DD \u0627\u0628\u0648\u0638\u0628\u064A \u0627\u062A\u0635\u0627\u0644\u0627\u062A \u0627\u0631\u0627\u0645\u0643\u0648 \u0627\u0644\u0627\u0631\u062F\u0646 \u0627\u0644\u0628\u062D\u0631\u064A\u0646 \u0627\u0644\u062C\u0632\u0627\u0626\u0631 \u0627\u0644\u0633\u0639\u0648\u062F\u064A\u0629 \u0627\u0644\u0639\u0644\u064A\u0627\u0646 \u0627\u0644\u0645\u063A\u0631\u0628 \u0627\u0645\u0627\u0631\u0627\u062A \u0627\u06CC\u0631\u0627\u0646 \u0628\u0627\u0631\u062A \u0628\u0627\u0632\u0627\u0631 \u0628\u06BE\u0627\u0631\u062A \u0628\u064A\u062A\u0643 \u067E\u0627\u06A9\u0633\u062A\u0627\u0646 \u0680\u0627\u0631\u062A \u062A\u0648\u0646\u0633 \u0633\u0648\u062F\u0627\u0646 \u0633\u0648\u0631\u064A\u0629 \u0634\u0628\u0643\u0629 \u0639\u0631\u0627\u0642 \u0639\u0631\u0628 \u0639\u0645\u0627\u0646 \u0641\u0644\u0633\u0637\u064A\u0646 \u0642\u0637\u0631 \u0643\u0627\u062B\u0648\u0644\u064A\u0643 \u0643\u0648\u0645 \u0645\u0635\u0631 \u0645\u0644\u064A\u0633\u064A\u0627 \u0645\u0648\u0631\u064A\u062A\u0627\u0646\u064A\u0627 \u0645\u0648\u0642\u0639 \u0647\u0645\u0631\u0627\u0647 \u0915\u0949\u092E \u0928\u0947\u091F \u092D\u093E\u0930\u0924 \u092D\u093E\u0930\u0924\u092E\u094D \u092D\u093E\u0930\u094B\u0924 \u0938\u0902\u0917\u0920\u0928 \u09AC\u09BE\u0982\u09B2\u09BE \u09AD\u09BE\u09B0\u09A4 \u09AD\u09BE\u09F0\u09A4 \u0A2D\u0A3E\u0A30\u0A24 \u0AAD\u0ABE\u0AB0\u0AA4 \u0B2D\u0B3E\u0B30\u0B24 \u0B87\u0BA8\u0BCD\u0BA4\u0BBF\u0BAF\u0BBE \u0B87\u0BB2\u0B99\u0BCD\u0B95\u0BC8 \u0B9A\u0BBF\u0B99\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0BC2\u0BB0\u0BCD \u0C2D\u0C3E\u0C30\u0C24\u0C4D \u0CAD\u0CBE\u0CB0\u0CA4 \u0D2D\u0D3E\u0D30\u0D24\u0D02 \u0DBD\u0D82\u0D9A\u0DCF \u0E04\u0E2D\u0E21 \u0E44\u0E17\u0E22 \u0EA5\u0EB2\u0EA7 \uB2F7\uB137 \uB2F7\uCEF4 \uC0BC\uC131 \uD55C\uAD6D \u30A2\u30DE\u30BE\u30F3 \u30B0\u30FC\u30B0\u30EB \u30AF\u30E9\u30A6\u30C9 \u30B3\u30E0 \u30B9\u30C8\u30A2 \u30BB\u30FC\u30EB \u30D5\u30A1\u30C3\u30B7\u30E7\u30F3 \u30DD\u30A4\u30F3\u30C8 \u307F\u3093\u306A \u4E16\u754C \u4E2D\u4FE1 \u4E2D\u56FD \u4E2D\u570B \u4E2D\u6587\u7F51 \u4E9A\u9A6C\u900A \u4F01\u4E1A \u4F5B\u5C71 \u4FE1\u606F \u5065\u5EB7 \u516B\u5366 \u516C\u53F8 \u516C\u76CA \u53F0\u6E7E \u53F0\u7063 \u5546\u57CE \u5546\u5E97 \u5546\u6807 \u5609\u91CC \u5609\u91CC\u5927\u9152\u5E97 \u5728\u7EBF \u5927\u4F17\u6C7D\u8F66 \u5927\u62FF \u5929\u4E3B\u6559 \u5A31\u4E50 \u5BB6\u96FB \u5E7F\u4E1C \u5FAE\u535A \u6148\u5584 \u6211\u7231\u4F60 \u624B\u673A \u62DB\u8058 \u653F\u52A1 \u653F\u5E9C \u65B0\u52A0\u5761 \u65B0\u95FB \u65F6\u5C1A \u66F8\u7C4D \u673A\u6784 \u6DE1\u9A6C\u9521 \u6E38\u620F \u6FB3\u9580 \u70B9\u770B \u79FB\u52A8 \u7EC4\u7EC7\u673A\u6784 \u7F51\u5740 \u7F51\u5E97 \u7F51\u7AD9 \u7F51\u7EDC \u8054\u901A \u8BFA\u57FA\u4E9A \u8C37\u6B4C \u8D2D\u7269 \u901A\u8CA9 \u96C6\u56E2 \u96FB\u8A0A\u76C8\u79D1 \u98DE\u5229\u6D66 \u98DF\u54C1 \u9910\u5385 \u9999\u683C\u91CC\u62C9 \u9999\u6E2F".split(" ");
var LETTER = /(?:[A-Za-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16F1-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF40\uDF42-\uDF49\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDD70-\uDD7A\uDD7C-\uDD8A\uDD8C-\uDD92\uDD94\uDD95\uDD97-\uDDA1\uDDA3-\uDDB1\uDDB3-\uDDB9\uDDBB\uDDBC\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67\uDF80-\uDF85\uDF87-\uDFB0\uDFB2-\uDFBA]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE35\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2\uDD00-\uDD23\uDE80-\uDEA9\uDEB0\uDEB1\uDF00-\uDF1C\uDF27\uDF30-\uDF45\uDF70-\uDF81\uDFB0-\uDFC4\uDFE0-\uDFF6]|\uD804[\uDC03-\uDC37\uDC71\uDC72\uDC75\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD44\uDD47\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC5F-\uDC61\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDEB8\uDF00-\uDF1A\uDF40-\uDF46]|\uD806[\uDC00-\uDC2B\uDCA0-\uDCDF\uDCFF-\uDD06\uDD09\uDD0C-\uDD13\uDD15\uDD16\uDD18-\uDD2F\uDD3F\uDD41\uDDA0-\uDDA7\uDDAA-\uDDD0\uDDE1\uDDE3\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE89\uDE9D\uDEB0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46\uDD60-\uDD65\uDD67\uDD68\uDD6A-\uDD89\uDD98\uDEE0-\uDEF2\uDFB0]|\uD808[\uDC00-\uDF99]|\uD809[\uDC80-\uDD43]|\uD80B[\uDF90-\uDFF0]|[\uD80C\uD81C-\uD820\uD822\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879\uD880-\uD883][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE70-\uDEBE\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDE40-\uDE7F\uDF00-\uDF4A\uDF50\uDF93-\uDF9F\uDFE0\uDFE1\uDFE3]|\uD821[\uDC00-\uDFF7]|\uD823[\uDC00-\uDCD5\uDD00-\uDD08]|\uD82B[\uDFF0-\uDFF3\uDFF5-\uDFFB\uDFFD\uDFFE]|\uD82C[\uDC00-\uDD22\uDD50-\uDD52\uDD64-\uDD67\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD837[\uDF00-\uDF1E]|\uD838[\uDD00-\uDD2C\uDD37-\uDD3D\uDD4E\uDE90-\uDEAD\uDEC0-\uDEEB]|\uD839[\uDFE0-\uDFE6\uDFE8-\uDFEB\uDFED\uDFEE\uDFF0-\uDFFE]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43\uDD4B]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDEDF\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF38\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uD884[\uDC00-\uDF4A])/;
var EMOJI = /(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26A7\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDED5-\uDED7\uDEDD-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEFC\uDFE0-\uDFEB\uDFF0]|\uD83E[\uDD0C-\uDD3A\uDD3C-\uDD45\uDD47-\uDDFF\uDE70-\uDE74\uDE78-\uDE7C\uDE80-\uDE86\uDE90-\uDEAC\uDEB0-\uDEBA\uDEC0-\uDEC5\uDED0-\uDED9\uDEE0-\uDEE7\uDEF0-\uDEF6])/;
var EMOJI_VARIATION = /\uFE0F/;
var DIGIT = /\d/;
var SPACE = /\s/;
function init$2() {
  var customProtocols = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
  var S_START = makeState();
  var S_NUM = makeAcceptingState(NUM);
  var S_DOMAIN = makeAcceptingState(DOMAIN);
  var S_DOMAIN_HYPHEN = makeState();
  var S_WS = makeAcceptingState(WS);
  var DOMAIN_REGEX_TRANSITIONS = [[DIGIT, S_DOMAIN], [LETTER, S_DOMAIN], [EMOJI, S_DOMAIN], [EMOJI_VARIATION, S_DOMAIN]];
  var makeDomainState = function makeDomainState2() {
    var state = makeAcceptingState(DOMAIN);
    state.j = {
      "-": S_DOMAIN_HYPHEN
    };
    state.jr = [].concat(DOMAIN_REGEX_TRANSITIONS);
    return state;
  };
  var makeNearDomainState = function makeNearDomainState2(token2) {
    var state = makeDomainState();
    state.t = token2;
    return state;
  };
  makeBatchT(S_START, [["'", makeAcceptingState(APOSTROPHE)], ["{", makeAcceptingState(OPENBRACE)], ["[", makeAcceptingState(OPENBRACKET)], ["<", makeAcceptingState(OPENANGLEBRACKET)], ["(", makeAcceptingState(OPENPAREN)], ["}", makeAcceptingState(CLOSEBRACE)], ["]", makeAcceptingState(CLOSEBRACKET)], [">", makeAcceptingState(CLOSEANGLEBRACKET)], [")", makeAcceptingState(CLOSEPAREN)], ["&", makeAcceptingState(AMPERSAND)], ["*", makeAcceptingState(ASTERISK)], ["@", makeAcceptingState(AT)], ["`", makeAcceptingState(BACKTICK)], ["^", makeAcceptingState(CARET)], [":", makeAcceptingState(COLON)], [",", makeAcceptingState(COMMA)], ["$", makeAcceptingState(DOLLAR)], [".", makeAcceptingState(DOT)], ["=", makeAcceptingState(EQUALS)], ["!", makeAcceptingState(EXCLAMATION)], ["-", makeAcceptingState(HYPHEN)], ["%", makeAcceptingState(PERCENT)], ["|", makeAcceptingState(PIPE)], ["+", makeAcceptingState(PLUS)], ["#", makeAcceptingState(POUND)], ["?", makeAcceptingState(QUERY)], ['"', makeAcceptingState(QUOTE)], ["/", makeAcceptingState(SLASH)], [";", makeAcceptingState(SEMI)], ["~", makeAcceptingState(TILDE)], ["_", makeAcceptingState(UNDERSCORE)], ["\\", makeAcceptingState(BACKSLASH)]]);
  makeT(S_START, "\n", makeAcceptingState(NL));
  makeRegexT(S_START, SPACE, S_WS);
  makeT(S_WS, "\n", makeState());
  makeRegexT(S_WS, SPACE, S_WS);
  for (var i3 = 0; i3 < tlds.length; i3++) {
    makeChainT(S_START, tlds[i3], makeNearDomainState(TLD), makeDomainState);
  }
  var S_PROTOCOL_FILE = makeDomainState();
  var S_PROTOCOL_FTP = makeDomainState();
  var S_PROTOCOL_HTTP = makeDomainState();
  var S_MAILTO = makeDomainState();
  makeChainT(S_START, "file", S_PROTOCOL_FILE, makeDomainState);
  makeChainT(S_START, "ftp", S_PROTOCOL_FTP, makeDomainState);
  makeChainT(S_START, "http", S_PROTOCOL_HTTP, makeDomainState);
  makeChainT(S_START, "mailto", S_MAILTO, makeDomainState);
  var S_PROTOCOL_SECURE = makeDomainState();
  var S_FULL_PROTOCOL = makeAcceptingState(PROTOCOL);
  var S_FULL_MAILTO = makeAcceptingState(MAILTO);
  makeT(S_PROTOCOL_FTP, "s", S_PROTOCOL_SECURE);
  makeT(S_PROTOCOL_FTP, ":", S_FULL_PROTOCOL);
  makeT(S_PROTOCOL_HTTP, "s", S_PROTOCOL_SECURE);
  makeT(S_PROTOCOL_HTTP, ":", S_FULL_PROTOCOL);
  makeT(S_PROTOCOL_FILE, ":", S_FULL_PROTOCOL);
  makeT(S_PROTOCOL_SECURE, ":", S_FULL_PROTOCOL);
  makeT(S_MAILTO, ":", S_FULL_MAILTO);
  var S_CUSTOM_PROTOCOL = makeDomainState();
  for (var _i = 0; _i < customProtocols.length; _i++) {
    makeChainT(S_START, customProtocols[_i], S_CUSTOM_PROTOCOL, makeDomainState);
  }
  makeT(S_CUSTOM_PROTOCOL, ":", S_FULL_PROTOCOL);
  makeChainT(S_START, "localhost", makeNearDomainState(LOCALHOST), makeDomainState);
  makeRegexT(S_START, DIGIT, S_NUM);
  makeRegexT(S_START, LETTER, S_DOMAIN);
  makeRegexT(S_START, EMOJI, S_DOMAIN);
  makeRegexT(S_START, EMOJI_VARIATION, S_DOMAIN);
  makeRegexT(S_NUM, DIGIT, S_NUM);
  makeRegexT(S_NUM, LETTER, S_DOMAIN);
  makeRegexT(S_NUM, EMOJI, S_DOMAIN);
  makeRegexT(S_NUM, EMOJI_VARIATION, S_DOMAIN);
  makeT(S_NUM, "-", S_DOMAIN_HYPHEN);
  makeT(S_DOMAIN, "-", S_DOMAIN_HYPHEN);
  makeT(S_DOMAIN_HYPHEN, "-", S_DOMAIN_HYPHEN);
  makeRegexT(S_DOMAIN, DIGIT, S_DOMAIN);
  makeRegexT(S_DOMAIN, LETTER, S_DOMAIN);
  makeRegexT(S_DOMAIN, EMOJI, S_DOMAIN);
  makeRegexT(S_DOMAIN, EMOJI_VARIATION, S_DOMAIN);
  makeRegexT(S_DOMAIN_HYPHEN, DIGIT, S_DOMAIN);
  makeRegexT(S_DOMAIN_HYPHEN, LETTER, S_DOMAIN);
  makeRegexT(S_DOMAIN_HYPHEN, EMOJI, S_DOMAIN);
  makeRegexT(S_DOMAIN_HYPHEN, EMOJI_VARIATION, S_DOMAIN);
  S_START.jd = makeAcceptingState(SYM);
  return S_START;
}
function run$1(start2, str) {
  var iterable = stringToArray(str.replace(/[A-Z]/g, function(c3) {
    return c3.toLowerCase();
  }));
  var charCount = iterable.length;
  var tokens = [];
  var cursor2 = 0;
  var charCursor = 0;
  while (charCursor < charCount) {
    var state = start2;
    var nextState = null;
    var tokenLength = 0;
    var latestAccepting = null;
    var sinceAccepts = -1;
    var charsSinceAccepts = -1;
    while (charCursor < charCount && (nextState = takeT(state, iterable[charCursor]))) {
      state = nextState;
      if (state.accepts()) {
        sinceAccepts = 0;
        charsSinceAccepts = 0;
        latestAccepting = state;
      } else if (sinceAccepts >= 0) {
        sinceAccepts += iterable[charCursor].length;
        charsSinceAccepts++;
      }
      tokenLength += iterable[charCursor].length;
      cursor2 += iterable[charCursor].length;
      charCursor++;
    }
    cursor2 -= sinceAccepts;
    charCursor -= charsSinceAccepts;
    tokenLength -= sinceAccepts;
    tokens.push({
      t: latestAccepting.t,
      v: str.substr(cursor2 - tokenLength, tokenLength),
      s: cursor2 - tokenLength,
      e: cursor2
    });
  }
  return tokens;
}
function stringToArray(str) {
  var result = [];
  var len = str.length;
  var index2 = 0;
  while (index2 < len) {
    var first2 = str.charCodeAt(index2);
    var second = void 0;
    var char2 = first2 < 55296 || first2 > 56319 || index2 + 1 === len || (second = str.charCodeAt(index2 + 1)) < 56320 || second > 57343 ? str[index2] : str.slice(index2, index2 + 2);
    result.push(char2);
    index2 += char2.length;
  }
  return result;
}
function _typeof$C(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$C = function(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$C = function(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$C(obj);
}
var defaults = {
  defaultProtocol: "http",
  events: null,
  format: noop,
  formatHref: noop,
  nl2br: false,
  tagName: "a",
  target: null,
  rel: null,
  validate: true,
  truncate: 0,
  className: null,
  attributes: null,
  ignoreTags: []
};
function Options(opts) {
  opts = opts || {};
  this.defaultProtocol = "defaultProtocol" in opts ? opts.defaultProtocol : defaults.defaultProtocol;
  this.events = "events" in opts ? opts.events : defaults.events;
  this.format = "format" in opts ? opts.format : defaults.format;
  this.formatHref = "formatHref" in opts ? opts.formatHref : defaults.formatHref;
  this.nl2br = "nl2br" in opts ? opts.nl2br : defaults.nl2br;
  this.tagName = "tagName" in opts ? opts.tagName : defaults.tagName;
  this.target = "target" in opts ? opts.target : defaults.target;
  this.rel = "rel" in opts ? opts.rel : defaults.rel;
  this.validate = "validate" in opts ? opts.validate : defaults.validate;
  this.truncate = "truncate" in opts ? opts.truncate : defaults.truncate;
  this.className = "className" in opts ? opts.className : defaults.className;
  this.attributes = opts.attributes || defaults.attributes;
  this.ignoreTags = [];
  var ignoredTags = "ignoreTags" in opts ? opts.ignoreTags : defaults.ignoreTags;
  for (var i3 = 0; i3 < ignoredTags.length; i3++) {
    this.ignoreTags.push(ignoredTags[i3].toUpperCase());
  }
}
Options.prototype = {
  resolve: function resolve(token2) {
    var href = token2.toHref(this.defaultProtocol);
    return {
      formatted: this.get("format", token2.toString(), token2),
      formattedHref: this.get("formatHref", href, token2),
      tagName: this.get("tagName", href, token2),
      className: this.get("className", href, token2),
      target: this.get("target", href, token2),
      rel: this.get("rel", href, token2),
      events: this.getObject("events", href, token2),
      attributes: this.getObject("attributes", href, token2),
      truncate: this.get("truncate", href, token2)
    };
  },
  check: function check(token2) {
    return this.get("validate", token2.toString(), token2);
  },
  get: function get(key, operator, token2) {
    var option2 = this[key];
    if (!option2) {
      return option2;
    }
    var optionValue;
    switch (_typeof$C(option2)) {
      case "function":
        return option2(operator, token2.t);
      case "object":
        optionValue = token2.t in option2 ? option2[token2.t] : defaults[key];
        return typeof optionValue === "function" ? optionValue(operator, token2.t) : optionValue;
    }
    return option2;
  },
  getObject: function getObject(key, operator, token2) {
    var option2 = this[key];
    return typeof option2 === "function" ? option2(operator, token2.t) : option2;
  }
};
function noop(val) {
  return val;
}
function inherits(parent, child) {
  var props = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  var extended = Object.create(parent.prototype);
  for (var p2 in props) {
    extended[p2] = props[p2];
  }
  extended.constructor = child;
  child.prototype = extended;
  return child;
}
function MultiToken() {
}
MultiToken.prototype = {
  t: "token",
  isLink: false,
  toString: function toString() {
    return this.v;
  },
  toHref: function toHref() {
    return this.toString();
  },
  startIndex: function startIndex() {
    return this.tk[0].s;
  },
  endIndex: function endIndex() {
    return this.tk[this.tk.length - 1].e;
  },
  toObject: function toObject() {
    var protocol = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : defaults.defaultProtocol;
    return {
      type: this.t,
      value: this.v,
      isLink: this.isLink,
      href: this.toHref(protocol),
      start: this.startIndex(),
      end: this.endIndex()
    };
  }
};
function createTokenClass(type, props) {
  function Token(value, tokens) {
    this.t = type;
    this.v = value;
    this.tk = tokens;
  }
  inherits(MultiToken, Token, props);
  return Token;
}
var MailtoEmail = createTokenClass("email", {
  isLink: true
});
var Email = createTokenClass("email", {
  isLink: true,
  toHref: function toHref2() {
    return "mailto:" + this.toString();
  }
});
var Text = createTokenClass("text");
var Nl = createTokenClass("nl");
var Url = createTokenClass("url", {
  isLink: true,
  toHref: function toHref3() {
    var protocol = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : defaults.defaultProtocol;
    var tokens = this.tk;
    var hasProtocol2 = false;
    var hasSlashSlash = false;
    var result = [];
    var i3 = 0;
    while (tokens[i3].t === PROTOCOL) {
      hasProtocol2 = true;
      result.push(tokens[i3].v);
      i3++;
    }
    while (tokens[i3].t === SLASH) {
      hasSlashSlash = true;
      result.push(tokens[i3].v);
      i3++;
    }
    for (; i3 < tokens.length; i3++) {
      result.push(tokens[i3].v);
    }
    result = result.join("");
    if (!(hasProtocol2 || hasSlashSlash)) {
      result = "".concat(protocol, "://").concat(result);
    }
    return result;
  },
  hasProtocol: function hasProtocol() {
    return this.tk[0].t === PROTOCOL;
  }
});
var multi = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  MultiToken,
  Base: MultiToken,
  createTokenClass,
  MailtoEmail,
  Email,
  Text,
  Nl,
  Url
});
function init$1() {
  var S_START = makeState();
  var S_PROTOCOL = makeState();
  var S_MAILTO = makeState();
  var S_PROTOCOL_SLASH = makeState();
  var S_PROTOCOL_SLASH_SLASH = makeState();
  var S_DOMAIN = makeState();
  var S_DOMAIN_DOT = makeState();
  var S_TLD = makeAcceptingState(Url);
  var S_TLD_COLON = makeState();
  var S_TLD_PORT = makeAcceptingState(Url);
  var S_URL = makeAcceptingState(Url);
  var S_URL_NON_ACCEPTING = makeState();
  var S_URL_OPENBRACE = makeState();
  var S_URL_OPENBRACKET = makeState();
  var S_URL_OPENANGLEBRACKET = makeState();
  var S_URL_OPENPAREN = makeState();
  var S_URL_OPENBRACE_Q = makeAcceptingState(Url);
  var S_URL_OPENBRACKET_Q = makeAcceptingState(Url);
  var S_URL_OPENANGLEBRACKET_Q = makeAcceptingState(Url);
  var S_URL_OPENPAREN_Q = makeAcceptingState(Url);
  var S_URL_OPENBRACE_SYMS = makeState();
  var S_URL_OPENBRACKET_SYMS = makeState();
  var S_URL_OPENANGLEBRACKET_SYMS = makeState();
  var S_URL_OPENPAREN_SYMS = makeState();
  var S_EMAIL_DOMAIN = makeState();
  var S_EMAIL_DOMAIN_DOT = makeState();
  var S_EMAIL = makeAcceptingState(Email);
  var S_EMAIL_COLON = makeState();
  var S_EMAIL_PORT = makeAcceptingState(Email);
  var S_MAILTO_EMAIL = makeAcceptingState(MailtoEmail);
  var S_MAILTO_EMAIL_NON_ACCEPTING = makeState();
  var S_LOCALPART = makeState();
  var S_LOCALPART_AT = makeState();
  var S_LOCALPART_DOT = makeState();
  var S_NL = makeAcceptingState(Nl);
  makeT(S_START, NL, S_NL);
  makeT(S_START, PROTOCOL, S_PROTOCOL);
  makeT(S_START, MAILTO, S_MAILTO);
  makeT(S_PROTOCOL, SLASH, S_PROTOCOL_SLASH);
  makeT(S_PROTOCOL_SLASH, SLASH, S_PROTOCOL_SLASH_SLASH);
  makeT(S_START, TLD, S_DOMAIN);
  makeT(S_START, DOMAIN, S_DOMAIN);
  makeT(S_START, LOCALHOST, S_TLD);
  makeT(S_START, NUM, S_DOMAIN);
  makeT(S_PROTOCOL_SLASH_SLASH, TLD, S_URL);
  makeT(S_PROTOCOL_SLASH_SLASH, DOMAIN, S_URL);
  makeT(S_PROTOCOL_SLASH_SLASH, NUM, S_URL);
  makeT(S_PROTOCOL_SLASH_SLASH, LOCALHOST, S_URL);
  makeT(S_DOMAIN, DOT, S_DOMAIN_DOT);
  makeT(S_EMAIL_DOMAIN, DOT, S_EMAIL_DOMAIN_DOT);
  makeT(S_DOMAIN_DOT, TLD, S_TLD);
  makeT(S_DOMAIN_DOT, DOMAIN, S_DOMAIN);
  makeT(S_DOMAIN_DOT, NUM, S_DOMAIN);
  makeT(S_DOMAIN_DOT, LOCALHOST, S_DOMAIN);
  makeT(S_EMAIL_DOMAIN_DOT, TLD, S_EMAIL);
  makeT(S_EMAIL_DOMAIN_DOT, DOMAIN, S_EMAIL_DOMAIN);
  makeT(S_EMAIL_DOMAIN_DOT, NUM, S_EMAIL_DOMAIN);
  makeT(S_EMAIL_DOMAIN_DOT, LOCALHOST, S_EMAIL_DOMAIN);
  makeT(S_TLD, DOT, S_DOMAIN_DOT);
  makeT(S_EMAIL, DOT, S_EMAIL_DOMAIN_DOT);
  makeT(S_TLD, COLON, S_TLD_COLON);
  makeT(S_TLD, SLASH, S_URL);
  makeT(S_TLD_COLON, NUM, S_TLD_PORT);
  makeT(S_TLD_PORT, SLASH, S_URL);
  makeT(S_EMAIL, COLON, S_EMAIL_COLON);
  makeT(S_EMAIL_COLON, NUM, S_EMAIL_PORT);
  var qsAccepting = [AMPERSAND, ASTERISK, AT, BACKSLASH, BACKTICK, CARET, DOLLAR, DOMAIN, EQUALS, HYPHEN, LOCALHOST, NUM, PERCENT, PIPE, PLUS, POUND, PROTOCOL, SLASH, SYM, TILDE, TLD, UNDERSCORE];
  var qsNonAccepting = [APOSTROPHE, CLOSEANGLEBRACKET, CLOSEBRACE, CLOSEBRACKET, CLOSEPAREN, COLON, COMMA, DOT, EXCLAMATION, OPENANGLEBRACKET, OPENBRACE, OPENBRACKET, OPENPAREN, QUERY, QUOTE, SEMI];
  makeT(S_URL, OPENBRACE, S_URL_OPENBRACE);
  makeT(S_URL, OPENBRACKET, S_URL_OPENBRACKET);
  makeT(S_URL, OPENANGLEBRACKET, S_URL_OPENANGLEBRACKET);
  makeT(S_URL, OPENPAREN, S_URL_OPENPAREN);
  makeT(S_URL_NON_ACCEPTING, OPENBRACE, S_URL_OPENBRACE);
  makeT(S_URL_NON_ACCEPTING, OPENBRACKET, S_URL_OPENBRACKET);
  makeT(S_URL_NON_ACCEPTING, OPENANGLEBRACKET, S_URL_OPENANGLEBRACKET);
  makeT(S_URL_NON_ACCEPTING, OPENPAREN, S_URL_OPENPAREN);
  makeT(S_URL_OPENBRACE, CLOSEBRACE, S_URL);
  makeT(S_URL_OPENBRACKET, CLOSEBRACKET, S_URL);
  makeT(S_URL_OPENANGLEBRACKET, CLOSEANGLEBRACKET, S_URL);
  makeT(S_URL_OPENPAREN, CLOSEPAREN, S_URL);
  makeT(S_URL_OPENBRACE_Q, CLOSEBRACE, S_URL);
  makeT(S_URL_OPENBRACKET_Q, CLOSEBRACKET, S_URL);
  makeT(S_URL_OPENANGLEBRACKET_Q, CLOSEANGLEBRACKET, S_URL);
  makeT(S_URL_OPENPAREN_Q, CLOSEPAREN, S_URL);
  makeT(S_URL_OPENBRACE_SYMS, CLOSEBRACE, S_URL);
  makeT(S_URL_OPENBRACKET_SYMS, CLOSEBRACKET, S_URL);
  makeT(S_URL_OPENANGLEBRACKET_SYMS, CLOSEANGLEBRACKET, S_URL);
  makeT(S_URL_OPENPAREN_SYMS, CLOSEPAREN, S_URL);
  makeMultiT(S_URL_OPENBRACE, qsAccepting, S_URL_OPENBRACE_Q);
  makeMultiT(S_URL_OPENBRACKET, qsAccepting, S_URL_OPENBRACKET_Q);
  makeMultiT(S_URL_OPENANGLEBRACKET, qsAccepting, S_URL_OPENANGLEBRACKET_Q);
  makeMultiT(S_URL_OPENPAREN, qsAccepting, S_URL_OPENPAREN_Q);
  makeMultiT(S_URL_OPENBRACE, qsNonAccepting, S_URL_OPENBRACE_SYMS);
  makeMultiT(S_URL_OPENBRACKET, qsNonAccepting, S_URL_OPENBRACKET_SYMS);
  makeMultiT(S_URL_OPENANGLEBRACKET, qsNonAccepting, S_URL_OPENANGLEBRACKET_SYMS);
  makeMultiT(S_URL_OPENPAREN, qsNonAccepting, S_URL_OPENPAREN_SYMS);
  makeMultiT(S_URL_OPENBRACE_Q, qsAccepting, S_URL_OPENBRACE_Q);
  makeMultiT(S_URL_OPENBRACKET_Q, qsAccepting, S_URL_OPENBRACKET_Q);
  makeMultiT(S_URL_OPENANGLEBRACKET_Q, qsAccepting, S_URL_OPENANGLEBRACKET_Q);
  makeMultiT(S_URL_OPENPAREN_Q, qsAccepting, S_URL_OPENPAREN_Q);
  makeMultiT(S_URL_OPENBRACE_Q, qsNonAccepting, S_URL_OPENBRACE_Q);
  makeMultiT(S_URL_OPENBRACKET_Q, qsNonAccepting, S_URL_OPENBRACKET_Q);
  makeMultiT(S_URL_OPENANGLEBRACKET_Q, qsNonAccepting, S_URL_OPENANGLEBRACKET_Q);
  makeMultiT(S_URL_OPENPAREN_Q, qsNonAccepting, S_URL_OPENPAREN_Q);
  makeMultiT(S_URL_OPENBRACE_SYMS, qsAccepting, S_URL_OPENBRACE_Q);
  makeMultiT(S_URL_OPENBRACKET_SYMS, qsAccepting, S_URL_OPENBRACKET_Q);
  makeMultiT(S_URL_OPENANGLEBRACKET_SYMS, qsAccepting, S_URL_OPENANGLEBRACKET_Q);
  makeMultiT(S_URL_OPENPAREN_SYMS, qsAccepting, S_URL_OPENPAREN_Q);
  makeMultiT(S_URL_OPENBRACE_SYMS, qsNonAccepting, S_URL_OPENBRACE_SYMS);
  makeMultiT(S_URL_OPENBRACKET_SYMS, qsNonAccepting, S_URL_OPENBRACKET_SYMS);
  makeMultiT(S_URL_OPENANGLEBRACKET_SYMS, qsNonAccepting, S_URL_OPENANGLEBRACKET_SYMS);
  makeMultiT(S_URL_OPENPAREN_SYMS, qsNonAccepting, S_URL_OPENPAREN_SYMS);
  makeMultiT(S_URL, qsAccepting, S_URL);
  makeMultiT(S_URL_NON_ACCEPTING, qsAccepting, S_URL);
  makeMultiT(S_URL, qsNonAccepting, S_URL_NON_ACCEPTING);
  makeMultiT(S_URL_NON_ACCEPTING, qsNonAccepting, S_URL_NON_ACCEPTING);
  makeT(S_MAILTO, TLD, S_MAILTO_EMAIL);
  makeT(S_MAILTO, DOMAIN, S_MAILTO_EMAIL);
  makeT(S_MAILTO, NUM, S_MAILTO_EMAIL);
  makeT(S_MAILTO, LOCALHOST, S_MAILTO_EMAIL);
  makeMultiT(S_MAILTO_EMAIL, qsAccepting, S_MAILTO_EMAIL);
  makeMultiT(S_MAILTO_EMAIL, qsNonAccepting, S_MAILTO_EMAIL_NON_ACCEPTING);
  makeMultiT(S_MAILTO_EMAIL_NON_ACCEPTING, qsAccepting, S_MAILTO_EMAIL);
  makeMultiT(S_MAILTO_EMAIL_NON_ACCEPTING, qsNonAccepting, S_MAILTO_EMAIL_NON_ACCEPTING);
  var localpartAccepting = [AMPERSAND, APOSTROPHE, ASTERISK, BACKSLASH, BACKTICK, CARET, CLOSEBRACE, DOLLAR, DOMAIN, EQUALS, HYPHEN, NUM, OPENBRACE, PERCENT, PIPE, PLUS, POUND, QUERY, SLASH, SYM, TILDE, TLD, UNDERSCORE];
  makeMultiT(S_DOMAIN, localpartAccepting, S_LOCALPART);
  makeT(S_DOMAIN, AT, S_LOCALPART_AT);
  makeMultiT(S_TLD, localpartAccepting, S_LOCALPART);
  makeT(S_TLD, AT, S_LOCALPART_AT);
  makeMultiT(S_DOMAIN_DOT, localpartAccepting, S_LOCALPART);
  makeMultiT(S_LOCALPART, localpartAccepting, S_LOCALPART);
  makeT(S_LOCALPART, AT, S_LOCALPART_AT);
  makeT(S_LOCALPART, DOT, S_LOCALPART_DOT);
  makeMultiT(S_LOCALPART_DOT, localpartAccepting, S_LOCALPART);
  makeT(S_LOCALPART_AT, TLD, S_EMAIL_DOMAIN);
  makeT(S_LOCALPART_AT, DOMAIN, S_EMAIL_DOMAIN);
  makeT(S_LOCALPART_AT, NUM, S_EMAIL_DOMAIN);
  makeT(S_LOCALPART_AT, LOCALHOST, S_EMAIL);
  return S_START;
}
function run(start2, input, tokens) {
  var len = tokens.length;
  var cursor2 = 0;
  var multis = [];
  var textTokens = [];
  while (cursor2 < len) {
    var state = start2;
    var secondState = null;
    var nextState = null;
    var multiLength = 0;
    var latestAccepting = null;
    var sinceAccepts = -1;
    while (cursor2 < len && !(secondState = takeT(state, tokens[cursor2].t))) {
      textTokens.push(tokens[cursor2++]);
    }
    while (cursor2 < len && (nextState = secondState || takeT(state, tokens[cursor2].t))) {
      secondState = null;
      state = nextState;
      if (state.accepts()) {
        sinceAccepts = 0;
        latestAccepting = state;
      } else if (sinceAccepts >= 0) {
        sinceAccepts++;
      }
      cursor2++;
      multiLength++;
    }
    if (sinceAccepts < 0) {
      for (var i3 = cursor2 - multiLength; i3 < cursor2; i3++) {
        textTokens.push(tokens[i3]);
      }
    } else {
      if (textTokens.length > 0) {
        multis.push(parserCreateMultiToken(Text, input, textTokens));
        textTokens = [];
      }
      cursor2 -= sinceAccepts;
      multiLength -= sinceAccepts;
      var Multi = latestAccepting.t;
      var subtokens = tokens.slice(cursor2 - multiLength, cursor2);
      multis.push(parserCreateMultiToken(Multi, input, subtokens));
    }
  }
  if (textTokens.length > 0) {
    multis.push(parserCreateMultiToken(Text, input, textTokens));
  }
  return multis;
}
function parserCreateMultiToken(Multi, input, tokens) {
  var startIdx = tokens[0].s;
  var endIdx = tokens[tokens.length - 1].e;
  var value = input.substr(startIdx, endIdx - startIdx);
  return new Multi(value, tokens);
}
var warn = typeof console !== "undefined" && console && console.warn || function() {
};
var INIT = {
  scanner: null,
  parser: null,
  pluginQueue: [],
  customProtocols: [],
  initialized: false
};
function reset() {
  INIT.scanner = null;
  INIT.parser = null;
  INIT.pluginQueue = [];
  INIT.customProtocols = [];
  INIT.initialized = false;
}
function registerCustomProtocol(protocol) {
  if (INIT.initialized) {
    warn('linkifyjs: already initialized - will not register custom protocol "'.concat(protocol, '" until you manually call linkify.init(). To avoid this warning, please register all custom protocols before invoking linkify the first time.'));
  }
  if (!/^[a-z-]+$/.test(protocol)) {
    throw Error("linkifyjs: protocols containing characters other than a-z or - (hyphen) are not supported");
  }
  INIT.customProtocols.push(protocol);
}
function init() {
  INIT.scanner = {
    start: init$2(INIT.customProtocols),
    tokens: text
  };
  INIT.parser = {
    start: init$1(),
    tokens: multi
  };
  var utils = {
    createTokenClass
  };
  for (var i3 = 0; i3 < INIT.pluginQueue.length; i3++) {
    INIT.pluginQueue[i3][1]({
      scanner: INIT.scanner,
      parser: INIT.parser,
      utils
    });
  }
  INIT.initialized = true;
}
function tokenize(str) {
  if (!INIT.initialized) {
    init();
  }
  return run(INIT.parser.start, str, run$1(INIT.scanner.start, str));
}
function find(str) {
  var type = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
  var tokens = tokenize(str);
  var filtered = [];
  for (var i3 = 0; i3 < tokens.length; i3++) {
    var token2 = tokens[i3];
    if (token2.isLink && (!type || token2.t === type)) {
      filtered.push(token2.toObject());
    }
  }
  return filtered;
}
function test(str) {
  var type = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
  var tokens = tokenize(str);
  return tokens.length === 1 && tokens[0].isLink && (!type || tokens[0].t === type);
}
function autolink(options) {
  return new Plugin({
    key: new PluginKey("autolink"),
    appendTransaction: (transactions, oldState, newState) => {
      const docChanges = transactions.some((transaction) => transaction.docChanged) && !oldState.doc.eq(newState.doc);
      const preventAutolink = transactions.some((transaction) => transaction.getMeta("preventAutolink"));
      if (!docChanges || preventAutolink) {
        return;
      }
      const { tr } = newState;
      const transform = combineTransactionSteps(oldState.doc, [...transactions]);
      const { mapping } = transform;
      const changes = getChangedRanges(transform);
      changes.forEach(({ oldRange, newRange }) => {
        getMarksBetween(oldRange.from, oldRange.to, oldState.doc).filter((item2) => item2.mark.type === options.type).forEach((oldMark) => {
          const newFrom = mapping.map(oldMark.from);
          const newTo = mapping.map(oldMark.to);
          const newMarks = getMarksBetween(newFrom, newTo, newState.doc).filter((item2) => item2.mark.type === options.type);
          if (!newMarks.length) {
            return;
          }
          const newMark = newMarks[0];
          const oldLinkText = oldState.doc.textBetween(oldMark.from, oldMark.to, void 0, " ");
          const newLinkText = newState.doc.textBetween(newMark.from, newMark.to, void 0, " ");
          const wasLink = test(oldLinkText);
          const isLink = test(newLinkText);
          if (wasLink && !isLink) {
            tr.removeMark(newMark.from, newMark.to, options.type);
          }
        });
        const nodesInChangedRanges = findChildrenInRange(newState.doc, newRange, (node2) => node2.isTextblock);
        let textBlock;
        let textBeforeWhitespace;
        if (nodesInChangedRanges.length > 1) {
          textBlock = nodesInChangedRanges[0];
          textBeforeWhitespace = newState.doc.textBetween(textBlock.pos, textBlock.pos + textBlock.node.nodeSize, void 0, " ");
        } else if (nodesInChangedRanges.length && newState.doc.textBetween(newRange.from, newRange.to, " ", " ").endsWith(" ")) {
          textBlock = nodesInChangedRanges[0];
          textBeforeWhitespace = newState.doc.textBetween(textBlock.pos, newRange.to, void 0, " ");
        }
        if (textBlock && textBeforeWhitespace) {
          const wordsBeforeWhitespace = textBeforeWhitespace.split(" ").filter((s4) => s4 !== "");
          if (wordsBeforeWhitespace.length <= 0) {
            return false;
          }
          const lastWordBeforeSpace = wordsBeforeWhitespace[wordsBeforeWhitespace.length - 1];
          const lastWordAndBlockOffset = textBlock.pos + textBeforeWhitespace.lastIndexOf(lastWordBeforeSpace);
          if (!lastWordBeforeSpace) {
            return false;
          }
          find(lastWordBeforeSpace).filter((link) => link.isLink).filter((link) => {
            if (options.validate) {
              return options.validate(link.value);
            }
            return true;
          }).map((link) => ({
            ...link,
            from: lastWordAndBlockOffset + link.start + 1,
            to: lastWordAndBlockOffset + link.end + 1
          })).forEach((link) => {
            tr.addMark(link.from, link.to, options.type.create({
              href: link.href
            }));
          });
        }
      });
      if (!tr.steps.length) {
        return;
      }
      return tr;
    }
  });
}
function clickHandler(options) {
  return new Plugin({
    key: new PluginKey("handleClickLink"),
    props: {
      handleClick: (view, pos, event) => {
        var _a;
        const attrs = getAttributes(view.state, options.type.name);
        const link = (_a = event.target) === null || _a === void 0 ? void 0 : _a.closest("a");
        if (link && attrs.href) {
          window.open(attrs.href, attrs.target);
          return true;
        }
        return false;
      }
    }
  });
}
function pasteHandler(options) {
  return new Plugin({
    key: new PluginKey("handlePasteLink"),
    props: {
      handlePaste: (view, event, slice3) => {
        const { state } = view;
        const { selection } = state;
        const { empty: empty2 } = selection;
        if (empty2) {
          return false;
        }
        let textContent2 = "";
        slice3.content.forEach((node2) => {
          textContent2 += node2.textContent;
        });
        const link = find(textContent2).find((item2) => item2.isLink && item2.value === textContent2);
        if (!textContent2 || !link) {
          return false;
        }
        options.editor.commands.setMark(options.type, {
          href: link.href
        });
        return true;
      }
    }
  });
}
const Link = Mark.create({
  name: "link",
  priority: 1e3,
  keepOnSplit: false,
  onCreate() {
    this.options.protocols.forEach(registerCustomProtocol);
  },
  onDestroy() {
    reset();
  },
  inclusive() {
    return this.options.autolink;
  },
  addOptions() {
    return {
      openOnClick: true,
      linkOnPaste: true,
      autolink: true,
      protocols: [],
      HTMLAttributes: {
        target: "_blank",
        rel: "noopener noreferrer nofollow",
        class: null
      },
      validate: void 0
    };
  },
  addAttributes() {
    return {
      href: {
        default: null
      },
      target: {
        default: this.options.HTMLAttributes.target
      },
      class: {
        default: this.options.HTMLAttributes.class
      }
    };
  },
  parseHTML() {
    return [{ tag: 'a[href]:not([href *= "javascript:" i])' }];
  },
  renderHTML({ HTMLAttributes }) {
    return ["a", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addCommands() {
    return {
      setLink: (attributes) => ({ chain }) => {
        return chain().setMark(this.name, attributes).setMeta("preventAutolink", true).run();
      },
      toggleLink: (attributes) => ({ chain }) => {
        return chain().toggleMark(this.name, attributes, { extendEmptyMarkRange: true }).setMeta("preventAutolink", true).run();
      },
      unsetLink: () => ({ chain }) => {
        return chain().unsetMark(this.name, { extendEmptyMarkRange: true }).setMeta("preventAutolink", true).run();
      }
    };
  },
  addPasteRules() {
    return [
      markPasteRule({
        find: (text2) => find(text2).filter((link) => {
          if (this.options.validate) {
            return this.options.validate(link.value);
          }
          return true;
        }).filter((link) => link.isLink).map((link) => ({
          text: link.value,
          index: link.start,
          data: link
        })),
        type: this.type,
        getAttributes: (match2) => {
          var _a;
          return {
            href: (_a = match2.data) === null || _a === void 0 ? void 0 : _a.href
          };
        }
      })
    ];
  },
  addProseMirrorPlugins() {
    const plugins2 = [];
    if (this.options.autolink) {
      plugins2.push(autolink({
        type: this.type,
        validate: this.options.validate
      }));
    }
    if (this.options.openOnClick) {
      plugins2.push(clickHandler({
        type: this.type
      }));
    }
    if (this.options.linkOnPaste) {
      plugins2.push(pasteHandler({
        editor: this.editor,
        type: this.type
      }));
    }
    return plugins2;
  }
});
const Underline = Mark.create({
  name: "underline",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "u"
      },
      {
        style: "text-decoration",
        consuming: false,
        getAttrs: (style2) => style2.includes("underline") ? {} : false
      }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["u", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addCommands() {
    return {
      setUnderline: () => ({ commands: commands2 }) => {
        return commands2.setMark(this.name);
      },
      toggleUnderline: () => ({ commands: commands2 }) => {
        return commands2.toggleMark(this.name);
      },
      unsetUnderline: () => ({ commands: commands2 }) => {
        return commands2.unsetMark(this.name);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-u": () => this.editor.commands.toggleUnderline(),
      "Mod-U": () => this.editor.commands.toggleUnderline()
    };
  }
});
const inputRegex$3 = /(?:^|\s)((?:==)((?:[^~=]+))(?:==))$/;
const pasteRegex = /(?:^|\s)((?:==)((?:[^~=]+))(?:==))/g;
const Highlight = Mark.create({
  name: "highlight",
  addOptions() {
    return {
      multicolor: false,
      HTMLAttributes: {}
    };
  },
  addAttributes() {
    if (!this.options.multicolor) {
      return {};
    }
    return {
      color: {
        default: null,
        parseHTML: (element) => element.getAttribute("data-color") || element.style.backgroundColor,
        renderHTML: (attributes) => {
          if (!attributes.color) {
            return {};
          }
          return {
            "data-color": attributes.color,
            style: `background-color: ${attributes.color}; color: inherit`
          };
        }
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: "mark"
      }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["mark", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addCommands() {
    return {
      setHighlight: (attributes) => ({ commands: commands2 }) => {
        return commands2.setMark(this.name, attributes);
      },
      toggleHighlight: (attributes) => ({ commands: commands2 }) => {
        return commands2.toggleMark(this.name, attributes);
      },
      unsetHighlight: () => ({ commands: commands2 }) => {
        return commands2.unsetMark(this.name);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-h": () => this.editor.commands.toggleHighlight()
    };
  },
  addInputRules() {
    return [
      markInputRule({
        find: inputRegex$3,
        type: this.type
      })
    ];
  },
  addPasteRules() {
    return [
      markPasteRule({
        find: pasteRegex,
        type: this.type
      })
    ];
  }
});
const TiptapToolbarButton = /* @__PURE__ */ createStyled(UnstyledButton, {
  target: "ecu6col0"
})("height:40px;width:28px;flex:none;cursor:pointer;display:flex;align-items:center;justify-content:center;&:hover{color:#FFF;}", (props) => ({
  color: props.active ? "#FFF" : "#CCC",
  background: props.active ? "rgba(255, 255, 255, .1)" : void 0
}), "");
function IconBold({
  size = 24
}) {
  return /* @__PURE__ */ jsx("svg", {
    width: size,
    height: size,
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    children: /* @__PURE__ */ jsx("path", {
      d: "M8 11h4.5a2.5 2.5 0 1 0 0-5H8v5zm10 4.5a4.5 4.5 0 0 1-4.5 4.5H6V4h6.5a4.5 4.5 0 0 1 3.256 7.606A4.498 4.498 0 0 1 18 15.5zM8 13v5h5.5a2.5 2.5 0 1 0 0-5H8z",
      fill: "currentColor"
    })
  });
}
function IconItalic({
  size = 24
}) {
  return /* @__PURE__ */ jsx("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    width: size,
    height: size,
    children: /* @__PURE__ */ jsx("path", {
      d: "M15 20H7v-2h2.927l2.116-12H9V4h8v2h-2.927l-2.116 12H15z",
      fill: "currentColor"
    })
  });
}
function IconUnderline({
  size = 24
}) {
  return /* @__PURE__ */ jsx("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    width: size,
    height: size,
    children: /* @__PURE__ */ jsx("path", {
      d: "M8 3v9a4 4 0 1 0 8 0V3h2v9a6 6 0 1 1-12 0V3h2zM4 20h16v2H4v-2z",
      fill: "currentColor"
    })
  });
}
function IconMark({
  size = 24
}) {
  return /* @__PURE__ */ jsx("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    width: size,
    height: size,
    children: /* @__PURE__ */ jsx("path", {
      d: "M15.243 4.515l-6.738 6.737-.707 2.121-1.04 1.041 2.828 2.829 1.04-1.041 2.122-.707 6.737-6.738-4.242-4.242zm6.364 3.535a1 1 0 0 1 0 1.414l-7.779 7.779-2.12.707-1.415 1.414a1 1 0 0 1-1.414 0l-4.243-4.243a1 1 0 0 1 0-1.414l1.414-1.414.707-2.121 7.779-7.779a1 1 0 0 1 1.414 0l5.657 5.657zm-6.364-.707l1.414 1.414-4.95 4.95-1.414-1.414 4.95-4.95zM4.283 16.89l2.828 2.829-1.414 1.414-4.243-1.414 2.828-2.829z",
      fill: "currentColor"
    })
  });
}
function IconLink({
  size = 24
}) {
  return /* @__PURE__ */ jsx("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    width: size,
    height: size,
    children: /* @__PURE__ */ jsx("path", {
      d: "M17.657 14.828l-1.414-1.414L17.657 12A4 4 0 1 0 12 6.343l-1.414 1.414-1.414-1.414 1.414-1.414a6 6 0 0 1 8.485 8.485l-1.414 1.414zm-2.829 2.829l-1.414 1.414a6 6 0 1 1-8.485-8.485l1.414-1.414 1.414 1.414L6.343 12A4 4 0 1 0 12 17.657l1.414-1.414 1.414 1.414zm0-9.9l1.415 1.415-7.071 7.07-1.415-1.414 7.071-7.07z",
      fill: "currentColor"
    })
  });
}
function IconClear({
  size = 24
}) {
  return /* @__PURE__ */ jsx("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    width: size,
    height: size,
    children: /* @__PURE__ */ jsx("path", {
      d: "M12.651 14.065L11.605 20H9.574l1.35-7.661-7.41-7.41L4.93 3.515 20.485 19.07l-1.414 1.414-6.42-6.42zm-.878-6.535l.27-1.53h-1.8l-2-2H20v2h-5.927L13.5 9.257 11.773 7.53z",
      fill: "currentColor"
    })
  });
}
function IconList({
  size = 24
}) {
  return /* @__PURE__ */ jsx("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    width: size,
    height: size,
    children: /* @__PURE__ */ jsx("path", {
      d: "M8 4h13v2H8V4zM4.5 6.5a1.5 1.5 0 1 1 0-3 1.5 1.5 0 0 1 0 3zm0 7a1.5 1.5 0 1 1 0-3 1.5 1.5 0 0 1 0 3zm0 6.9a1.5 1.5 0 1 1 0-3 1.5 1.5 0 0 1 0 3zM8 11h13v2H8v-2zm0 7h13v2H8v-2z",
      fill: "currentColor"
    })
  });
}
function IconQuote({
  size = 24
}) {
  return /* @__PURE__ */ jsx("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    width: size,
    height: size,
    children: /* @__PURE__ */ jsx("path", {
      d: "M4.583 17.321C3.553 16.227 3 15 3 13.011c0-3.5 2.457-6.637 6.03-8.188l.893 1.378c-3.335 1.804-3.987 4.145-4.247 5.621.537-.278 1.24-.375 1.929-.311 1.804.167 3.226 1.648 3.226 3.489a3.5 3.5 0 0 1-3.5 3.5c-1.073 0-2.099-.49-2.748-1.179zm10 0C13.553 16.227 13 15 13 13.011c0-3.5 2.457-6.637 6.03-8.188l.893 1.378c-3.335 1.804-3.987 4.145-4.247 5.621.537-.278 1.24-.375 1.929-.311 1.804.167 3.226 1.648 3.226 3.489a3.5 3.5 0 0 1-3.5 3.5c-1.073 0-2.099-.49-2.748-1.179z",
      fill: "currentColor"
    })
  });
}
function IconOrderedList({
  size = 24
}) {
  return /* @__PURE__ */ jsx("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    width: size,
    height: size,
    children: /* @__PURE__ */ jsx("path", {
      d: "M8 4h13v2H8V4zM5 3v3h1v1H3V6h1V4H3V3h2zM3 14v-2.5h2V11H3v-1h3v2.5H4v.5h2v1H3zm2 5.5H3v-1h2V18H3v-1h3v4H3v-1h2v-.5zM8 11h13v2H8v-2zm0 7h13v2H8v-2z",
      fill: "currentColor"
    })
  });
}
function IconHeading({
  size = 24,
  level
}) {
  let path = "";
  if (level === void 0) {
    path = "M17 11V4h2v17h-2v-8H7v8H5V4h2v7z";
  } else if (level === 1) {
    path = "M13 20h-2v-7H4v7H2V4h2v7h7V4h2v16zm8-12v12h-2v-9.796l-2 .536V8.67L19.5 8H21z";
  } else if (level === 2) {
    path = "M4 4v7h7V4h2v16h-2v-7H4v7H2V4h2zm14.5 4c2.071 0 3.75 1.679 3.75 3.75 0 .857-.288 1.648-.772 2.28l-.148.18L18.034 18H22v2h-7v-1.556l4.82-5.546c.268-.307.43-.709.43-1.148 0-.966-.784-1.75-1.75-1.75-.918 0-1.671.707-1.744 1.606l-.006.144h-2C14.75 9.679 16.429 8 18.5 8z";
  } else if (level === 3) {
    path = "M22 8l-.002 2-2.505 2.883c1.59.435 2.757 1.89 2.757 3.617 0 2.071-1.679 3.75-3.75 3.75-1.826 0-3.347-1.305-3.682-3.033l1.964-.382c.156.806.866 1.415 1.718 1.415.966 0 1.75-.784 1.75-1.75s-.784-1.75-1.75-1.75c-.286 0-.556.069-.794.19l-1.307-1.547L19.35 10H15V8h7zM4 4v7h7V4h2v16h-2v-7H4v7H2V4h2z";
  } else if (level === 4) {
    path = "M13 20h-2v-7H4v7H2V4h2v7h7V4h2v16zm9-12v8h1.5v2H22v2h-2v-2h-5.5v-1.34l5-8.66H22zm-2 3.133L17.19 16H20v-4.867z";
  } else if (level === 5) {
    path = "M22 8v2h-4.323l-.464 2.636c.33-.089.678-.136 1.037-.136 2.21 0 4 1.79 4 4s-1.79 4-4 4c-1.827 0-3.367-1.224-3.846-2.897l1.923-.551c.24.836 1.01 1.448 1.923 1.448 1.105 0 2-.895 2-2s-.895-2-2-2c-.63 0-1.193.292-1.56.748l-1.81-.904L16 8h6zM4 4v7h7V4h2v16h-2v-7H4v7H2V4h2z";
  } else if (level === 6) {
    path = "M21.097 8l-2.598 4.5c2.21 0 4.001 1.79 4.001 4s-1.79 4-4 4-4-1.79-4-4c0-.736.199-1.426.546-2.019L18.788 8h2.309zM4 4v7h7V4h2v16h-2v-7H4v7H2V4h2zm14.5 10.5c-1.105 0-2 .895-2 2s.895 2 2 2 2-.895 2-2-.895-2-2-2z";
  }
  return /* @__PURE__ */ jsx("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    width: size,
    height: size,
    children: /* @__PURE__ */ jsx("path", {
      d: path,
      fill: "currentColor"
    })
  });
}
function IconAlign({
  size = 24,
  direction = "left"
}) {
  if (direction === "left") {
    return /* @__PURE__ */ jsx("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 24 24",
      width: size,
      height: size,
      children: /* @__PURE__ */ jsx("path", {
        d: "M3 4h18v2H3V4zm0 15h14v2H3v-2zm0-5h18v2H3v-2zm0-5h14v2H3V9z",
        fill: "currentColor"
      })
    });
  } else if (direction === "right") {
    return /* @__PURE__ */ jsx("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 24 24",
      width: size,
      height: size,
      children: /* @__PURE__ */ jsx("path", {
        d: "M3 4h18v2H3V4zm4 15h14v2H7v-2zm-4-5h18v2H3v-2zm4-5h14v2H7V9z",
        fill: "currentColor"
      })
    });
  } else if (direction === "center") {
    return /* @__PURE__ */ jsx("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 24 24",
      width: size,
      height: size,
      children: /* @__PURE__ */ jsx("path", {
        d: "M3 4h18v2H3V4zm2 15h14v2H5v-2zm-2-5h18v2H3v-2zm2-5h14v2H5V9z",
        fill: "currentColor"
      })
    });
  }
  return /* @__PURE__ */ jsx("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    width: size,
    height: size,
    children: /* @__PURE__ */ jsx("path", {
      d: "M3 4h18v2H3V4zm0 15h18v2H3v-2zm0-5h18v2H3v-2zm0-5h18v2H3V9z",
      fill: "currentColor"
    })
  });
}
const baseHeight = 40;
const TiptapDropdown = /* @__PURE__ */ createStyled("div", {
  target: "erfnamg0"
})({
  position: "relative",
  display: "flex",
  flexDirection: "column",
  background: "#444",
  height: baseHeight,
  flex: "none",
  overflow: "hidden",
  alignItems: "center",
  transition: "height .2s, transform .3s",
  transformOrigin: "50% 0",
  borderRadius: 3,
  "& > *": {
    height: baseHeight - 10
  },
  "& > *:first-of-type": {
    marginTop: 0,
    transition: "margin .3s",
    height: baseHeight
  },
  "&:hover > *:first-of-type": {
    marginTop: -3
  },
  "&:hover": {
    transform: "scale(1.2)"
  }
}, (props) => ({
  "&:hover": {
    height: baseHeight * props.size - 10 * (props.size - 1)
  }
}), "");
var _ref$2 = {
  name: "zdz8xi",
  styles: "height:30px"
};
const TiptapToolbarAlign = ({
  editor
}) => {
  const alignments = ["left", "center", "right", "justify"];
  const currentAlign = alignments.filter((align) => editor.isActive({
    textAlign: align
  }))[0];
  if (!editor.can().setParagraph()) {
    return null;
  }
  return /* @__PURE__ */ jsxs(TiptapDropdown, {
    size: alignments.length,
    children: [/* @__PURE__ */ jsx(TiptapToolbarButton, {
      title: capitalize(currentAlign),
      type: "button",
      children: /* @__PURE__ */ jsx(IconAlign, {
        size: 16,
        direction: currentAlign
      })
    }), alignments.filter((align) => align !== currentAlign).map((align) => /* @__PURE__ */ jsx(TiptapToolbarButton, {
      onClick: prevent(() => editor.chain().focus().setTextAlign(align).run()),
      css: _ref$2,
      title: capitalize(align),
      children: /* @__PURE__ */ jsx(IconAlign, {
        size: 16,
        direction: align
      })
    }, align))]
  });
};
var _ref$1 = {
  name: "zdz8xi",
  styles: "height:30px"
};
const TiptapToolbarHeadings = ({
  editor
}) => {
  const levels = [2, 3, 4, 5, 6];
  const currentLevel = editor.getAttributes("heading").level;
  if (!("toggleHeading" in editor.can()) || !editor.can().toggleHeading({
    level: 2
  })) {
    return null;
  }
  const clickHandler2 = (level) => prevent(() => {
    if (!level) {
      return;
    }
    editor.chain().focus().toggleHeading({
      level
    }).run();
  });
  return /* @__PURE__ */ jsxs(TiptapDropdown, {
    size: levels.length + 1,
    children: [/* @__PURE__ */ jsx(TiptapToolbarButton, {
      active: !!currentLevel,
      onClick: clickHandler2(currentLevel),
      children: /* @__PURE__ */ jsx(IconHeading, {
        size: 16,
        level: currentLevel
      })
    }), levels.map((level) => /* @__PURE__ */ jsx(TiptapToolbarButton, {
      active: level === currentLevel,
      onClick: clickHandler2(level),
      css: _ref$1,
      children: /* @__PURE__ */ jsx(IconHeading, {
        size: 16,
        level
      })
    }, level))]
  });
};
var _ref = {
  name: "bjn8wh",
  styles: "position:relative"
};
function TiptapColorPicker({
  editor,
  colors
}) {
  const currentColor = editor == null ? void 0 : editor.getAttributes("textStyle").color;
  const cssColors = react.exports.useMemo(() => colors.map(colorToProperty), [colors]);
  const [expanded, toggleExpanded, setExpanded] = useToggle();
  const handleChange = (color2) => {
    toggleExpanded();
    editor.chain().focus().setColor(color2).run();
  };
  react.exports.useEffect(() => {
    if (editor.isFocused) {
      setExpanded(false);
    }
  }, [editor.isFocused]);
  if (colors.length === 0) {
    return null;
  }
  return /* @__PURE__ */ jsxs("div", {
    css: _ref,
    children: [/* @__PURE__ */ jsx(TiptapToolbarButton, {
      onClick: prevent(toggleExpanded),
      children: /* @__PURE__ */ jsxs("svg", {
        width: 16,
        height: 16,
        viewBox: "0 0 24 24",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        children: [/* @__PURE__ */ jsx("path", {
          d: "M15.246 14H8.754L7.154 18H5L11 3H13L19 18H16.846L15.246 14ZM14.446 12L12 5.885L9.554 12H14.446Z",
          fill: "currentColor"
        }), /* @__PURE__ */ jsx("path", {
          d: "M3 20H21V22H3V20Z",
          fill: currentColor || "currentColor"
        })]
      })
    }), expanded && /* @__PURE__ */ jsx(Palette, {
      colors: cssColors,
      onChange: handleChange
    })]
  });
}
const PaletteWrapper = /* @__PURE__ */ createStyled("div", {
  target: "evadtag1"
})("position:absolute;top:100%;right:0;background:#444;display:grid;grid-gap:3px;padding:4px;", (props) => ({
  gridTemplateColumns: `repeat(${Math.ceil(props.size / 3)}, 16px)`
}), "");
const PaletteItem = /* @__PURE__ */ createStyled("button", {
  target: "evadtag0"
})({
  name: "1j36tbg",
  styles: "width:16px;height:16px;border:1px solid transparent;cursor:pointer;&:hover{border-color:white;transform:scale(1.5);}"
});
function Palette({
  colors,
  onChange
}) {
  const changeHandler = (color2) => prevent(() => onChange(color2));
  return /* @__PURE__ */ jsx(PaletteWrapper, {
    size: colors.length,
    children: colors.map((color2) => /* @__PURE__ */ jsx(PaletteItem, {
      onClick: changeHandler(color2),
      style: {
        backgroundColor: color2
      }
    }, color2))
  });
}
const iconSize = 16;
function TiptapToolbar({
  editor,
  colors
}) {
  const [mode, setMode] = react.exports.useState(0);
  const setLinkMode = () => setMode(1);
  const setButtonsMode = () => setMode(0);
  const insertLink = (link) => {
    editor.commands.setLink({
      href: link
    });
  };
  let rootElement = null;
  try {
    rootElement = useRootElement();
  } catch (e3) {
  }
  react.exports.useEffect(() => {
    if (editor.isFocused) {
      setMode(0);
    }
  }, [editor.isFocused]);
  return /* @__PURE__ */ jsx(Toolbar, {
    className: "WysiwygToolbar",
    editor,
    shouldShow: ({
      from: from3,
      to
    }) => from3 !== to,
    tippyOptions: {
      maxWidth: 500,
      ...rootElement ? {
        appendTo: () => rootElement
      } : {}
    },
    children: mode === 1 ? /* @__PURE__ */ jsx(ToolbarLink, {
      onSubmit: insertLink,
      onCancel: setButtonsMode
    }) : /* @__PURE__ */ jsx(ToolbarButtons, {
      editor,
      onLinkClick: setLinkMode,
      colors
    })
  });
}
function ToolbarLink({
  onSubmit,
  onCancel
}) {
  const handleKeyDown = (e3) => {
    if (e3.key === "Escape") {
      onCancel();
    }
  };
  const handleSubmit = (e3) => {
    const data = new FormData(e3.target);
    const link = data.get("link");
    if (link) {
      onSubmit(link.toString());
    } else {
      onCancel(link);
    }
  };
  return /* @__PURE__ */ jsxs(Flex, {
    as: "form",
    onKeyDown: handleKeyDown,
    onSubmit: prevent(handleSubmit),
    children: [/* @__PURE__ */ jsx(LinkInput, {
      name: "link",
      type: "text",
      placeholder: "https://...",
      autoFocus: true
    }), /* @__PURE__ */ jsx(TiptapToolbarButton, {
      children: "Ok"
    })]
  });
}
function ToolbarButtons({
  editor,
  onLinkClick,
  colors
}) {
  const clearFormat = () => editor.chain().focus().clearNodes().unsetAllMarks().run();
  const toggleLink = () => {
    if (editor.isActive("link")) {
      editor.chain().focus().unsetLink().run();
    } else {
      onLinkClick();
    }
  };
  return /* @__PURE__ */ jsxs(Fragment$1, {
    children: [editor.can().toggleOrderedList() && /* @__PURE__ */ jsx(TiptapToolbarButton, {
      onClick: prevent(() => editor.chain().focus().toggleOrderedList().run()),
      active: editor.isActive("orderedList"),
      title: "Ordered List",
      children: /* @__PURE__ */ jsx(IconOrderedList, {
        size: iconSize
      })
    }), editor.can().toggleBulletList() && /* @__PURE__ */ jsx(TiptapToolbarButton, {
      onClick: prevent(() => editor.chain().focus().toggleBulletList().run()),
      active: editor.isActive("bulletList"),
      title: "Unordered List",
      children: /* @__PURE__ */ jsx(IconList, {
        size: iconSize
      })
    }), editor.can().toggleBlockquote() && /* @__PURE__ */ jsx(TiptapToolbarButton, {
      onClick: prevent(() => editor.chain().focus().toggleBlockquote().run()),
      active: editor.isActive("blockquote"),
      title: "Blockquote",
      children: /* @__PURE__ */ jsx(IconQuote, {
        size: iconSize
      })
    }), /* @__PURE__ */ jsx(TiptapToolbarHeadings, {
      editor
    }), editor.can().toggleBulletList() && /* @__PURE__ */ jsx(Separator, {}), /* @__PURE__ */ jsx(TiptapToolbarAlign, {
      editor
    }), /* @__PURE__ */ jsx(TiptapToolbarButton, {
      onClick: prevent(() => editor.chain().focus().toggleBold().run()),
      active: editor.isActive("bold"),
      title: "Bold",
      children: /* @__PURE__ */ jsx(IconBold, {
        size: iconSize
      })
    }), /* @__PURE__ */ jsx(TiptapToolbarButton, {
      onClick: prevent(() => editor.chain().focus().toggleItalic().run()),
      active: editor.isActive("italic"),
      title: "Italic",
      children: /* @__PURE__ */ jsx(IconItalic, {
        size: iconSize
      })
    }), /* @__PURE__ */ jsx(TiptapToolbarButton, {
      onClick: prevent(() => editor.chain().focus().toggleUnderline().run()),
      active: editor.isActive("underline"),
      title: "Underline",
      children: /* @__PURE__ */ jsx(IconUnderline, {
        size: iconSize
      })
    }), /* @__PURE__ */ jsx(TiptapToolbarButton, {
      onClick: prevent(() => editor.chain().focus().toggleHighlight().run()),
      active: editor.isActive("highlight"),
      title: "Mark",
      children: /* @__PURE__ */ jsx(IconMark, {
        size: iconSize
      })
    }), /* @__PURE__ */ jsx(TiptapColorPicker, {
      editor,
      colors
    }), /* @__PURE__ */ jsx(Separator, {}), /* @__PURE__ */ jsx(TiptapToolbarButton, {
      onClick: prevent(toggleLink),
      active: editor.isActive("link"),
      title: "Link",
      children: /* @__PURE__ */ jsx(IconLink, {
        size: iconSize
      })
    }), /* @__PURE__ */ jsx(TiptapToolbarButton, {
      onClick: prevent(clearFormat),
      title: "Clear",
      children: /* @__PURE__ */ jsx(IconClear, {
        size: iconSize
      })
    })]
  });
}
const Toolbar = /* @__PURE__ */ createStyled(BubbleMenu, {
  target: "e1q0ivoj2"
})({
  name: "1i1xml5",
  styles: "border-radius:25px;background-color:#444;color:#FFF;height:40px;display:flex;padding:0 1em"
});
const Separator = /* @__PURE__ */ createStyled("div", {
  target: "e1q0ivoj1"
})({
  name: "kfg3zs",
  styles: "width:.5em;flex:none"
});
const LinkInput = /* @__PURE__ */ createStyled("input", {
  target: "e1q0ivoj0"
})({
  name: "o4a0dh",
  styles: "border:none;height:30px;color:inherit;font:inherit;background:transparent;outline:none"
});
const Paragraph = Node$1.create({
  name: "paragraph",
  priority: 1e3,
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  group: "block",
  content: "inline*",
  parseHTML() {
    return [
      { tag: "p" }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["p", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addCommands() {
    return {
      setParagraph: () => ({ commands: commands2 }) => {
        return commands2.setNode(this.name);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Alt-0": () => this.editor.commands.setParagraph()
    };
  }
});
const inputRegex$2 = /^(\d+)\.\s$/;
const OrderedList = Node$1.create({
  name: "orderedList",
  addOptions() {
    return {
      itemTypeName: "listItem",
      HTMLAttributes: {}
    };
  },
  group: "block list",
  content() {
    return `${this.options.itemTypeName}+`;
  },
  addAttributes() {
    return {
      start: {
        default: 1,
        parseHTML: (element) => {
          return element.hasAttribute("start") ? parseInt(element.getAttribute("start") || "", 10) : 1;
        }
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: "ol"
      }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    const { start: start2, ...attributesWithoutStart } = HTMLAttributes;
    return start2 === 1 ? ["ol", mergeAttributes(this.options.HTMLAttributes, attributesWithoutStart), 0] : ["ol", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addCommands() {
    return {
      toggleOrderedList: () => ({ commands: commands2 }) => {
        return commands2.toggleList(this.name, this.options.itemTypeName);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-7": () => this.editor.commands.toggleOrderedList()
    };
  },
  addInputRules() {
    return [
      wrappingInputRule({
        find: inputRegex$2,
        type: this.type,
        getAttributes: (match2) => ({ start: +match2[1] }),
        joinPredicate: (match2, node2) => node2.childCount + node2.attrs.start === +match2[1]
      })
    ];
  }
});
const inputRegex$1 = /^\s*([-+*])\s$/;
const BulletList = Node$1.create({
  name: "bulletList",
  addOptions() {
    return {
      itemTypeName: "listItem",
      HTMLAttributes: {}
    };
  },
  group: "block list",
  content() {
    return `${this.options.itemTypeName}+`;
  },
  parseHTML() {
    return [
      { tag: "ul" }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["ul", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addCommands() {
    return {
      toggleBulletList: () => ({ commands: commands2 }) => {
        return commands2.toggleList(this.name, this.options.itemTypeName);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-8": () => this.editor.commands.toggleBulletList()
    };
  },
  addInputRules() {
    return [
      wrappingInputRule({
        find: inputRegex$1,
        type: this.type
      })
    ];
  }
});
const ListItem = Node$1.create({
  name: "listItem",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  content: "paragraph block*",
  defining: true,
  parseHTML() {
    return [
      {
        tag: "li"
      }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["li", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addKeyboardShortcuts() {
    return {
      Enter: () => this.editor.commands.splitListItem(this.name),
      Tab: () => this.editor.commands.sinkListItem(this.name),
      "Shift-Tab": () => this.editor.commands.liftListItem(this.name)
    };
  }
});
const Document = Node$1.create({
  name: "doc",
  topNode: true,
  content: "block+"
});
const Heading = Node$1.create({
  name: "heading",
  addOptions() {
    return {
      levels: [1, 2, 3, 4, 5, 6],
      HTMLAttributes: {}
    };
  },
  content: "inline*",
  group: "block",
  defining: true,
  addAttributes() {
    return {
      level: {
        default: 1,
        rendered: false
      }
    };
  },
  parseHTML() {
    return this.options.levels.map((level) => ({
      tag: `h${level}`,
      attrs: { level }
    }));
  },
  renderHTML({ node: node2, HTMLAttributes }) {
    const hasLevel = this.options.levels.includes(node2.attrs.level);
    const level = hasLevel ? node2.attrs.level : this.options.levels[0];
    return [`h${level}`, mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addCommands() {
    return {
      setHeading: (attributes) => ({ commands: commands2 }) => {
        if (!this.options.levels.includes(attributes.level)) {
          return false;
        }
        return commands2.setNode(this.name, attributes);
      },
      toggleHeading: (attributes) => ({ commands: commands2 }) => {
        if (!this.options.levels.includes(attributes.level)) {
          return false;
        }
        return commands2.toggleNode(this.name, "paragraph", attributes);
      }
    };
  },
  addKeyboardShortcuts() {
    return this.options.levels.reduce((items, level) => ({
      ...items,
      ...{
        [`Mod-Alt-${level}`]: () => this.editor.commands.toggleHeading({ level })
      }
    }), {});
  },
  addInputRules() {
    return this.options.levels.map((level) => {
      return textblockTypeInputRule({
        find: new RegExp(`^(#{1,${level}})\\s$`),
        type: this.type,
        getAttributes: {
          level
        }
      });
    });
  }
});
const TextAlign$1 = Extension.create({
  name: "textAlign",
  addOptions() {
    return {
      types: [],
      alignments: ["left", "center", "right", "justify"],
      defaultAlignment: "left"
    };
  },
  addGlobalAttributes() {
    return [
      {
        types: this.options.types,
        attributes: {
          textAlign: {
            default: this.options.defaultAlignment,
            parseHTML: (element) => element.style.textAlign || this.options.defaultAlignment,
            renderHTML: (attributes) => {
              if (attributes.textAlign === this.options.defaultAlignment) {
                return {};
              }
              return { style: `text-align: ${attributes.textAlign}` };
            }
          }
        }
      }
    ];
  },
  addCommands() {
    return {
      setTextAlign: (alignment) => ({ commands: commands2 }) => {
        if (!this.options.alignments.includes(alignment)) {
          return false;
        }
        return this.options.types.every((type) => commands2.updateAttributes(type, { textAlign: alignment }));
      },
      unsetTextAlign: () => ({ commands: commands2 }) => {
        return this.options.types.every((type) => commands2.resetAttributes(type, "textAlign"));
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-l": () => this.editor.commands.setTextAlign("left"),
      "Mod-Shift-e": () => this.editor.commands.setTextAlign("center"),
      "Mod-Shift-r": () => this.editor.commands.setTextAlign("right"),
      "Mod-Shift-j": () => this.editor.commands.setTextAlign("justify")
    };
  }
});
const TextStyle = Mark.create({
  name: "textStyle",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "span",
        getAttrs: (element) => {
          const hasStyles = element.hasAttribute("style");
          if (!hasStyles) {
            return false;
          }
          return {};
        }
      }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["span", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addCommands() {
    return {
      removeEmptyTextStyle: () => ({ state, commands: commands2 }) => {
        const attributes = getMarkAttributes(state, this.type);
        const hasStyles = Object.entries(attributes).some(([, value]) => !!value);
        if (hasStyles) {
          return true;
        }
        return commands2.unsetMark(this.name);
      }
    };
  }
});
const Color$1 = Extension.create({
  name: "color",
  addOptions() {
    return {
      types: ["textStyle"]
    };
  },
  addGlobalAttributes() {
    return [
      {
        types: this.options.types,
        attributes: {
          color: {
            default: null,
            parseHTML: (element) => {
              var _a;
              return (_a = element.style.color) === null || _a === void 0 ? void 0 : _a.replace(/['"]+/g, "");
            },
            renderHTML: (attributes) => {
              if (!attributes.color) {
                return {};
              }
              return {
                style: `color: ${attributes.color}`
              };
            }
          }
        }
      }
    ];
  },
  addCommands() {
    return {
      setColor: (color2) => ({ chain }) => {
        return chain().setMark("textStyle", { color: color2 }).run();
      },
      unsetColor: () => ({ chain }) => {
        return chain().setMark("textStyle", { color: null }).removeEmptyTextStyle().run();
      }
    };
  }
});
const HardBreak = Node$1.create({
  name: "hardBreak",
  addOptions() {
    return {
      keepMarks: true,
      HTMLAttributes: {}
    };
  },
  inline: true,
  group: "inline",
  selectable: false,
  parseHTML() {
    return [
      { tag: "br" }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["br", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes)];
  },
  renderText() {
    return "\n";
  },
  addCommands() {
    return {
      setHardBreak: () => ({ commands: commands2, chain, state, editor }) => {
        return commands2.first([
          () => commands2.exitCode(),
          () => commands2.command(() => {
            const { selection, storedMarks } = state;
            if (selection.$from.parent.type.spec.isolating) {
              return false;
            }
            const { keepMarks } = this.options;
            const { splittableMarks } = editor.extensionManager;
            const marks = storedMarks || selection.$to.parentOffset && selection.$from.marks();
            return chain().insertContent({ type: this.name }).command(({ tr, dispatch }) => {
              if (dispatch && marks && keepMarks) {
                const filteredMarks = marks.filter((mark) => splittableMarks.includes(mark.type.name));
                tr.ensureMarks(filteredMarks);
              }
              return true;
            }).run();
          })
        ]);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Enter": () => this.editor.commands.setHardBreak(),
      "Shift-Enter": () => this.editor.commands.setHardBreak()
    };
  }
});
var GOOD_LEAF_SIZE = 200;
var RopeSequence = function RopeSequence2() {
};
RopeSequence.prototype.append = function append2(other) {
  if (!other.length) {
    return this;
  }
  other = RopeSequence.from(other);
  return !this.length && other || other.length < GOOD_LEAF_SIZE && this.leafAppend(other) || this.length < GOOD_LEAF_SIZE && other.leafPrepend(this) || this.appendInner(other);
};
RopeSequence.prototype.prepend = function prepend(other) {
  if (!other.length) {
    return this;
  }
  return RopeSequence.from(other).append(this);
};
RopeSequence.prototype.appendInner = function appendInner(other) {
  return new Append(this, other);
};
RopeSequence.prototype.slice = function slice2(from3, to) {
  if (from3 === void 0)
    from3 = 0;
  if (to === void 0)
    to = this.length;
  if (from3 >= to) {
    return RopeSequence.empty;
  }
  return this.sliceInner(Math.max(0, from3), Math.min(this.length, to));
};
RopeSequence.prototype.get = function get2(i3) {
  if (i3 < 0 || i3 >= this.length) {
    return void 0;
  }
  return this.getInner(i3);
};
RopeSequence.prototype.forEach = function forEach2(f2, from3, to) {
  if (from3 === void 0)
    from3 = 0;
  if (to === void 0)
    to = this.length;
  if (from3 <= to) {
    this.forEachInner(f2, from3, to, 0);
  } else {
    this.forEachInvertedInner(f2, from3, to, 0);
  }
};
RopeSequence.prototype.map = function map(f2, from3, to) {
  if (from3 === void 0)
    from3 = 0;
  if (to === void 0)
    to = this.length;
  var result = [];
  this.forEach(function(elt, i3) {
    return result.push(f2(elt, i3));
  }, from3, to);
  return result;
};
RopeSequence.from = function from2(values) {
  if (values instanceof RopeSequence) {
    return values;
  }
  return values && values.length ? new Leaf(values) : RopeSequence.empty;
};
var Leaf = /* @__PURE__ */ function(RopeSequence3) {
  function Leaf2(values) {
    RopeSequence3.call(this);
    this.values = values;
  }
  if (RopeSequence3)
    Leaf2.__proto__ = RopeSequence3;
  Leaf2.prototype = Object.create(RopeSequence3 && RopeSequence3.prototype);
  Leaf2.prototype.constructor = Leaf2;
  var prototypeAccessors = { length: { configurable: true }, depth: { configurable: true } };
  Leaf2.prototype.flatten = function flatten() {
    return this.values;
  };
  Leaf2.prototype.sliceInner = function sliceInner(from3, to) {
    if (from3 == 0 && to == this.length) {
      return this;
    }
    return new Leaf2(this.values.slice(from3, to));
  };
  Leaf2.prototype.getInner = function getInner(i3) {
    return this.values[i3];
  };
  Leaf2.prototype.forEachInner = function forEachInner(f2, from3, to, start2) {
    for (var i3 = from3; i3 < to; i3++) {
      if (f2(this.values[i3], start2 + i3) === false) {
        return false;
      }
    }
  };
  Leaf2.prototype.forEachInvertedInner = function forEachInvertedInner(f2, from3, to, start2) {
    for (var i3 = from3 - 1; i3 >= to; i3--) {
      if (f2(this.values[i3], start2 + i3) === false) {
        return false;
      }
    }
  };
  Leaf2.prototype.leafAppend = function leafAppend(other) {
    if (this.length + other.length <= GOOD_LEAF_SIZE) {
      return new Leaf2(this.values.concat(other.flatten()));
    }
  };
  Leaf2.prototype.leafPrepend = function leafPrepend(other) {
    if (this.length + other.length <= GOOD_LEAF_SIZE) {
      return new Leaf2(other.flatten().concat(this.values));
    }
  };
  prototypeAccessors.length.get = function() {
    return this.values.length;
  };
  prototypeAccessors.depth.get = function() {
    return 0;
  };
  Object.defineProperties(Leaf2.prototype, prototypeAccessors);
  return Leaf2;
}(RopeSequence);
RopeSequence.empty = new Leaf([]);
var Append = /* @__PURE__ */ function(RopeSequence3) {
  function Append2(left2, right2) {
    RopeSequence3.call(this);
    this.left = left2;
    this.right = right2;
    this.length = left2.length + right2.length;
    this.depth = Math.max(left2.depth, right2.depth) + 1;
  }
  if (RopeSequence3)
    Append2.__proto__ = RopeSequence3;
  Append2.prototype = Object.create(RopeSequence3 && RopeSequence3.prototype);
  Append2.prototype.constructor = Append2;
  Append2.prototype.flatten = function flatten() {
    return this.left.flatten().concat(this.right.flatten());
  };
  Append2.prototype.getInner = function getInner(i3) {
    return i3 < this.left.length ? this.left.get(i3) : this.right.get(i3 - this.left.length);
  };
  Append2.prototype.forEachInner = function forEachInner(f2, from3, to, start2) {
    var leftLen = this.left.length;
    if (from3 < leftLen && this.left.forEachInner(f2, from3, Math.min(to, leftLen), start2) === false) {
      return false;
    }
    if (to > leftLen && this.right.forEachInner(f2, Math.max(from3 - leftLen, 0), Math.min(this.length, to) - leftLen, start2 + leftLen) === false) {
      return false;
    }
  };
  Append2.prototype.forEachInvertedInner = function forEachInvertedInner(f2, from3, to, start2) {
    var leftLen = this.left.length;
    if (from3 > leftLen && this.right.forEachInvertedInner(f2, from3 - leftLen, Math.max(to, leftLen) - leftLen, start2 + leftLen) === false) {
      return false;
    }
    if (to < leftLen && this.left.forEachInvertedInner(f2, Math.min(from3, leftLen), to, start2) === false) {
      return false;
    }
  };
  Append2.prototype.sliceInner = function sliceInner(from3, to) {
    if (from3 == 0 && to == this.length) {
      return this;
    }
    var leftLen = this.left.length;
    if (to <= leftLen) {
      return this.left.slice(from3, to);
    }
    if (from3 >= leftLen) {
      return this.right.slice(from3 - leftLen, to - leftLen);
    }
    return this.left.slice(from3, leftLen).append(this.right.slice(0, to - leftLen));
  };
  Append2.prototype.leafAppend = function leafAppend(other) {
    var inner = this.right.leafAppend(other);
    if (inner) {
      return new Append2(this.left, inner);
    }
  };
  Append2.prototype.leafPrepend = function leafPrepend(other) {
    var inner = this.left.leafPrepend(other);
    if (inner) {
      return new Append2(inner, this.right);
    }
  };
  Append2.prototype.appendInner = function appendInner2(other) {
    if (this.left.depth >= Math.max(this.right.depth, other.depth) + 1) {
      return new Append2(this.left, new Append2(this.right, other));
    }
    return new Append2(this, other);
  };
  return Append2;
}(RopeSequence);
var ropeSequence = RopeSequence;
const max_empty_items = 500;
class Branch {
  constructor(items, eventCount) {
    this.items = items;
    this.eventCount = eventCount;
  }
  popEvent(state, preserveItems) {
    if (this.eventCount == 0)
      return null;
    let end2 = this.items.length;
    for (; ; end2--) {
      let next2 = this.items.get(end2 - 1);
      if (next2.selection) {
        --end2;
        break;
      }
    }
    let remap, mapFrom;
    if (preserveItems) {
      remap = this.remapping(end2, this.items.length);
      mapFrom = remap.maps.length;
    }
    let transform = state.tr;
    let selection, remaining;
    let addAfter = [], addBefore = [];
    this.items.forEach((item2, i3) => {
      if (!item2.step) {
        if (!remap) {
          remap = this.remapping(end2, i3 + 1);
          mapFrom = remap.maps.length;
        }
        mapFrom--;
        addBefore.push(item2);
        return;
      }
      if (remap) {
        addBefore.push(new Item(item2.map));
        let step = item2.step.map(remap.slice(mapFrom)), map2;
        if (step && transform.maybeStep(step).doc) {
          map2 = transform.mapping.maps[transform.mapping.maps.length - 1];
          addAfter.push(new Item(map2, void 0, void 0, addAfter.length + addBefore.length));
        }
        mapFrom--;
        if (map2)
          remap.appendMap(map2, mapFrom);
      } else {
        transform.maybeStep(item2.step);
      }
      if (item2.selection) {
        selection = remap ? item2.selection.map(remap.slice(mapFrom)) : item2.selection;
        remaining = new Branch(this.items.slice(0, end2).append(addBefore.reverse().concat(addAfter)), this.eventCount - 1);
        return false;
      }
    }, this.items.length, 0);
    return { remaining, transform, selection };
  }
  addTransform(transform, selection, histOptions, preserveItems) {
    let newItems = [], eventCount = this.eventCount;
    let oldItems = this.items, lastItem = !preserveItems && oldItems.length ? oldItems.get(oldItems.length - 1) : null;
    for (let i3 = 0; i3 < transform.steps.length; i3++) {
      let step = transform.steps[i3].invert(transform.docs[i3]);
      let item2 = new Item(transform.mapping.maps[i3], step, selection), merged;
      if (merged = lastItem && lastItem.merge(item2)) {
        item2 = merged;
        if (i3)
          newItems.pop();
        else
          oldItems = oldItems.slice(0, oldItems.length - 1);
      }
      newItems.push(item2);
      if (selection) {
        eventCount++;
        selection = void 0;
      }
      if (!preserveItems)
        lastItem = item2;
    }
    let overflow = eventCount - histOptions.depth;
    if (overflow > DEPTH_OVERFLOW) {
      oldItems = cutOffEvents(oldItems, overflow);
      eventCount -= overflow;
    }
    return new Branch(oldItems.append(newItems), eventCount);
  }
  remapping(from3, to) {
    let maps = new Mapping();
    this.items.forEach((item2, i3) => {
      let mirrorPos = item2.mirrorOffset != null && i3 - item2.mirrorOffset >= from3 ? maps.maps.length - item2.mirrorOffset : void 0;
      maps.appendMap(item2.map, mirrorPos);
    }, from3, to);
    return maps;
  }
  addMaps(array) {
    if (this.eventCount == 0)
      return this;
    return new Branch(this.items.append(array.map((map2) => new Item(map2))), this.eventCount);
  }
  rebased(rebasedTransform, rebasedCount) {
    if (!this.eventCount)
      return this;
    let rebasedItems = [], start2 = Math.max(0, this.items.length - rebasedCount);
    let mapping = rebasedTransform.mapping;
    let newUntil = rebasedTransform.steps.length;
    let eventCount = this.eventCount;
    this.items.forEach((item2) => {
      if (item2.selection)
        eventCount--;
    }, start2);
    let iRebased = rebasedCount;
    this.items.forEach((item2) => {
      let pos = mapping.getMirror(--iRebased);
      if (pos == null)
        return;
      newUntil = Math.min(newUntil, pos);
      let map2 = mapping.maps[pos];
      if (item2.step) {
        let step = rebasedTransform.steps[pos].invert(rebasedTransform.docs[pos]);
        let selection = item2.selection && item2.selection.map(mapping.slice(iRebased + 1, pos));
        if (selection)
          eventCount++;
        rebasedItems.push(new Item(map2, step, selection));
      } else {
        rebasedItems.push(new Item(map2));
      }
    }, start2);
    let newMaps = [];
    for (let i3 = rebasedCount; i3 < newUntil; i3++)
      newMaps.push(new Item(mapping.maps[i3]));
    let items = this.items.slice(0, start2).append(newMaps).append(rebasedItems);
    let branch = new Branch(items, eventCount);
    if (branch.emptyItemCount() > max_empty_items)
      branch = branch.compress(this.items.length - rebasedItems.length);
    return branch;
  }
  emptyItemCount() {
    let count = 0;
    this.items.forEach((item2) => {
      if (!item2.step)
        count++;
    });
    return count;
  }
  compress(upto = this.items.length) {
    let remap = this.remapping(0, upto), mapFrom = remap.maps.length;
    let items = [], events2 = 0;
    this.items.forEach((item2, i3) => {
      if (i3 >= upto) {
        items.push(item2);
        if (item2.selection)
          events2++;
      } else if (item2.step) {
        let step = item2.step.map(remap.slice(mapFrom)), map2 = step && step.getMap();
        mapFrom--;
        if (map2)
          remap.appendMap(map2, mapFrom);
        if (step) {
          let selection = item2.selection && item2.selection.map(remap.slice(mapFrom));
          if (selection)
            events2++;
          let newItem = new Item(map2.invert(), step, selection), merged, last = items.length - 1;
          if (merged = items.length && items[last].merge(newItem))
            items[last] = merged;
          else
            items.push(newItem);
        }
      } else if (item2.map) {
        mapFrom--;
      }
    }, this.items.length, 0);
    return new Branch(ropeSequence.from(items.reverse()), events2);
  }
}
Branch.empty = new Branch(ropeSequence.empty, 0);
function cutOffEvents(items, n2) {
  let cutPoint;
  items.forEach((item2, i3) => {
    if (item2.selection && n2-- == 0) {
      cutPoint = i3;
      return false;
    }
  });
  return items.slice(cutPoint);
}
class Item {
  constructor(map2, step, selection, mirrorOffset) {
    this.map = map2;
    this.step = step;
    this.selection = selection;
    this.mirrorOffset = mirrorOffset;
  }
  merge(other) {
    if (this.step && other.step && !other.selection) {
      let step = other.step.merge(this.step);
      if (step)
        return new Item(step.getMap().invert(), step, this.selection);
    }
  }
}
class HistoryState {
  constructor(done, undone, prevRanges, prevTime) {
    this.done = done;
    this.undone = undone;
    this.prevRanges = prevRanges;
    this.prevTime = prevTime;
  }
}
const DEPTH_OVERFLOW = 20;
function applyTransaction(history2, state, tr, options) {
  let historyTr = tr.getMeta(historyKey), rebased;
  if (historyTr)
    return historyTr.historyState;
  if (tr.getMeta(closeHistoryKey))
    history2 = new HistoryState(history2.done, history2.undone, null, 0);
  let appended = tr.getMeta("appendedTransaction");
  if (tr.steps.length == 0) {
    return history2;
  } else if (appended && appended.getMeta(historyKey)) {
    if (appended.getMeta(historyKey).redo)
      return new HistoryState(history2.done.addTransform(tr, void 0, options, mustPreserveItems(state)), history2.undone, rangesFor(tr.mapping.maps[tr.steps.length - 1]), history2.prevTime);
    else
      return new HistoryState(history2.done, history2.undone.addTransform(tr, void 0, options, mustPreserveItems(state)), null, history2.prevTime);
  } else if (tr.getMeta("addToHistory") !== false && !(appended && appended.getMeta("addToHistory") === false)) {
    let newGroup = history2.prevTime == 0 || !appended && (history2.prevTime < (tr.time || 0) - options.newGroupDelay || !isAdjacentTo(tr, history2.prevRanges));
    let prevRanges = appended ? mapRanges(history2.prevRanges, tr.mapping) : rangesFor(tr.mapping.maps[tr.steps.length - 1]);
    return new HistoryState(history2.done.addTransform(tr, newGroup ? state.selection.getBookmark() : void 0, options, mustPreserveItems(state)), Branch.empty, prevRanges, tr.time);
  } else if (rebased = tr.getMeta("rebased")) {
    return new HistoryState(history2.done.rebased(tr, rebased), history2.undone.rebased(tr, rebased), mapRanges(history2.prevRanges, tr.mapping), history2.prevTime);
  } else {
    return new HistoryState(history2.done.addMaps(tr.mapping.maps), history2.undone.addMaps(tr.mapping.maps), mapRanges(history2.prevRanges, tr.mapping), history2.prevTime);
  }
}
function isAdjacentTo(transform, prevRanges) {
  if (!prevRanges)
    return false;
  if (!transform.docChanged)
    return true;
  let adjacent = false;
  transform.mapping.maps[0].forEach((start2, end2) => {
    for (let i3 = 0; i3 < prevRanges.length; i3 += 2)
      if (start2 <= prevRanges[i3 + 1] && end2 >= prevRanges[i3])
        adjacent = true;
  });
  return adjacent;
}
function rangesFor(map2) {
  let result = [];
  map2.forEach((_from, _to, from3, to) => result.push(from3, to));
  return result;
}
function mapRanges(ranges, mapping) {
  if (!ranges)
    return null;
  let result = [];
  for (let i3 = 0; i3 < ranges.length; i3 += 2) {
    let from3 = mapping.map(ranges[i3], 1), to = mapping.map(ranges[i3 + 1], -1);
    if (from3 <= to)
      result.push(from3, to);
  }
  return result;
}
function histTransaction(history2, state, dispatch, redo2) {
  let preserveItems = mustPreserveItems(state);
  let histOptions = historyKey.get(state).spec.config;
  let pop = (redo2 ? history2.undone : history2.done).popEvent(state, preserveItems);
  if (!pop)
    return;
  let selection = pop.selection.resolve(pop.transform.doc);
  let added = (redo2 ? history2.done : history2.undone).addTransform(pop.transform, state.selection.getBookmark(), histOptions, preserveItems);
  let newHist = new HistoryState(redo2 ? added : pop.remaining, redo2 ? pop.remaining : added, null, 0);
  dispatch(pop.transform.setSelection(selection).setMeta(historyKey, { redo: redo2, historyState: newHist }).scrollIntoView());
}
let cachedPreserveItems = false, cachedPreserveItemsPlugins = null;
function mustPreserveItems(state) {
  let plugins2 = state.plugins;
  if (cachedPreserveItemsPlugins != plugins2) {
    cachedPreserveItems = false;
    cachedPreserveItemsPlugins = plugins2;
    for (let i3 = 0; i3 < plugins2.length; i3++)
      if (plugins2[i3].spec.historyPreserveItems) {
        cachedPreserveItems = true;
        break;
      }
  }
  return cachedPreserveItems;
}
const historyKey = new PluginKey("history");
const closeHistoryKey = new PluginKey("closeHistory");
function history$1(config = {}) {
  config = {
    depth: config.depth || 100,
    newGroupDelay: config.newGroupDelay || 500
  };
  return new Plugin({
    key: historyKey,
    state: {
      init() {
        return new HistoryState(Branch.empty, Branch.empty, null, 0);
      },
      apply(tr, hist, state) {
        return applyTransaction(hist, state, tr, config);
      }
    },
    config,
    props: {
      handleDOMEvents: {
        beforeinput(view, e3) {
          let inputType = e3.inputType;
          let command2 = inputType == "historyUndo" ? undo : inputType == "historyRedo" ? redo : null;
          if (!command2)
            return false;
          e3.preventDefault();
          return command2(view.state, view.dispatch);
        }
      }
    }
  });
}
const undo = (state, dispatch) => {
  let hist = historyKey.getState(state);
  if (!hist || hist.done.eventCount == 0)
    return false;
  if (dispatch)
    histTransaction(hist, state, dispatch, false);
  return true;
};
const redo = (state, dispatch) => {
  let hist = historyKey.getState(state);
  if (!hist || hist.undone.eventCount == 0)
    return false;
  if (dispatch)
    histTransaction(hist, state, dispatch, true);
  return true;
};
const History = Extension.create({
  name: "history",
  addOptions() {
    return {
      depth: 100,
      newGroupDelay: 500
    };
  },
  addCommands() {
    return {
      undo: () => ({ state, dispatch }) => {
        return undo(state, dispatch);
      },
      redo: () => ({ state, dispatch }) => {
        return redo(state, dispatch);
      }
    };
  },
  addProseMirrorPlugins() {
    return [
      history$1(this.options)
    ];
  },
  addKeyboardShortcuts() {
    return {
      "Mod-z": () => this.editor.commands.undo(),
      "Mod-y": () => this.editor.commands.redo(),
      "Shift-Mod-z": () => this.editor.commands.redo(),
      "Mod-\u044F": () => this.editor.commands.undo(),
      "Shift-Mod-\u044F": () => this.editor.commands.redo()
    };
  }
});
const inputRegex = /^\s*>\s$/;
const Blockquote = Node$1.create({
  name: "blockquote",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  content: "block+",
  group: "block",
  defining: true,
  parseHTML() {
    return [
      { tag: "blockquote" }
    ];
  },
  renderHTML({ HTMLAttributes }) {
    return ["blockquote", mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addCommands() {
    return {
      setBlockquote: () => ({ commands: commands2 }) => {
        return commands2.wrapIn(this.name);
      },
      toggleBlockquote: () => ({ commands: commands2 }) => {
        return commands2.toggleWrap(this.name);
      },
      unsetBlockquote: () => ({ commands: commands2 }) => {
        return commands2.lift(this.name);
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-b": () => this.editor.commands.toggleBlockquote()
    };
  },
  addInputRules() {
    return [
      wrappingInputRule({
        find: inputRegex,
        type: this.type
      })
    ];
  }
});
const SingleDocument = Node$1.create({
  name: "doc",
  topNode: true,
  group: "block",
  content: "inline*"
});
function TiptapEditor({
  value,
  onChange,
  multiline = false,
  colors = [],
  defaultAlign = "left",
  backgroundColor,
  color: color2
}) {
  const [isFocused, setFocus] = react.exports.useState(false);
  const onChangeRef = react.exports.useRef(onChange);
  onChangeRef.current = onChange;
  const editor = useEditor({
    extensions: [...multiline ? [Document] : [SingleDocument], Paragraph, OrderedList, BulletList, ListItem, Text$1, Bold, Italic, Highlight, Underline, TextStyle, Color$1, HardBreak, History, Blockquote, Link.configure({
      openOnClick: false
    }), Heading.configure({
      levels: [2, 3, 4, 5, 6]
    }), TextAlign$1.configure({
      types: ["heading", "bulletList", "listItem", "orderedList", "blockquote", "paragraph"],
      defaultAlignment: defaultAlign
    })],
    onUpdate: ({
      editor: editor2
    }) => onChangeRef.current(cleanHTML(editor2.getHTML(), multiline)),
    onFocus: () => setFocus(true),
    onBlur: () => setFocus(false),
    content: value
  });
  react.exports.useEffect(() => {
    if (editor) {
      editor.extensionManager.extensions.find((e3) => e3.name === "textAlign").options.defaultAlignment = defaultAlign;
      editor.commands.setContent(value);
    }
  }, [defaultAlign]);
  return /* @__PURE__ */ jsxs(EditorWrapper, {
    focused: isFocused,
    style: {
      textAlign: defaultAlign,
      color: color2,
      backgroundColor
    },
    children: [/* @__PURE__ */ jsx(EditorContent, {
      editor
    }), editor && /* @__PURE__ */ jsx(TiptapToolbar, {
      editor,
      colors
    })]
  });
}
const cleanHTML = (str, multiline) => {
  let content = str.replaceAll(/(<[uo]l[^>]*>)(.*?)(<\/[uo]l>)/gi, (_2, openingTag, inner, closingTag) => `${openingTag}${removeParagraphs(inner)}${closingTag}`);
  if (!multiline) {
    content = removeParagraphs(content);
  }
  return content.trim();
};
function removeParagraphs(str) {
  return str.replaceAll(/<\/p><p[^>]*>/gi, "<br>").replaceAll(/<p[^>]*>/gi, "").replaceAll(/<\/p>/gi, "");
}
const EditorWrapper = /* @__PURE__ */ createStyled("div", {
  target: "ey10unl0"
})("border:1px solid var(--border);background:var(--background);border-radius:0.25em;color:var(--color-dark);padding:calc(1.5 * var(--space, 8px)) calc(1 * var(--space, 8px));display:block;width:100%;outline:none;min-height:48px;p, ul, ol, h2, h3, h4, h5, h1{margin:0 0 1em 0;}li p{margin:0;}.ProseMirror{outline:none;}.ProseMirror > *:last-child{margin:0;}", (props) => ({
  ...props.focused ? Styles.FocusState : void 0,
  p: {
    marginBottom: props.singleLine ? "0" : "1em"
  }
}), "");
const Component$8 = ({
  value,
  onChange,
  options,
  backgroundColor,
  textColor,
  defaultAlign
}) => {
  return /* @__PURE__ */ jsx(Field$1, {
    label: options.label,
    help: options.help,
    children: /* @__PURE__ */ jsx(TiptapEditor, {
      value,
      onChange,
      backgroundColor,
      color: textColor,
      colors: options.colors,
      multiline: options.multiline,
      defaultAlign
    })
  });
};
const HTMLText = (name, options = {}) => {
  return {
    name,
    options: {
      multiline: true,
      allowHeadings: false,
      default: "",
      ...options
    },
    extraProps: (data) => ({
      backgroundColor: colorToProperty(options.backgroundColor && data[options.backgroundColor]),
      textColor: colorToProperty(options.textColor && data[options.textColor]),
      defaultAlign: options.defaultAlign ? data[options.defaultAlign] : void 0
    }),
    render: Component$8,
    ...defaultFieldProperties()
  };
};
function useSize(r2) {
  const [i3, t3] = react.exports.useState(void 0);
  return react.exports.useEffect(() => {
    if (r2) {
      const e3 = new ResizeObserver((e4) => {
        if (!Array.isArray(e4))
          return;
        if (!e4.length)
          return;
        const i4 = e4[0];
        let o2, n2;
        if ("borderBoxSize" in i4) {
          const e5 = i4.borderBoxSize, r3 = Array.isArray(e5) ? e5[0] : e5;
          o2 = r3.inlineSize, n2 = r3.blockSize;
        } else {
          const e5 = r2.getBoundingClientRect();
          o2 = e5.width, n2 = e5.height;
        }
        t3({ width: o2, height: n2 });
      });
      return e3.observe(r2, { box: "border-box" }), () => e3.unobserve(r2);
    }
    t3(void 0);
  }, [r2]), i3;
}
function observeElementRect(n2, o2) {
  const i3 = e$1.get(n2);
  return void 0 === i3 ? (e$1.set(n2, { rect: {}, callbacks: [o2] }), 1 === e$1.size && (t$1 = requestAnimationFrame(c$1))) : (i3.callbacks.push(o2), o2(n2.getBoundingClientRect())), () => {
    const c3 = e$1.get(n2);
    if (void 0 === c3)
      return;
    const i4 = c3.callbacks.indexOf(o2);
    i4 > -1 && c3.callbacks.splice(i4, 1), 0 === c3.callbacks.length && (e$1.delete(n2), 0 === e$1.size && cancelAnimationFrame(t$1));
  };
}
let t$1;
const e$1 = /* @__PURE__ */ new Map();
function c$1() {
  const n2 = [];
  e$1.forEach((t3, e3) => {
    const c3 = e3.getBoundingClientRect();
    var o2, i3;
    o2 = t3.rect, i3 = c3, (o2.width !== i3.width || o2.height !== i3.height || o2.top !== i3.top || o2.right !== i3.right || o2.bottom !== i3.bottom || o2.left !== i3.left) && (t3.rect = c3, n2.push(t3));
  }), n2.forEach((t3) => {
    t3.callbacks.forEach((e3) => e3(t3.rect));
  }), t$1 = requestAnimationFrame(c$1);
}
function useRect(e3) {
  const [o2, c3] = react.exports.useState();
  return react.exports.useEffect(() => {
    if (e3) {
      const r2 = observeElementRect(e3, c3);
      return () => {
        c3(void 0), r2();
      };
    }
  }, [e3]), o2;
}
function getPlacementData({ anchorRect: p2, popperSize: c3, arrowSize: f2, arrowOffset: l2 = 0, side: d4, sideOffset: h4 = 0, align: x3, alignOffset: g2 = 0, shouldAvoidCollisions: u3 = true, collisionBoundariesRect: w3, collisionTolerance: m4 = 0 }) {
  if (!p2 || !c3 || !w3)
    return { popperStyles: o, arrowStyles: n };
  const y4 = function(e3, r2, o2 = 0, n2 = 0, i3) {
    const p3 = i3 ? i3.height : 0, a4 = t(r2, e3, "x"), s4 = t(r2, e3, "y"), c4 = s4.before - o2 - p3, f3 = s4.after + o2 + p3, l3 = a4.before - o2 - p3, d5 = a4.after + o2 + p3;
    return { top: { start: { x: a4.start + n2, y: c4 }, center: { x: a4.center, y: c4 }, end: { x: a4.end - n2, y: c4 } }, right: { start: { x: d5, y: s4.start + n2 }, center: { x: d5, y: s4.center }, end: { x: d5, y: s4.end - n2 } }, bottom: { start: { x: a4.start + n2, y: f3 }, center: { x: a4.center, y: f3 }, end: { x: a4.end - n2, y: f3 } }, left: { start: { x: l3, y: s4.start + n2 }, center: { x: l3, y: s4.center }, end: { x: l3, y: s4.end - n2 } } };
  }(c3, p2, h4, g2, f2), b3 = y4[d4][x3];
  if (false === u3) {
    const t3 = e(b3);
    let o2 = n;
    f2 && (o2 = i({ popperSize: c3, arrowSize: f2, arrowOffset: l2, side: d4, align: x3 }));
    return { popperStyles: { ...t3, "--radix-popper-transform-origin": r$1(c3, d4, x3, l2, f2) }, arrowStyles: o2, placedSide: d4, placedAlign: x3 };
  }
  const S4 = DOMRect.fromRect({ ...c3, ...b3 }), $2 = (O3 = w3, z3 = m4, DOMRect.fromRect({ width: O3.width - 2 * z3, height: O3.height - 2 * z3, x: O3.left + z3, y: O3.top + z3 }));
  var O3, z3;
  const R3 = s(S4, $2), M4 = y4[a(d4)][x3], D3 = function(t3, e3, r2) {
    const o2 = a(t3);
    return e3[t3] && !r2[o2] ? o2 : t3;
  }(d4, R3, s(DOMRect.fromRect({ ...c3, ...M4 }), $2)), A2 = function(t3, e3, r2, o2, n2) {
    const i3 = "top" === r2 || "bottom" === r2, p3 = i3 ? "left" : "top", a4 = i3 ? "right" : "bottom", s4 = i3 ? "width" : "height", c4 = e3[s4] > t3[s4];
    if (("start" === o2 || "center" === o2) && (n2[p3] && c4 || n2[a4] && !c4))
      return "end";
    if (("end" === o2 || "center" === o2) && (n2[a4] && c4 || n2[p3] && !c4))
      return "start";
    return o2;
  }(c3, p2, d4, x3, R3), I3 = e(y4[D3][A2]);
  let C2 = n;
  f2 && (C2 = i({ popperSize: c3, arrowSize: f2, arrowOffset: l2, side: D3, align: A2 }));
  return { popperStyles: { ...I3, "--radix-popper-transform-origin": r$1(c3, D3, A2, l2, f2) }, arrowStyles: C2, placedSide: D3, placedAlign: A2 };
}
function t(t3, e3, r2) {
  const o2 = t3["x" === r2 ? "left" : "top"], n2 = "x" === r2 ? "width" : "height", i3 = t3[n2], p2 = e3[n2];
  return { before: o2 - p2, start: o2, center: o2 + (i3 - p2) / 2, end: o2 + i3 - p2, after: o2 + i3 };
}
function e(t3) {
  return { position: "absolute", top: 0, left: 0, minWidth: "max-content", willChange: "transform", transform: `translate3d(${Math.round(t3.x + window.scrollX)}px, ${Math.round(t3.y + window.scrollY)}px, 0)` };
}
function r$1(t3, e3, r2, o2, n2) {
  const i3 = "top" === e3 || "bottom" === e3, p2 = n2 ? n2.width : 0, a4 = n2 ? n2.height : 0, s4 = p2 / 2 + o2;
  let c3 = "", f2 = "";
  return i3 ? (c3 = { start: `${s4}px`, center: "center", end: t3.width - s4 + "px" }[r2], f2 = "top" === e3 ? `${t3.height + a4}px` : -a4 + "px") : (c3 = "left" === e3 ? `${t3.width + a4}px` : -a4 + "px", f2 = { start: `${s4}px`, center: "center", end: t3.height - s4 + "px" }[r2]), `${c3} ${f2}`;
}
const o = { position: "fixed", top: 0, left: 0, opacity: 0, transform: "translate3d(0, -200%, 0)" }, n = { position: "absolute", opacity: 0 };
function i({ popperSize: t3, arrowSize: e3, arrowOffset: r2, side: o2, align: n2 }) {
  const i3 = (t3.width - e3.width) / 2, a4 = (t3.height - e3.width) / 2, s4 = { top: 0, right: 90, bottom: 180, left: -90 }[o2], c3 = Math.max(e3.width, e3.height), f2 = { width: `${c3}px`, height: `${c3}px`, transform: `rotate(${s4}deg)`, willChange: "transform", position: "absolute", [o2]: "100%", direction: p$1(o2, n2) };
  return "top" !== o2 && "bottom" !== o2 || ("start" === n2 && (f2.left = `${r2}px`), "center" === n2 && (f2.left = `${i3}px`), "end" === n2 && (f2.right = `${r2}px`)), "left" !== o2 && "right" !== o2 || ("start" === n2 && (f2.top = `${r2}px`), "center" === n2 && (f2.top = `${a4}px`), "end" === n2 && (f2.bottom = `${r2}px`)), f2;
}
function p$1(t3, e3) {
  return ("top" !== t3 && "right" !== t3 || "end" !== e3) && ("bottom" !== t3 && "left" !== t3 || "end" === e3) ? "ltr" : "rtl";
}
function a(t3) {
  return { top: "bottom", right: "left", bottom: "top", left: "right" }[t3];
}
function s(t3, e3) {
  return { top: t3.top < e3.top, right: t3.right > e3.right, bottom: t3.bottom > e3.bottom, left: t3.left < e3.left };
}
const [c, l] = createContextScope("Popper");
const [f$1, d] = c("Popper");
const Popper$1 = (e3) => {
  const { __scopePopper: o2, children: r2 } = e3, [t3, n2] = react.exports.useState(null);
  return react.exports.createElement(f$1, { scope: o2, anchor: t3, onAnchorChange: n2 }, r2);
};
const PopperAnchor = /* @__PURE__ */ react.exports.forwardRef((e3, r2) => {
  const { __scopePopper: t3, virtualRef: n2, ...p2 } = e3, c3 = d("PopperAnchor", t3), l2 = react.exports.useRef(null), f2 = useComposedRefs(r2, l2);
  return react.exports.useEffect(() => {
    c3.onAnchorChange((null == n2 ? void 0 : n2.current) || l2.current);
  }), n2 ? null : /* @__PURE__ */ react.exports.createElement(Primitive.div, _extends$1({}, p2, { ref: f2 }));
});
const [u, m$1] = c("PopperContent");
const PopperContent = /* @__PURE__ */ react.exports.forwardRef((e3, n2) => {
  const { __scopePopper: c3, side: l2 = "bottom", sideOffset: f2, align: m4 = "center", alignOffset: w3, collisionTolerance: h4, avoidCollisions: x3 = true, ...v2 } = e3, P2 = d("PopperContent", c3), [A2, g2] = react.exports.useState(), E3 = useRect(P2.anchor), [y4, C2] = react.exports.useState(null), S4 = useSize(y4), [R3, O3] = react.exports.useState(null), _2 = useSize(R3), b3 = useComposedRefs(n2, (e4) => C2(e4)), z3 = function() {
    const [e4, o2] = react.exports.useState(void 0);
    return react.exports.useEffect(() => {
      let e5;
      function r2() {
        o2({ width: window.innerWidth, height: window.innerHeight });
      }
      function t3() {
        window.clearTimeout(e5), e5 = window.setTimeout(r2, 100);
      }
      return r2(), window.addEventListener("resize", t3), () => window.removeEventListener("resize", t3);
    }, []), e4;
  }(), T3 = z3 ? DOMRect.fromRect({ ...z3, x: 0, y: 0 }) : void 0, { popperStyles: k3, arrowStyles: L3, placedSide: B3, placedAlign: D3 } = getPlacementData({ anchorRect: E3, popperSize: S4, arrowSize: _2, arrowOffset: A2, side: l2, sideOffset: f2, align: m4, alignOffset: w3, shouldAvoidCollisions: x3, collisionBoundariesRect: T3, collisionTolerance: h4 }), H4 = void 0 !== B3;
  return react.exports.createElement("div", { style: k3, "data-radix-popper-content-wrapper": "" }, /* @__PURE__ */ react.exports.createElement(u, { scope: c3, arrowStyles: L3, onArrowChange: O3, onArrowOffsetChange: g2 }, /* @__PURE__ */ react.exports.createElement(Primitive.div, _extends$1({ "data-side": B3, "data-align": D3 }, v2, { style: { ...v2.style, animation: H4 ? void 0 : "none" }, ref: b3 }))));
});
const Root$2 = Popper$1;
const Anchor = PopperAnchor;
const Content$1 = PopperContent;
const [C, g$1] = createContextScope("Popover", [l]);
const x$1 = l(), [h$1, E$1] = C("Popover");
const Popover = (e3) => {
  const { __scopePopover: o2, children: t3, open: n2, defaultOpen: c3, onOpenChange: a4, modal: s4 = false } = e3, i3 = x$1(o2), u3 = react.exports.useRef(null), [d4, m4] = react.exports.useState(false), [f2 = false, P2] = useControllableState({ prop: n2, defaultProp: c3, onChange: a4 });
  return react.exports.createElement(Root$2, i3, /* @__PURE__ */ react.exports.createElement(h$1, { scope: o2, contentId: useId(), triggerRef: u3, open: f2, onOpenChange: P2, onOpenToggle: react.exports.useCallback(() => P2((e4) => !e4), [P2]), hasCustomAnchor: d4, onCustomAnchorAdd: react.exports.useCallback(() => m4(true), []), onCustomAnchorRemove: react.exports.useCallback(() => m4(false), []), modal: s4 }, t3));
};
const PopoverTrigger = /* @__PURE__ */ react.exports.forwardRef((e3, o2) => {
  const { __scopePopover: r2, ...n2 } = e3, c3 = E$1("PopoverTrigger", r2), a4 = x$1(r2), s4 = useComposedRefs(o2, c3.triggerRef), i3 = /* @__PURE__ */ react.exports.createElement(Primitive.button, _extends$1({ type: "button", "aria-haspopup": "dialog", "aria-expanded": c3.open, "aria-controls": c3.contentId, "data-state": w$1(c3.open) }, n2, { ref: s4, onClick: composeEventHandlers(e3.onClick, c3.onOpenToggle) }));
  return c3.hasCustomAnchor ? i3 : /* @__PURE__ */ react.exports.createElement(Anchor, _extends$1({ asChild: true }, a4), i3);
});
const PopoverContent = /* @__PURE__ */ react.exports.forwardRef((e3, o2) => {
  const { forceMount: r2, ...t3 } = e3, c3 = E$1("PopoverContent", e3.__scopePopover);
  return react.exports.createElement(Presence, { present: r2 || c3.open }, c3.modal ? /* @__PURE__ */ react.exports.createElement(A, _extends$1({}, t3, { ref: o2 })) : /* @__PURE__ */ react.exports.createElement(O, _extends$1({}, t3, { ref: o2 })));
});
const A = /* @__PURE__ */ react.exports.forwardRef((r2, t3) => {
  const { allowPinchZoom: n2, portalled: c3 = true, ...s4 } = r2, i3 = E$1("PopoverContent", r2.__scopePopover), p2 = react.exports.useRef(null), u3 = useComposedRefs(t3, p2), l2 = react.exports.useRef(false);
  react.exports.useEffect(() => {
    const o2 = p2.current;
    if (o2)
      return hideOthers(o2);
  }, []);
  const d4 = c3 ? Portal : react.exports.Fragment;
  return react.exports.createElement(d4, null, /* @__PURE__ */ react.exports.createElement(o$4, { allowPinchZoom: n2 }, /* @__PURE__ */ react.exports.createElement(R$1, _extends$1({}, s4, { ref: u3, trapFocus: i3.open, disableOutsidePointerEvents: true, onCloseAutoFocus: composeEventHandlers(r2.onCloseAutoFocus, (e3) => {
    var o2;
    e3.preventDefault(), l2.current || null === (o2 = i3.triggerRef.current) || void 0 === o2 || o2.focus();
  }), onPointerDownOutside: composeEventHandlers(r2.onPointerDownOutside, (e3) => {
    const o2 = e3.detail.originalEvent, r3 = 0 === o2.button && true === o2.ctrlKey, t4 = 2 === o2.button || r3;
    l2.current = t4;
  }, { checkForDefaultPrevented: false }), onFocusOutside: composeEventHandlers(r2.onFocusOutside, (e3) => e3.preventDefault(), { checkForDefaultPrevented: false }) }))));
}), O = /* @__PURE__ */ react.exports.forwardRef((e3, o2) => {
  const { portalled: r2 = true, ...t3 } = e3, n2 = E$1("PopoverContent", e3.__scopePopover), c3 = react.exports.useRef(false), s4 = r2 ? Portal : react.exports.Fragment;
  return react.exports.createElement(s4, null, /* @__PURE__ */ react.exports.createElement(R$1, _extends$1({}, t3, { ref: o2, trapFocus: false, disableOutsidePointerEvents: false, onCloseAutoFocus: (o3) => {
    var r3, t4;
    (null === (r3 = e3.onCloseAutoFocus) || void 0 === r3 || r3.call(e3, o3), o3.defaultPrevented) || (c3.current || null === (t4 = n2.triggerRef.current) || void 0 === t4 || t4.focus(), o3.preventDefault());
    c3.current = false;
  }, onInteractOutside: (o3) => {
    var r3, t4;
    null === (r3 = e3.onInteractOutside) || void 0 === r3 || r3.call(e3, o3), o3.defaultPrevented || (c3.current = true);
    const a4 = o3.target;
    (null === (t4 = n2.triggerRef.current) || void 0 === t4 ? void 0 : t4.contains(a4)) && o3.preventDefault();
  } })));
}), R$1 = /* @__PURE__ */ react.exports.forwardRef((e3, o2) => {
  const { __scopePopover: r2, trapFocus: t3, onOpenAutoFocus: n2, onCloseAutoFocus: a4, disableOutsidePointerEvents: u3, onEscapeKeyDown: l2, onPointerDownOutside: d4, onFocusOutside: m4, onInteractOutside: f2, ...C2 } = e3, g2 = E$1("PopoverContent", r2), h4 = x$1(r2);
  return useFocusGuards(), /* @__PURE__ */ react.exports.createElement(FocusScope, { asChild: true, loop: true, trapped: t3, onMountAutoFocus: n2, onUnmountAutoFocus: a4 }, /* @__PURE__ */ react.exports.createElement(DismissableLayer, { asChild: true, disableOutsidePointerEvents: u3, onInteractOutside: f2, onEscapeKeyDown: l2, onPointerDownOutside: d4, onFocusOutside: m4, onDismiss: () => g2.onOpenChange(false) }, /* @__PURE__ */ react.exports.createElement(Content$1, _extends$1({ "data-state": w$1(g2.open), role: "dialog", id: g2.contentId }, h4, C2, { ref: o2, style: { ...C2.style, "--radix-popover-content-transform-origin": "var(--radix-popper-transform-origin)" } }))));
});
function w$1(e3) {
  return e3 ? "open" : "closed";
}
const Root$1 = Popover;
const Trigger = PopoverTrigger;
const Content = PopoverContent;
const color = "_color_gi4lb_1";
const button = "_button_gi4lb_1";
const transparent = "_transparent_gi4lb_15";
const tooltip = "_tooltip_gi4lb_37";
const In = "_In_gi4lb_1";
const palette = "_palette_gi4lb_45";
const item = "_item_gi4lb_50";
var Style$4 = {
  color,
  button,
  transparent,
  tooltip,
  In,
  palette,
  item,
  "item-transparent": "_item-transparent_gi4lb_50"
};
const Component$7 = ({
  value,
  onChange,
  options
}) => {
  const [isOpen, setOpen] = react.exports.useState(false);
  const changeHandler = (color2) => prevent(() => {
    onChange(color2);
    setOpen(false);
  });
  return /* @__PURE__ */ jsx(Field$1, {
    label: options.label,
    children: /* @__PURE__ */ jsx("div", {
      className: Style$4.color,
      children: /* @__PURE__ */ jsxs(Root$1, {
        open: isOpen,
        onOpenChange: () => setOpen((v2) => !v2),
        children: [/* @__PURE__ */ jsx(Trigger, {
          asChild: true,
          children: /* @__PURE__ */ jsx("button", {
            className: `${Style$4.button} ${value === null ? Style$4.transparent : ""}`,
            style: value ? {
              "--selected-color": colorToProperty(value)
            } : void 0
          })
        }), /* @__PURE__ */ jsx(Content, {
          className: Style$4.tooltip,
          side: "top",
          children: /* @__PURE__ */ jsxs("div", {
            className: Style$4.palette,
            style: {
              "--children": options.colors.length + 1
            },
            children: [/* @__PURE__ */ jsx("button", {
              className: Style$4["item-transparent"],
              onClick: prevent(() => onChange(null))
            }), options.colors.map((color2) => /* @__PURE__ */ jsx("button", {
              className: Style$4.item,
              style: {
                "--color-button": colorToProperty(color2)
              },
              onClick: changeHandler(color2)
            }, color2))]
          })
        })]
      })
    })
  });
};
const Color = defineField({
  defaultOptions: {
    default: "",
    colors: []
  },
  render: Component$7
});
const row = "_row_7tu5i_1";
const grid = "_grid_7tu5i_1";
var Style$3 = {
  row,
  grid
};
const RowComponent = ({
  options,
  children
}) => {
  console.log(options.columns);
  return /* @__PURE__ */ jsx(Field$1, {
    label: options.label,
    children: /* @__PURE__ */ jsx(Flex, {
      className: `${Style$3.row} ${options.columns ? Style$3.grid : ""}`,
      style: {
        "--row-columns": options.columns || ""
      },
      children
    })
  });
};
const Row = defineFieldGroup({
  defaultOptions: {},
  render: RowComponent
});
const alignment__buttons = "_alignment__buttons_dxn3l_1";
const alignment__button = "_alignment__button_dxn3l_1";
var Style$2 = {
  alignment__buttons,
  alignment__button
};
function AlignmentButton({
  value,
  onChange,
  icon: IconComponent,
  ...props
}) {
  return /* @__PURE__ */ jsxs("div", {
    className: Style$2.alignment__button,
    children: [/* @__PURE__ */ jsx("input", {
      type: "radio",
      value,
      onChange: () => onChange(value),
      title: capitalize(value),
      ...props
    }), /* @__PURE__ */ jsx("div", {
      children: /* @__PURE__ */ jsx(IconComponent, {})
    })]
  });
}
const AlignmentButtons = ({
  children
}) => {
  return /* @__PURE__ */ jsx("div", {
    className: Style$2.alignment__buttons,
    children
  });
};
const AlignmentIcons$1 = {
  top: IconAlignTop,
  left: IconAlignLeft,
  bottom: IconAlignBottom,
  right: IconAlignRight
};
const Component$6 = ({
  value,
  onChange,
  options
}) => {
  const alignements = ["left", "right", ...options.vertical ? ["top", "bottom"] : []];
  return /* @__PURE__ */ jsx(Field$1, {
    label: options.label,
    children: /* @__PURE__ */ jsx(AlignmentButtons, {
      children: alignements.map((alignment) => /* @__PURE__ */ jsx(AlignmentButton, {
        value: alignment,
        checked: value === alignment,
        onChange,
        icon: AlignmentIcons$1[alignment]
      }, alignment))
    })
  });
};
const Alignment = defineField({
  defaultOptions: {
    default: "left"
  },
  render: Component$6
});
const Component$5 = ({
  value,
  onChange,
  options
}) => {
  const id2 = useUniqId("selectinput");
  return /* @__PURE__ */ jsx(Field$1, {
    id: id2,
    label: options.label,
    help: options.help,
    options: options.options,
    value,
    onInput: (e3) => onChange(e3.target.value)
  });
};
const Select = defineField({
  defaultOptions: {
    default: "",
    options: []
  },
  render: Component$5
});
const Component$4 = ({
  value,
  onChange,
  options
}) => {
  const id2 = useUniqId("numberinput");
  return /* @__PURE__ */ jsx(Field$1, {
    label: options.label,
    type: "number",
    id: id2,
    value,
    onInput: (e3) => onChange(e3.target.value),
    help: options.help
  });
};
const Number$1 = defineField({
  defaultOptions: {
    default: ""
  },
  render: Component$4
});
function usePrevious(r2) {
  const u3 = react.exports.useRef({ value: r2, previous: r2 });
  return react.exports.useMemo(() => (u3.current.value !== r2 && (u3.current.previous = u3.current.value, u3.current.value = r2), u3.current.previous), [r2]);
}
function useDirection(t3, n2) {
  const [r2, o2] = react.exports.useState("ltr"), [i3, u3] = react.exports.useState(), c3 = react.exports.useRef(0);
  return react.exports.useEffect(() => {
    if (void 0 === n2 && null != t3 && t3.parentElement) {
      const e3 = getComputedStyle(t3.parentElement);
      u3(e3);
    }
  }, [t3, n2]), react.exports.useEffect(() => (void 0 === n2 && function e3() {
    c3.current = requestAnimationFrame(() => {
      const t4 = null == i3 ? void 0 : i3.direction;
      t4 && o2(t4), e3();
    });
  }(), () => cancelAnimationFrame(c3.current)), [i3, n2, o2]), n2 || r2;
}
function clamp(t3, [a4, n2]) {
  return Math.min(n2, Math.max(a4, t3));
}
const m = ["PageUp", "PageDown"], f = ["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"], p = { ltr: ["ArrowDown", "Home", "ArrowLeft", "PageDown"], rtl: ["ArrowDown", "Home", "ArrowRight", "PageDown"] }, [S, h, v] = createCollection("Slider"), [w, g] = createContextScope("Slider", [v]);
const [x, b] = w("Slider");
const Slider = /* @__PURE__ */ react.exports.forwardRef((e3, t3) => {
  const { name: n2, min: r2 = 0, max: o2 = 100, step: a4 = 1, orientation: d4 = "horizontal", disabled: p2 = false, minStepsBetweenThumbs: h4 = 0, defaultValue: v2 = [r2], value: w3, onValueChange: g2 = () => {
  }, ...b3 } = e3, [E3, y4] = react.exports.useState(null), _2 = useComposedRefs(t3, (e4) => y4(e4)), M4 = react.exports.useRef(/* @__PURE__ */ new Set()), K3 = react.exports.useRef(0), T3 = "horizontal" === d4, k3 = !E3 || Boolean(E3.closest("form")), C2 = T3 ? R : D, [I3 = [], z3] = useControllableState({ prop: w3, defaultProp: v2, onChange: (e4) => {
    var t4;
    null === (t4 = [...M4.current][K3.current]) || void 0 === t4 || t4.focus(), g2(e4);
  } });
  function A2(e4, t4) {
    const n3 = function(e5) {
      return (String(e5).split(".")[1] || "").length;
    }(a4), i3 = function(e5, t5) {
      const n4 = Math.pow(10, t5);
      return Math.round(e5 * n4) / n4;
    }(Math.round((e4 - r2) / a4) * a4 + r2, n3), l2 = clamp(i3, [r2, o2]);
    z3((e5 = []) => {
      const n4 = function(e6 = [], t5, n5) {
        const r3 = [...e6];
        return r3[n5] = t5, r3.sort((e7, t6) => e7 - t6);
      }(e5, l2, t4);
      return function(e6, t5) {
        if (t5 > 0) {
          const n5 = function(e7) {
            return e7.slice(0, -1).map((t6, n6) => e7[n6 + 1] - t6);
          }(e6);
          return Math.min(...n5) >= t5;
        }
        return true;
      }(n4, h4 * a4) ? (K3.current = n4.indexOf(l2), String(n4) === String(e5) ? e5 : n4) : e5;
    });
  }
  return react.exports.createElement(x, { scope: e3.__scopeSlider, disabled: p2, min: r2, max: o2, valueIndexToChangeRef: K3, thumbs: M4.current, values: I3, orientation: d4 }, /* @__PURE__ */ react.exports.createElement(S.Provider, { scope: e3.__scopeSlider }, /* @__PURE__ */ react.exports.createElement(S.Slot, { scope: e3.__scopeSlider }, /* @__PURE__ */ react.exports.createElement(C2, _extends$1({ "aria-disabled": p2, "data-disabled": p2 ? "" : void 0 }, b3, { ref: _2, min: r2, max: o2, onSlideStart: p2 ? void 0 : function(e4) {
    A2(e4, function(e5, t4) {
      if (1 === e5.length)
        return 0;
      const n3 = e5.map((e6) => Math.abs(e6 - t4)), r3 = Math.min(...n3);
      return n3.indexOf(r3);
    }(I3, e4));
  }, onSlideMove: p2 ? void 0 : function(e4) {
    A2(e4, K3.current);
  }, onHomeKeyDown: () => !p2 && A2(r2, 0), onEndKeyDown: () => !p2 && A2(o2, I3.length - 1), onStepKeyDown: ({ event: e4, direction: t4 }) => {
    if (!p2) {
      const n3 = m.includes(e4.key) || e4.shiftKey && f.includes(e4.key) ? 10 : 1, r3 = K3.current;
      A2(I3[r3] + a4 * n3 * t4, r3);
    }
  } })))), k3 && I3.map((e4, t4) => /* @__PURE__ */ react.exports.createElement(P, { key: t4, name: n2 ? n2 + (I3.length > 1 ? "[]" : "") : void 0, value: e4 })));
});
const [E, y] = w("Slider", { startEdge: "left", endEdge: "right", size: "width", direction: 1 }), R = /* @__PURE__ */ react.exports.forwardRef((e3, t3) => {
  const { min: n2, max: r2, dir: i3, onSlideStart: a4, onSlideMove: d4, onStepKeyDown: s4, ...m4 } = e3, [f2, S4] = react.exports.useState(null), h4 = useComposedRefs(t3, (e4) => S4(e4)), v2 = react.exports.useRef(), w3 = useDirection(f2, i3), g2 = "ltr" === w3;
  function x3(e4) {
    const t4 = v2.current || f2.getBoundingClientRect(), o2 = T([0, t4.width], g2 ? [n2, r2] : [r2, n2]);
    return v2.current = t4, o2(e4 - t4.left);
  }
  return react.exports.createElement(E, { scope: e3.__scopeSlider, startEdge: g2 ? "left" : "right", endEdge: g2 ? "right" : "left", direction: g2 ? 1 : -1, size: "width" }, /* @__PURE__ */ react.exports.createElement(_, _extends$1({ "data-orientation": "horizontal" }, m4, { ref: h4, style: { ...m4.style, "--radix-slider-thumb-transform": "translateX(-50%)" }, onSlideStart: (e4) => {
    const t4 = x3(e4.clientX);
    null == a4 || a4(t4);
  }, onSlideMove: (e4) => {
    const t4 = x3(e4.clientX);
    null == d4 || d4(t4);
  }, onSlideEnd: () => v2.current = void 0, onStepKeyDown: (e4) => {
    const t4 = p[w3].includes(e4.key);
    null == s4 || s4({ event: e4, direction: t4 ? -1 : 1 });
  } })));
}), D = /* @__PURE__ */ react.exports.forwardRef((e3, t3) => {
  const { min: n2, max: r2, onSlideStart: o2, onSlideMove: i3, onStepKeyDown: a4, ...d4 } = e3, s4 = react.exports.useRef(null), m4 = useComposedRefs(t3, s4), f2 = react.exports.useRef();
  function S4(e4) {
    const t4 = f2.current || s4.current.getBoundingClientRect(), o3 = T([0, t4.height], [r2, n2]);
    return f2.current = t4, o3(e4 - t4.top);
  }
  return react.exports.createElement(E, { scope: e3.__scopeSlider, startEdge: "bottom", endEdge: "top", size: "height", direction: 1 }, /* @__PURE__ */ react.exports.createElement(_, _extends$1({ "data-orientation": "vertical" }, d4, { ref: m4, style: { ...d4.style, "--radix-slider-thumb-transform": "translateY(50%)" }, onSlideStart: (e4) => {
    const t4 = S4(e4.clientY);
    null == o2 || o2(t4);
  }, onSlideMove: (e4) => {
    const t4 = S4(e4.clientY);
    null == i3 || i3(t4);
  }, onSlideEnd: () => f2.current = void 0, onStepKeyDown: (e4) => {
    const t4 = p.ltr.includes(e4.key);
    null == a4 || a4({ event: e4, direction: t4 ? -1 : 1 });
  } })));
}), _ = /* @__PURE__ */ react.exports.forwardRef((e3, n2) => {
  const { __scopeSlider: r2, onSlideStart: o2, onSlideMove: i3, onSlideEnd: a4, onHomeKeyDown: l2, onEndKeyDown: s4, onStepKeyDown: p2, ...S4 } = e3, h4 = b("Slider", r2);
  return react.exports.createElement(Primitive.span, _extends$1({}, S4, { ref: n2, onKeyDown: composeEventHandlers(e3.onKeyDown, (e4) => {
    "Home" === e4.key ? (l2(e4), e4.preventDefault()) : "End" === e4.key ? (s4(e4), e4.preventDefault()) : m.concat(f).includes(e4.key) && (p2(e4), e4.preventDefault());
  }), onPointerDown: composeEventHandlers(e3.onPointerDown, (e4) => {
    const t3 = e4.target;
    t3.setPointerCapture(e4.pointerId), e4.preventDefault(), h4.thumbs.has(t3) ? t3.focus() : o2(e4);
  }), onPointerMove: composeEventHandlers(e3.onPointerMove, (e4) => {
    e4.target.hasPointerCapture(e4.pointerId) && i3(e4);
  }), onPointerUp: composeEventHandlers(e3.onPointerUp, (e4) => {
    const t3 = e4.target;
    t3.hasPointerCapture(e4.pointerId) && (t3.releasePointerCapture(e4.pointerId), a4(e4));
  }) }));
});
const SliderTrack = /* @__PURE__ */ react.exports.forwardRef((e3, n2) => {
  const { __scopeSlider: r2, ...o2 } = e3, i3 = b("SliderTrack", r2);
  return react.exports.createElement(Primitive.span, _extends$1({ "data-disabled": i3.disabled ? "" : void 0, "data-orientation": i3.orientation }, o2, { ref: n2 }));
});
const SliderRange = /* @__PURE__ */ react.exports.forwardRef((e3, n2) => {
  const { __scopeSlider: r2, ...o2 } = e3, i3 = b("SliderRange", r2), a4 = y("SliderRange", r2), d4 = react.exports.useRef(null), s4 = useComposedRefs(n2, d4), m4 = i3.values.length, f2 = i3.values.map((e4) => K(e4, i3.min, i3.max)), p2 = m4 > 1 ? Math.min(...f2) : 0, S4 = 100 - Math.max(...f2);
  return react.exports.createElement(Primitive.span, _extends$1({ "data-orientation": i3.orientation, "data-disabled": i3.disabled ? "" : void 0 }, o2, { ref: s4, style: { ...e3.style, [a4.startEdge]: p2 + "%", [a4.endEdge]: S4 + "%" } }));
});
const SliderThumb = /* @__PURE__ */ react.exports.forwardRef((e3, t3) => {
  const n2 = h(e3.__scopeSlider), [r2, o2] = react.exports.useState(null), i3 = useComposedRefs(t3, (e4) => o2(e4)), a4 = react.exports.useMemo(() => r2 ? n2().findIndex((e4) => e4.ref.current === r2) : -1, [n2, r2]);
  return react.exports.createElement(M, _extends$1({}, e3, { ref: i3, index: a4 }));
});
const M = /* @__PURE__ */ react.exports.forwardRef((e3, r2) => {
  const { __scopeSlider: o2, index: i3, ...a4 } = e3, s4 = b("SliderThumb", o2), m4 = y("SliderThumb", o2), [f2, p2] = react.exports.useState(null), h4 = useComposedRefs(r2, (e4) => p2(e4)), v2 = useSize(f2), w3 = s4.values[i3], g2 = void 0 === w3 ? 0 : K(w3, s4.min, s4.max), x3 = function(e4, t3) {
    return t3 > 2 ? `Value ${e4 + 1} of ${t3}` : 2 === t3 ? ["Minimum", "Maximum"][e4] : void 0;
  }(i3, s4.values.length), E3 = null == v2 ? void 0 : v2[m4.size], R3 = E3 ? function(e4, t3, n2) {
    const r3 = e4 / 2, o3 = T([0, 50], [0, r3]);
    return (r3 - o3(t3) * n2) * n2;
  }(E3, g2, m4.direction) : 0;
  return react.exports.useEffect(() => {
    if (f2)
      return s4.thumbs.add(f2), () => {
        s4.thumbs.delete(f2);
      };
  }, [f2, s4.thumbs]), /* @__PURE__ */ react.exports.createElement("span", { style: { transform: "var(--radix-slider-thumb-transform)", position: "absolute", [m4.startEdge]: `calc(${g2}% + ${R3}px)` } }, /* @__PURE__ */ react.exports.createElement(S.ItemSlot, { scope: e3.__scopeSlider }, /* @__PURE__ */ react.exports.createElement(Primitive.span, _extends$1({ role: "slider", "aria-label": e3["aria-label"] || x3, "aria-valuemin": s4.min, "aria-valuenow": w3, "aria-valuemax": s4.max, "aria-orientation": s4.orientation, "data-orientation": s4.orientation, "data-disabled": s4.disabled ? "" : void 0, tabIndex: s4.disabled ? void 0 : 0 }, a4, { ref: h4, style: void 0 === w3 ? { display: "none" } : e3.style, onFocus: composeEventHandlers(e3.onFocus, () => {
    s4.valueIndexToChangeRef.current = i3;
  }) }))));
}), P = (e3) => {
  const { value: t3, ...n2 } = e3, o2 = react.exports.useRef(null), i3 = usePrevious(t3);
  return react.exports.useEffect(() => {
    const e4 = o2.current, n3 = window.HTMLInputElement.prototype, r2 = Object.getOwnPropertyDescriptor(n3, "value").set;
    if (i3 !== t3 && r2) {
      const n4 = new Event("input", { bubbles: true });
      r2.call(e4, t3), e4.dispatchEvent(n4);
    }
  }, [i3, t3]), /* @__PURE__ */ react.exports.createElement("input", _extends$1({ style: { display: "none" } }, n2, { ref: o2, defaultValue: t3 }));
};
function K(e3, t3, n2) {
  return 100 / (n2 - t3) * (e3 - t3);
}
function T(e3, t3) {
  return (n2) => {
    if (e3[0] === e3[1] || t3[0] === t3[1])
      return t3[0];
    const r2 = (t3[1] - t3[0]) / (e3[1] - e3[0]);
    return t3[0] + r2 * (n2 - e3[0]);
  };
}
const Root = Slider;
const Track = SliderTrack;
const Range$1 = SliderRange;
const Thumb = SliderThumb;
const range = "_range_n90ln_1";
const track = "_track_n90ln_10";
const track__selected = "_track__selected_n90ln_18";
const thumb = "_thumb_n90ln_26";
var Style$1 = {
  range,
  track,
  track__selected,
  thumb
};
const Component$3 = ({
  value,
  onChange,
  options
}) => {
  return /* @__PURE__ */ jsx(Field$1, {
    label: /* @__PURE__ */ jsxs(Fragment$1, {
      children: [options.label, " ", /* @__PURE__ */ jsxs("small", {
        children: ["(", value, ")"]
      })]
    }),
    help: options.help,
    children: /* @__PURE__ */ jsxs(Root, {
      className: Style$1.range,
      min: options.min,
      max: options.max,
      value: [value === void 0 ? options.default || 0 : value],
      step: options.step,
      onValueChange: (v2) => onChange(v2[0] || 0),
      children: [/* @__PURE__ */ jsx(Track, {
        className: Style$1.track,
        children: /* @__PURE__ */ jsx(Range$1, {
          className: Style$1.track__selected
        })
      }), /* @__PURE__ */ jsx(Thumb, {
        className: Style$1.thumb
      })]
    })
  });
};
const Range = defineField({
  defaultOptions: {
    default: 0,
    min: 0,
    max: 100,
    step: 1
  },
  render: Component$3
});
const Component$2 = ({
  children,
  options
}) => {
  const childrenForTab = (tab) => {
    return react.exports.cloneElement(children, {
      fields: tab.fields
    });
  };
  return /* @__PURE__ */ jsx(Tabs$1, {
    children: options.tabs.map((tab) => /* @__PURE__ */ jsx(Tabs$1.Tab, {
      title: tab.label,
      children: /* @__PURE__ */ jsx(Flex, {
        column: true,
        children: childrenForTab(tab)
      })
    }, tab.label))
  });
};
function Tabs(...tabs) {
  return {
    ...defaultFieldProperties(),
    group: true,
    options: {
      tabs
    },
    render: Component$2,
    fields: tabs.reduce((acc, tab) => [...acc, ...tab.fields], [])
  };
}
var classnames2 = { exports: {} };
/*!
	Copyright (c) 2018 Jed Watson.
	Licensed under the MIT License (MIT), see
	http://jedwatson.github.io/classnames
*/
(function(module) {
  (function() {
    var hasOwn = {}.hasOwnProperty;
    function classNames() {
      var classes = [];
      for (var i3 = 0; i3 < arguments.length; i3++) {
        var arg = arguments[i3];
        if (!arg)
          continue;
        var argType = typeof arg;
        if (argType === "string" || argType === "number") {
          classes.push(arg);
        } else if (Array.isArray(arg)) {
          if (arg.length) {
            var inner = classNames.apply(null, arg);
            if (inner) {
              classes.push(inner);
            }
          }
        } else if (argType === "object") {
          if (arg.toString !== Object.prototype.toString && !arg.toString.toString().includes("[native code]")) {
            classes.push(arg.toString());
            continue;
          }
          for (var key in arg) {
            if (hasOwn.call(arg, key) && arg[key]) {
              classes.push(key);
            }
          }
        }
      }
      return classes.join(" ");
    }
    if (module.exports) {
      classNames.default = classNames;
      module.exports = classNames;
    } else {
      window.classNames = classNames;
    }
  })();
})(classnames2);
var r = classnames2.exports;
function requiredArgs(required, args) {
  if (args.length < required) {
    throw new TypeError(required + " argument" + (required > 1 ? "s" : "") + " required, but only " + args.length + " present");
  }
}
function _typeof$B(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$B = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$B = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$B(obj);
}
function isDate(value) {
  requiredArgs(1, arguments);
  return value instanceof Date || _typeof$B(value) === "object" && Object.prototype.toString.call(value) === "[object Date]";
}
function _typeof$A(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$A = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$A = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$A(obj);
}
function toDate(argument) {
  requiredArgs(1, arguments);
  var argStr = Object.prototype.toString.call(argument);
  if (argument instanceof Date || _typeof$A(argument) === "object" && argStr === "[object Date]") {
    return new Date(argument.getTime());
  } else if (typeof argument === "number" || argStr === "[object Number]") {
    return new Date(argument);
  } else {
    if ((typeof argument === "string" || argStr === "[object String]") && typeof console !== "undefined") {
      console.warn("Starting with v2.0.0-beta.1 date-fns doesn't accept strings as date arguments. Please use `parseISO` to parse strings. See: https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#string-arguments");
      console.warn(new Error().stack);
    }
    return new Date(NaN);
  }
}
function isValid(dirtyDate) {
  requiredArgs(1, arguments);
  if (!isDate(dirtyDate) && typeof dirtyDate !== "number") {
    return false;
  }
  var date = toDate(dirtyDate);
  return !isNaN(Number(date));
}
function toInteger(dirtyNumber) {
  if (dirtyNumber === null || dirtyNumber === true || dirtyNumber === false) {
    return NaN;
  }
  var number = Number(dirtyNumber);
  if (isNaN(number)) {
    return number;
  }
  return number < 0 ? Math.ceil(number) : Math.floor(number);
}
function addMilliseconds(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var timestamp = toDate(dirtyDate).getTime();
  var amount = toInteger(dirtyAmount);
  return new Date(timestamp + amount);
}
function subMilliseconds(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var amount = toInteger(dirtyAmount);
  return addMilliseconds(dirtyDate, -amount);
}
var MILLISECONDS_IN_DAY$1 = 864e5;
function getUTCDayOfYear(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var timestamp = date.getTime();
  date.setUTCMonth(0, 1);
  date.setUTCHours(0, 0, 0, 0);
  var startOfYearTimestamp = date.getTime();
  var difference = timestamp - startOfYearTimestamp;
  return Math.floor(difference / MILLISECONDS_IN_DAY$1) + 1;
}
function startOfUTCISOWeek(dirtyDate) {
  requiredArgs(1, arguments);
  var weekStartsOn = 1;
  var date = toDate(dirtyDate);
  var day = date.getUTCDay();
  var diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
  date.setUTCDate(date.getUTCDate() - diff);
  date.setUTCHours(0, 0, 0, 0);
  return date;
}
function getUTCISOWeekYear(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var year = date.getUTCFullYear();
  var fourthOfJanuaryOfNextYear = new Date(0);
  fourthOfJanuaryOfNextYear.setUTCFullYear(year + 1, 0, 4);
  fourthOfJanuaryOfNextYear.setUTCHours(0, 0, 0, 0);
  var startOfNextYear = startOfUTCISOWeek(fourthOfJanuaryOfNextYear);
  var fourthOfJanuaryOfThisYear = new Date(0);
  fourthOfJanuaryOfThisYear.setUTCFullYear(year, 0, 4);
  fourthOfJanuaryOfThisYear.setUTCHours(0, 0, 0, 0);
  var startOfThisYear = startOfUTCISOWeek(fourthOfJanuaryOfThisYear);
  if (date.getTime() >= startOfNextYear.getTime()) {
    return year + 1;
  } else if (date.getTime() >= startOfThisYear.getTime()) {
    return year;
  } else {
    return year - 1;
  }
}
function startOfUTCISOWeekYear(dirtyDate) {
  requiredArgs(1, arguments);
  var year = getUTCISOWeekYear(dirtyDate);
  var fourthOfJanuary = new Date(0);
  fourthOfJanuary.setUTCFullYear(year, 0, 4);
  fourthOfJanuary.setUTCHours(0, 0, 0, 0);
  var date = startOfUTCISOWeek(fourthOfJanuary);
  return date;
}
var MILLISECONDS_IN_WEEK$2 = 6048e5;
function getUTCISOWeek(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var diff = startOfUTCISOWeek(date).getTime() - startOfUTCISOWeekYear(date).getTime();
  return Math.round(diff / MILLISECONDS_IN_WEEK$2) + 1;
}
var defaultOptions = {};
function getDefaultOptions() {
  return defaultOptions;
}
function startOfUTCWeek(dirtyDate, options) {
  var _ref2, _ref22, _ref3, _options$weekStartsOn, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
  requiredArgs(1, arguments);
  var defaultOptions2 = getDefaultOptions();
  var weekStartsOn = toInteger((_ref2 = (_ref22 = (_ref3 = (_options$weekStartsOn = options === null || options === void 0 ? void 0 : options.weekStartsOn) !== null && _options$weekStartsOn !== void 0 ? _options$weekStartsOn : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.weekStartsOn) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions2.weekStartsOn) !== null && _ref22 !== void 0 ? _ref22 : (_defaultOptions$local = defaultOptions2.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.weekStartsOn) !== null && _ref2 !== void 0 ? _ref2 : 0);
  if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
    throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
  }
  var date = toDate(dirtyDate);
  var day = date.getUTCDay();
  var diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
  date.setUTCDate(date.getUTCDate() - diff);
  date.setUTCHours(0, 0, 0, 0);
  return date;
}
function getUTCWeekYear(dirtyDate, options) {
  var _ref2, _ref22, _ref3, _options$firstWeekCon, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var year = date.getUTCFullYear();
  var defaultOptions2 = getDefaultOptions();
  var firstWeekContainsDate = toInteger((_ref2 = (_ref22 = (_ref3 = (_options$firstWeekCon = options === null || options === void 0 ? void 0 : options.firstWeekContainsDate) !== null && _options$firstWeekCon !== void 0 ? _options$firstWeekCon : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.firstWeekContainsDate) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions2.firstWeekContainsDate) !== null && _ref22 !== void 0 ? _ref22 : (_defaultOptions$local = defaultOptions2.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.firstWeekContainsDate) !== null && _ref2 !== void 0 ? _ref2 : 1);
  if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7)) {
    throw new RangeError("firstWeekContainsDate must be between 1 and 7 inclusively");
  }
  var firstWeekOfNextYear = new Date(0);
  firstWeekOfNextYear.setUTCFullYear(year + 1, 0, firstWeekContainsDate);
  firstWeekOfNextYear.setUTCHours(0, 0, 0, 0);
  var startOfNextYear = startOfUTCWeek(firstWeekOfNextYear, options);
  var firstWeekOfThisYear = new Date(0);
  firstWeekOfThisYear.setUTCFullYear(year, 0, firstWeekContainsDate);
  firstWeekOfThisYear.setUTCHours(0, 0, 0, 0);
  var startOfThisYear = startOfUTCWeek(firstWeekOfThisYear, options);
  if (date.getTime() >= startOfNextYear.getTime()) {
    return year + 1;
  } else if (date.getTime() >= startOfThisYear.getTime()) {
    return year;
  } else {
    return year - 1;
  }
}
function startOfUTCWeekYear(dirtyDate, options) {
  var _ref2, _ref22, _ref3, _options$firstWeekCon, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
  requiredArgs(1, arguments);
  var defaultOptions2 = getDefaultOptions();
  var firstWeekContainsDate = toInteger((_ref2 = (_ref22 = (_ref3 = (_options$firstWeekCon = options === null || options === void 0 ? void 0 : options.firstWeekContainsDate) !== null && _options$firstWeekCon !== void 0 ? _options$firstWeekCon : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.firstWeekContainsDate) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions2.firstWeekContainsDate) !== null && _ref22 !== void 0 ? _ref22 : (_defaultOptions$local = defaultOptions2.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.firstWeekContainsDate) !== null && _ref2 !== void 0 ? _ref2 : 1);
  var year = getUTCWeekYear(dirtyDate, options);
  var firstWeek = new Date(0);
  firstWeek.setUTCFullYear(year, 0, firstWeekContainsDate);
  firstWeek.setUTCHours(0, 0, 0, 0);
  var date = startOfUTCWeek(firstWeek, options);
  return date;
}
var MILLISECONDS_IN_WEEK$1 = 6048e5;
function getUTCWeek(dirtyDate, options) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var diff = startOfUTCWeek(date, options).getTime() - startOfUTCWeekYear(date, options).getTime();
  return Math.round(diff / MILLISECONDS_IN_WEEK$1) + 1;
}
function addLeadingZeros(number, targetLength) {
  var sign = number < 0 ? "-" : "";
  var output = Math.abs(number).toString();
  while (output.length < targetLength) {
    output = "0" + output;
  }
  return sign + output;
}
var formatters$2 = {
  y: function y2(date, token2) {
    var signedYear = date.getUTCFullYear();
    var year = signedYear > 0 ? signedYear : 1 - signedYear;
    return addLeadingZeros(token2 === "yy" ? year % 100 : year, token2.length);
  },
  M: function M2(date, token2) {
    var month = date.getUTCMonth();
    return token2 === "M" ? String(month + 1) : addLeadingZeros(month + 1, 2);
  },
  d: function d2(date, token2) {
    return addLeadingZeros(date.getUTCDate(), token2.length);
  },
  a: function a2(date, token2) {
    var dayPeriodEnumValue = date.getUTCHours() / 12 >= 1 ? "pm" : "am";
    switch (token2) {
      case "a":
      case "aa":
        return dayPeriodEnumValue.toUpperCase();
      case "aaa":
        return dayPeriodEnumValue;
      case "aaaaa":
        return dayPeriodEnumValue[0];
      case "aaaa":
      default:
        return dayPeriodEnumValue === "am" ? "a.m." : "p.m.";
    }
  },
  h: function h2(date, token2) {
    return addLeadingZeros(date.getUTCHours() % 12 || 12, token2.length);
  },
  H: function H2(date, token2) {
    return addLeadingZeros(date.getUTCHours(), token2.length);
  },
  m: function m2(date, token2) {
    return addLeadingZeros(date.getUTCMinutes(), token2.length);
  },
  s: function s2(date, token2) {
    return addLeadingZeros(date.getUTCSeconds(), token2.length);
  },
  S: function S2(date, token2) {
    var numberOfDigits = token2.length;
    var milliseconds = date.getUTCMilliseconds();
    var fractionalSeconds = Math.floor(milliseconds * Math.pow(10, numberOfDigits - 3));
    return addLeadingZeros(fractionalSeconds, token2.length);
  }
};
var lightFormatters = formatters$2;
var dayPeriodEnum = {
  am: "am",
  pm: "pm",
  midnight: "midnight",
  noon: "noon",
  morning: "morning",
  afternoon: "afternoon",
  evening: "evening",
  night: "night"
};
var formatters = {
  G: function G2(date, token2, localize2) {
    var era = date.getUTCFullYear() > 0 ? 1 : 0;
    switch (token2) {
      case "G":
      case "GG":
      case "GGG":
        return localize2.era(era, {
          width: "abbreviated"
        });
      case "GGGGG":
        return localize2.era(era, {
          width: "narrow"
        });
      case "GGGG":
      default:
        return localize2.era(era, {
          width: "wide"
        });
    }
  },
  y: function y3(date, token2, localize2) {
    if (token2 === "yo") {
      var signedYear = date.getUTCFullYear();
      var year = signedYear > 0 ? signedYear : 1 - signedYear;
      return localize2.ordinalNumber(year, {
        unit: "year"
      });
    }
    return lightFormatters.y(date, token2);
  },
  Y: function Y2(date, token2, localize2, options) {
    var signedWeekYear = getUTCWeekYear(date, options);
    var weekYear = signedWeekYear > 0 ? signedWeekYear : 1 - signedWeekYear;
    if (token2 === "YY") {
      var twoDigitYear = weekYear % 100;
      return addLeadingZeros(twoDigitYear, 2);
    }
    if (token2 === "Yo") {
      return localize2.ordinalNumber(weekYear, {
        unit: "year"
      });
    }
    return addLeadingZeros(weekYear, token2.length);
  },
  R: function R2(date, token2) {
    var isoWeekYear = getUTCISOWeekYear(date);
    return addLeadingZeros(isoWeekYear, token2.length);
  },
  u: function u2(date, token2) {
    var year = date.getUTCFullYear();
    return addLeadingZeros(year, token2.length);
  },
  Q: function Q2(date, token2, localize2) {
    var quarter = Math.ceil((date.getUTCMonth() + 1) / 3);
    switch (token2) {
      case "Q":
        return String(quarter);
      case "QQ":
        return addLeadingZeros(quarter, 2);
      case "Qo":
        return localize2.ordinalNumber(quarter, {
          unit: "quarter"
        });
      case "QQQ":
        return localize2.quarter(quarter, {
          width: "abbreviated",
          context: "formatting"
        });
      case "QQQQQ":
        return localize2.quarter(quarter, {
          width: "narrow",
          context: "formatting"
        });
      case "QQQQ":
      default:
        return localize2.quarter(quarter, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  q: function q2(date, token2, localize2) {
    var quarter = Math.ceil((date.getUTCMonth() + 1) / 3);
    switch (token2) {
      case "q":
        return String(quarter);
      case "qq":
        return addLeadingZeros(quarter, 2);
      case "qo":
        return localize2.ordinalNumber(quarter, {
          unit: "quarter"
        });
      case "qqq":
        return localize2.quarter(quarter, {
          width: "abbreviated",
          context: "standalone"
        });
      case "qqqqq":
        return localize2.quarter(quarter, {
          width: "narrow",
          context: "standalone"
        });
      case "qqqq":
      default:
        return localize2.quarter(quarter, {
          width: "wide",
          context: "standalone"
        });
    }
  },
  M: function M3(date, token2, localize2) {
    var month = date.getUTCMonth();
    switch (token2) {
      case "M":
      case "MM":
        return lightFormatters.M(date, token2);
      case "Mo":
        return localize2.ordinalNumber(month + 1, {
          unit: "month"
        });
      case "MMM":
        return localize2.month(month, {
          width: "abbreviated",
          context: "formatting"
        });
      case "MMMMM":
        return localize2.month(month, {
          width: "narrow",
          context: "formatting"
        });
      case "MMMM":
      default:
        return localize2.month(month, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  L: function L2(date, token2, localize2) {
    var month = date.getUTCMonth();
    switch (token2) {
      case "L":
        return String(month + 1);
      case "LL":
        return addLeadingZeros(month + 1, 2);
      case "Lo":
        return localize2.ordinalNumber(month + 1, {
          unit: "month"
        });
      case "LLL":
        return localize2.month(month, {
          width: "abbreviated",
          context: "standalone"
        });
      case "LLLLL":
        return localize2.month(month, {
          width: "narrow",
          context: "standalone"
        });
      case "LLLL":
      default:
        return localize2.month(month, {
          width: "wide",
          context: "standalone"
        });
    }
  },
  w: function w2(date, token2, localize2, options) {
    var week = getUTCWeek(date, options);
    if (token2 === "wo") {
      return localize2.ordinalNumber(week, {
        unit: "week"
      });
    }
    return addLeadingZeros(week, token2.length);
  },
  I: function I2(date, token2, localize2) {
    var isoWeek = getUTCISOWeek(date);
    if (token2 === "Io") {
      return localize2.ordinalNumber(isoWeek, {
        unit: "week"
      });
    }
    return addLeadingZeros(isoWeek, token2.length);
  },
  d: function d3(date, token2, localize2) {
    if (token2 === "do") {
      return localize2.ordinalNumber(date.getUTCDate(), {
        unit: "date"
      });
    }
    return lightFormatters.d(date, token2);
  },
  D: function D2(date, token2, localize2) {
    var dayOfYear = getUTCDayOfYear(date);
    if (token2 === "Do") {
      return localize2.ordinalNumber(dayOfYear, {
        unit: "dayOfYear"
      });
    }
    return addLeadingZeros(dayOfYear, token2.length);
  },
  E: function E2(date, token2, localize2) {
    var dayOfWeek = date.getUTCDay();
    switch (token2) {
      case "E":
      case "EE":
      case "EEE":
        return localize2.day(dayOfWeek, {
          width: "abbreviated",
          context: "formatting"
        });
      case "EEEEE":
        return localize2.day(dayOfWeek, {
          width: "narrow",
          context: "formatting"
        });
      case "EEEEEE":
        return localize2.day(dayOfWeek, {
          width: "short",
          context: "formatting"
        });
      case "EEEE":
      default:
        return localize2.day(dayOfWeek, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  e: function e2(date, token2, localize2, options) {
    var dayOfWeek = date.getUTCDay();
    var localDayOfWeek = (dayOfWeek - options.weekStartsOn + 8) % 7 || 7;
    switch (token2) {
      case "e":
        return String(localDayOfWeek);
      case "ee":
        return addLeadingZeros(localDayOfWeek, 2);
      case "eo":
        return localize2.ordinalNumber(localDayOfWeek, {
          unit: "day"
        });
      case "eee":
        return localize2.day(dayOfWeek, {
          width: "abbreviated",
          context: "formatting"
        });
      case "eeeee":
        return localize2.day(dayOfWeek, {
          width: "narrow",
          context: "formatting"
        });
      case "eeeeee":
        return localize2.day(dayOfWeek, {
          width: "short",
          context: "formatting"
        });
      case "eeee":
      default:
        return localize2.day(dayOfWeek, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  c: function c2(date, token2, localize2, options) {
    var dayOfWeek = date.getUTCDay();
    var localDayOfWeek = (dayOfWeek - options.weekStartsOn + 8) % 7 || 7;
    switch (token2) {
      case "c":
        return String(localDayOfWeek);
      case "cc":
        return addLeadingZeros(localDayOfWeek, token2.length);
      case "co":
        return localize2.ordinalNumber(localDayOfWeek, {
          unit: "day"
        });
      case "ccc":
        return localize2.day(dayOfWeek, {
          width: "abbreviated",
          context: "standalone"
        });
      case "ccccc":
        return localize2.day(dayOfWeek, {
          width: "narrow",
          context: "standalone"
        });
      case "cccccc":
        return localize2.day(dayOfWeek, {
          width: "short",
          context: "standalone"
        });
      case "cccc":
      default:
        return localize2.day(dayOfWeek, {
          width: "wide",
          context: "standalone"
        });
    }
  },
  i: function i2(date, token2, localize2) {
    var dayOfWeek = date.getUTCDay();
    var isoDayOfWeek = dayOfWeek === 0 ? 7 : dayOfWeek;
    switch (token2) {
      case "i":
        return String(isoDayOfWeek);
      case "ii":
        return addLeadingZeros(isoDayOfWeek, token2.length);
      case "io":
        return localize2.ordinalNumber(isoDayOfWeek, {
          unit: "day"
        });
      case "iii":
        return localize2.day(dayOfWeek, {
          width: "abbreviated",
          context: "formatting"
        });
      case "iiiii":
        return localize2.day(dayOfWeek, {
          width: "narrow",
          context: "formatting"
        });
      case "iiiiii":
        return localize2.day(dayOfWeek, {
          width: "short",
          context: "formatting"
        });
      case "iiii":
      default:
        return localize2.day(dayOfWeek, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  a: function a3(date, token2, localize2) {
    var hours = date.getUTCHours();
    var dayPeriodEnumValue = hours / 12 >= 1 ? "pm" : "am";
    switch (token2) {
      case "a":
      case "aa":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "abbreviated",
          context: "formatting"
        });
      case "aaa":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "abbreviated",
          context: "formatting"
        }).toLowerCase();
      case "aaaaa":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "narrow",
          context: "formatting"
        });
      case "aaaa":
      default:
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  b: function b2(date, token2, localize2) {
    var hours = date.getUTCHours();
    var dayPeriodEnumValue;
    if (hours === 12) {
      dayPeriodEnumValue = dayPeriodEnum.noon;
    } else if (hours === 0) {
      dayPeriodEnumValue = dayPeriodEnum.midnight;
    } else {
      dayPeriodEnumValue = hours / 12 >= 1 ? "pm" : "am";
    }
    switch (token2) {
      case "b":
      case "bb":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "abbreviated",
          context: "formatting"
        });
      case "bbb":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "abbreviated",
          context: "formatting"
        }).toLowerCase();
      case "bbbbb":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "narrow",
          context: "formatting"
        });
      case "bbbb":
      default:
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  B: function B2(date, token2, localize2) {
    var hours = date.getUTCHours();
    var dayPeriodEnumValue;
    if (hours >= 17) {
      dayPeriodEnumValue = dayPeriodEnum.evening;
    } else if (hours >= 12) {
      dayPeriodEnumValue = dayPeriodEnum.afternoon;
    } else if (hours >= 4) {
      dayPeriodEnumValue = dayPeriodEnum.morning;
    } else {
      dayPeriodEnumValue = dayPeriodEnum.night;
    }
    switch (token2) {
      case "B":
      case "BB":
      case "BBB":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "abbreviated",
          context: "formatting"
        });
      case "BBBBB":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "narrow",
          context: "formatting"
        });
      case "BBBB":
      default:
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  h: function h3(date, token2, localize2) {
    if (token2 === "ho") {
      var hours = date.getUTCHours() % 12;
      if (hours === 0)
        hours = 12;
      return localize2.ordinalNumber(hours, {
        unit: "hour"
      });
    }
    return lightFormatters.h(date, token2);
  },
  H: function H3(date, token2, localize2) {
    if (token2 === "Ho") {
      return localize2.ordinalNumber(date.getUTCHours(), {
        unit: "hour"
      });
    }
    return lightFormatters.H(date, token2);
  },
  K: function K2(date, token2, localize2) {
    var hours = date.getUTCHours() % 12;
    if (token2 === "Ko") {
      return localize2.ordinalNumber(hours, {
        unit: "hour"
      });
    }
    return addLeadingZeros(hours, token2.length);
  },
  k: function k2(date, token2, localize2) {
    var hours = date.getUTCHours();
    if (hours === 0)
      hours = 24;
    if (token2 === "ko") {
      return localize2.ordinalNumber(hours, {
        unit: "hour"
      });
    }
    return addLeadingZeros(hours, token2.length);
  },
  m: function m3(date, token2, localize2) {
    if (token2 === "mo") {
      return localize2.ordinalNumber(date.getUTCMinutes(), {
        unit: "minute"
      });
    }
    return lightFormatters.m(date, token2);
  },
  s: function s3(date, token2, localize2) {
    if (token2 === "so") {
      return localize2.ordinalNumber(date.getUTCSeconds(), {
        unit: "second"
      });
    }
    return lightFormatters.s(date, token2);
  },
  S: function S3(date, token2) {
    return lightFormatters.S(date, token2);
  },
  X: function X2(date, token2, _localize, options) {
    var originalDate = options._originalDate || date;
    var timezoneOffset = originalDate.getTimezoneOffset();
    if (timezoneOffset === 0) {
      return "Z";
    }
    switch (token2) {
      case "X":
        return formatTimezoneWithOptionalMinutes(timezoneOffset);
      case "XXXX":
      case "XX":
        return formatTimezone(timezoneOffset);
      case "XXXXX":
      case "XXX":
      default:
        return formatTimezone(timezoneOffset, ":");
    }
  },
  x: function x2(date, token2, _localize, options) {
    var originalDate = options._originalDate || date;
    var timezoneOffset = originalDate.getTimezoneOffset();
    switch (token2) {
      case "x":
        return formatTimezoneWithOptionalMinutes(timezoneOffset);
      case "xxxx":
      case "xx":
        return formatTimezone(timezoneOffset);
      case "xxxxx":
      case "xxx":
      default:
        return formatTimezone(timezoneOffset, ":");
    }
  },
  O: function O2(date, token2, _localize, options) {
    var originalDate = options._originalDate || date;
    var timezoneOffset = originalDate.getTimezoneOffset();
    switch (token2) {
      case "O":
      case "OO":
      case "OOO":
        return "GMT" + formatTimezoneShort(timezoneOffset, ":");
      case "OOOO":
      default:
        return "GMT" + formatTimezone(timezoneOffset, ":");
    }
  },
  z: function z2(date, token2, _localize, options) {
    var originalDate = options._originalDate || date;
    var timezoneOffset = originalDate.getTimezoneOffset();
    switch (token2) {
      case "z":
      case "zz":
      case "zzz":
        return "GMT" + formatTimezoneShort(timezoneOffset, ":");
      case "zzzz":
      default:
        return "GMT" + formatTimezone(timezoneOffset, ":");
    }
  },
  t: function t2(date, token2, _localize, options) {
    var originalDate = options._originalDate || date;
    var timestamp = Math.floor(originalDate.getTime() / 1e3);
    return addLeadingZeros(timestamp, token2.length);
  },
  T: function T2(date, token2, _localize, options) {
    var originalDate = options._originalDate || date;
    var timestamp = originalDate.getTime();
    return addLeadingZeros(timestamp, token2.length);
  }
};
function formatTimezoneShort(offset2, dirtyDelimiter) {
  var sign = offset2 > 0 ? "-" : "+";
  var absOffset = Math.abs(offset2);
  var hours = Math.floor(absOffset / 60);
  var minutes = absOffset % 60;
  if (minutes === 0) {
    return sign + String(hours);
  }
  var delimiter2 = dirtyDelimiter || "";
  return sign + String(hours) + delimiter2 + addLeadingZeros(minutes, 2);
}
function formatTimezoneWithOptionalMinutes(offset2, dirtyDelimiter) {
  if (offset2 % 60 === 0) {
    var sign = offset2 > 0 ? "-" : "+";
    return sign + addLeadingZeros(Math.abs(offset2) / 60, 2);
  }
  return formatTimezone(offset2, dirtyDelimiter);
}
function formatTimezone(offset2, dirtyDelimiter) {
  var delimiter2 = dirtyDelimiter || "";
  var sign = offset2 > 0 ? "-" : "+";
  var absOffset = Math.abs(offset2);
  var hours = addLeadingZeros(Math.floor(absOffset / 60), 2);
  var minutes = addLeadingZeros(absOffset % 60, 2);
  return sign + hours + delimiter2 + minutes;
}
var formatters$1 = formatters;
var dateLongFormatter = function dateLongFormatter2(pattern, formatLong2) {
  switch (pattern) {
    case "P":
      return formatLong2.date({
        width: "short"
      });
    case "PP":
      return formatLong2.date({
        width: "medium"
      });
    case "PPP":
      return formatLong2.date({
        width: "long"
      });
    case "PPPP":
    default:
      return formatLong2.date({
        width: "full"
      });
  }
};
var timeLongFormatter = function timeLongFormatter2(pattern, formatLong2) {
  switch (pattern) {
    case "p":
      return formatLong2.time({
        width: "short"
      });
    case "pp":
      return formatLong2.time({
        width: "medium"
      });
    case "ppp":
      return formatLong2.time({
        width: "long"
      });
    case "pppp":
    default:
      return formatLong2.time({
        width: "full"
      });
  }
};
var dateTimeLongFormatter = function dateTimeLongFormatter2(pattern, formatLong2) {
  var matchResult = pattern.match(/(P+)(p+)?/) || [];
  var datePattern = matchResult[1];
  var timePattern = matchResult[2];
  if (!timePattern) {
    return dateLongFormatter(pattern, formatLong2);
  }
  var dateTimeFormat;
  switch (datePattern) {
    case "P":
      dateTimeFormat = formatLong2.dateTime({
        width: "short"
      });
      break;
    case "PP":
      dateTimeFormat = formatLong2.dateTime({
        width: "medium"
      });
      break;
    case "PPP":
      dateTimeFormat = formatLong2.dateTime({
        width: "long"
      });
      break;
    case "PPPP":
    default:
      dateTimeFormat = formatLong2.dateTime({
        width: "full"
      });
      break;
  }
  return dateTimeFormat.replace("{{date}}", dateLongFormatter(datePattern, formatLong2)).replace("{{time}}", timeLongFormatter(timePattern, formatLong2));
};
var longFormatters = {
  p: timeLongFormatter,
  P: dateTimeLongFormatter
};
var longFormatters$1 = longFormatters;
function getTimezoneOffsetInMilliseconds(date) {
  var utcDate = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds()));
  utcDate.setUTCFullYear(date.getFullYear());
  return date.getTime() - utcDate.getTime();
}
var protectedDayOfYearTokens = ["D", "DD"];
var protectedWeekYearTokens = ["YY", "YYYY"];
function isProtectedDayOfYearToken(token2) {
  return protectedDayOfYearTokens.indexOf(token2) !== -1;
}
function isProtectedWeekYearToken(token2) {
  return protectedWeekYearTokens.indexOf(token2) !== -1;
}
function throwProtectedError(token2, format2, input) {
  if (token2 === "YYYY") {
    throw new RangeError("Use `yyyy` instead of `YYYY` (in `".concat(format2, "`) for formatting years to the input `").concat(input, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
  } else if (token2 === "YY") {
    throw new RangeError("Use `yy` instead of `YY` (in `".concat(format2, "`) for formatting years to the input `").concat(input, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
  } else if (token2 === "D") {
    throw new RangeError("Use `d` instead of `D` (in `".concat(format2, "`) for formatting days of the month to the input `").concat(input, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
  } else if (token2 === "DD") {
    throw new RangeError("Use `dd` instead of `DD` (in `".concat(format2, "`) for formatting days of the month to the input `").concat(input, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
  }
}
var formatDistanceLocale = {
  lessThanXSeconds: {
    one: "less than a second",
    other: "less than {{count}} seconds"
  },
  xSeconds: {
    one: "1 second",
    other: "{{count}} seconds"
  },
  halfAMinute: "half a minute",
  lessThanXMinutes: {
    one: "less than a minute",
    other: "less than {{count}} minutes"
  },
  xMinutes: {
    one: "1 minute",
    other: "{{count}} minutes"
  },
  aboutXHours: {
    one: "about 1 hour",
    other: "about {{count}} hours"
  },
  xHours: {
    one: "1 hour",
    other: "{{count}} hours"
  },
  xDays: {
    one: "1 day",
    other: "{{count}} days"
  },
  aboutXWeeks: {
    one: "about 1 week",
    other: "about {{count}} weeks"
  },
  xWeeks: {
    one: "1 week",
    other: "{{count}} weeks"
  },
  aboutXMonths: {
    one: "about 1 month",
    other: "about {{count}} months"
  },
  xMonths: {
    one: "1 month",
    other: "{{count}} months"
  },
  aboutXYears: {
    one: "about 1 year",
    other: "about {{count}} years"
  },
  xYears: {
    one: "1 year",
    other: "{{count}} years"
  },
  overXYears: {
    one: "over 1 year",
    other: "over {{count}} years"
  },
  almostXYears: {
    one: "almost 1 year",
    other: "almost {{count}} years"
  }
};
var formatDistance = function formatDistance2(token2, count, options) {
  var result;
  var tokenValue = formatDistanceLocale[token2];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace("{{count}}", count.toString());
  }
  if (options !== null && options !== void 0 && options.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return "in " + result;
    } else {
      return result + " ago";
    }
  }
  return result;
};
var formatDistance$1 = formatDistance;
function buildFormatLongFn(args) {
  return function() {
    var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    var width = options.width ? String(options.width) : args.defaultWidth;
    var format2 = args.formats[width] || args.formats[args.defaultWidth];
    return format2;
  };
}
var dateFormats = {
  full: "EEEE, MMMM do, y",
  long: "MMMM do, y",
  medium: "MMM d, y",
  short: "MM/dd/yyyy"
};
var timeFormats = {
  full: "h:mm:ss a zzzz",
  long: "h:mm:ss a z",
  medium: "h:mm:ss a",
  short: "h:mm a"
};
var dateTimeFormats = {
  full: "{{date}} 'at' {{time}}",
  long: "{{date}} 'at' {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}"
};
var formatLong = {
  date: buildFormatLongFn({
    formats: dateFormats,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats,
    defaultWidth: "full"
  })
};
var formatLong$1 = formatLong;
var formatRelativeLocale = {
  lastWeek: "'last' eeee 'at' p",
  yesterday: "'yesterday at' p",
  today: "'today at' p",
  tomorrow: "'tomorrow at' p",
  nextWeek: "eeee 'at' p",
  other: "P"
};
var formatRelative = function formatRelative2(token2, _date, _baseDate, _options) {
  return formatRelativeLocale[token2];
};
var formatRelative$1 = formatRelative;
function buildLocalizeFn(args) {
  return function(dirtyIndex, options) {
    var context = options !== null && options !== void 0 && options.context ? String(options.context) : "standalone";
    var valuesArray;
    if (context === "formatting" && args.formattingValues) {
      var defaultWidth = args.defaultFormattingWidth || args.defaultWidth;
      var width = options !== null && options !== void 0 && options.width ? String(options.width) : defaultWidth;
      valuesArray = args.formattingValues[width] || args.formattingValues[defaultWidth];
    } else {
      var _defaultWidth = args.defaultWidth;
      var _width = options !== null && options !== void 0 && options.width ? String(options.width) : args.defaultWidth;
      valuesArray = args.values[_width] || args.values[_defaultWidth];
    }
    var index2 = args.argumentCallback ? args.argumentCallback(dirtyIndex) : dirtyIndex;
    return valuesArray[index2];
  };
}
var eraValues = {
  narrow: ["B", "A"],
  abbreviated: ["BC", "AD"],
  wide: ["Before Christ", "Anno Domini"]
};
var quarterValues = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["Q1", "Q2", "Q3", "Q4"],
  wide: ["1st quarter", "2nd quarter", "3rd quarter", "4th quarter"]
};
var monthValues = {
  narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
  abbreviated: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
  wide: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"]
};
var dayValues = {
  narrow: ["S", "M", "T", "W", "T", "F", "S"],
  short: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
  abbreviated: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  wide: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"]
};
var dayPeriodValues = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "mi",
    noon: "n",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "midnight",
    noon: "noon",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "midnight",
    noon: "noon",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  }
};
var formattingDayPeriodValues = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "mi",
    noon: "n",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "midnight",
    noon: "noon",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "midnight",
    noon: "noon",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  }
};
var ordinalNumber = function ordinalNumber2(dirtyNumber, _options) {
  var number = Number(dirtyNumber);
  var rem100 = number % 100;
  if (rem100 > 20 || rem100 < 10) {
    switch (rem100 % 10) {
      case 1:
        return number + "st";
      case 2:
        return number + "nd";
      case 3:
        return number + "rd";
    }
  }
  return number + "th";
};
var localize = {
  ordinalNumber,
  era: buildLocalizeFn({
    values: eraValues,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues,
    defaultWidth: "wide",
    argumentCallback: function argumentCallback(quarter) {
      return quarter - 1;
    }
  }),
  month: buildLocalizeFn({
    values: monthValues,
    defaultWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues,
    defaultFormattingWidth: "wide"
  })
};
var localize$1 = localize;
function buildMatchFn(args) {
  return function(string) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var width = options.width;
    var matchPattern = width && args.matchPatterns[width] || args.matchPatterns[args.defaultMatchWidth];
    var matchResult = string.match(matchPattern);
    if (!matchResult) {
      return null;
    }
    var matchedString = matchResult[0];
    var parsePatterns = width && args.parsePatterns[width] || args.parsePatterns[args.defaultParseWidth];
    var key = Array.isArray(parsePatterns) ? findIndex(parsePatterns, function(pattern) {
      return pattern.test(matchedString);
    }) : findKey(parsePatterns, function(pattern) {
      return pattern.test(matchedString);
    });
    var value;
    value = args.valueCallback ? args.valueCallback(key) : key;
    value = options.valueCallback ? options.valueCallback(value) : value;
    var rest = string.slice(matchedString.length);
    return {
      value,
      rest
    };
  };
}
function findKey(object, predicate) {
  for (var key in object) {
    if (object.hasOwnProperty(key) && predicate(object[key])) {
      return key;
    }
  }
  return void 0;
}
function findIndex(array, predicate) {
  for (var key = 0; key < array.length; key++) {
    if (predicate(array[key])) {
      return key;
    }
  }
  return void 0;
}
function buildMatchPatternFn(args) {
  return function(string) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var matchResult = string.match(args.matchPattern);
    if (!matchResult)
      return null;
    var matchedString = matchResult[0];
    var parseResult = string.match(args.parsePattern);
    if (!parseResult)
      return null;
    var value = args.valueCallback ? args.valueCallback(parseResult[0]) : parseResult[0];
    value = options.valueCallback ? options.valueCallback(value) : value;
    var rest = string.slice(matchedString.length);
    return {
      value,
      rest
    };
  };
}
var matchOrdinalNumberPattern = /^(\d+)(th|st|nd|rd)?/i;
var parseOrdinalNumberPattern = /\d+/i;
var matchEraPatterns = {
  narrow: /^(b|a)/i,
  abbreviated: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i,
  wide: /^(before christ|before common era|anno domini|common era)/i
};
var parseEraPatterns = {
  any: [/^b/i, /^(a|c)/i]
};
var matchQuarterPatterns = {
  narrow: /^[1234]/i,
  abbreviated: /^q[1234]/i,
  wide: /^[1234](th|st|nd|rd)? quarter/i
};
var parseQuarterPatterns = {
  any: [/1/i, /2/i, /3/i, /4/i]
};
var matchMonthPatterns = {
  narrow: /^[jfmasond]/i,
  abbreviated: /^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i,
  wide: /^(january|february|march|april|may|june|july|august|september|october|november|december)/i
};
var parseMonthPatterns = {
  narrow: [/^j/i, /^f/i, /^m/i, /^a/i, /^m/i, /^j/i, /^j/i, /^a/i, /^s/i, /^o/i, /^n/i, /^d/i],
  any: [/^ja/i, /^f/i, /^mar/i, /^ap/i, /^may/i, /^jun/i, /^jul/i, /^au/i, /^s/i, /^o/i, /^n/i, /^d/i]
};
var matchDayPatterns = {
  narrow: /^[smtwf]/i,
  short: /^(su|mo|tu|we|th|fr|sa)/i,
  abbreviated: /^(sun|mon|tue|wed|thu|fri|sat)/i,
  wide: /^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i
};
var parseDayPatterns = {
  narrow: [/^s/i, /^m/i, /^t/i, /^w/i, /^t/i, /^f/i, /^s/i],
  any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i]
};
var matchDayPeriodPatterns = {
  narrow: /^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i,
  any: /^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i
};
var parseDayPeriodPatterns = {
  any: {
    am: /^a/i,
    pm: /^p/i,
    midnight: /^mi/i,
    noon: /^no/i,
    morning: /morning/i,
    afternoon: /afternoon/i,
    evening: /evening/i,
    night: /night/i
  }
};
var match = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern,
    parsePattern: parseOrdinalNumberPattern,
    valueCallback: function valueCallback(value) {
      return parseInt(value, 10);
    }
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns,
    defaultParseWidth: "any",
    valueCallback: function valueCallback2(index2) {
      return index2 + 1;
    }
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns,
    defaultParseWidth: "any"
  })
};
var match$1 = match;
var locale = {
  code: "en-US",
  formatDistance: formatDistance$1,
  formatLong: formatLong$1,
  formatRelative: formatRelative$1,
  localize: localize$1,
  match: match$1,
  options: {
    weekStartsOn: 0,
    firstWeekContainsDate: 1
  }
};
var defaultLocale = locale;
var formattingTokensRegExp$1 = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g;
var longFormattingTokensRegExp$1 = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g;
var escapedStringRegExp$1 = /^'([^]*?)'?$/;
var doubleQuoteRegExp$1 = /''/g;
var unescapedLatinCharacterRegExp$1 = /[a-zA-Z]/;
function format(dirtyDate, dirtyFormatStr, options) {
  var _ref2, _options$locale, _ref22, _ref3, _ref4, _options$firstWeekCon, _options$locale2, _options$locale2$opti, _defaultOptions$local, _defaultOptions$local2, _ref5, _ref6, _ref7, _options$weekStartsOn, _options$locale3, _options$locale3$opti, _defaultOptions$local3, _defaultOptions$local4;
  requiredArgs(2, arguments);
  var formatStr = String(dirtyFormatStr);
  var defaultOptions2 = getDefaultOptions();
  var locale2 = (_ref2 = (_options$locale = options === null || options === void 0 ? void 0 : options.locale) !== null && _options$locale !== void 0 ? _options$locale : defaultOptions2.locale) !== null && _ref2 !== void 0 ? _ref2 : defaultLocale;
  var firstWeekContainsDate = toInteger((_ref22 = (_ref3 = (_ref4 = (_options$firstWeekCon = options === null || options === void 0 ? void 0 : options.firstWeekContainsDate) !== null && _options$firstWeekCon !== void 0 ? _options$firstWeekCon : options === null || options === void 0 ? void 0 : (_options$locale2 = options.locale) === null || _options$locale2 === void 0 ? void 0 : (_options$locale2$opti = _options$locale2.options) === null || _options$locale2$opti === void 0 ? void 0 : _options$locale2$opti.firstWeekContainsDate) !== null && _ref4 !== void 0 ? _ref4 : defaultOptions2.firstWeekContainsDate) !== null && _ref3 !== void 0 ? _ref3 : (_defaultOptions$local = defaultOptions2.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.firstWeekContainsDate) !== null && _ref22 !== void 0 ? _ref22 : 1);
  if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7)) {
    throw new RangeError("firstWeekContainsDate must be between 1 and 7 inclusively");
  }
  var weekStartsOn = toInteger((_ref5 = (_ref6 = (_ref7 = (_options$weekStartsOn = options === null || options === void 0 ? void 0 : options.weekStartsOn) !== null && _options$weekStartsOn !== void 0 ? _options$weekStartsOn : options === null || options === void 0 ? void 0 : (_options$locale3 = options.locale) === null || _options$locale3 === void 0 ? void 0 : (_options$locale3$opti = _options$locale3.options) === null || _options$locale3$opti === void 0 ? void 0 : _options$locale3$opti.weekStartsOn) !== null && _ref7 !== void 0 ? _ref7 : defaultOptions2.weekStartsOn) !== null && _ref6 !== void 0 ? _ref6 : (_defaultOptions$local3 = defaultOptions2.locale) === null || _defaultOptions$local3 === void 0 ? void 0 : (_defaultOptions$local4 = _defaultOptions$local3.options) === null || _defaultOptions$local4 === void 0 ? void 0 : _defaultOptions$local4.weekStartsOn) !== null && _ref5 !== void 0 ? _ref5 : 0);
  if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
    throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
  }
  if (!locale2.localize) {
    throw new RangeError("locale must contain localize property");
  }
  if (!locale2.formatLong) {
    throw new RangeError("locale must contain formatLong property");
  }
  var originalDate = toDate(dirtyDate);
  if (!isValid(originalDate)) {
    throw new RangeError("Invalid time value");
  }
  var timezoneOffset = getTimezoneOffsetInMilliseconds(originalDate);
  var utcDate = subMilliseconds(originalDate, timezoneOffset);
  var formatterOptions = {
    firstWeekContainsDate,
    weekStartsOn,
    locale: locale2,
    _originalDate: originalDate
  };
  var result = formatStr.match(longFormattingTokensRegExp$1).map(function(substring) {
    var firstCharacter = substring[0];
    if (firstCharacter === "p" || firstCharacter === "P") {
      var longFormatter = longFormatters$1[firstCharacter];
      return longFormatter(substring, locale2.formatLong);
    }
    return substring;
  }).join("").match(formattingTokensRegExp$1).map(function(substring) {
    if (substring === "''") {
      return "'";
    }
    var firstCharacter = substring[0];
    if (firstCharacter === "'") {
      return cleanEscapedString$1(substring);
    }
    var formatter = formatters$1[firstCharacter];
    if (formatter) {
      if (!(options !== null && options !== void 0 && options.useAdditionalWeekYearTokens) && isProtectedWeekYearToken(substring)) {
        throwProtectedError(substring, dirtyFormatStr, String(dirtyDate));
      }
      if (!(options !== null && options !== void 0 && options.useAdditionalDayOfYearTokens) && isProtectedDayOfYearToken(substring)) {
        throwProtectedError(substring, dirtyFormatStr, String(dirtyDate));
      }
      return formatter(utcDate, substring, locale2.localize, formatterOptions);
    }
    if (firstCharacter.match(unescapedLatinCharacterRegExp$1)) {
      throw new RangeError("Format string contains an unescaped latin alphabet character `" + firstCharacter + "`");
    }
    return substring;
  }).join("");
  return result;
}
function cleanEscapedString$1(input) {
  var matched = input.match(escapedStringRegExp$1);
  if (!matched) {
    return input;
  }
  return matched[1].replace(doubleQuoteRegExp$1, "'");
}
var MILLISECONDS_IN_MINUTE = 6e4;
function addMinutes(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var amount = toInteger(dirtyAmount);
  return addMilliseconds(dirtyDate, amount * MILLISECONDS_IN_MINUTE);
}
var MILLISECONDS_IN_HOUR = 36e5;
function addHours(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var amount = toInteger(dirtyAmount);
  return addMilliseconds(dirtyDate, amount * MILLISECONDS_IN_HOUR);
}
function addDays(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var date = toDate(dirtyDate);
  var amount = toInteger(dirtyAmount);
  if (isNaN(amount)) {
    return new Date(NaN);
  }
  if (!amount) {
    return date;
  }
  date.setDate(date.getDate() + amount);
  return date;
}
function addWeeks(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var amount = toInteger(dirtyAmount);
  var days = amount * 7;
  return addDays(dirtyDate, days);
}
function addMonths(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var date = toDate(dirtyDate);
  var amount = toInteger(dirtyAmount);
  if (isNaN(amount)) {
    return new Date(NaN);
  }
  if (!amount) {
    return date;
  }
  var dayOfMonth = date.getDate();
  var endOfDesiredMonth = new Date(date.getTime());
  endOfDesiredMonth.setMonth(date.getMonth() + amount + 1, 0);
  var daysInMonth = endOfDesiredMonth.getDate();
  if (dayOfMonth >= daysInMonth) {
    return endOfDesiredMonth;
  } else {
    date.setFullYear(endOfDesiredMonth.getFullYear(), endOfDesiredMonth.getMonth(), dayOfMonth);
    return date;
  }
}
function addQuarters(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var amount = toInteger(dirtyAmount);
  var months = amount * 3;
  return addMonths(dirtyDate, months);
}
function addYears(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var amount = toInteger(dirtyAmount);
  return addMonths(dirtyDate, amount * 12);
}
function subDays(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var amount = toInteger(dirtyAmount);
  return addDays(dirtyDate, -amount);
}
function subWeeks(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var amount = toInteger(dirtyAmount);
  return addWeeks(dirtyDate, -amount);
}
function subMonths(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var amount = toInteger(dirtyAmount);
  return addMonths(dirtyDate, -amount);
}
function subQuarters(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var amount = toInteger(dirtyAmount);
  return addQuarters(dirtyDate, -amount);
}
function subYears(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var amount = toInteger(dirtyAmount);
  return addYears(dirtyDate, -amount);
}
function getSeconds(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var seconds = date.getSeconds();
  return seconds;
}
function getMinutes(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var minutes = date.getMinutes();
  return minutes;
}
function getHours(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var hours = date.getHours();
  return hours;
}
function getDay(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var day = date.getDay();
  return day;
}
function getDate(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var dayOfMonth = date.getDate();
  return dayOfMonth;
}
function startOfWeek(dirtyDate, options) {
  var _ref2, _ref22, _ref3, _options$weekStartsOn, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
  requiredArgs(1, arguments);
  var defaultOptions2 = getDefaultOptions();
  var weekStartsOn = toInteger((_ref2 = (_ref22 = (_ref3 = (_options$weekStartsOn = options === null || options === void 0 ? void 0 : options.weekStartsOn) !== null && _options$weekStartsOn !== void 0 ? _options$weekStartsOn : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.weekStartsOn) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions2.weekStartsOn) !== null && _ref22 !== void 0 ? _ref22 : (_defaultOptions$local = defaultOptions2.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.weekStartsOn) !== null && _ref2 !== void 0 ? _ref2 : 0);
  if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
    throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
  }
  var date = toDate(dirtyDate);
  var day = date.getDay();
  var diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
  date.setDate(date.getDate() - diff);
  date.setHours(0, 0, 0, 0);
  return date;
}
function startOfISOWeek(dirtyDate) {
  requiredArgs(1, arguments);
  return startOfWeek(dirtyDate, {
    weekStartsOn: 1
  });
}
function getISOWeekYear(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var year = date.getFullYear();
  var fourthOfJanuaryOfNextYear = new Date(0);
  fourthOfJanuaryOfNextYear.setFullYear(year + 1, 0, 4);
  fourthOfJanuaryOfNextYear.setHours(0, 0, 0, 0);
  var startOfNextYear = startOfISOWeek(fourthOfJanuaryOfNextYear);
  var fourthOfJanuaryOfThisYear = new Date(0);
  fourthOfJanuaryOfThisYear.setFullYear(year, 0, 4);
  fourthOfJanuaryOfThisYear.setHours(0, 0, 0, 0);
  var startOfThisYear = startOfISOWeek(fourthOfJanuaryOfThisYear);
  if (date.getTime() >= startOfNextYear.getTime()) {
    return year + 1;
  } else if (date.getTime() >= startOfThisYear.getTime()) {
    return year;
  } else {
    return year - 1;
  }
}
function startOfISOWeekYear(dirtyDate) {
  requiredArgs(1, arguments);
  var year = getISOWeekYear(dirtyDate);
  var fourthOfJanuary = new Date(0);
  fourthOfJanuary.setFullYear(year, 0, 4);
  fourthOfJanuary.setHours(0, 0, 0, 0);
  var date = startOfISOWeek(fourthOfJanuary);
  return date;
}
var MILLISECONDS_IN_WEEK = 6048e5;
function getISOWeek(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var diff = startOfISOWeek(date).getTime() - startOfISOWeekYear(date).getTime();
  return Math.round(diff / MILLISECONDS_IN_WEEK) + 1;
}
function getMonth(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var month = date.getMonth();
  return month;
}
function getQuarter(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var quarter = Math.floor(date.getMonth() / 3) + 1;
  return quarter;
}
function getYear(dirtyDate) {
  requiredArgs(1, arguments);
  return toDate(dirtyDate).getFullYear();
}
function getTime(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var timestamp = date.getTime();
  return timestamp;
}
function setSeconds(dirtyDate, dirtySeconds) {
  requiredArgs(2, arguments);
  var date = toDate(dirtyDate);
  var seconds = toInteger(dirtySeconds);
  date.setSeconds(seconds);
  return date;
}
function setMinutes(dirtyDate, dirtyMinutes) {
  requiredArgs(2, arguments);
  var date = toDate(dirtyDate);
  var minutes = toInteger(dirtyMinutes);
  date.setMinutes(minutes);
  return date;
}
function setHours(dirtyDate, dirtyHours) {
  requiredArgs(2, arguments);
  var date = toDate(dirtyDate);
  var hours = toInteger(dirtyHours);
  date.setHours(hours);
  return date;
}
function getDaysInMonth(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var year = date.getFullYear();
  var monthIndex = date.getMonth();
  var lastDayOfMonth = new Date(0);
  lastDayOfMonth.setFullYear(year, monthIndex + 1, 0);
  lastDayOfMonth.setHours(0, 0, 0, 0);
  return lastDayOfMonth.getDate();
}
function setMonth(dirtyDate, dirtyMonth) {
  requiredArgs(2, arguments);
  var date = toDate(dirtyDate);
  var month = toInteger(dirtyMonth);
  var year = date.getFullYear();
  var day = date.getDate();
  var dateWithDesiredMonth = new Date(0);
  dateWithDesiredMonth.setFullYear(year, month, 15);
  dateWithDesiredMonth.setHours(0, 0, 0, 0);
  var daysInMonth = getDaysInMonth(dateWithDesiredMonth);
  date.setMonth(month, Math.min(day, daysInMonth));
  return date;
}
function setQuarter(dirtyDate, dirtyQuarter) {
  requiredArgs(2, arguments);
  var date = toDate(dirtyDate);
  var quarter = toInteger(dirtyQuarter);
  var oldQuarter = Math.floor(date.getMonth() / 3) + 1;
  var diff = quarter - oldQuarter;
  return setMonth(date, date.getMonth() + diff * 3);
}
function setYear(dirtyDate, dirtyYear) {
  requiredArgs(2, arguments);
  var date = toDate(dirtyDate);
  var year = toInteger(dirtyYear);
  if (isNaN(date.getTime())) {
    return new Date(NaN);
  }
  date.setFullYear(year);
  return date;
}
function _typeof$z(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$z = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$z = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$z(obj);
}
function min(dirtyDatesArray) {
  requiredArgs(1, arguments);
  var datesArray;
  if (dirtyDatesArray && typeof dirtyDatesArray.forEach === "function") {
    datesArray = dirtyDatesArray;
  } else if (_typeof$z(dirtyDatesArray) === "object" && dirtyDatesArray !== null) {
    datesArray = Array.prototype.slice.call(dirtyDatesArray);
  } else {
    return new Date(NaN);
  }
  var result;
  datesArray.forEach(function(dirtyDate) {
    var currentDate = toDate(dirtyDate);
    if (result === void 0 || result > currentDate || isNaN(currentDate.getDate())) {
      result = currentDate;
    }
  });
  return result || new Date(NaN);
}
function _typeof$y(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$y = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$y = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$y(obj);
}
function max(dirtyDatesArray) {
  requiredArgs(1, arguments);
  var datesArray;
  if (dirtyDatesArray && typeof dirtyDatesArray.forEach === "function") {
    datesArray = dirtyDatesArray;
  } else if (_typeof$y(dirtyDatesArray) === "object" && dirtyDatesArray !== null) {
    datesArray = Array.prototype.slice.call(dirtyDatesArray);
  } else {
    return new Date(NaN);
  }
  var result;
  datesArray.forEach(function(dirtyDate) {
    var currentDate = toDate(dirtyDate);
    if (result === void 0 || result < currentDate || isNaN(Number(currentDate))) {
      result = currentDate;
    }
  });
  return result || new Date(NaN);
}
function startOfDay(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  date.setHours(0, 0, 0, 0);
  return date;
}
var MILLISECONDS_IN_DAY = 864e5;
function differenceInCalendarDays(dirtyDateLeft, dirtyDateRight) {
  requiredArgs(2, arguments);
  var startOfDayLeft = startOfDay(dirtyDateLeft);
  var startOfDayRight = startOfDay(dirtyDateRight);
  var timestampLeft = startOfDayLeft.getTime() - getTimezoneOffsetInMilliseconds(startOfDayLeft);
  var timestampRight = startOfDayRight.getTime() - getTimezoneOffsetInMilliseconds(startOfDayRight);
  return Math.round((timestampLeft - timestampRight) / MILLISECONDS_IN_DAY);
}
function differenceInCalendarMonths(dirtyDateLeft, dirtyDateRight) {
  requiredArgs(2, arguments);
  var dateLeft = toDate(dirtyDateLeft);
  var dateRight = toDate(dirtyDateRight);
  var yearDiff = dateLeft.getFullYear() - dateRight.getFullYear();
  var monthDiff = dateLeft.getMonth() - dateRight.getMonth();
  return yearDiff * 12 + monthDiff;
}
function differenceInCalendarYears(dirtyDateLeft, dirtyDateRight) {
  requiredArgs(2, arguments);
  var dateLeft = toDate(dirtyDateLeft);
  var dateRight = toDate(dirtyDateRight);
  return dateLeft.getFullYear() - dateRight.getFullYear();
}
function startOfMonth(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  date.setDate(1);
  date.setHours(0, 0, 0, 0);
  return date;
}
function startOfQuarter(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var currentMonth = date.getMonth();
  var month = currentMonth - currentMonth % 3;
  date.setMonth(month, 1);
  date.setHours(0, 0, 0, 0);
  return date;
}
function startOfYear(dirtyDate) {
  requiredArgs(1, arguments);
  var cleanDate = toDate(dirtyDate);
  var date = new Date(0);
  date.setFullYear(cleanDate.getFullYear(), 0, 1);
  date.setHours(0, 0, 0, 0);
  return date;
}
function endOfDay(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  date.setHours(23, 59, 59, 999);
  return date;
}
function endOfMonth(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var month = date.getMonth();
  date.setFullYear(date.getFullYear(), month + 1, 0);
  date.setHours(23, 59, 59, 999);
  return date;
}
function endOfYear(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var year = date.getFullYear();
  date.setFullYear(year + 1, 0, 0);
  date.setHours(23, 59, 59, 999);
  return date;
}
function isEqual(dirtyLeftDate, dirtyRightDate) {
  requiredArgs(2, arguments);
  var dateLeft = toDate(dirtyLeftDate);
  var dateRight = toDate(dirtyRightDate);
  return dateLeft.getTime() === dateRight.getTime();
}
function isSameDay(dirtyDateLeft, dirtyDateRight) {
  requiredArgs(2, arguments);
  var dateLeftStartOfDay = startOfDay(dirtyDateLeft);
  var dateRightStartOfDay = startOfDay(dirtyDateRight);
  return dateLeftStartOfDay.getTime() === dateRightStartOfDay.getTime();
}
function isSameMonth(dirtyDateLeft, dirtyDateRight) {
  requiredArgs(2, arguments);
  var dateLeft = toDate(dirtyDateLeft);
  var dateRight = toDate(dirtyDateRight);
  return dateLeft.getFullYear() === dateRight.getFullYear() && dateLeft.getMonth() === dateRight.getMonth();
}
function isSameYear(dirtyDateLeft, dirtyDateRight) {
  requiredArgs(2, arguments);
  var dateLeft = toDate(dirtyDateLeft);
  var dateRight = toDate(dirtyDateRight);
  return dateLeft.getFullYear() === dateRight.getFullYear();
}
function isSameQuarter(dirtyDateLeft, dirtyDateRight) {
  requiredArgs(2, arguments);
  var dateLeftStartOfQuarter = startOfQuarter(dirtyDateLeft);
  var dateRightStartOfQuarter = startOfQuarter(dirtyDateRight);
  return dateLeftStartOfQuarter.getTime() === dateRightStartOfQuarter.getTime();
}
function isAfter(dirtyDate, dirtyDateToCompare) {
  requiredArgs(2, arguments);
  var date = toDate(dirtyDate);
  var dateToCompare = toDate(dirtyDateToCompare);
  return date.getTime() > dateToCompare.getTime();
}
function isBefore(dirtyDate, dirtyDateToCompare) {
  requiredArgs(2, arguments);
  var date = toDate(dirtyDate);
  var dateToCompare = toDate(dirtyDateToCompare);
  return date.getTime() < dateToCompare.getTime();
}
function isWithinInterval(dirtyDate, interval) {
  requiredArgs(2, arguments);
  var time = toDate(dirtyDate).getTime();
  var startTime = toDate(interval.start).getTime();
  var endTime = toDate(interval.end).getTime();
  if (!(startTime <= endTime)) {
    throw new RangeError("Invalid interval");
  }
  return time >= startTime && time <= endTime;
}
function assign(target, object) {
  if (target == null) {
    throw new TypeError("assign requires that input parameter not be null or undefined");
  }
  for (var property in object) {
    if (Object.prototype.hasOwnProperty.call(object, property)) {
      target[property] = object[property];
    }
  }
  return target;
}
function _typeof$x(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$x = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$x = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$x(obj);
}
function _inherits$v(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  if (superClass)
    _setPrototypeOf$w(subClass, superClass);
}
function _setPrototypeOf$w(o2, p2) {
  _setPrototypeOf$w = Object.setPrototypeOf || function _setPrototypeOf2(o3, p3) {
    o3.__proto__ = p3;
    return o3;
  };
  return _setPrototypeOf$w(o2, p2);
}
function _createSuper$v(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$v();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$v(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$v(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$v(this, result);
  };
}
function _possibleConstructorReturn$v(self2, call) {
  if (call && (_typeof$x(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$w(self2);
}
function _assertThisInitialized$w(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$v() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e3) {
    return false;
  }
}
function _getPrototypeOf$v(o2) {
  _getPrototypeOf$v = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o3) {
    return o3.__proto__ || Object.getPrototypeOf(o3);
  };
  return _getPrototypeOf$v(o2);
}
function _classCallCheck$w(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$w(target, props) {
  for (var i3 = 0; i3 < props.length; i3++) {
    var descriptor = props[i3];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$w(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$w(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$w(Constructor, staticProps);
  return Constructor;
}
function _defineProperty$v(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var TIMEZONE_UNIT_PRIORITY = 10;
var Setter = /* @__PURE__ */ function() {
  function Setter2() {
    _classCallCheck$w(this, Setter2);
    _defineProperty$v(this, "subPriority", 0);
  }
  _createClass$w(Setter2, [{
    key: "validate",
    value: function validate(_utcDate, _options) {
      return true;
    }
  }]);
  return Setter2;
}();
var ValueSetter = /* @__PURE__ */ function(_Setter) {
  _inherits$v(ValueSetter2, _Setter);
  var _super = _createSuper$v(ValueSetter2);
  function ValueSetter2(value, validateValue, setValue, priority, subPriority) {
    var _this;
    _classCallCheck$w(this, ValueSetter2);
    _this = _super.call(this);
    _this.value = value;
    _this.validateValue = validateValue;
    _this.setValue = setValue;
    _this.priority = priority;
    if (subPriority) {
      _this.subPriority = subPriority;
    }
    return _this;
  }
  _createClass$w(ValueSetter2, [{
    key: "validate",
    value: function validate(utcDate, options) {
      return this.validateValue(utcDate, this.value, options);
    }
  }, {
    key: "set",
    value: function set2(utcDate, flags, options) {
      return this.setValue(utcDate, flags, this.value, options);
    }
  }]);
  return ValueSetter2;
}(Setter);
var DateToSystemTimezoneSetter = /* @__PURE__ */ function(_Setter2) {
  _inherits$v(DateToSystemTimezoneSetter2, _Setter2);
  var _super2 = _createSuper$v(DateToSystemTimezoneSetter2);
  function DateToSystemTimezoneSetter2() {
    var _this2;
    _classCallCheck$w(this, DateToSystemTimezoneSetter2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this2 = _super2.call.apply(_super2, [this].concat(args));
    _defineProperty$v(_assertThisInitialized$w(_this2), "priority", TIMEZONE_UNIT_PRIORITY);
    _defineProperty$v(_assertThisInitialized$w(_this2), "subPriority", -1);
    return _this2;
  }
  _createClass$w(DateToSystemTimezoneSetter2, [{
    key: "set",
    value: function set2(date, flags) {
      if (flags.timestampIsSet) {
        return date;
      }
      var convertedDate = new Date(0);
      convertedDate.setFullYear(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate());
      convertedDate.setHours(date.getUTCHours(), date.getUTCMinutes(), date.getUTCSeconds(), date.getUTCMilliseconds());
      return convertedDate;
    }
  }]);
  return DateToSystemTimezoneSetter2;
}(Setter);
function _classCallCheck$v(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$v(target, props) {
  for (var i3 = 0; i3 < props.length; i3++) {
    var descriptor = props[i3];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$v(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$v(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$v(Constructor, staticProps);
  return Constructor;
}
var Parser = /* @__PURE__ */ function() {
  function Parser2() {
    _classCallCheck$v(this, Parser2);
  }
  _createClass$v(Parser2, [{
    key: "run",
    value: function run2(dateString, token2, match2, options) {
      var result = this.parse(dateString, token2, match2, options);
      if (!result) {
        return null;
      }
      return {
        setter: new ValueSetter(result.value, this.validate, this.set, this.priority, this.subPriority),
        rest: result.rest
      };
    }
  }, {
    key: "validate",
    value: function validate(_utcDate, _value, _options) {
      return true;
    }
  }]);
  return Parser2;
}();
function _typeof$w(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$w = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$w = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$w(obj);
}
function _classCallCheck$u(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$u(target, props) {
  for (var i3 = 0; i3 < props.length; i3++) {
    var descriptor = props[i3];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$u(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$u(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$u(Constructor, staticProps);
  return Constructor;
}
function _inherits$u(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  if (superClass)
    _setPrototypeOf$v(subClass, superClass);
}
function _setPrototypeOf$v(o2, p2) {
  _setPrototypeOf$v = Object.setPrototypeOf || function _setPrototypeOf2(o3, p3) {
    o3.__proto__ = p3;
    return o3;
  };
  return _setPrototypeOf$v(o2, p2);
}
function _createSuper$u(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$u();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$u(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$u(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$u(this, result);
  };
}
function _possibleConstructorReturn$u(self2, call) {
  if (call && (_typeof$w(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$v(self2);
}
function _assertThisInitialized$v(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$u() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e3) {
    return false;
  }
}
function _getPrototypeOf$u(o2) {
  _getPrototypeOf$u = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o3) {
    return o3.__proto__ || Object.getPrototypeOf(o3);
  };
  return _getPrototypeOf$u(o2);
}
function _defineProperty$u(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var EraParser = /* @__PURE__ */ function(_Parser) {
  _inherits$u(EraParser2, _Parser);
  var _super = _createSuper$u(EraParser2);
  function EraParser2() {
    var _this;
    _classCallCheck$u(this, EraParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty$u(_assertThisInitialized$v(_this), "priority", 140);
    _defineProperty$u(_assertThisInitialized$v(_this), "incompatibleTokens", ["R", "u", "t", "T"]);
    return _this;
  }
  _createClass$u(EraParser2, [{
    key: "parse",
    value: function parse2(dateString, token2, match2) {
      switch (token2) {
        case "G":
        case "GG":
        case "GGG":
          return match2.era(dateString, {
            width: "abbreviated"
          }) || match2.era(dateString, {
            width: "narrow"
          });
        case "GGGGG":
          return match2.era(dateString, {
            width: "narrow"
          });
        case "GGGG":
        default:
          return match2.era(dateString, {
            width: "wide"
          }) || match2.era(dateString, {
            width: "abbreviated"
          }) || match2.era(dateString, {
            width: "narrow"
          });
      }
    }
  }, {
    key: "set",
    value: function set2(date, flags, value) {
      flags.era = value;
      date.setUTCFullYear(value, 0, 1);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);
  return EraParser2;
}(Parser);
var millisecondsInMinute = 6e4;
var millisecondsInHour = 36e5;
var millisecondsInSecond = 1e3;
var numericPatterns = {
  month: /^(1[0-2]|0?\d)/,
  date: /^(3[0-1]|[0-2]?\d)/,
  dayOfYear: /^(36[0-6]|3[0-5]\d|[0-2]?\d?\d)/,
  week: /^(5[0-3]|[0-4]?\d)/,
  hour23h: /^(2[0-3]|[0-1]?\d)/,
  hour24h: /^(2[0-4]|[0-1]?\d)/,
  hour11h: /^(1[0-1]|0?\d)/,
  hour12h: /^(1[0-2]|0?\d)/,
  minute: /^[0-5]?\d/,
  second: /^[0-5]?\d/,
  singleDigit: /^\d/,
  twoDigits: /^\d{1,2}/,
  threeDigits: /^\d{1,3}/,
  fourDigits: /^\d{1,4}/,
  anyDigitsSigned: /^-?\d+/,
  singleDigitSigned: /^-?\d/,
  twoDigitsSigned: /^-?\d{1,2}/,
  threeDigitsSigned: /^-?\d{1,3}/,
  fourDigitsSigned: /^-?\d{1,4}/
};
var timezonePatterns = {
  basicOptionalMinutes: /^([+-])(\d{2})(\d{2})?|Z/,
  basic: /^([+-])(\d{2})(\d{2})|Z/,
  basicOptionalSeconds: /^([+-])(\d{2})(\d{2})((\d{2}))?|Z/,
  extended: /^([+-])(\d{2}):(\d{2})|Z/,
  extendedOptionalSeconds: /^([+-])(\d{2}):(\d{2})(:(\d{2}))?|Z/
};
function mapValue(parseFnResult, mapFn) {
  if (!parseFnResult) {
    return parseFnResult;
  }
  return {
    value: mapFn(parseFnResult.value),
    rest: parseFnResult.rest
  };
}
function parseNumericPattern(pattern, dateString) {
  var matchResult = dateString.match(pattern);
  if (!matchResult) {
    return null;
  }
  return {
    value: parseInt(matchResult[0], 10),
    rest: dateString.slice(matchResult[0].length)
  };
}
function parseTimezonePattern(pattern, dateString) {
  var matchResult = dateString.match(pattern);
  if (!matchResult) {
    return null;
  }
  if (matchResult[0] === "Z") {
    return {
      value: 0,
      rest: dateString.slice(1)
    };
  }
  var sign = matchResult[1] === "+" ? 1 : -1;
  var hours = matchResult[2] ? parseInt(matchResult[2], 10) : 0;
  var minutes = matchResult[3] ? parseInt(matchResult[3], 10) : 0;
  var seconds = matchResult[5] ? parseInt(matchResult[5], 10) : 0;
  return {
    value: sign * (hours * millisecondsInHour + minutes * millisecondsInMinute + seconds * millisecondsInSecond),
    rest: dateString.slice(matchResult[0].length)
  };
}
function parseAnyDigitsSigned(dateString) {
  return parseNumericPattern(numericPatterns.anyDigitsSigned, dateString);
}
function parseNDigits(n2, dateString) {
  switch (n2) {
    case 1:
      return parseNumericPattern(numericPatterns.singleDigit, dateString);
    case 2:
      return parseNumericPattern(numericPatterns.twoDigits, dateString);
    case 3:
      return parseNumericPattern(numericPatterns.threeDigits, dateString);
    case 4:
      return parseNumericPattern(numericPatterns.fourDigits, dateString);
    default:
      return parseNumericPattern(new RegExp("^\\d{1," + n2 + "}"), dateString);
  }
}
function parseNDigitsSigned(n2, dateString) {
  switch (n2) {
    case 1:
      return parseNumericPattern(numericPatterns.singleDigitSigned, dateString);
    case 2:
      return parseNumericPattern(numericPatterns.twoDigitsSigned, dateString);
    case 3:
      return parseNumericPattern(numericPatterns.threeDigitsSigned, dateString);
    case 4:
      return parseNumericPattern(numericPatterns.fourDigitsSigned, dateString);
    default:
      return parseNumericPattern(new RegExp("^-?\\d{1," + n2 + "}"), dateString);
  }
}
function dayPeriodEnumToHours(dayPeriod) {
  switch (dayPeriod) {
    case "morning":
      return 4;
    case "evening":
      return 17;
    case "pm":
    case "noon":
    case "afternoon":
      return 12;
    case "am":
    case "midnight":
    case "night":
    default:
      return 0;
  }
}
function normalizeTwoDigitYear(twoDigitYear, currentYear) {
  var isCommonEra = currentYear > 0;
  var absCurrentYear = isCommonEra ? currentYear : 1 - currentYear;
  var result;
  if (absCurrentYear <= 50) {
    result = twoDigitYear || 100;
  } else {
    var rangeEnd = absCurrentYear + 50;
    var rangeEndCentury = Math.floor(rangeEnd / 100) * 100;
    var isPreviousCentury = twoDigitYear >= rangeEnd % 100;
    result = twoDigitYear + rangeEndCentury - (isPreviousCentury ? 100 : 0);
  }
  return isCommonEra ? result : 1 - result;
}
function isLeapYearIndex$1(year) {
  return year % 400 === 0 || year % 4 === 0 && year % 100 !== 0;
}
function _typeof$v(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$v = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$v = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$v(obj);
}
function _classCallCheck$t(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$t(target, props) {
  for (var i3 = 0; i3 < props.length; i3++) {
    var descriptor = props[i3];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$t(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$t(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$t(Constructor, staticProps);
  return Constructor;
}
function _inherits$t(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  if (superClass)
    _setPrototypeOf$u(subClass, superClass);
}
function _setPrototypeOf$u(o2, p2) {
  _setPrototypeOf$u = Object.setPrototypeOf || function _setPrototypeOf2(o3, p3) {
    o3.__proto__ = p3;
    return o3;
  };
  return _setPrototypeOf$u(o2, p2);
}
function _createSuper$t(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$t();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$t(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$t(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$t(this, result);
  };
}
function _possibleConstructorReturn$t(self2, call) {
  if (call && (_typeof$v(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$u(self2);
}
function _assertThisInitialized$u(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$t() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e3) {
    return false;
  }
}
function _getPrototypeOf$t(o2) {
  _getPrototypeOf$t = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o3) {
    return o3.__proto__ || Object.getPrototypeOf(o3);
  };
  return _getPrototypeOf$t(o2);
}
function _defineProperty$t(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var YearParser = /* @__PURE__ */ function(_Parser) {
  _inherits$t(YearParser2, _Parser);
  var _super = _createSuper$t(YearParser2);
  function YearParser2() {
    var _this;
    _classCallCheck$t(this, YearParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty$t(_assertThisInitialized$u(_this), "priority", 130);
    _defineProperty$t(_assertThisInitialized$u(_this), "incompatibleTokens", ["Y", "R", "u", "w", "I", "i", "e", "c", "t", "T"]);
    return _this;
  }
  _createClass$t(YearParser2, [{
    key: "parse",
    value: function parse2(dateString, token2, match2) {
      var valueCallback3 = function valueCallback4(year) {
        return {
          year,
          isTwoDigitYear: token2 === "yy"
        };
      };
      switch (token2) {
        case "y":
          return mapValue(parseNDigits(4, dateString), valueCallback3);
        case "yo":
          return mapValue(match2.ordinalNumber(dateString, {
            unit: "year"
          }), valueCallback3);
        default:
          return mapValue(parseNDigits(token2.length, dateString), valueCallback3);
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value.isTwoDigitYear || value.year > 0;
    }
  }, {
    key: "set",
    value: function set2(date, flags, value) {
      var currentYear = date.getUTCFullYear();
      if (value.isTwoDigitYear) {
        var normalizedTwoDigitYear = normalizeTwoDigitYear(value.year, currentYear);
        date.setUTCFullYear(normalizedTwoDigitYear, 0, 1);
        date.setUTCHours(0, 0, 0, 0);
        return date;
      }
      var year = !("era" in flags) || flags.era === 1 ? value.year : 1 - value.year;
      date.setUTCFullYear(year, 0, 1);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);
  return YearParser2;
}(Parser);
function _typeof$u(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$u = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$u = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$u(obj);
}
function _classCallCheck$s(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$s(target, props) {
  for (var i3 = 0; i3 < props.length; i3++) {
    var descriptor = props[i3];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$s(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$s(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$s(Constructor, staticProps);
  return Constructor;
}
function _inherits$s(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  if (superClass)
    _setPrototypeOf$t(subClass, superClass);
}
function _setPrototypeOf$t(o2, p2) {
  _setPrototypeOf$t = Object.setPrototypeOf || function _setPrototypeOf2(o3, p3) {
    o3.__proto__ = p3;
    return o3;
  };
  return _setPrototypeOf$t(o2, p2);
}
function _createSuper$s(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$s();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$s(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$s(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$s(this, result);
  };
}
function _possibleConstructorReturn$s(self2, call) {
  if (call && (_typeof$u(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$t(self2);
}
function _assertThisInitialized$t(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$s() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e3) {
    return false;
  }
}
function _getPrototypeOf$s(o2) {
  _getPrototypeOf$s = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o3) {
    return o3.__proto__ || Object.getPrototypeOf(o3);
  };
  return _getPrototypeOf$s(o2);
}
function _defineProperty$s(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var LocalWeekYearParser = /* @__PURE__ */ function(_Parser) {
  _inherits$s(LocalWeekYearParser2, _Parser);
  var _super = _createSuper$s(LocalWeekYearParser2);
  function LocalWeekYearParser2() {
    var _this;
    _classCallCheck$s(this, LocalWeekYearParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty$s(_assertThisInitialized$t(_this), "priority", 130);
    _defineProperty$s(_assertThisInitialized$t(_this), "incompatibleTokens", ["y", "R", "u", "Q", "q", "M", "L", "I", "d", "D", "i", "t", "T"]);
    return _this;
  }
  _createClass$s(LocalWeekYearParser2, [{
    key: "parse",
    value: function parse2(dateString, token2, match2) {
      var valueCallback3 = function valueCallback4(year) {
        return {
          year,
          isTwoDigitYear: token2 === "YY"
        };
      };
      switch (token2) {
        case "Y":
          return mapValue(parseNDigits(4, dateString), valueCallback3);
        case "Yo":
          return mapValue(match2.ordinalNumber(dateString, {
            unit: "year"
          }), valueCallback3);
        default:
          return mapValue(parseNDigits(token2.length, dateString), valueCallback3);
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value.isTwoDigitYear || value.year > 0;
    }
  }, {
    key: "set",
    value: function set2(date, flags, value, options) {
      var currentYear = getUTCWeekYear(date, options);
      if (value.isTwoDigitYear) {
        var normalizedTwoDigitYear = normalizeTwoDigitYear(value.year, currentYear);
        date.setUTCFullYear(normalizedTwoDigitYear, 0, options.firstWeekContainsDate);
        date.setUTCHours(0, 0, 0, 0);
        return startOfUTCWeek(date, options);
      }
      var year = !("era" in flags) || flags.era === 1 ? value.year : 1 - value.year;
      date.setUTCFullYear(year, 0, options.firstWeekContainsDate);
      date.setUTCHours(0, 0, 0, 0);
      return startOfUTCWeek(date, options);
    }
  }]);
  return LocalWeekYearParser2;
}(Parser);
function _typeof$t(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$t = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$t = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$t(obj);
}
function _classCallCheck$r(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$r(target, props) {
  for (var i3 = 0; i3 < props.length; i3++) {
    var descriptor = props[i3];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$r(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$r(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$r(Constructor, staticProps);
  return Constructor;
}
function _inherits$r(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  if (superClass)
    _setPrototypeOf$s(subClass, superClass);
}
function _setPrototypeOf$s(o2, p2) {
  _setPrototypeOf$s = Object.setPrototypeOf || function _setPrototypeOf2(o3, p3) {
    o3.__proto__ = p3;
    return o3;
  };
  return _setPrototypeOf$s(o2, p2);
}
function _createSuper$r(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$r();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$r(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$r(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$r(this, result);
  };
}
function _possibleConstructorReturn$r(self2, call) {
  if (call && (_typeof$t(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$s(self2);
}
function _assertThisInitialized$s(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$r() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e3) {
    return false;
  }
}
function _getPrototypeOf$r(o2) {
  _getPrototypeOf$r = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o3) {
    return o3.__proto__ || Object.getPrototypeOf(o3);
  };
  return _getPrototypeOf$r(o2);
}
function _defineProperty$r(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var ISOWeekYearParser = /* @__PURE__ */ function(_Parser) {
  _inherits$r(ISOWeekYearParser2, _Parser);
  var _super = _createSuper$r(ISOWeekYearParser2);
  function ISOWeekYearParser2() {
    var _this;
    _classCallCheck$r(this, ISOWeekYearParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty$r(_assertThisInitialized$s(_this), "priority", 130);
    _defineProperty$r(_assertThisInitialized$s(_this), "incompatibleTokens", ["G", "y", "Y", "u", "Q", "q", "M", "L", "w", "d", "D", "e", "c", "t", "T"]);
    return _this;
  }
  _createClass$r(ISOWeekYearParser2, [{
    key: "parse",
    value: function parse2(dateString, token2) {
      if (token2 === "R") {
        return parseNDigitsSigned(4, dateString);
      }
      return parseNDigitsSigned(token2.length, dateString);
    }
  }, {
    key: "set",
    value: function set2(_date, _flags, value) {
      var firstWeekOfYear = new Date(0);
      firstWeekOfYear.setUTCFullYear(value, 0, 4);
      firstWeekOfYear.setUTCHours(0, 0, 0, 0);
      return startOfUTCISOWeek(firstWeekOfYear);
    }
  }]);
  return ISOWeekYearParser2;
}(Parser);
function _typeof$s(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$s = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$s = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$s(obj);
}
function _classCallCheck$q(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$q(target, props) {
  for (var i3 = 0; i3 < props.length; i3++) {
    var descriptor = props[i3];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$q(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$q(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$q(Constructor, staticProps);
  return Constructor;
}
function _inherits$q(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  if (superClass)
    _setPrototypeOf$r(subClass, superClass);
}
function _setPrototypeOf$r(o2, p2) {
  _setPrototypeOf$r = Object.setPrototypeOf || function _setPrototypeOf2(o3, p3) {
    o3.__proto__ = p3;
    return o3;
  };
  return _setPrototypeOf$r(o2, p2);
}
function _createSuper$q(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$q();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$q(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$q(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$q(this, result);
  };
}
function _possibleConstructorReturn$q(self2, call) {
  if (call && (_typeof$s(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$r(self2);
}
function _assertThisInitialized$r(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$q() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e3) {
    return false;
  }
}
function _getPrototypeOf$q(o2) {
  _getPrototypeOf$q = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o3) {
    return o3.__proto__ || Object.getPrototypeOf(o3);
  };
  return _getPrototypeOf$q(o2);
}
function _defineProperty$q(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var ExtendedYearParser = /* @__PURE__ */ function(_Parser) {
  _inherits$q(ExtendedYearParser2, _Parser);
  var _super = _createSuper$q(ExtendedYearParser2);
  function ExtendedYearParser2() {
    var _this;
    _classCallCheck$q(this, ExtendedYearParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty$q(_assertThisInitialized$r(_this), "priority", 130);
    _defineProperty$q(_assertThisInitialized$r(_this), "incompatibleTokens", ["G", "y", "Y", "R", "w", "I", "i", "e", "c", "t", "T"]);
    return _this;
  }
  _createClass$q(ExtendedYearParser2, [{
    key: "parse",
    value: function parse2(dateString, token2) {
      if (token2 === "u") {
        return parseNDigitsSigned(4, dateString);
      }
      return parseNDigitsSigned(token2.length, dateString);
    }
  }, {
    key: "set",
    value: function set2(date, _flags, value) {
      date.setUTCFullYear(value, 0, 1);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);
  return ExtendedYearParser2;
}(Parser);
function _typeof$r(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$r = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$r = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$r(obj);
}
function _classCallCheck$p(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$p(target, props) {
  for (var i3 = 0; i3 < props.length; i3++) {
    var descriptor = props[i3];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$p(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$p(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$p(Constructor, staticProps);
  return Constructor;
}
function _inherits$p(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  if (superClass)
    _setPrototypeOf$q(subClass, superClass);
}
function _setPrototypeOf$q(o2, p2) {
  _setPrototypeOf$q = Object.setPrototypeOf || function _setPrototypeOf2(o3, p3) {
    o3.__proto__ = p3;
    return o3;
  };
  return _setPrototypeOf$q(o2, p2);
}
function _createSuper$p(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$p();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$p(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$p(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$p(this, result);
  };
}
function _possibleConstructorReturn$p(self2, call) {
  if (call && (_typeof$r(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$q(self2);
}
function _assertThisInitialized$q(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$p() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e3) {
    return false;
  }
}
function _getPrototypeOf$p(o2) {
  _getPrototypeOf$p = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o3) {
    return o3.__proto__ || Object.getPrototypeOf(o3);
  };
  return _getPrototypeOf$p(o2);
}
function _defineProperty$p(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var QuarterParser = /* @__PURE__ */ function(_Parser) {
  _inherits$p(QuarterParser2, _Parser);
  var _super = _createSuper$p(QuarterParser2);
  function QuarterParser2() {
    var _this;
    _classCallCheck$p(this, QuarterParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty$p(_assertThisInitialized$q(_this), "priority", 120);
    _defineProperty$p(_assertThisInitialized$q(_this), "incompatibleTokens", ["Y", "R", "q", "M", "L", "w", "I", "d", "D", "i", "e", "c", "t", "T"]);
    return _this;
  }
  _createClass$p(QuarterParser2, [{
    key: "parse",
    value: function parse2(dateString, token2, match2) {
      switch (token2) {
        case "Q":
        case "QQ":
          return parseNDigits(token2.length, dateString);
        case "Qo":
          return match2.ordinalNumber(dateString, {
            unit: "quarter"
          });
        case "QQQ":
          return match2.quarter(dateString, {
            width: "abbreviated",
            context: "formatting"
          }) || match2.quarter(dateString, {
            width: "narrow",
            context: "formatting"
          });
        case "QQQQQ":
          return match2.quarter(dateString, {
            width: "narrow",
            context: "formatting"
          });
        case "QQQQ":
        default:
          return match2.quarter(dateString, {
            width: "wide",
            context: "formatting"
          }) || match2.quarter(dateString, {
            width: "abbreviated",
            context: "formatting"
          }) || match2.quarter(dateString, {
            width: "narrow",
            context: "formatting"
          });
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 1 && value <= 4;
    }
  }, {
    key: "set",
    value: function set2(date, _flags, value) {
      date.setUTCMonth((value - 1) * 3, 1);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);
  return QuarterParser2;
}(Parser);
function _typeof$q(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$q = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$q = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$q(obj);
}
function _classCallCheck$o(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$o(target, props) {
  for (var i3 = 0; i3 < props.length; i3++) {
    var descriptor = props[i3];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$o(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$o(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$o(Constructor, staticProps);
  return Constructor;
}
function _inherits$o(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  if (superClass)
    _setPrototypeOf$p(subClass, superClass);
}
function _setPrototypeOf$p(o2, p2) {
  _setPrototypeOf$p = Object.setPrototypeOf || function _setPrototypeOf2(o3, p3) {
    o3.__proto__ = p3;
    return o3;
  };
  return _setPrototypeOf$p(o2, p2);
}
function _createSuper$o(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$o();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$o(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$o(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$o(this, result);
  };
}
function _possibleConstructorReturn$o(self2, call) {
  if (call && (_typeof$q(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$p(self2);
}
function _assertThisInitialized$p(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$o() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e3) {
    return false;
  }
}
function _getPrototypeOf$o(o2) {
  _getPrototypeOf$o = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o3) {
    return o3.__proto__ || Object.getPrototypeOf(o3);
  };
  return _getPrototypeOf$o(o2);
}
function _defineProperty$o(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var StandAloneQuarterParser = /* @__PURE__ */ function(_Parser) {
  _inherits$o(StandAloneQuarterParser2, _Parser);
  var _super = _createSuper$o(StandAloneQuarterParser2);
  function StandAloneQuarterParser2() {
    var _this;
    _classCallCheck$o(this, StandAloneQuarterParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty$o(_assertThisInitialized$p(_this), "priority", 120);
    _defineProperty$o(_assertThisInitialized$p(_this), "incompatibleTokens", ["Y", "R", "Q", "M", "L", "w", "I", "d", "D", "i", "e", "c", "t", "T"]);
    return _this;
  }
  _createClass$o(StandAloneQuarterParser2, [{
    key: "parse",
    value: function parse2(dateString, token2, match2) {
      switch (token2) {
        case "q":
        case "qq":
          return parseNDigits(token2.length, dateString);
        case "qo":
          return match2.ordinalNumber(dateString, {
            unit: "quarter"
          });
        case "qqq":
          return match2.quarter(dateString, {
            width: "abbreviated",
            context: "standalone"
          }) || match2.quarter(dateString, {
            width: "narrow",
            context: "standalone"
          });
        case "qqqqq":
          return match2.quarter(dateString, {
            width: "narrow",
            context: "standalone"
          });
        case "qqqq":
        default:
          return match2.quarter(dateString, {
            width: "wide",
            context: "standalone"
          }) || match2.quarter(dateString, {
            width: "abbreviated",
            context: "standalone"
          }) || match2.quarter(dateString, {
            width: "narrow",
            context: "standalone"
          });
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 1 && value <= 4;
    }
  }, {
    key: "set",
    value: function set2(date, _flags, value) {
      date.setUTCMonth((value - 1) * 3, 1);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);
  return StandAloneQuarterParser2;
}(Parser);
function _typeof$p(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$p = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$p = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$p(obj);
}
function _classCallCheck$n(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$n(target, props) {
  for (var i3 = 0; i3 < props.length; i3++) {
    var descriptor = props[i3];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$n(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$n(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$n(Constructor, staticProps);
  return Constructor;
}
function _inherits$n(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  if (superClass)
    _setPrototypeOf$o(subClass, superClass);
}
function _setPrototypeOf$o(o2, p2) {
  _setPrototypeOf$o = Object.setPrototypeOf || function _setPrototypeOf2(o3, p3) {
    o3.__proto__ = p3;
    return o3;
  };
  return _setPrototypeOf$o(o2, p2);
}
function _createSuper$n(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$n();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$n(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$n(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$n(this, result);
  };
}
function _possibleConstructorReturn$n(self2, call) {
  if (call && (_typeof$p(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$o(self2);
}
function _assertThisInitialized$o(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$n() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e3) {
    return false;
  }
}
function _getPrototypeOf$n(o2) {
  _getPrototypeOf$n = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o3) {
    return o3.__proto__ || Object.getPrototypeOf(o3);
  };
  return _getPrototypeOf$n(o2);
}
function _defineProperty$n(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var MonthParser = /* @__PURE__ */ function(_Parser) {
  _inherits$n(MonthParser2, _Parser);
  var _super = _createSuper$n(MonthParser2);
  function MonthParser2() {
    var _this;
    _classCallCheck$n(this, MonthParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty$n(_assertThisInitialized$o(_this), "incompatibleTokens", ["Y", "R", "q", "Q", "L", "w", "I", "D", "i", "e", "c", "t", "T"]);
    _defineProperty$n(_assertThisInitialized$o(_this), "priority", 110);
    return _this;
  }
  _createClass$n(MonthParser2, [{
    key: "parse",
    value: function parse2(dateString, token2, match2) {
      var valueCallback3 = function valueCallback4(value) {
        return value - 1;
      };
      switch (token2) {
        case "M":
          return mapValue(parseNumericPattern(numericPatterns.month, dateString), valueCallback3);
        case "MM":
          return mapValue(parseNDigits(2, dateString), valueCallback3);
        case "Mo":
          return mapValue(match2.ordinalNumber(dateString, {
            unit: "month"
          }), valueCallback3);
        case "MMM":
          return match2.month(dateString, {
            width: "abbreviated",
            context: "formatting"
          }) || match2.month(dateString, {
            width: "narrow",
            context: "formatting"
          });
        case "MMMMM":
          return match2.month(dateString, {
            width: "narrow",
            context: "formatting"
          });
        case "MMMM":
        default:
          return match2.month(dateString, {
            width: "wide",
            context: "formatting"
          }) || match2.month(dateString, {
            width: "abbreviated",
            context: "formatting"
          }) || match2.month(dateString, {
            width: "narrow",
            context: "formatting"
          });
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 0 && value <= 11;
    }
  }, {
    key: "set",
    value: function set2(date, _flags, value) {
      date.setUTCMonth(value, 1);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);
  return MonthParser2;
}(Parser);
function _typeof$o(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$o = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$o = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$o(obj);
}
function _classCallCheck$m(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$m(target, props) {
  for (var i3 = 0; i3 < props.length; i3++) {
    var descriptor = props[i3];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$m(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$m(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$m(Constructor, staticProps);
  return Constructor;
}
function _inherits$m(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  if (superClass)
    _setPrototypeOf$n(subClass, superClass);
}
function _setPrototypeOf$n(o2, p2) {
  _setPrototypeOf$n = Object.setPrototypeOf || function _setPrototypeOf2(o3, p3) {
    o3.__proto__ = p3;
    return o3;
  };
  return _setPrototypeOf$n(o2, p2);
}
function _createSuper$m(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$m();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$m(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$m(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$m(this, result);
  };
}
function _possibleConstructorReturn$m(self2, call) {
  if (call && (_typeof$o(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$n(self2);
}
function _assertThisInitialized$n(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$m() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e3) {
    return false;
  }
}
function _getPrototypeOf$m(o2) {
  _getPrototypeOf$m = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o3) {
    return o3.__proto__ || Object.getPrototypeOf(o3);
  };
  return _getPrototypeOf$m(o2);
}
function _defineProperty$m(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var StandAloneMonthParser = /* @__PURE__ */ function(_Parser) {
  _inherits$m(StandAloneMonthParser2, _Parser);
  var _super = _createSuper$m(StandAloneMonthParser2);
  function StandAloneMonthParser2() {
    var _this;
    _classCallCheck$m(this, StandAloneMonthParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty$m(_assertThisInitialized$n(_this), "priority", 110);
    _defineProperty$m(_assertThisInitialized$n(_this), "incompatibleTokens", ["Y", "R", "q", "Q", "M", "w", "I", "D", "i", "e", "c", "t", "T"]);
    return _this;
  }
  _createClass$m(StandAloneMonthParser2, [{
    key: "parse",
    value: function parse2(dateString, token2, match2) {
      var valueCallback3 = function valueCallback4(value) {
        return value - 1;
      };
      switch (token2) {
        case "L":
          return mapValue(parseNumericPattern(numericPatterns.month, dateString), valueCallback3);
        case "LL":
          return mapValue(parseNDigits(2, dateString), valueCallback3);
        case "Lo":
          return mapValue(match2.ordinalNumber(dateString, {
            unit: "month"
          }), valueCallback3);
        case "LLL":
          return match2.month(dateString, {
            width: "abbreviated",
            context: "standalone"
          }) || match2.month(dateString, {
            width: "narrow",
            context: "standalone"
          });
        case "LLLLL":
          return match2.month(dateString, {
            width: "narrow",
            context: "standalone"
          });
        case "LLLL":
        default:
          return match2.month(dateString, {
            width: "wide",
            context: "standalone"
          }) || match2.month(dateString, {
            width: "abbreviated",
            context: "standalone"
          }) || match2.month(dateString, {
            width: "narrow",
            context: "standalone"
          });
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 0 && value <= 11;
    }
  }, {
    key: "set",
    value: function set2(date, _flags, value) {
      date.setUTCMonth(value, 1);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);
  return StandAloneMonthParser2;
}(Parser);
function setUTCWeek(dirtyDate, dirtyWeek, options) {
  requiredArgs(2, arguments);
  var date = toDate(dirtyDate);
  var week = toInteger(dirtyWeek);
  var diff = getUTCWeek(date, options) - week;
  date.setUTCDate(date.getUTCDate() - diff * 7);
  return date;
}
function _typeof$n(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$n = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$n = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$n(obj);
}
function _classCallCheck$l(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$l(target, props) {
  for (var i3 = 0; i3 < props.length; i3++) {
    var descriptor = props[i3];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$l(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$l(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$l(Constructor, staticProps);
  return Constructor;
}
function _inherits$l(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  if (superClass)
    _setPrototypeOf$m(subClass, superClass);
}
function _setPrototypeOf$m(o2, p2) {
  _setPrototypeOf$m = Object.setPrototypeOf || function _setPrototypeOf2(o3, p3) {
    o3.__proto__ = p3;
    return o3;
  };
  return _setPrototypeOf$m(o2, p2);
}
function _createSuper$l(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$l();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$l(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$l(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$l(this, result);
  };
}
function _possibleConstructorReturn$l(self2, call) {
  if (call && (_typeof$n(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$m(self2);
}
function _assertThisInitialized$m(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$l() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e3) {
    return false;
  }
}
function _getPrototypeOf$l(o2) {
  _getPrototypeOf$l = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o3) {
    return o3.__proto__ || Object.getPrototypeOf(o3);
  };
  return _getPrototypeOf$l(o2);
}
function _defineProperty$l(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var LocalWeekParser = /* @__PURE__ */ function(_Parser) {
  _inherits$l(LocalWeekParser2, _Parser);
  var _super = _createSuper$l(LocalWeekParser2);
  function LocalWeekParser2() {
    var _this;
    _classCallCheck$l(this, LocalWeekParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty$l(_assertThisInitialized$m(_this), "priority", 100);
    _defineProperty$l(_assertThisInitialized$m(_this), "incompatibleTokens", ["y", "R", "u", "q", "Q", "M", "L", "I", "d", "D", "i", "t", "T"]);
    return _this;
  }
  _createClass$l(LocalWeekParser2, [{
    key: "parse",
    value: function parse2(dateString, token2, match2) {
      switch (token2) {
        case "w":
          return parseNumericPattern(numericPatterns.week, dateString);
        case "wo":
          return match2.ordinalNumber(dateString, {
            unit: "week"
          });
        default:
          return parseNDigits(token2.length, dateString);
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 1 && value <= 53;
    }
  }, {
    key: "set",
    value: function set2(date, _flags, value, options) {
      return startOfUTCWeek(setUTCWeek(date, value, options), options);
    }
  }]);
  return LocalWeekParser2;
}(Parser);
function setUTCISOWeek(dirtyDate, dirtyISOWeek) {
  requiredArgs(2, arguments);
  var date = toDate(dirtyDate);
  var isoWeek = toInteger(dirtyISOWeek);
  var diff = getUTCISOWeek(date) - isoWeek;
  date.setUTCDate(date.getUTCDate() - diff * 7);
  return date;
}
function _typeof$m(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$m = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$m = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$m(obj);
}
function _classCallCheck$k(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$k(target, props) {
  for (var i3 = 0; i3 < props.length; i3++) {
    var descriptor = props[i3];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$k(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$k(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$k(Constructor, staticProps);
  return Constructor;
}
function _inherits$k(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  if (superClass)
    _setPrototypeOf$l(subClass, superClass);
}
function _setPrototypeOf$l(o2, p2) {
  _setPrototypeOf$l = Object.setPrototypeOf || function _setPrototypeOf2(o3, p3) {
    o3.__proto__ = p3;
    return o3;
  };
  return _setPrototypeOf$l(o2, p2);
}
function _createSuper$k(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$k();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$k(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$k(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$k(this, result);
  };
}
function _possibleConstructorReturn$k(self2, call) {
  if (call && (_typeof$m(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$l(self2);
}
function _assertThisInitialized$l(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$k() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e3) {
    return false;
  }
}
function _getPrototypeOf$k(o2) {
  _getPrototypeOf$k = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o3) {
    return o3.__proto__ || Object.getPrototypeOf(o3);
  };
  return _getPrototypeOf$k(o2);
}
function _defineProperty$k(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var ISOWeekParser = /* @__PURE__ */ function(_Parser) {
  _inherits$k(ISOWeekParser2, _Parser);
  var _super = _createSuper$k(ISOWeekParser2);
  function ISOWeekParser2() {
    var _this;
    _classCallCheck$k(this, ISOWeekParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty$k(_assertThisInitialized$l(_this), "priority", 100);
    _defineProperty$k(_assertThisInitialized$l(_this), "incompatibleTokens", ["y", "Y", "u", "q", "Q", "M", "L", "w", "d", "D", "e", "c", "t", "T"]);
    return _this;
  }
  _createClass$k(ISOWeekParser2, [{
    key: "parse",
    value: function parse2(dateString, token2, match2) {
      switch (token2) {
        case "I":
          return parseNumericPattern(numericPatterns.week, dateString);
        case "Io":
          return match2.ordinalNumber(dateString, {
            unit: "week"
          });
        default:
          return parseNDigits(token2.length, dateString);
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 1 && value <= 53;
    }
  }, {
    key: "set",
    value: function set2(date, _flags, value) {
      return startOfUTCISOWeek(setUTCISOWeek(date, value));
    }
  }]);
  return ISOWeekParser2;
}(Parser);
function _typeof$l(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$l = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$l = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$l(obj);
}
function _classCallCheck$j(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$j(target, props) {
  for (var i3 = 0; i3 < props.length; i3++) {
    var descriptor = props[i3];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$j(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$j(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$j(Constructor, staticProps);
  return Constructor;
}
function _inherits$j(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  if (superClass)
    _setPrototypeOf$k(subClass, superClass);
}
function _setPrototypeOf$k(o2, p2) {
  _setPrototypeOf$k = Object.setPrototypeOf || function _setPrototypeOf2(o3, p3) {
    o3.__proto__ = p3;
    return o3;
  };
  return _setPrototypeOf$k(o2, p2);
}
function _createSuper$j(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$j();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$j(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$j(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$j(this, result);
  };
}
function _possibleConstructorReturn$j(self2, call) {
  if (call && (_typeof$l(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$k(self2);
}
function _assertThisInitialized$k(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$j() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e3) {
    return false;
  }
}
function _getPrototypeOf$j(o2) {
  _getPrototypeOf$j = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o3) {
    return o3.__proto__ || Object.getPrototypeOf(o3);
  };
  return _getPrototypeOf$j(o2);
}
function _defineProperty$j(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
var DAYS_IN_MONTH_LEAP_YEAR = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
var DateParser = /* @__PURE__ */ function(_Parser) {
  _inherits$j(DateParser2, _Parser);
  var _super = _createSuper$j(DateParser2);
  function DateParser2() {
    var _this;
    _classCallCheck$j(this, DateParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty$j(_assertThisInitialized$k(_this), "priority", 90);
    _defineProperty$j(_assertThisInitialized$k(_this), "subPriority", 1);
    _defineProperty$j(_assertThisInitialized$k(_this), "incompatibleTokens", ["Y", "R", "q", "Q", "w", "I", "D", "i", "e", "c", "t", "T"]);
    return _this;
  }
  _createClass$j(DateParser2, [{
    key: "parse",
    value: function parse2(dateString, token2, match2) {
      switch (token2) {
        case "d":
          return parseNumericPattern(numericPatterns.date, dateString);
        case "do":
          return match2.ordinalNumber(dateString, {
            unit: "date"
          });
        default:
          return parseNDigits(token2.length, dateString);
      }
    }
  }, {
    key: "validate",
    value: function validate(date, value) {
      var year = date.getUTCFullYear();
      var isLeapYear = isLeapYearIndex$1(year);
      var month = date.getUTCMonth();
      if (isLeapYear) {
        return value >= 1 && value <= DAYS_IN_MONTH_LEAP_YEAR[month];
      } else {
        return value >= 1 && value <= DAYS_IN_MONTH[month];
      }
    }
  }, {
    key: "set",
    value: function set2(date, _flags, value) {
      date.setUTCDate(value);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);
  return DateParser2;
}(Parser);
function _typeof$k(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$k = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$k = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$k(obj);
}
function _classCallCheck$i(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$i(target, props) {
  for (var i3 = 0; i3 < props.length; i3++) {
    var descriptor = props[i3];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$i(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$i(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$i(Constructor, staticProps);
  return Constructor;
}
function _inherits$i(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  if (superClass)
    _setPrototypeOf$j(subClass, superClass);
}
function _setPrototypeOf$j(o2, p2) {
  _setPrototypeOf$j = Object.setPrototypeOf || function _setPrototypeOf2(o3, p3) {
    o3.__proto__ = p3;
    return o3;
  };
  return _setPrototypeOf$j(o2, p2);
}
function _createSuper$i(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$i();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$i(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$i(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$i(this, result);
  };
}
function _possibleConstructorReturn$i(self2, call) {
  if (call && (_typeof$k(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$j(self2);
}
function _assertThisInitialized$j(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$i() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e3) {
    return false;
  }
}
function _getPrototypeOf$i(o2) {
  _getPrototypeOf$i = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o3) {
    return o3.__proto__ || Object.getPrototypeOf(o3);
  };
  return _getPrototypeOf$i(o2);
}
function _defineProperty$i(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var DayOfYearParser = /* @__PURE__ */ function(_Parser) {
  _inherits$i(DayOfYearParser2, _Parser);
  var _super = _createSuper$i(DayOfYearParser2);
  function DayOfYearParser2() {
    var _this;
    _classCallCheck$i(this, DayOfYearParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty$i(_assertThisInitialized$j(_this), "priority", 90);
    _defineProperty$i(_assertThisInitialized$j(_this), "subpriority", 1);
    _defineProperty$i(_assertThisInitialized$j(_this), "incompatibleTokens", ["Y", "R", "q", "Q", "M", "L", "w", "I", "d", "E", "i", "e", "c", "t", "T"]);
    return _this;
  }
  _createClass$i(DayOfYearParser2, [{
    key: "parse",
    value: function parse2(dateString, token2, match2) {
      switch (token2) {
        case "D":
        case "DD":
          return parseNumericPattern(numericPatterns.dayOfYear, dateString);
        case "Do":
          return match2.ordinalNumber(dateString, {
            unit: "date"
          });
        default:
          return parseNDigits(token2.length, dateString);
      }
    }
  }, {
    key: "validate",
    value: function validate(date, value) {
      var year = date.getUTCFullYear();
      var isLeapYear = isLeapYearIndex$1(year);
      if (isLeapYear) {
        return value >= 1 && value <= 366;
      } else {
        return value >= 1 && value <= 365;
      }
    }
  }, {
    key: "set",
    value: function set2(date, _flags, value) {
      date.setUTCMonth(0, value);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);
  return DayOfYearParser2;
}(Parser);
function setUTCDay(dirtyDate, dirtyDay, options) {
  var _ref2, _ref22, _ref3, _options$weekStartsOn, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
  requiredArgs(2, arguments);
  var defaultOptions2 = getDefaultOptions();
  var weekStartsOn = toInteger((_ref2 = (_ref22 = (_ref3 = (_options$weekStartsOn = options === null || options === void 0 ? void 0 : options.weekStartsOn) !== null && _options$weekStartsOn !== void 0 ? _options$weekStartsOn : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.weekStartsOn) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions2.weekStartsOn) !== null && _ref22 !== void 0 ? _ref22 : (_defaultOptions$local = defaultOptions2.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.weekStartsOn) !== null && _ref2 !== void 0 ? _ref2 : 0);
  if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
    throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
  }
  var date = toDate(dirtyDate);
  var day = toInteger(dirtyDay);
  var currentDay = date.getUTCDay();
  var remainder = day % 7;
  var dayIndex = (remainder + 7) % 7;
  var diff = (dayIndex < weekStartsOn ? 7 : 0) + day - currentDay;
  date.setUTCDate(date.getUTCDate() + diff);
  return date;
}
function _typeof$j(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$j = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$j = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$j(obj);
}
function _classCallCheck$h(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$h(target, props) {
  for (var i3 = 0; i3 < props.length; i3++) {
    var descriptor = props[i3];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$h(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$h(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$h(Constructor, staticProps);
  return Constructor;
}
function _inherits$h(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  if (superClass)
    _setPrototypeOf$i(subClass, superClass);
}
function _setPrototypeOf$i(o2, p2) {
  _setPrototypeOf$i = Object.setPrototypeOf || function _setPrototypeOf2(o3, p3) {
    o3.__proto__ = p3;
    return o3;
  };
  return _setPrototypeOf$i(o2, p2);
}
function _createSuper$h(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$h();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$h(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$h(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$h(this, result);
  };
}
function _possibleConstructorReturn$h(self2, call) {
  if (call && (_typeof$j(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$i(self2);
}
function _assertThisInitialized$i(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$h() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e3) {
    return false;
  }
}
function _getPrototypeOf$h(o2) {
  _getPrototypeOf$h = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o3) {
    return o3.__proto__ || Object.getPrototypeOf(o3);
  };
  return _getPrototypeOf$h(o2);
}
function _defineProperty$h(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var DayParser = /* @__PURE__ */ function(_Parser) {
  _inherits$h(DayParser2, _Parser);
  var _super = _createSuper$h(DayParser2);
  function DayParser2() {
    var _this;
    _classCallCheck$h(this, DayParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty$h(_assertThisInitialized$i(_this), "priority", 90);
    _defineProperty$h(_assertThisInitialized$i(_this), "incompatibleTokens", ["D", "i", "e", "c", "t", "T"]);
    return _this;
  }
  _createClass$h(DayParser2, [{
    key: "parse",
    value: function parse2(dateString, token2, match2) {
      switch (token2) {
        case "E":
        case "EE":
        case "EEE":
          return match2.day(dateString, {
            width: "abbreviated",
            context: "formatting"
          }) || match2.day(dateString, {
            width: "short",
            context: "formatting"
          }) || match2.day(dateString, {
            width: "narrow",
            context: "formatting"
          });
        case "EEEEE":
          return match2.day(dateString, {
            width: "narrow",
            context: "formatting"
          });
        case "EEEEEE":
          return match2.day(dateString, {
            width: "short",
            context: "formatting"
          }) || match2.day(dateString, {
            width: "narrow",
            context: "formatting"
          });
        case "EEEE":
        default:
          return match2.day(dateString, {
            width: "wide",
            context: "formatting"
          }) || match2.day(dateString, {
            width: "abbreviated",
            context: "formatting"
          }) || match2.day(dateString, {
            width: "short",
            context: "formatting"
          }) || match2.day(dateString, {
            width: "narrow",
            context: "formatting"
          });
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 0 && value <= 6;
    }
  }, {
    key: "set",
    value: function set2(date, _flags, value, options) {
      date = setUTCDay(date, value, options);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);
  return DayParser2;
}(Parser);
function _typeof$i(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$i = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$i = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$i(obj);
}
function _classCallCheck$g(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$g(target, props) {
  for (var i3 = 0; i3 < props.length; i3++) {
    var descriptor = props[i3];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$g(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$g(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$g(Constructor, staticProps);
  return Constructor;
}
function _inherits$g(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  if (superClass)
    _setPrototypeOf$h(subClass, superClass);
}
function _setPrototypeOf$h(o2, p2) {
  _setPrototypeOf$h = Object.setPrototypeOf || function _setPrototypeOf2(o3, p3) {
    o3.__proto__ = p3;
    return o3;
  };
  return _setPrototypeOf$h(o2, p2);
}
function _createSuper$g(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$g();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$g(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$g(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$g(this, result);
  };
}
function _possibleConstructorReturn$g(self2, call) {
  if (call && (_typeof$i(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$h(self2);
}
function _assertThisInitialized$h(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$g() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e3) {
    return false;
  }
}
function _getPrototypeOf$g(o2) {
  _getPrototypeOf$g = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o3) {
    return o3.__proto__ || Object.getPrototypeOf(o3);
  };
  return _getPrototypeOf$g(o2);
}
function _defineProperty$g(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var LocalDayParser = /* @__PURE__ */ function(_Parser) {
  _inherits$g(LocalDayParser2, _Parser);
  var _super = _createSuper$g(LocalDayParser2);
  function LocalDayParser2() {
    var _this;
    _classCallCheck$g(this, LocalDayParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty$g(_assertThisInitialized$h(_this), "priority", 90);
    _defineProperty$g(_assertThisInitialized$h(_this), "incompatibleTokens", ["y", "R", "u", "q", "Q", "M", "L", "I", "d", "D", "E", "i", "c", "t", "T"]);
    return _this;
  }
  _createClass$g(LocalDayParser2, [{
    key: "parse",
    value: function parse2(dateString, token2, match2, options) {
      var valueCallback3 = function valueCallback4(value) {
        var wholeWeekDays = Math.floor((value - 1) / 7) * 7;
        return (value + options.weekStartsOn + 6) % 7 + wholeWeekDays;
      };
      switch (token2) {
        case "e":
        case "ee":
          return mapValue(parseNDigits(token2.length, dateString), valueCallback3);
        case "eo":
          return mapValue(match2.ordinalNumber(dateString, {
            unit: "day"
          }), valueCallback3);
        case "eee":
          return match2.day(dateString, {
            width: "abbreviated",
            context: "formatting"
          }) || match2.day(dateString, {
            width: "short",
            context: "formatting"
          }) || match2.day(dateString, {
            width: "narrow",
            context: "formatting"
          });
        case "eeeee":
          return match2.day(dateString, {
            width: "narrow",
            context: "formatting"
          });
        case "eeeeee":
          return match2.day(dateString, {
            width: "short",
            context: "formatting"
          }) || match2.day(dateString, {
            width: "narrow",
            context: "formatting"
          });
        case "eeee":
        default:
          return match2.day(dateString, {
            width: "wide",
            context: "formatting"
          }) || match2.day(dateString, {
            width: "abbreviated",
            context: "formatting"
          }) || match2.day(dateString, {
            width: "short",
            context: "formatting"
          }) || match2.day(dateString, {
            width: "narrow",
            context: "formatting"
          });
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 0 && value <= 6;
    }
  }, {
    key: "set",
    value: function set2(date, _flags, value, options) {
      date = setUTCDay(date, value, options);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);
  return LocalDayParser2;
}(Parser);
function _typeof$h(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$h = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$h = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$h(obj);
}
function _classCallCheck$f(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$f(target, props) {
  for (var i3 = 0; i3 < props.length; i3++) {
    var descriptor = props[i3];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$f(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$f(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$f(Constructor, staticProps);
  return Constructor;
}
function _inherits$f(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  if (superClass)
    _setPrototypeOf$g(subClass, superClass);
}
function _setPrototypeOf$g(o2, p2) {
  _setPrototypeOf$g = Object.setPrototypeOf || function _setPrototypeOf2(o3, p3) {
    o3.__proto__ = p3;
    return o3;
  };
  return _setPrototypeOf$g(o2, p2);
}
function _createSuper$f(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$f();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$f(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$f(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$f(this, result);
  };
}
function _possibleConstructorReturn$f(self2, call) {
  if (call && (_typeof$h(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$g(self2);
}
function _assertThisInitialized$g(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$f() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e3) {
    return false;
  }
}
function _getPrototypeOf$f(o2) {
  _getPrototypeOf$f = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o3) {
    return o3.__proto__ || Object.getPrototypeOf(o3);
  };
  return _getPrototypeOf$f(o2);
}
function _defineProperty$f(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var StandAloneLocalDayParser = /* @__PURE__ */ function(_Parser) {
  _inherits$f(StandAloneLocalDayParser2, _Parser);
  var _super = _createSuper$f(StandAloneLocalDayParser2);
  function StandAloneLocalDayParser2() {
    var _this;
    _classCallCheck$f(this, StandAloneLocalDayParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty$f(_assertThisInitialized$g(_this), "priority", 90);
    _defineProperty$f(_assertThisInitialized$g(_this), "incompatibleTokens", ["y", "R", "u", "q", "Q", "M", "L", "I", "d", "D", "E", "i", "e", "t", "T"]);
    return _this;
  }
  _createClass$f(StandAloneLocalDayParser2, [{
    key: "parse",
    value: function parse2(dateString, token2, match2, options) {
      var valueCallback3 = function valueCallback4(value) {
        var wholeWeekDays = Math.floor((value - 1) / 7) * 7;
        return (value + options.weekStartsOn + 6) % 7 + wholeWeekDays;
      };
      switch (token2) {
        case "c":
        case "cc":
          return mapValue(parseNDigits(token2.length, dateString), valueCallback3);
        case "co":
          return mapValue(match2.ordinalNumber(dateString, {
            unit: "day"
          }), valueCallback3);
        case "ccc":
          return match2.day(dateString, {
            width: "abbreviated",
            context: "standalone"
          }) || match2.day(dateString, {
            width: "short",
            context: "standalone"
          }) || match2.day(dateString, {
            width: "narrow",
            context: "standalone"
          });
        case "ccccc":
          return match2.day(dateString, {
            width: "narrow",
            context: "standalone"
          });
        case "cccccc":
          return match2.day(dateString, {
            width: "short",
            context: "standalone"
          }) || match2.day(dateString, {
            width: "narrow",
            context: "standalone"
          });
        case "cccc":
        default:
          return match2.day(dateString, {
            width: "wide",
            context: "standalone"
          }) || match2.day(dateString, {
            width: "abbreviated",
            context: "standalone"
          }) || match2.day(dateString, {
            width: "short",
            context: "standalone"
          }) || match2.day(dateString, {
            width: "narrow",
            context: "standalone"
          });
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 0 && value <= 6;
    }
  }, {
    key: "set",
    value: function set2(date, _flags, value, options) {
      date = setUTCDay(date, value, options);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);
  return StandAloneLocalDayParser2;
}(Parser);
function setUTCISODay(dirtyDate, dirtyDay) {
  requiredArgs(2, arguments);
  var day = toInteger(dirtyDay);
  if (day % 7 === 0) {
    day = day - 7;
  }
  var weekStartsOn = 1;
  var date = toDate(dirtyDate);
  var currentDay = date.getUTCDay();
  var remainder = day % 7;
  var dayIndex = (remainder + 7) % 7;
  var diff = (dayIndex < weekStartsOn ? 7 : 0) + day - currentDay;
  date.setUTCDate(date.getUTCDate() + diff);
  return date;
}
function _typeof$g(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$g = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$g = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$g(obj);
}
function _classCallCheck$e(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$e(target, props) {
  for (var i3 = 0; i3 < props.length; i3++) {
    var descriptor = props[i3];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$e(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$e(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$e(Constructor, staticProps);
  return Constructor;
}
function _inherits$e(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  if (superClass)
    _setPrototypeOf$f(subClass, superClass);
}
function _setPrototypeOf$f(o2, p2) {
  _setPrototypeOf$f = Object.setPrototypeOf || function _setPrototypeOf2(o3, p3) {
    o3.__proto__ = p3;
    return o3;
  };
  return _setPrototypeOf$f(o2, p2);
}
function _createSuper$e(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$e();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$e(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$e(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$e(this, result);
  };
}
function _possibleConstructorReturn$e(self2, call) {
  if (call && (_typeof$g(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$f(self2);
}
function _assertThisInitialized$f(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$e() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e3) {
    return false;
  }
}
function _getPrototypeOf$e(o2) {
  _getPrototypeOf$e = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o3) {
    return o3.__proto__ || Object.getPrototypeOf(o3);
  };
  return _getPrototypeOf$e(o2);
}
function _defineProperty$e(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var ISODayParser = /* @__PURE__ */ function(_Parser) {
  _inherits$e(ISODayParser2, _Parser);
  var _super = _createSuper$e(ISODayParser2);
  function ISODayParser2() {
    var _this;
    _classCallCheck$e(this, ISODayParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty$e(_assertThisInitialized$f(_this), "priority", 90);
    _defineProperty$e(_assertThisInitialized$f(_this), "incompatibleTokens", ["y", "Y", "u", "q", "Q", "M", "L", "w", "d", "D", "E", "e", "c", "t", "T"]);
    return _this;
  }
  _createClass$e(ISODayParser2, [{
    key: "parse",
    value: function parse2(dateString, token2, match2) {
      var valueCallback3 = function valueCallback4(value) {
        if (value === 0) {
          return 7;
        }
        return value;
      };
      switch (token2) {
        case "i":
        case "ii":
          return parseNDigits(token2.length, dateString);
        case "io":
          return match2.ordinalNumber(dateString, {
            unit: "day"
          });
        case "iii":
          return mapValue(match2.day(dateString, {
            width: "abbreviated",
            context: "formatting"
          }) || match2.day(dateString, {
            width: "short",
            context: "formatting"
          }) || match2.day(dateString, {
            width: "narrow",
            context: "formatting"
          }), valueCallback3);
        case "iiiii":
          return mapValue(match2.day(dateString, {
            width: "narrow",
            context: "formatting"
          }), valueCallback3);
        case "iiiiii":
          return mapValue(match2.day(dateString, {
            width: "short",
            context: "formatting"
          }) || match2.day(dateString, {
            width: "narrow",
            context: "formatting"
          }), valueCallback3);
        case "iiii":
        default:
          return mapValue(match2.day(dateString, {
            width: "wide",
            context: "formatting"
          }) || match2.day(dateString, {
            width: "abbreviated",
            context: "formatting"
          }) || match2.day(dateString, {
            width: "short",
            context: "formatting"
          }) || match2.day(dateString, {
            width: "narrow",
            context: "formatting"
          }), valueCallback3);
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 1 && value <= 7;
    }
  }, {
    key: "set",
    value: function set2(date, _flags, value) {
      date = setUTCISODay(date, value);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);
  return ISODayParser2;
}(Parser);
function _typeof$f(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$f = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$f = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$f(obj);
}
function _classCallCheck$d(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$d(target, props) {
  for (var i3 = 0; i3 < props.length; i3++) {
    var descriptor = props[i3];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$d(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$d(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$d(Constructor, staticProps);
  return Constructor;
}
function _inherits$d(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  if (superClass)
    _setPrototypeOf$e(subClass, superClass);
}
function _setPrototypeOf$e(o2, p2) {
  _setPrototypeOf$e = Object.setPrototypeOf || function _setPrototypeOf2(o3, p3) {
    o3.__proto__ = p3;
    return o3;
  };
  return _setPrototypeOf$e(o2, p2);
}
function _createSuper$d(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$d();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$d(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$d(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$d(this, result);
  };
}
function _possibleConstructorReturn$d(self2, call) {
  if (call && (_typeof$f(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$e(self2);
}
function _assertThisInitialized$e(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$d() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e3) {
    return false;
  }
}
function _getPrototypeOf$d(o2) {
  _getPrototypeOf$d = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o3) {
    return o3.__proto__ || Object.getPrototypeOf(o3);
  };
  return _getPrototypeOf$d(o2);
}
function _defineProperty$d(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var AMPMParser = /* @__PURE__ */ function(_Parser) {
  _inherits$d(AMPMParser2, _Parser);
  var _super = _createSuper$d(AMPMParser2);
  function AMPMParser2() {
    var _this;
    _classCallCheck$d(this, AMPMParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty$d(_assertThisInitialized$e(_this), "priority", 80);
    _defineProperty$d(_assertThisInitialized$e(_this), "incompatibleTokens", ["b", "B", "H", "k", "t", "T"]);
    return _this;
  }
  _createClass$d(AMPMParser2, [{
    key: "parse",
    value: function parse2(dateString, token2, match2) {
      switch (token2) {
        case "a":
        case "aa":
        case "aaa":
          return match2.dayPeriod(dateString, {
            width: "abbreviated",
            context: "formatting"
          }) || match2.dayPeriod(dateString, {
            width: "narrow",
            context: "formatting"
          });
        case "aaaaa":
          return match2.dayPeriod(dateString, {
            width: "narrow",
            context: "formatting"
          });
        case "aaaa":
        default:
          return match2.dayPeriod(dateString, {
            width: "wide",
            context: "formatting"
          }) || match2.dayPeriod(dateString, {
            width: "abbreviated",
            context: "formatting"
          }) || match2.dayPeriod(dateString, {
            width: "narrow",
            context: "formatting"
          });
      }
    }
  }, {
    key: "set",
    value: function set2(date, _flags, value) {
      date.setUTCHours(dayPeriodEnumToHours(value), 0, 0, 0);
      return date;
    }
  }]);
  return AMPMParser2;
}(Parser);
function _typeof$e(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$e = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$e = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$e(obj);
}
function _classCallCheck$c(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$c(target, props) {
  for (var i3 = 0; i3 < props.length; i3++) {
    var descriptor = props[i3];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$c(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$c(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$c(Constructor, staticProps);
  return Constructor;
}
function _inherits$c(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  if (superClass)
    _setPrototypeOf$d(subClass, superClass);
}
function _setPrototypeOf$d(o2, p2) {
  _setPrototypeOf$d = Object.setPrototypeOf || function _setPrototypeOf2(o3, p3) {
    o3.__proto__ = p3;
    return o3;
  };
  return _setPrototypeOf$d(o2, p2);
}
function _createSuper$c(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$c();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$c(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$c(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$c(this, result);
  };
}
function _possibleConstructorReturn$c(self2, call) {
  if (call && (_typeof$e(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$d(self2);
}
function _assertThisInitialized$d(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$c() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e3) {
    return false;
  }
}
function _getPrototypeOf$c(o2) {
  _getPrototypeOf$c = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o3) {
    return o3.__proto__ || Object.getPrototypeOf(o3);
  };
  return _getPrototypeOf$c(o2);
}
function _defineProperty$c(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var AMPMMidnightParser = /* @__PURE__ */ function(_Parser) {
  _inherits$c(AMPMMidnightParser2, _Parser);
  var _super = _createSuper$c(AMPMMidnightParser2);
  function AMPMMidnightParser2() {
    var _this;
    _classCallCheck$c(this, AMPMMidnightParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty$c(_assertThisInitialized$d(_this), "priority", 80);
    _defineProperty$c(_assertThisInitialized$d(_this), "incompatibleTokens", ["a", "B", "H", "k", "t", "T"]);
    return _this;
  }
  _createClass$c(AMPMMidnightParser2, [{
    key: "parse",
    value: function parse2(dateString, token2, match2) {
      switch (token2) {
        case "b":
        case "bb":
        case "bbb":
          return match2.dayPeriod(dateString, {
            width: "abbreviated",
            context: "formatting"
          }) || match2.dayPeriod(dateString, {
            width: "narrow",
            context: "formatting"
          });
        case "bbbbb":
          return match2.dayPeriod(dateString, {
            width: "narrow",
            context: "formatting"
          });
        case "bbbb":
        default:
          return match2.dayPeriod(dateString, {
            width: "wide",
            context: "formatting"
          }) || match2.dayPeriod(dateString, {
            width: "abbreviated",
            context: "formatting"
          }) || match2.dayPeriod(dateString, {
            width: "narrow",
            context: "formatting"
          });
      }
    }
  }, {
    key: "set",
    value: function set2(date, _flags, value) {
      date.setUTCHours(dayPeriodEnumToHours(value), 0, 0, 0);
      return date;
    }
  }]);
  return AMPMMidnightParser2;
}(Parser);
function _typeof$d(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$d = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$d = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$d(obj);
}
function _classCallCheck$b(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$b(target, props) {
  for (var i3 = 0; i3 < props.length; i3++) {
    var descriptor = props[i3];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$b(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$b(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$b(Constructor, staticProps);
  return Constructor;
}
function _inherits$b(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  if (superClass)
    _setPrototypeOf$c(subClass, superClass);
}
function _setPrototypeOf$c(o2, p2) {
  _setPrototypeOf$c = Object.setPrototypeOf || function _setPrototypeOf2(o3, p3) {
    o3.__proto__ = p3;
    return o3;
  };
  return _setPrototypeOf$c(o2, p2);
}
function _createSuper$b(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$b();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$b(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$b(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$b(this, result);
  };
}
function _possibleConstructorReturn$b(self2, call) {
  if (call && (_typeof$d(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$c(self2);
}
function _assertThisInitialized$c(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$b() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e3) {
    return false;
  }
}
function _getPrototypeOf$b(o2) {
  _getPrototypeOf$b = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o3) {
    return o3.__proto__ || Object.getPrototypeOf(o3);
  };
  return _getPrototypeOf$b(o2);
}
function _defineProperty$b(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var DayPeriodParser = /* @__PURE__ */ function(_Parser) {
  _inherits$b(DayPeriodParser2, _Parser);
  var _super = _createSuper$b(DayPeriodParser2);
  function DayPeriodParser2() {
    var _this;
    _classCallCheck$b(this, DayPeriodParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty$b(_assertThisInitialized$c(_this), "priority", 80);
    _defineProperty$b(_assertThisInitialized$c(_this), "incompatibleTokens", ["a", "b", "t", "T"]);
    return _this;
  }
  _createClass$b(DayPeriodParser2, [{
    key: "parse",
    value: function parse2(dateString, token2, match2) {
      switch (token2) {
        case "B":
        case "BB":
        case "BBB":
          return match2.dayPeriod(dateString, {
            width: "abbreviated",
            context: "formatting"
          }) || match2.dayPeriod(dateString, {
            width: "narrow",
            context: "formatting"
          });
        case "BBBBB":
          return match2.dayPeriod(dateString, {
            width: "narrow",
            context: "formatting"
          });
        case "BBBB":
        default:
          return match2.dayPeriod(dateString, {
            width: "wide",
            context: "formatting"
          }) || match2.dayPeriod(dateString, {
            width: "abbreviated",
            context: "formatting"
          }) || match2.dayPeriod(dateString, {
            width: "narrow",
            context: "formatting"
          });
      }
    }
  }, {
    key: "set",
    value: function set2(date, _flags, value) {
      date.setUTCHours(dayPeriodEnumToHours(value), 0, 0, 0);
      return date;
    }
  }]);
  return DayPeriodParser2;
}(Parser);
function _typeof$c(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$c = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$c = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$c(obj);
}
function _classCallCheck$a(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$a(target, props) {
  for (var i3 = 0; i3 < props.length; i3++) {
    var descriptor = props[i3];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$a(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$a(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$a(Constructor, staticProps);
  return Constructor;
}
function _inherits$a(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  if (superClass)
    _setPrototypeOf$b(subClass, superClass);
}
function _setPrototypeOf$b(o2, p2) {
  _setPrototypeOf$b = Object.setPrototypeOf || function _setPrototypeOf2(o3, p3) {
    o3.__proto__ = p3;
    return o3;
  };
  return _setPrototypeOf$b(o2, p2);
}
function _createSuper$a(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$a();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$a(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$a(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$a(this, result);
  };
}
function _possibleConstructorReturn$a(self2, call) {
  if (call && (_typeof$c(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$b(self2);
}
function _assertThisInitialized$b(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$a() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e3) {
    return false;
  }
}
function _getPrototypeOf$a(o2) {
  _getPrototypeOf$a = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o3) {
    return o3.__proto__ || Object.getPrototypeOf(o3);
  };
  return _getPrototypeOf$a(o2);
}
function _defineProperty$a(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var Hour1to12Parser = /* @__PURE__ */ function(_Parser) {
  _inherits$a(Hour1to12Parser2, _Parser);
  var _super = _createSuper$a(Hour1to12Parser2);
  function Hour1to12Parser2() {
    var _this;
    _classCallCheck$a(this, Hour1to12Parser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty$a(_assertThisInitialized$b(_this), "priority", 70);
    _defineProperty$a(_assertThisInitialized$b(_this), "incompatibleTokens", ["H", "K", "k", "t", "T"]);
    return _this;
  }
  _createClass$a(Hour1to12Parser2, [{
    key: "parse",
    value: function parse2(dateString, token2, match2) {
      switch (token2) {
        case "h":
          return parseNumericPattern(numericPatterns.hour12h, dateString);
        case "ho":
          return match2.ordinalNumber(dateString, {
            unit: "hour"
          });
        default:
          return parseNDigits(token2.length, dateString);
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 1 && value <= 12;
    }
  }, {
    key: "set",
    value: function set2(date, _flags, value) {
      var isPM = date.getUTCHours() >= 12;
      if (isPM && value < 12) {
        date.setUTCHours(value + 12, 0, 0, 0);
      } else if (!isPM && value === 12) {
        date.setUTCHours(0, 0, 0, 0);
      } else {
        date.setUTCHours(value, 0, 0, 0);
      }
      return date;
    }
  }]);
  return Hour1to12Parser2;
}(Parser);
function _typeof$b(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$b = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$b = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$b(obj);
}
function _classCallCheck$9(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$9(target, props) {
  for (var i3 = 0; i3 < props.length; i3++) {
    var descriptor = props[i3];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$9(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$9(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$9(Constructor, staticProps);
  return Constructor;
}
function _inherits$9(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  if (superClass)
    _setPrototypeOf$a(subClass, superClass);
}
function _setPrototypeOf$a(o2, p2) {
  _setPrototypeOf$a = Object.setPrototypeOf || function _setPrototypeOf2(o3, p3) {
    o3.__proto__ = p3;
    return o3;
  };
  return _setPrototypeOf$a(o2, p2);
}
function _createSuper$9(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$9();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$9(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$9(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$9(this, result);
  };
}
function _possibleConstructorReturn$9(self2, call) {
  if (call && (_typeof$b(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$a(self2);
}
function _assertThisInitialized$a(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$9() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e3) {
    return false;
  }
}
function _getPrototypeOf$9(o2) {
  _getPrototypeOf$9 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o3) {
    return o3.__proto__ || Object.getPrototypeOf(o3);
  };
  return _getPrototypeOf$9(o2);
}
function _defineProperty$9(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var Hour0to23Parser = /* @__PURE__ */ function(_Parser) {
  _inherits$9(Hour0to23Parser2, _Parser);
  var _super = _createSuper$9(Hour0to23Parser2);
  function Hour0to23Parser2() {
    var _this;
    _classCallCheck$9(this, Hour0to23Parser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty$9(_assertThisInitialized$a(_this), "priority", 70);
    _defineProperty$9(_assertThisInitialized$a(_this), "incompatibleTokens", ["a", "b", "h", "K", "k", "t", "T"]);
    return _this;
  }
  _createClass$9(Hour0to23Parser2, [{
    key: "parse",
    value: function parse2(dateString, token2, match2) {
      switch (token2) {
        case "H":
          return parseNumericPattern(numericPatterns.hour23h, dateString);
        case "Ho":
          return match2.ordinalNumber(dateString, {
            unit: "hour"
          });
        default:
          return parseNDigits(token2.length, dateString);
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 0 && value <= 23;
    }
  }, {
    key: "set",
    value: function set2(date, _flags, value) {
      date.setUTCHours(value, 0, 0, 0);
      return date;
    }
  }]);
  return Hour0to23Parser2;
}(Parser);
function _typeof$a(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$a = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$a = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$a(obj);
}
function _classCallCheck$8(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$8(target, props) {
  for (var i3 = 0; i3 < props.length; i3++) {
    var descriptor = props[i3];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$8(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$8(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$8(Constructor, staticProps);
  return Constructor;
}
function _inherits$8(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  if (superClass)
    _setPrototypeOf$9(subClass, superClass);
}
function _setPrototypeOf$9(o2, p2) {
  _setPrototypeOf$9 = Object.setPrototypeOf || function _setPrototypeOf2(o3, p3) {
    o3.__proto__ = p3;
    return o3;
  };
  return _setPrototypeOf$9(o2, p2);
}
function _createSuper$8(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$8();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$8(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$8(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$8(this, result);
  };
}
function _possibleConstructorReturn$8(self2, call) {
  if (call && (_typeof$a(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$9(self2);
}
function _assertThisInitialized$9(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$8() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e3) {
    return false;
  }
}
function _getPrototypeOf$8(o2) {
  _getPrototypeOf$8 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o3) {
    return o3.__proto__ || Object.getPrototypeOf(o3);
  };
  return _getPrototypeOf$8(o2);
}
function _defineProperty$8(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var Hour0To11Parser = /* @__PURE__ */ function(_Parser) {
  _inherits$8(Hour0To11Parser2, _Parser);
  var _super = _createSuper$8(Hour0To11Parser2);
  function Hour0To11Parser2() {
    var _this;
    _classCallCheck$8(this, Hour0To11Parser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty$8(_assertThisInitialized$9(_this), "priority", 70);
    _defineProperty$8(_assertThisInitialized$9(_this), "incompatibleTokens", ["h", "H", "k", "t", "T"]);
    return _this;
  }
  _createClass$8(Hour0To11Parser2, [{
    key: "parse",
    value: function parse2(dateString, token2, match2) {
      switch (token2) {
        case "K":
          return parseNumericPattern(numericPatterns.hour11h, dateString);
        case "Ko":
          return match2.ordinalNumber(dateString, {
            unit: "hour"
          });
        default:
          return parseNDigits(token2.length, dateString);
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 0 && value <= 11;
    }
  }, {
    key: "set",
    value: function set2(date, _flags, value) {
      var isPM = date.getUTCHours() >= 12;
      if (isPM && value < 12) {
        date.setUTCHours(value + 12, 0, 0, 0);
      } else {
        date.setUTCHours(value, 0, 0, 0);
      }
      return date;
    }
  }]);
  return Hour0To11Parser2;
}(Parser);
function _typeof$9(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$9 = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$9 = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$9(obj);
}
function _classCallCheck$7(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$7(target, props) {
  for (var i3 = 0; i3 < props.length; i3++) {
    var descriptor = props[i3];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$7(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$7(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$7(Constructor, staticProps);
  return Constructor;
}
function _inherits$7(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  if (superClass)
    _setPrototypeOf$8(subClass, superClass);
}
function _setPrototypeOf$8(o2, p2) {
  _setPrototypeOf$8 = Object.setPrototypeOf || function _setPrototypeOf2(o3, p3) {
    o3.__proto__ = p3;
    return o3;
  };
  return _setPrototypeOf$8(o2, p2);
}
function _createSuper$7(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$7();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$7(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$7(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$7(this, result);
  };
}
function _possibleConstructorReturn$7(self2, call) {
  if (call && (_typeof$9(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$8(self2);
}
function _assertThisInitialized$8(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$7() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e3) {
    return false;
  }
}
function _getPrototypeOf$7(o2) {
  _getPrototypeOf$7 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o3) {
    return o3.__proto__ || Object.getPrototypeOf(o3);
  };
  return _getPrototypeOf$7(o2);
}
function _defineProperty$7(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var Hour1To24Parser = /* @__PURE__ */ function(_Parser) {
  _inherits$7(Hour1To24Parser2, _Parser);
  var _super = _createSuper$7(Hour1To24Parser2);
  function Hour1To24Parser2() {
    var _this;
    _classCallCheck$7(this, Hour1To24Parser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty$7(_assertThisInitialized$8(_this), "priority", 70);
    _defineProperty$7(_assertThisInitialized$8(_this), "incompatibleTokens", ["a", "b", "h", "H", "K", "t", "T"]);
    return _this;
  }
  _createClass$7(Hour1To24Parser2, [{
    key: "parse",
    value: function parse2(dateString, token2, match2) {
      switch (token2) {
        case "k":
          return parseNumericPattern(numericPatterns.hour24h, dateString);
        case "ko":
          return match2.ordinalNumber(dateString, {
            unit: "hour"
          });
        default:
          return parseNDigits(token2.length, dateString);
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 1 && value <= 24;
    }
  }, {
    key: "set",
    value: function set2(date, _flags, value) {
      var hours = value <= 24 ? value % 24 : value;
      date.setUTCHours(hours, 0, 0, 0);
      return date;
    }
  }]);
  return Hour1To24Parser2;
}(Parser);
function _typeof$8(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$8 = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$8 = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$8(obj);
}
function _classCallCheck$6(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$6(target, props) {
  for (var i3 = 0; i3 < props.length; i3++) {
    var descriptor = props[i3];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$6(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$6(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$6(Constructor, staticProps);
  return Constructor;
}
function _inherits$6(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  if (superClass)
    _setPrototypeOf$7(subClass, superClass);
}
function _setPrototypeOf$7(o2, p2) {
  _setPrototypeOf$7 = Object.setPrototypeOf || function _setPrototypeOf2(o3, p3) {
    o3.__proto__ = p3;
    return o3;
  };
  return _setPrototypeOf$7(o2, p2);
}
function _createSuper$6(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$6();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$6(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$6(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$6(this, result);
  };
}
function _possibleConstructorReturn$6(self2, call) {
  if (call && (_typeof$8(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$7(self2);
}
function _assertThisInitialized$7(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$6() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e3) {
    return false;
  }
}
function _getPrototypeOf$6(o2) {
  _getPrototypeOf$6 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o3) {
    return o3.__proto__ || Object.getPrototypeOf(o3);
  };
  return _getPrototypeOf$6(o2);
}
function _defineProperty$6(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var MinuteParser = /* @__PURE__ */ function(_Parser) {
  _inherits$6(MinuteParser2, _Parser);
  var _super = _createSuper$6(MinuteParser2);
  function MinuteParser2() {
    var _this;
    _classCallCheck$6(this, MinuteParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty$6(_assertThisInitialized$7(_this), "priority", 60);
    _defineProperty$6(_assertThisInitialized$7(_this), "incompatibleTokens", ["t", "T"]);
    return _this;
  }
  _createClass$6(MinuteParser2, [{
    key: "parse",
    value: function parse2(dateString, token2, match2) {
      switch (token2) {
        case "m":
          return parseNumericPattern(numericPatterns.minute, dateString);
        case "mo":
          return match2.ordinalNumber(dateString, {
            unit: "minute"
          });
        default:
          return parseNDigits(token2.length, dateString);
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 0 && value <= 59;
    }
  }, {
    key: "set",
    value: function set2(date, _flags, value) {
      date.setUTCMinutes(value, 0, 0);
      return date;
    }
  }]);
  return MinuteParser2;
}(Parser);
function _typeof$7(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$7 = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$7 = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$7(obj);
}
function _classCallCheck$5(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$5(target, props) {
  for (var i3 = 0; i3 < props.length; i3++) {
    var descriptor = props[i3];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$5(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$5(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$5(Constructor, staticProps);
  return Constructor;
}
function _inherits$5(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  if (superClass)
    _setPrototypeOf$6(subClass, superClass);
}
function _setPrototypeOf$6(o2, p2) {
  _setPrototypeOf$6 = Object.setPrototypeOf || function _setPrototypeOf2(o3, p3) {
    o3.__proto__ = p3;
    return o3;
  };
  return _setPrototypeOf$6(o2, p2);
}
function _createSuper$5(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$5();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$5(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$5(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$5(this, result);
  };
}
function _possibleConstructorReturn$5(self2, call) {
  if (call && (_typeof$7(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$6(self2);
}
function _assertThisInitialized$6(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$5() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e3) {
    return false;
  }
}
function _getPrototypeOf$5(o2) {
  _getPrototypeOf$5 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o3) {
    return o3.__proto__ || Object.getPrototypeOf(o3);
  };
  return _getPrototypeOf$5(o2);
}
function _defineProperty$5(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var SecondParser = /* @__PURE__ */ function(_Parser) {
  _inherits$5(SecondParser2, _Parser);
  var _super = _createSuper$5(SecondParser2);
  function SecondParser2() {
    var _this;
    _classCallCheck$5(this, SecondParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty$5(_assertThisInitialized$6(_this), "priority", 50);
    _defineProperty$5(_assertThisInitialized$6(_this), "incompatibleTokens", ["t", "T"]);
    return _this;
  }
  _createClass$5(SecondParser2, [{
    key: "parse",
    value: function parse2(dateString, token2, match2) {
      switch (token2) {
        case "s":
          return parseNumericPattern(numericPatterns.second, dateString);
        case "so":
          return match2.ordinalNumber(dateString, {
            unit: "second"
          });
        default:
          return parseNDigits(token2.length, dateString);
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 0 && value <= 59;
    }
  }, {
    key: "set",
    value: function set2(date, _flags, value) {
      date.setUTCSeconds(value, 0);
      return date;
    }
  }]);
  return SecondParser2;
}(Parser);
function _typeof$6(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$6 = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$6 = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$6(obj);
}
function _classCallCheck$4(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$4(target, props) {
  for (var i3 = 0; i3 < props.length; i3++) {
    var descriptor = props[i3];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$4(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$4(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$4(Constructor, staticProps);
  return Constructor;
}
function _inherits$4(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  if (superClass)
    _setPrototypeOf$5(subClass, superClass);
}
function _setPrototypeOf$5(o2, p2) {
  _setPrototypeOf$5 = Object.setPrototypeOf || function _setPrototypeOf2(o3, p3) {
    o3.__proto__ = p3;
    return o3;
  };
  return _setPrototypeOf$5(o2, p2);
}
function _createSuper$4(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$4();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$4(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$4(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$4(this, result);
  };
}
function _possibleConstructorReturn$4(self2, call) {
  if (call && (_typeof$6(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$5(self2);
}
function _assertThisInitialized$5(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$4() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e3) {
    return false;
  }
}
function _getPrototypeOf$4(o2) {
  _getPrototypeOf$4 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o3) {
    return o3.__proto__ || Object.getPrototypeOf(o3);
  };
  return _getPrototypeOf$4(o2);
}
function _defineProperty$4(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var FractionOfSecondParser = /* @__PURE__ */ function(_Parser) {
  _inherits$4(FractionOfSecondParser2, _Parser);
  var _super = _createSuper$4(FractionOfSecondParser2);
  function FractionOfSecondParser2() {
    var _this;
    _classCallCheck$4(this, FractionOfSecondParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty$4(_assertThisInitialized$5(_this), "priority", 30);
    _defineProperty$4(_assertThisInitialized$5(_this), "incompatibleTokens", ["t", "T"]);
    return _this;
  }
  _createClass$4(FractionOfSecondParser2, [{
    key: "parse",
    value: function parse2(dateString, token2) {
      var valueCallback3 = function valueCallback4(value) {
        return Math.floor(value * Math.pow(10, -token2.length + 3));
      };
      return mapValue(parseNDigits(token2.length, dateString), valueCallback3);
    }
  }, {
    key: "set",
    value: function set2(date, _flags, value) {
      date.setUTCMilliseconds(value);
      return date;
    }
  }]);
  return FractionOfSecondParser2;
}(Parser);
function _typeof$5(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$5 = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$5 = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$5(obj);
}
function _classCallCheck$3(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$3(target, props) {
  for (var i3 = 0; i3 < props.length; i3++) {
    var descriptor = props[i3];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$3(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$3(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$3(Constructor, staticProps);
  return Constructor;
}
function _inherits$3(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  if (superClass)
    _setPrototypeOf$4(subClass, superClass);
}
function _setPrototypeOf$4(o2, p2) {
  _setPrototypeOf$4 = Object.setPrototypeOf || function _setPrototypeOf2(o3, p3) {
    o3.__proto__ = p3;
    return o3;
  };
  return _setPrototypeOf$4(o2, p2);
}
function _createSuper$3(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$3();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$3(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$3(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$3(this, result);
  };
}
function _possibleConstructorReturn$3(self2, call) {
  if (call && (_typeof$5(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$4(self2);
}
function _assertThisInitialized$4(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$3() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e3) {
    return false;
  }
}
function _getPrototypeOf$3(o2) {
  _getPrototypeOf$3 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o3) {
    return o3.__proto__ || Object.getPrototypeOf(o3);
  };
  return _getPrototypeOf$3(o2);
}
function _defineProperty$3(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var ISOTimezoneWithZParser = /* @__PURE__ */ function(_Parser) {
  _inherits$3(ISOTimezoneWithZParser2, _Parser);
  var _super = _createSuper$3(ISOTimezoneWithZParser2);
  function ISOTimezoneWithZParser2() {
    var _this;
    _classCallCheck$3(this, ISOTimezoneWithZParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty$3(_assertThisInitialized$4(_this), "priority", 10);
    _defineProperty$3(_assertThisInitialized$4(_this), "incompatibleTokens", ["t", "T", "x"]);
    return _this;
  }
  _createClass$3(ISOTimezoneWithZParser2, [{
    key: "parse",
    value: function parse2(dateString, token2) {
      switch (token2) {
        case "X":
          return parseTimezonePattern(timezonePatterns.basicOptionalMinutes, dateString);
        case "XX":
          return parseTimezonePattern(timezonePatterns.basic, dateString);
        case "XXXX":
          return parseTimezonePattern(timezonePatterns.basicOptionalSeconds, dateString);
        case "XXXXX":
          return parseTimezonePattern(timezonePatterns.extendedOptionalSeconds, dateString);
        case "XXX":
        default:
          return parseTimezonePattern(timezonePatterns.extended, dateString);
      }
    }
  }, {
    key: "set",
    value: function set2(date, flags, value) {
      if (flags.timestampIsSet) {
        return date;
      }
      return new Date(date.getTime() - value);
    }
  }]);
  return ISOTimezoneWithZParser2;
}(Parser);
function _typeof$4(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$4 = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$4 = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$4(obj);
}
function _classCallCheck$2(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$2(target, props) {
  for (var i3 = 0; i3 < props.length; i3++) {
    var descriptor = props[i3];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$2(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$2(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$2(Constructor, staticProps);
  return Constructor;
}
function _inherits$2(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  if (superClass)
    _setPrototypeOf$3(subClass, superClass);
}
function _setPrototypeOf$3(o2, p2) {
  _setPrototypeOf$3 = Object.setPrototypeOf || function _setPrototypeOf2(o3, p3) {
    o3.__proto__ = p3;
    return o3;
  };
  return _setPrototypeOf$3(o2, p2);
}
function _createSuper$2(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$2();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$2(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$2(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$2(this, result);
  };
}
function _possibleConstructorReturn$2(self2, call) {
  if (call && (_typeof$4(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$3(self2);
}
function _assertThisInitialized$3(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$2() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e3) {
    return false;
  }
}
function _getPrototypeOf$2(o2) {
  _getPrototypeOf$2 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o3) {
    return o3.__proto__ || Object.getPrototypeOf(o3);
  };
  return _getPrototypeOf$2(o2);
}
function _defineProperty$2(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var ISOTimezoneParser = /* @__PURE__ */ function(_Parser) {
  _inherits$2(ISOTimezoneParser2, _Parser);
  var _super = _createSuper$2(ISOTimezoneParser2);
  function ISOTimezoneParser2() {
    var _this;
    _classCallCheck$2(this, ISOTimezoneParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty$2(_assertThisInitialized$3(_this), "priority", 10);
    _defineProperty$2(_assertThisInitialized$3(_this), "incompatibleTokens", ["t", "T", "X"]);
    return _this;
  }
  _createClass$2(ISOTimezoneParser2, [{
    key: "parse",
    value: function parse2(dateString, token2) {
      switch (token2) {
        case "x":
          return parseTimezonePattern(timezonePatterns.basicOptionalMinutes, dateString);
        case "xx":
          return parseTimezonePattern(timezonePatterns.basic, dateString);
        case "xxxx":
          return parseTimezonePattern(timezonePatterns.basicOptionalSeconds, dateString);
        case "xxxxx":
          return parseTimezonePattern(timezonePatterns.extendedOptionalSeconds, dateString);
        case "xxx":
        default:
          return parseTimezonePattern(timezonePatterns.extended, dateString);
      }
    }
  }, {
    key: "set",
    value: function set2(date, flags, value) {
      if (flags.timestampIsSet) {
        return date;
      }
      return new Date(date.getTime() - value);
    }
  }]);
  return ISOTimezoneParser2;
}(Parser);
function _typeof$3(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$3 = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$3 = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$3(obj);
}
function _classCallCheck$1(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$1(target, props) {
  for (var i3 = 0; i3 < props.length; i3++) {
    var descriptor = props[i3];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$1(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$1(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$1(Constructor, staticProps);
  return Constructor;
}
function _inherits$1(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  if (superClass)
    _setPrototypeOf$2(subClass, superClass);
}
function _setPrototypeOf$2(o2, p2) {
  _setPrototypeOf$2 = Object.setPrototypeOf || function _setPrototypeOf2(o3, p3) {
    o3.__proto__ = p3;
    return o3;
  };
  return _setPrototypeOf$2(o2, p2);
}
function _createSuper$1(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$1();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$1(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$1(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$1(this, result);
  };
}
function _possibleConstructorReturn$1(self2, call) {
  if (call && (_typeof$3(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$2(self2);
}
function _assertThisInitialized$2(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$1() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e3) {
    return false;
  }
}
function _getPrototypeOf$1(o2) {
  _getPrototypeOf$1 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o3) {
    return o3.__proto__ || Object.getPrototypeOf(o3);
  };
  return _getPrototypeOf$1(o2);
}
function _defineProperty$1(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var TimestampSecondsParser = /* @__PURE__ */ function(_Parser) {
  _inherits$1(TimestampSecondsParser2, _Parser);
  var _super = _createSuper$1(TimestampSecondsParser2);
  function TimestampSecondsParser2() {
    var _this;
    _classCallCheck$1(this, TimestampSecondsParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty$1(_assertThisInitialized$2(_this), "priority", 40);
    _defineProperty$1(_assertThisInitialized$2(_this), "incompatibleTokens", "*");
    return _this;
  }
  _createClass$1(TimestampSecondsParser2, [{
    key: "parse",
    value: function parse2(dateString) {
      return parseAnyDigitsSigned(dateString);
    }
  }, {
    key: "set",
    value: function set2(_date, _flags, value) {
      return [new Date(value * 1e3), {
        timestampIsSet: true
      }];
    }
  }]);
  return TimestampSecondsParser2;
}(Parser);
function _typeof$2(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$2 = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$2 = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$2(obj);
}
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties(target, props) {
  for (var i3 = 0; i3 < props.length; i3++) {
    var descriptor = props[i3];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties(Constructor, staticProps);
  return Constructor;
}
function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  if (superClass)
    _setPrototypeOf$1(subClass, superClass);
}
function _setPrototypeOf$1(o2, p2) {
  _setPrototypeOf$1 = Object.setPrototypeOf || function _setPrototypeOf2(o3, p3) {
    o3.__proto__ = p3;
    return o3;
  };
  return _setPrototypeOf$1(o2, p2);
}
function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _possibleConstructorReturn(self2, call) {
  if (call && (_typeof$2(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$1(self2);
}
function _assertThisInitialized$1(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e3) {
    return false;
  }
}
function _getPrototypeOf(o2) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o3) {
    return o3.__proto__ || Object.getPrototypeOf(o3);
  };
  return _getPrototypeOf(o2);
}
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var TimestampMillisecondsParser = /* @__PURE__ */ function(_Parser) {
  _inherits(TimestampMillisecondsParser2, _Parser);
  var _super = _createSuper(TimestampMillisecondsParser2);
  function TimestampMillisecondsParser2() {
    var _this;
    _classCallCheck(this, TimestampMillisecondsParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized$1(_this), "priority", 20);
    _defineProperty(_assertThisInitialized$1(_this), "incompatibleTokens", "*");
    return _this;
  }
  _createClass(TimestampMillisecondsParser2, [{
    key: "parse",
    value: function parse2(dateString) {
      return parseAnyDigitsSigned(dateString);
    }
  }, {
    key: "set",
    value: function set2(_date, _flags, value) {
      return [new Date(value), {
        timestampIsSet: true
      }];
    }
  }]);
  return TimestampMillisecondsParser2;
}(Parser);
var parsers = {
  G: new EraParser(),
  y: new YearParser(),
  Y: new LocalWeekYearParser(),
  R: new ISOWeekYearParser(),
  u: new ExtendedYearParser(),
  Q: new QuarterParser(),
  q: new StandAloneQuarterParser(),
  M: new MonthParser(),
  L: new StandAloneMonthParser(),
  w: new LocalWeekParser(),
  I: new ISOWeekParser(),
  d: new DateParser(),
  D: new DayOfYearParser(),
  E: new DayParser(),
  e: new LocalDayParser(),
  c: new StandAloneLocalDayParser(),
  i: new ISODayParser(),
  a: new AMPMParser(),
  b: new AMPMMidnightParser(),
  B: new DayPeriodParser(),
  h: new Hour1to12Parser(),
  H: new Hour0to23Parser(),
  K: new Hour0To11Parser(),
  k: new Hour1To24Parser(),
  m: new MinuteParser(),
  s: new SecondParser(),
  S: new FractionOfSecondParser(),
  X: new ISOTimezoneWithZParser(),
  x: new ISOTimezoneParser(),
  t: new TimestampSecondsParser(),
  T: new TimestampMillisecondsParser()
};
function _typeof$1(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$1 = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$1 = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$1(obj);
}
function _createForOfIteratorHelper(o2, allowArrayLike) {
  var it2;
  if (typeof Symbol === "undefined" || o2[Symbol.iterator] == null) {
    if (Array.isArray(o2) || (it2 = _unsupportedIterableToArray(o2)) || allowArrayLike && o2 && typeof o2.length === "number") {
      if (it2)
        o2 = it2;
      var i3 = 0;
      var F2 = function F3() {
      };
      return { s: F2, n: function n2() {
        if (i3 >= o2.length)
          return { done: true };
        return { done: false, value: o2[i3++] };
      }, e: function e3(_e2) {
        throw _e2;
      }, f: F2 };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var normalCompletion = true, didErr = false, err;
  return { s: function s4() {
    it2 = o2[Symbol.iterator]();
  }, n: function n2() {
    var step = it2.next();
    normalCompletion = step.done;
    return step;
  }, e: function e3(_e2) {
    didErr = true;
    err = _e2;
  }, f: function f2() {
    try {
      if (!normalCompletion && it2.return != null)
        it2.return();
    } finally {
      if (didErr)
        throw err;
    }
  } };
}
function _unsupportedIterableToArray(o2, minLen) {
  if (!o2)
    return;
  if (typeof o2 === "string")
    return _arrayLikeToArray(o2, minLen);
  var n2 = Object.prototype.toString.call(o2).slice(8, -1);
  if (n2 === "Object" && o2.constructor)
    n2 = o2.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o2);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray(o2, minLen);
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i3 = 0, arr2 = new Array(len); i3 < len; i3++) {
    arr2[i3] = arr[i3];
  }
  return arr2;
}
var formattingTokensRegExp = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g;
var longFormattingTokensRegExp = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g;
var escapedStringRegExp = /^'([^]*?)'?$/;
var doubleQuoteRegExp = /''/g;
var notWhitespaceRegExp = /\S/;
var unescapedLatinCharacterRegExp = /[a-zA-Z]/;
function parse(dirtyDateString, dirtyFormatString, dirtyReferenceDate, options) {
  var _ref2, _options$locale, _ref22, _ref3, _ref4, _options$firstWeekCon, _options$locale2, _options$locale2$opti, _defaultOptions$local, _defaultOptions$local2, _ref5, _ref6, _ref7, _options$weekStartsOn, _options$locale3, _options$locale3$opti, _defaultOptions$local3, _defaultOptions$local4;
  requiredArgs(3, arguments);
  var dateString = String(dirtyDateString);
  var formatString = String(dirtyFormatString);
  var defaultOptions2 = getDefaultOptions();
  var locale2 = (_ref2 = (_options$locale = options === null || options === void 0 ? void 0 : options.locale) !== null && _options$locale !== void 0 ? _options$locale : defaultOptions2.locale) !== null && _ref2 !== void 0 ? _ref2 : defaultLocale;
  if (!locale2.match) {
    throw new RangeError("locale must contain match property");
  }
  var firstWeekContainsDate = toInteger((_ref22 = (_ref3 = (_ref4 = (_options$firstWeekCon = options === null || options === void 0 ? void 0 : options.firstWeekContainsDate) !== null && _options$firstWeekCon !== void 0 ? _options$firstWeekCon : options === null || options === void 0 ? void 0 : (_options$locale2 = options.locale) === null || _options$locale2 === void 0 ? void 0 : (_options$locale2$opti = _options$locale2.options) === null || _options$locale2$opti === void 0 ? void 0 : _options$locale2$opti.firstWeekContainsDate) !== null && _ref4 !== void 0 ? _ref4 : defaultOptions2.firstWeekContainsDate) !== null && _ref3 !== void 0 ? _ref3 : (_defaultOptions$local = defaultOptions2.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.firstWeekContainsDate) !== null && _ref22 !== void 0 ? _ref22 : 1);
  if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7)) {
    throw new RangeError("firstWeekContainsDate must be between 1 and 7 inclusively");
  }
  var weekStartsOn = toInteger((_ref5 = (_ref6 = (_ref7 = (_options$weekStartsOn = options === null || options === void 0 ? void 0 : options.weekStartsOn) !== null && _options$weekStartsOn !== void 0 ? _options$weekStartsOn : options === null || options === void 0 ? void 0 : (_options$locale3 = options.locale) === null || _options$locale3 === void 0 ? void 0 : (_options$locale3$opti = _options$locale3.options) === null || _options$locale3$opti === void 0 ? void 0 : _options$locale3$opti.weekStartsOn) !== null && _ref7 !== void 0 ? _ref7 : defaultOptions2.weekStartsOn) !== null && _ref6 !== void 0 ? _ref6 : (_defaultOptions$local3 = defaultOptions2.locale) === null || _defaultOptions$local3 === void 0 ? void 0 : (_defaultOptions$local4 = _defaultOptions$local3.options) === null || _defaultOptions$local4 === void 0 ? void 0 : _defaultOptions$local4.weekStartsOn) !== null && _ref5 !== void 0 ? _ref5 : 0);
  if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
    throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
  }
  if (formatString === "") {
    if (dateString === "") {
      return toDate(dirtyReferenceDate);
    } else {
      return new Date(NaN);
    }
  }
  var subFnOptions = {
    firstWeekContainsDate,
    weekStartsOn,
    locale: locale2
  };
  var setters = [new DateToSystemTimezoneSetter()];
  var tokens = formatString.match(longFormattingTokensRegExp).map(function(substring) {
    var firstCharacter = substring[0];
    if (firstCharacter in longFormatters$1) {
      var longFormatter = longFormatters$1[firstCharacter];
      return longFormatter(substring, locale2.formatLong);
    }
    return substring;
  }).join("").match(formattingTokensRegExp);
  var usedTokens = [];
  var _iterator = _createForOfIteratorHelper(tokens), _step;
  try {
    var _loop = function _loop2() {
      var token2 = _step.value;
      if (!(options !== null && options !== void 0 && options.useAdditionalWeekYearTokens) && isProtectedWeekYearToken(token2)) {
        throwProtectedError(token2, formatString, dirtyDateString);
      }
      if (!(options !== null && options !== void 0 && options.useAdditionalDayOfYearTokens) && isProtectedDayOfYearToken(token2)) {
        throwProtectedError(token2, formatString, dirtyDateString);
      }
      var firstCharacter = token2[0];
      var parser = parsers[firstCharacter];
      if (parser) {
        var incompatibleTokens = parser.incompatibleTokens;
        if (Array.isArray(incompatibleTokens)) {
          var incompatibleToken = usedTokens.find(function(usedToken) {
            return incompatibleTokens.includes(usedToken.token) || usedToken.token === firstCharacter;
          });
          if (incompatibleToken) {
            throw new RangeError("The format string mustn't contain `".concat(incompatibleToken.fullToken, "` and `").concat(token2, "` at the same time"));
          }
        } else if (parser.incompatibleTokens === "*" && usedTokens.length > 0) {
          throw new RangeError("The format string mustn't contain `".concat(token2, "` and any other token at the same time"));
        }
        usedTokens.push({
          token: firstCharacter,
          fullToken: token2
        });
        var parseResult = parser.run(dateString, token2, locale2.match, subFnOptions);
        if (!parseResult) {
          return {
            v: new Date(NaN)
          };
        }
        setters.push(parseResult.setter);
        dateString = parseResult.rest;
      } else {
        if (firstCharacter.match(unescapedLatinCharacterRegExp)) {
          throw new RangeError("Format string contains an unescaped latin alphabet character `" + firstCharacter + "`");
        }
        if (token2 === "''") {
          token2 = "'";
        } else if (firstCharacter === "'") {
          token2 = cleanEscapedString(token2);
        }
        if (dateString.indexOf(token2) === 0) {
          dateString = dateString.slice(token2.length);
        } else {
          return {
            v: new Date(NaN)
          };
        }
      }
    };
    for (_iterator.s(); !(_step = _iterator.n()).done; ) {
      var _ret = _loop();
      if (_typeof$1(_ret) === "object")
        return _ret.v;
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  if (dateString.length > 0 && notWhitespaceRegExp.test(dateString)) {
    return new Date(NaN);
  }
  var uniquePrioritySetters = setters.map(function(setter2) {
    return setter2.priority;
  }).sort(function(a4, b3) {
    return b3 - a4;
  }).filter(function(priority, index2, array) {
    return array.indexOf(priority) === index2;
  }).map(function(priority) {
    return setters.filter(function(setter2) {
      return setter2.priority === priority;
    }).sort(function(a4, b3) {
      return b3.subPriority - a4.subPriority;
    });
  }).map(function(setterArray) {
    return setterArray[0];
  });
  var date = toDate(dirtyReferenceDate);
  if (isNaN(date.getTime())) {
    return new Date(NaN);
  }
  var utcDate = subMilliseconds(date, getTimezoneOffsetInMilliseconds(date));
  var flags = {};
  var _iterator2 = _createForOfIteratorHelper(uniquePrioritySetters), _step2;
  try {
    for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
      var setter = _step2.value;
      if (!setter.validate(utcDate, subFnOptions)) {
        return new Date(NaN);
      }
      var result = setter.set(utcDate, flags, subFnOptions);
      if (Array.isArray(result)) {
        utcDate = result[0];
        assign(flags, result[1]);
      } else {
        utcDate = result;
      }
    }
  } catch (err) {
    _iterator2.e(err);
  } finally {
    _iterator2.f();
  }
  return utcDate;
}
function cleanEscapedString(input) {
  return input.match(escapedStringRegExp)[1].replace(doubleQuoteRegExp, "'");
}
function parseISO(argument, options) {
  var _options$additionalDi;
  requiredArgs(1, arguments);
  var additionalDigits = toInteger((_options$additionalDi = options === null || options === void 0 ? void 0 : options.additionalDigits) !== null && _options$additionalDi !== void 0 ? _options$additionalDi : 2);
  if (additionalDigits !== 2 && additionalDigits !== 1 && additionalDigits !== 0) {
    throw new RangeError("additionalDigits must be 0, 1 or 2");
  }
  if (!(typeof argument === "string" || Object.prototype.toString.call(argument) === "[object String]")) {
    return new Date(NaN);
  }
  var dateStrings = splitDateString(argument);
  var date;
  if (dateStrings.date) {
    var parseYearResult = parseYear(dateStrings.date, additionalDigits);
    date = parseDate(parseYearResult.restDateString, parseYearResult.year);
  }
  if (!date || isNaN(date.getTime())) {
    return new Date(NaN);
  }
  var timestamp = date.getTime();
  var time = 0;
  var offset2;
  if (dateStrings.time) {
    time = parseTime(dateStrings.time);
    if (isNaN(time)) {
      return new Date(NaN);
    }
  }
  if (dateStrings.timezone) {
    offset2 = parseTimezone(dateStrings.timezone);
    if (isNaN(offset2)) {
      return new Date(NaN);
    }
  } else {
    var dirtyDate = new Date(timestamp + time);
    var result = new Date(0);
    result.setFullYear(dirtyDate.getUTCFullYear(), dirtyDate.getUTCMonth(), dirtyDate.getUTCDate());
    result.setHours(dirtyDate.getUTCHours(), dirtyDate.getUTCMinutes(), dirtyDate.getUTCSeconds(), dirtyDate.getUTCMilliseconds());
    return result;
  }
  return new Date(timestamp + time + offset2);
}
var patterns = {
  dateTimeDelimiter: /[T ]/,
  timeZoneDelimiter: /[Z ]/i,
  timezone: /([Z+-].*)$/
};
var dateRegex = /^-?(?:(\d{3})|(\d{2})(?:-?(\d{2}))?|W(\d{2})(?:-?(\d{1}))?|)$/;
var timeRegex = /^(\d{2}(?:[.,]\d*)?)(?::?(\d{2}(?:[.,]\d*)?))?(?::?(\d{2}(?:[.,]\d*)?))?$/;
var timezoneRegex = /^([+-])(\d{2})(?::?(\d{2}))?$/;
function splitDateString(dateString) {
  var dateStrings = {};
  var array = dateString.split(patterns.dateTimeDelimiter);
  var timeString;
  if (array.length > 2) {
    return dateStrings;
  }
  if (/:/.test(array[0])) {
    timeString = array[0];
  } else {
    dateStrings.date = array[0];
    timeString = array[1];
    if (patterns.timeZoneDelimiter.test(dateStrings.date)) {
      dateStrings.date = dateString.split(patterns.timeZoneDelimiter)[0];
      timeString = dateString.substr(dateStrings.date.length, dateString.length);
    }
  }
  if (timeString) {
    var token2 = patterns.timezone.exec(timeString);
    if (token2) {
      dateStrings.time = timeString.replace(token2[1], "");
      dateStrings.timezone = token2[1];
    } else {
      dateStrings.time = timeString;
    }
  }
  return dateStrings;
}
function parseYear(dateString, additionalDigits) {
  var regex = new RegExp("^(?:(\\d{4}|[+-]\\d{" + (4 + additionalDigits) + "})|(\\d{2}|[+-]\\d{" + (2 + additionalDigits) + "})$)");
  var captures = dateString.match(regex);
  if (!captures)
    return {
      year: NaN,
      restDateString: ""
    };
  var year = captures[1] ? parseInt(captures[1]) : null;
  var century = captures[2] ? parseInt(captures[2]) : null;
  return {
    year: century === null ? year : century * 100,
    restDateString: dateString.slice((captures[1] || captures[2]).length)
  };
}
function parseDate(dateString, year) {
  if (year === null)
    return new Date(NaN);
  var captures = dateString.match(dateRegex);
  if (!captures)
    return new Date(NaN);
  var isWeekDate = !!captures[4];
  var dayOfYear = parseDateUnit(captures[1]);
  var month = parseDateUnit(captures[2]) - 1;
  var day = parseDateUnit(captures[3]);
  var week = parseDateUnit(captures[4]);
  var dayOfWeek = parseDateUnit(captures[5]) - 1;
  if (isWeekDate) {
    if (!validateWeekDate(year, week, dayOfWeek)) {
      return new Date(NaN);
    }
    return dayOfISOWeekYear(year, week, dayOfWeek);
  } else {
    var date = new Date(0);
    if (!validateDate(year, month, day) || !validateDayOfYearDate(year, dayOfYear)) {
      return new Date(NaN);
    }
    date.setUTCFullYear(year, month, Math.max(dayOfYear, day));
    return date;
  }
}
function parseDateUnit(value) {
  return value ? parseInt(value) : 1;
}
function parseTime(timeString) {
  var captures = timeString.match(timeRegex);
  if (!captures)
    return NaN;
  var hours = parseTimeUnit(captures[1]);
  var minutes = parseTimeUnit(captures[2]);
  var seconds = parseTimeUnit(captures[3]);
  if (!validateTime(hours, minutes, seconds)) {
    return NaN;
  }
  return hours * millisecondsInHour + minutes * millisecondsInMinute + seconds * 1e3;
}
function parseTimeUnit(value) {
  return value && parseFloat(value.replace(",", ".")) || 0;
}
function parseTimezone(timezoneString) {
  if (timezoneString === "Z")
    return 0;
  var captures = timezoneString.match(timezoneRegex);
  if (!captures)
    return 0;
  var sign = captures[1] === "+" ? -1 : 1;
  var hours = parseInt(captures[2]);
  var minutes = captures[3] && parseInt(captures[3]) || 0;
  if (!validateTimezone(hours, minutes)) {
    return NaN;
  }
  return sign * (hours * millisecondsInHour + minutes * millisecondsInMinute);
}
function dayOfISOWeekYear(isoWeekYear, week, day) {
  var date = new Date(0);
  date.setUTCFullYear(isoWeekYear, 0, 4);
  var fourthOfJanuaryDay = date.getUTCDay() || 7;
  var diff = (week - 1) * 7 + day + 1 - fourthOfJanuaryDay;
  date.setUTCDate(date.getUTCDate() + diff);
  return date;
}
var daysInMonths = [31, null, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
function isLeapYearIndex(year) {
  return year % 400 === 0 || year % 4 === 0 && year % 100 !== 0;
}
function validateDate(year, month, date) {
  return month >= 0 && month <= 11 && date >= 1 && date <= (daysInMonths[month] || (isLeapYearIndex(year) ? 29 : 28));
}
function validateDayOfYearDate(year, dayOfYear) {
  return dayOfYear >= 1 && dayOfYear <= (isLeapYearIndex(year) ? 366 : 365);
}
function validateWeekDate(_year, week, day) {
  return week >= 1 && week <= 53 && day >= 0 && day <= 6;
}
function validateTime(hours, minutes, seconds) {
  if (hours === 24) {
    return minutes === 0 && seconds === 0;
  }
  return seconds >= 0 && seconds < 60 && minutes >= 0 && minutes < 60 && hours >= 0 && hours < 25;
}
function validateTimezone(_hours, minutes) {
  return minutes >= 0 && minutes <= 59;
}
function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  _setPrototypeOf(subClass, superClass);
}
function _setPrototypeOf(o2, p2) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o3, p3) {
    o3.__proto__ = p3;
    return o3;
  };
  return _setPrototypeOf(o2, p2);
}
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i3;
  for (i3 = 0; i3 < sourceKeys.length; i3++) {
    key = sourceKeys[i3];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
function _assertThisInitialized(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function isNodeFound(current, componentNode, ignoreClass) {
  if (current === componentNode) {
    return true;
  }
  if (current.correspondingElement) {
    return current.correspondingElement.classList.contains(ignoreClass);
  }
  return current.classList.contains(ignoreClass);
}
function findHighest(current, componentNode, ignoreClass) {
  if (current === componentNode) {
    return true;
  }
  while (current.parentNode || current.host) {
    if (current.parentNode && isNodeFound(current, componentNode, ignoreClass)) {
      return true;
    }
    current = current.parentNode || current.host;
  }
  return current;
}
function clickedScrollbar(evt) {
  return document.documentElement.clientWidth <= evt.clientX || document.documentElement.clientHeight <= evt.clientY;
}
var testPassiveEventSupport = function testPassiveEventSupport2() {
  if (typeof window === "undefined" || typeof window.addEventListener !== "function") {
    return;
  }
  var passive2 = false;
  var options = Object.defineProperty({}, "passive", {
    get: function get3() {
      passive2 = true;
    }
  });
  var noop2 = function noop3() {
  };
  window.addEventListener("testPassiveEventSupport", noop2, options);
  window.removeEventListener("testPassiveEventSupport", noop2, options);
  return passive2;
};
function autoInc(seed) {
  if (seed === void 0) {
    seed = 0;
  }
  return function() {
    return ++seed;
  };
}
var uid = autoInc();
var passiveEventSupport;
var handlersMap = {};
var enabledInstances = {};
var touchEvents = ["touchstart", "touchmove"];
var IGNORE_CLASS_NAME = "ignore-react-onclickoutside";
function getEventHandlerOptions(instance, eventName) {
  var handlerOptions = null;
  var isTouchEvent2 = touchEvents.indexOf(eventName) !== -1;
  if (isTouchEvent2 && passiveEventSupport) {
    handlerOptions = {
      passive: !instance.props.preventDefault
    };
  }
  return handlerOptions;
}
function onClickOutsideHOC(WrappedComponent, config) {
  var _class, _temp;
  var componentName = WrappedComponent.displayName || WrappedComponent.name || "Component";
  return _temp = _class = /* @__PURE__ */ function(_Component) {
    _inheritsLoose(onClickOutside2, _Component);
    function onClickOutside2(props) {
      var _this;
      _this = _Component.call(this, props) || this;
      _this.__outsideClickHandler = function(event) {
        if (typeof _this.__clickOutsideHandlerProp === "function") {
          _this.__clickOutsideHandlerProp(event);
          return;
        }
        var instance = _this.getInstance();
        if (typeof instance.props.handleClickOutside === "function") {
          instance.props.handleClickOutside(event);
          return;
        }
        if (typeof instance.handleClickOutside === "function") {
          instance.handleClickOutside(event);
          return;
        }
        throw new Error("WrappedComponent: " + componentName + " lacks a handleClickOutside(event) function for processing outside click events.");
      };
      _this.__getComponentNode = function() {
        var instance = _this.getInstance();
        if (config && typeof config.setClickOutsideRef === "function") {
          return config.setClickOutsideRef()(instance);
        }
        if (typeof instance.setClickOutsideRef === "function") {
          return instance.setClickOutsideRef();
        }
        return reactDom.exports.findDOMNode(instance);
      };
      _this.enableOnClickOutside = function() {
        if (typeof document === "undefined" || enabledInstances[_this._uid]) {
          return;
        }
        if (typeof passiveEventSupport === "undefined") {
          passiveEventSupport = testPassiveEventSupport();
        }
        enabledInstances[_this._uid] = true;
        var events2 = _this.props.eventTypes;
        if (!events2.forEach) {
          events2 = [events2];
        }
        handlersMap[_this._uid] = function(event) {
          if (_this.componentNode === null)
            return;
          if (_this.props.preventDefault) {
            event.preventDefault();
          }
          if (_this.props.stopPropagation) {
            event.stopPropagation();
          }
          if (_this.props.excludeScrollbar && clickedScrollbar(event))
            return;
          var current = event.composed && event.composedPath && event.composedPath().shift() || event.target;
          if (findHighest(current, _this.componentNode, _this.props.outsideClickIgnoreClass) !== document) {
            return;
          }
          _this.__outsideClickHandler(event);
        };
        events2.forEach(function(eventName) {
          document.addEventListener(eventName, handlersMap[_this._uid], getEventHandlerOptions(_assertThisInitialized(_this), eventName));
        });
      };
      _this.disableOnClickOutside = function() {
        delete enabledInstances[_this._uid];
        var fn3 = handlersMap[_this._uid];
        if (fn3 && typeof document !== "undefined") {
          var events2 = _this.props.eventTypes;
          if (!events2.forEach) {
            events2 = [events2];
          }
          events2.forEach(function(eventName) {
            return document.removeEventListener(eventName, fn3, getEventHandlerOptions(_assertThisInitialized(_this), eventName));
          });
          delete handlersMap[_this._uid];
        }
      };
      _this.getRef = function(ref) {
        return _this.instanceRef = ref;
      };
      _this._uid = uid();
      return _this;
    }
    var _proto = onClickOutside2.prototype;
    _proto.getInstance = function getInstance() {
      if (WrappedComponent.prototype && !WrappedComponent.prototype.isReactComponent) {
        return this;
      }
      var ref = this.instanceRef;
      return ref.getInstance ? ref.getInstance() : ref;
    };
    _proto.componentDidMount = function componentDidMount() {
      if (typeof document === "undefined" || !document.createElement) {
        return;
      }
      var instance = this.getInstance();
      if (config && typeof config.handleClickOutside === "function") {
        this.__clickOutsideHandlerProp = config.handleClickOutside(instance);
        if (typeof this.__clickOutsideHandlerProp !== "function") {
          throw new Error("WrappedComponent: " + componentName + " lacks a function for processing outside click events specified by the handleClickOutside config option.");
        }
      }
      this.componentNode = this.__getComponentNode();
      if (this.props.disableOnClickOutside)
        return;
      this.enableOnClickOutside();
    };
    _proto.componentDidUpdate = function componentDidUpdate() {
      this.componentNode = this.__getComponentNode();
    };
    _proto.componentWillUnmount = function componentWillUnmount() {
      this.disableOnClickOutside();
    };
    _proto.render = function render2() {
      var _this$props = this.props;
      _this$props.excludeScrollbar;
      var props = _objectWithoutPropertiesLoose(_this$props, ["excludeScrollbar"]);
      if (WrappedComponent.prototype && WrappedComponent.prototype.isReactComponent) {
        props.ref = this.getRef;
      } else {
        props.wrappedRef = this.getRef;
      }
      props.disableOnClickOutside = this.disableOnClickOutside;
      props.enableOnClickOutside = this.enableOnClickOutside;
      return react.exports.createElement(WrappedComponent, props);
    };
    return onClickOutside2;
  }(react.exports.Component), _class.displayName = "OnClickOutside(" + componentName + ")", _class.defaultProps = {
    eventTypes: ["mousedown", "touchstart"],
    excludeScrollbar: config && config.excludeScrollbar || false,
    outsideClickIgnoreClass: IGNORE_CLASS_NAME,
    preventDefault: false,
    stopPropagation: false
  }, _class.getClass = function() {
    return WrappedComponent.getClass ? WrappedComponent.getClass() : WrappedComponent;
  }, _temp;
}
var ManagerReferenceNodeContext = react.exports.createContext();
var ManagerReferenceNodeSetterContext = react.exports.createContext();
function Manager(_ref2) {
  var children = _ref2.children;
  var _React$useState = react.exports.useState(null), referenceNode = _React$useState[0], setReferenceNode = _React$useState[1];
  var hasUnmounted = react.exports.useRef(false);
  react.exports.useEffect(function() {
    return function() {
      hasUnmounted.current = true;
    };
  }, []);
  var handleSetReferenceNode = react.exports.useCallback(function(node2) {
    if (!hasUnmounted.current) {
      setReferenceNode(node2);
    }
  }, []);
  return /* @__PURE__ */ react.exports.createElement(ManagerReferenceNodeContext.Provider, {
    value: referenceNode
  }, /* @__PURE__ */ react.exports.createElement(ManagerReferenceNodeSetterContext.Provider, {
    value: handleSetReferenceNode
  }, children));
}
var unwrapArray = function unwrapArray2(arg) {
  return Array.isArray(arg) ? arg[0] : arg;
};
var safeInvoke = function safeInvoke2(fn3) {
  if (typeof fn3 === "function") {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }
    return fn3.apply(void 0, args);
  }
};
var setRef = function setRef2(ref, node2) {
  if (typeof ref === "function") {
    return safeInvoke(ref, node2);
  } else if (ref != null) {
    ref.current = node2;
  }
};
var fromEntries = function fromEntries2(entries) {
  return entries.reduce(function(acc, _ref2) {
    var key = _ref2[0], value = _ref2[1];
    acc[key] = value;
    return acc;
  }, {});
};
var useIsomorphicLayoutEffect = typeof window !== "undefined" && window.document && window.document.createElement ? react.exports.useLayoutEffect : react.exports.useEffect;
var hasElementType = typeof Element !== "undefined";
var hasMap = typeof Map === "function";
var hasSet = typeof Set === "function";
var hasArrayBuffer = typeof ArrayBuffer === "function" && !!ArrayBuffer.isView;
function equal(a4, b3) {
  if (a4 === b3)
    return true;
  if (a4 && b3 && typeof a4 == "object" && typeof b3 == "object") {
    if (a4.constructor !== b3.constructor)
      return false;
    var length2, i3, keys2;
    if (Array.isArray(a4)) {
      length2 = a4.length;
      if (length2 != b3.length)
        return false;
      for (i3 = length2; i3-- !== 0; )
        if (!equal(a4[i3], b3[i3]))
          return false;
      return true;
    }
    var it2;
    if (hasMap && a4 instanceof Map && b3 instanceof Map) {
      if (a4.size !== b3.size)
        return false;
      it2 = a4.entries();
      while (!(i3 = it2.next()).done)
        if (!b3.has(i3.value[0]))
          return false;
      it2 = a4.entries();
      while (!(i3 = it2.next()).done)
        if (!equal(i3.value[1], b3.get(i3.value[0])))
          return false;
      return true;
    }
    if (hasSet && a4 instanceof Set && b3 instanceof Set) {
      if (a4.size !== b3.size)
        return false;
      it2 = a4.entries();
      while (!(i3 = it2.next()).done)
        if (!b3.has(i3.value[0]))
          return false;
      return true;
    }
    if (hasArrayBuffer && ArrayBuffer.isView(a4) && ArrayBuffer.isView(b3)) {
      length2 = a4.length;
      if (length2 != b3.length)
        return false;
      for (i3 = length2; i3-- !== 0; )
        if (a4[i3] !== b3[i3])
          return false;
      return true;
    }
    if (a4.constructor === RegExp)
      return a4.source === b3.source && a4.flags === b3.flags;
    if (a4.valueOf !== Object.prototype.valueOf)
      return a4.valueOf() === b3.valueOf();
    if (a4.toString !== Object.prototype.toString)
      return a4.toString() === b3.toString();
    keys2 = Object.keys(a4);
    length2 = keys2.length;
    if (length2 !== Object.keys(b3).length)
      return false;
    for (i3 = length2; i3-- !== 0; )
      if (!Object.prototype.hasOwnProperty.call(b3, keys2[i3]))
        return false;
    if (hasElementType && a4 instanceof Element)
      return false;
    for (i3 = length2; i3-- !== 0; ) {
      if ((keys2[i3] === "_owner" || keys2[i3] === "__v" || keys2[i3] === "__o") && a4.$$typeof) {
        continue;
      }
      if (!equal(a4[keys2[i3]], b3[keys2[i3]]))
        return false;
    }
    return true;
  }
  return a4 !== a4 && b3 !== b3;
}
var reactFastCompare = function isEqual2(a4, b3) {
  try {
    return equal(a4, b3);
  } catch (error) {
    if ((error.message || "").match(/stack|recursion/i)) {
      console.warn("react-fast-compare cannot handle circular refs");
      return false;
    }
    throw error;
  }
};
var EMPTY_MODIFIERS$1 = [];
var usePopper = function usePopper2(referenceElement, popperElement, options) {
  if (options === void 0) {
    options = {};
  }
  var prevOptions = react.exports.useRef(null);
  var optionsWithDefaults = {
    onFirstUpdate: options.onFirstUpdate,
    placement: options.placement || "bottom",
    strategy: options.strategy || "absolute",
    modifiers: options.modifiers || EMPTY_MODIFIERS$1
  };
  var _React$useState = react.exports.useState({
    styles: {
      popper: {
        position: optionsWithDefaults.strategy,
        left: "0",
        top: "0"
      },
      arrow: {
        position: "absolute"
      }
    },
    attributes: {}
  }), state = _React$useState[0], setState = _React$useState[1];
  var updateStateModifier = react.exports.useMemo(function() {
    return {
      name: "updateState",
      enabled: true,
      phase: "write",
      fn: function fn3(_ref2) {
        var state2 = _ref2.state;
        var elements = Object.keys(state2.elements);
        reactDom.exports.flushSync(function() {
          setState({
            styles: fromEntries(elements.map(function(element) {
              return [element, state2.styles[element] || {}];
            })),
            attributes: fromEntries(elements.map(function(element) {
              return [element, state2.attributes[element]];
            }))
          });
        });
      },
      requires: ["computeStyles"]
    };
  }, []);
  var popperOptions = react.exports.useMemo(function() {
    var newOptions = {
      onFirstUpdate: optionsWithDefaults.onFirstUpdate,
      placement: optionsWithDefaults.placement,
      strategy: optionsWithDefaults.strategy,
      modifiers: [].concat(optionsWithDefaults.modifiers, [updateStateModifier, {
        name: "applyStyles",
        enabled: false
      }])
    };
    if (reactFastCompare(prevOptions.current, newOptions)) {
      return prevOptions.current || newOptions;
    } else {
      prevOptions.current = newOptions;
      return newOptions;
    }
  }, [optionsWithDefaults.onFirstUpdate, optionsWithDefaults.placement, optionsWithDefaults.strategy, optionsWithDefaults.modifiers, updateStateModifier]);
  var popperInstanceRef = react.exports.useRef();
  useIsomorphicLayoutEffect(function() {
    if (popperInstanceRef.current) {
      popperInstanceRef.current.setOptions(popperOptions);
    }
  }, [popperOptions]);
  useIsomorphicLayoutEffect(function() {
    if (referenceElement == null || popperElement == null) {
      return;
    }
    var createPopper$1 = options.createPopper || createPopper;
    var popperInstance = createPopper$1(referenceElement, popperElement, popperOptions);
    popperInstanceRef.current = popperInstance;
    return function() {
      popperInstance.destroy();
      popperInstanceRef.current = null;
    };
  }, [referenceElement, popperElement, options.createPopper]);
  return {
    state: popperInstanceRef.current ? popperInstanceRef.current.state : null,
    styles: state.styles,
    attributes: state.attributes,
    update: popperInstanceRef.current ? popperInstanceRef.current.update : null,
    forceUpdate: popperInstanceRef.current ? popperInstanceRef.current.forceUpdate : null
  };
};
var NOOP = function NOOP2() {
  return void 0;
};
var NOOP_PROMISE = function NOOP_PROMISE2() {
  return Promise.resolve(null);
};
var EMPTY_MODIFIERS = [];
function Popper(_ref2) {
  var _ref$placement = _ref2.placement, placement = _ref$placement === void 0 ? "bottom" : _ref$placement, _ref$strategy = _ref2.strategy, strategy = _ref$strategy === void 0 ? "absolute" : _ref$strategy, _ref$modifiers = _ref2.modifiers, modifiers2 = _ref$modifiers === void 0 ? EMPTY_MODIFIERS : _ref$modifiers, referenceElement = _ref2.referenceElement, onFirstUpdate = _ref2.onFirstUpdate, innerRef = _ref2.innerRef, children = _ref2.children;
  var referenceNode = react.exports.useContext(ManagerReferenceNodeContext);
  var _React$useState = react.exports.useState(null), popperElement = _React$useState[0], setPopperElement = _React$useState[1];
  var _React$useState2 = react.exports.useState(null), arrowElement = _React$useState2[0], setArrowElement = _React$useState2[1];
  react.exports.useEffect(function() {
    setRef(innerRef, popperElement);
  }, [innerRef, popperElement]);
  var options = react.exports.useMemo(function() {
    return {
      placement,
      strategy,
      onFirstUpdate,
      modifiers: [].concat(modifiers2, [{
        name: "arrow",
        enabled: arrowElement != null,
        options: {
          element: arrowElement
        }
      }])
    };
  }, [placement, strategy, onFirstUpdate, modifiers2, arrowElement]);
  var _usePopper = usePopper(referenceElement || referenceNode, popperElement, options), state = _usePopper.state, styles = _usePopper.styles, forceUpdate = _usePopper.forceUpdate, update = _usePopper.update;
  var childrenProps = react.exports.useMemo(function() {
    return {
      ref: setPopperElement,
      style: styles.popper,
      placement: state ? state.placement : placement,
      hasPopperEscaped: state && state.modifiersData.hide ? state.modifiersData.hide.hasPopperEscaped : null,
      isReferenceHidden: state && state.modifiersData.hide ? state.modifiersData.hide.isReferenceHidden : null,
      arrowProps: {
        style: styles.arrow,
        ref: setArrowElement
      },
      forceUpdate: forceUpdate || NOOP,
      update: update || NOOP_PROMISE
    };
  }, [setPopperElement, setArrowElement, placement, state, styles, update, forceUpdate]);
  return unwrapArray(children)(childrenProps);
}
function Reference(_ref2) {
  var children = _ref2.children, innerRef = _ref2.innerRef;
  var setReferenceNode = react.exports.useContext(ManagerReferenceNodeSetterContext);
  var refHandler = react.exports.useCallback(function(node2) {
    setRef(innerRef, node2);
    safeInvoke(setReferenceNode, node2);
  }, [innerRef, setReferenceNode]);
  react.exports.useEffect(function() {
    return function() {
      return setRef(innerRef, null);
    };
  }, []);
  react.exports.useEffect(function() {
  }, [setReferenceNode]);
  return unwrapArray(children)({
    ref: refHandler
  });
}
function _typeof(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof(obj);
}
function set(dirtyDate, values) {
  requiredArgs(2, arguments);
  if (_typeof(values) !== "object" || values === null) {
    throw new RangeError("values parameter must be an object");
  }
  var date = toDate(dirtyDate);
  if (isNaN(date.getTime())) {
    return new Date(NaN);
  }
  if (values.year != null) {
    date.setFullYear(values.year);
  }
  if (values.month != null) {
    date = setMonth(date, values.month);
  }
  if (values.date != null) {
    date.setDate(toInteger(values.date));
  }
  if (values.hours != null) {
    date.setHours(toInteger(values.hours));
  }
  if (values.minutes != null) {
    date.setMinutes(toInteger(values.minutes));
  }
  if (values.seconds != null) {
    date.setSeconds(toInteger(values.seconds));
  }
  if (values.milliseconds != null) {
    date.setMilliseconds(toInteger(values.milliseconds));
  }
  return date;
}
function le(e3, t3) {
  var r2 = Object.keys(e3);
  if (Object.getOwnPropertySymbols) {
    var n2 = Object.getOwnPropertySymbols(e3);
    t3 && (n2 = n2.filter(function(t4) {
      return Object.getOwnPropertyDescriptor(e3, t4).enumerable;
    })), r2.push.apply(r2, n2);
  }
  return r2;
}
function de(e3) {
  for (var t3 = 1; t3 < arguments.length; t3++) {
    var r2 = null != arguments[t3] ? arguments[t3] : {};
    t3 % 2 ? le(Object(r2), true).forEach(function(t4) {
      ye(e3, t4, r2[t4]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(r2)) : le(Object(r2)).forEach(function(t4) {
      Object.defineProperty(e3, t4, Object.getOwnPropertyDescriptor(r2, t4));
    });
  }
  return e3;
}
function ue(e3) {
  return (ue = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e4) {
    return typeof e4;
  } : function(e4) {
    return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : typeof e4;
  })(e3);
}
function he(e3, t3) {
  if (!(e3 instanceof t3))
    throw new TypeError("Cannot call a class as a function");
}
function me(e3, t3) {
  for (var r2 = 0; r2 < t3.length; r2++) {
    var n2 = t3[r2];
    n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(e3, Me(n2.key), n2);
  }
}
function fe(e3, t3, r2) {
  return t3 && me(e3.prototype, t3), r2 && me(e3, r2), Object.defineProperty(e3, "prototype", { writable: false }), e3;
}
function ye(e3, t3, r2) {
  return (t3 = Me(t3)) in e3 ? Object.defineProperty(e3, t3, { value: r2, enumerable: true, configurable: true, writable: true }) : e3[t3] = r2, e3;
}
function ve() {
  return (ve = Object.assign ? Object.assign.bind() : function(e3) {
    for (var t3 = 1; t3 < arguments.length; t3++) {
      var r2 = arguments[t3];
      for (var n2 in r2)
        Object.prototype.hasOwnProperty.call(r2, n2) && (e3[n2] = r2[n2]);
    }
    return e3;
  }).apply(this, arguments);
}
function De(e3, t3) {
  if ("function" != typeof t3 && null !== t3)
    throw new TypeError("Super expression must either be null or a function");
  e3.prototype = Object.create(t3 && t3.prototype, { constructor: { value: e3, writable: true, configurable: true } }), Object.defineProperty(e3, "prototype", { writable: false }), t3 && ge(e3, t3);
}
function we(e3) {
  return (we = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(e4) {
    return e4.__proto__ || Object.getPrototypeOf(e4);
  })(e3);
}
function ge(e3, t3) {
  return (ge = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(e4, t4) {
    return e4.__proto__ = t4, e4;
  })(e3, t3);
}
function ke(e3) {
  if (void 0 === e3)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e3;
}
function be(e3, t3) {
  if (t3 && ("object" == typeof t3 || "function" == typeof t3))
    return t3;
  if (void 0 !== t3)
    throw new TypeError("Derived constructors may only return object or undefined");
  return ke(e3);
}
function Se(e3) {
  var t3 = function() {
    if ("undefined" == typeof Reflect || !Reflect.construct)
      return false;
    if (Reflect.construct.sham)
      return false;
    if ("function" == typeof Proxy)
      return true;
    try {
      return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      })), true;
    } catch (e4) {
      return false;
    }
  }();
  return function() {
    var r2, n2 = we(e3);
    if (t3) {
      var o2 = we(this).constructor;
      r2 = Reflect.construct(n2, arguments, o2);
    } else
      r2 = n2.apply(this, arguments);
    return be(this, r2);
  };
}
function Ce(e3) {
  return function(e4) {
    if (Array.isArray(e4))
      return _e(e4);
  }(e3) || function(e4) {
    if ("undefined" != typeof Symbol && null != e4[Symbol.iterator] || null != e4["@@iterator"])
      return Array.from(e4);
  }(e3) || function(e4, t3) {
    if (!e4)
      return;
    if ("string" == typeof e4)
      return _e(e4, t3);
    var r2 = Object.prototype.toString.call(e4).slice(8, -1);
    "Object" === r2 && e4.constructor && (r2 = e4.constructor.name);
    if ("Map" === r2 || "Set" === r2)
      return Array.from(e4);
    if ("Arguments" === r2 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r2))
      return _e(e4, t3);
  }(e3) || function() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }();
}
function _e(e3, t3) {
  (null == t3 || t3 > e3.length) && (t3 = e3.length);
  for (var r2 = 0, n2 = new Array(t3); r2 < t3; r2++)
    n2[r2] = e3[r2];
  return n2;
}
function Me(e3) {
  var t3 = function(e4, t4) {
    if ("object" != typeof e4 || null === e4)
      return e4;
    var r2 = e4[Symbol.toPrimitive];
    if (void 0 !== r2) {
      var n2 = r2.call(e4, t4 || "default");
      if ("object" != typeof n2)
        return n2;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === t4 ? String : Number)(e4);
  }(e3, "string");
  return "symbol" == typeof t3 ? t3 : String(t3);
}
function Pe(e3) {
  var t3 = e3 ? "string" == typeof e3 || e3 instanceof String ? parseISO(e3) : toDate(e3) : new Date();
  return Ne(t3) ? t3 : null;
}
function Ee(e3, t3, r2, n2, o2) {
  var a4 = Ge(r2) || Ge(ze()), s4 = Array.isArray(t3) ? t3 : [t3];
  o2 = o2 || Pe();
  for (var i3 = 0, p2 = s4.length; i3 < p2; i3++) {
    var c3 = s4[i3], l2 = parse(e3, c3, o2, { locale: a4 });
    if (Ne(l2) && (!n2 || e3 === xe(l2, c3, r2)))
      return l2;
  }
  return null;
}
function Ne(e3, t3) {
  return t3 = t3 || new Date("1/1/1000"), isValid(e3) && !isBefore(e3, t3);
}
function xe(e3, t3, r2) {
  if ("en" === r2)
    return format(e3, t3, { awareOfUnicodeTokens: true });
  var n2 = Ge(r2) || Ge(ze()) || null;
  return r2 && !n2 && console.warn('A locale object was not found for the provided string ["'.concat(r2, '"].')), format(e3, t3, { locale: n2, awareOfUnicodeTokens: true });
}
function Ye(e3, t3) {
  var r2 = t3.dateFormat, n2 = t3.locale;
  return e3 && xe(e3, Array.isArray(r2) ? r2[0] : r2, n2) || "";
}
function Oe(e3, t3) {
  var r2 = t3.hour, n2 = void 0 === r2 ? 0 : r2, o2 = t3.minute, a4 = void 0 === o2 ? 0 : o2, s4 = t3.second;
  return setHours(setMinutes(setSeconds(e3, void 0 === s4 ? 0 : s4), a4), n2);
}
function Ie(e3, t3) {
  var r2 = t3 && Ge(t3) || ze() && Ge(ze());
  return getISOWeek(e3, r2 ? { locale: r2 } : null);
}
function Te(e3, t3) {
  return xe(e3, "ddd", t3);
}
function Le(e3) {
  return startOfDay(e3);
}
function Re(e3, t3, r2) {
  var n2 = Ge(t3 || ze());
  return startOfWeek(e3, { locale: n2, weekStartsOn: r2 });
}
function Fe(e3) {
  return startOfMonth(e3);
}
function Ae(e3) {
  return startOfYear(e3);
}
function Ke(e3) {
  return startOfQuarter(e3);
}
function Be() {
  return startOfDay(Pe());
}
function We(e3, t3) {
  return e3 && t3 ? isSameYear(e3, t3) : !e3 && !t3;
}
function je(e3, t3) {
  return e3 && t3 ? isSameMonth(e3, t3) : !e3 && !t3;
}
function Qe(e3, t3) {
  return e3 && t3 ? isSameQuarter(e3, t3) : !e3 && !t3;
}
function He(e3, t3) {
  return e3 && t3 ? isSameDay(e3, t3) : !e3 && !t3;
}
function Ve(e3, t3) {
  return e3 && t3 ? isEqual(e3, t3) : !e3 && !t3;
}
function qe(e3, t3, r2) {
  var n2, o2 = startOfDay(t3), a4 = endOfDay(r2);
  try {
    n2 = isWithinInterval(e3, { start: o2, end: a4 });
  } catch (e4) {
    n2 = false;
  }
  return n2;
}
function ze() {
  return ("undefined" != typeof window ? window : globalThis).__localeId__;
}
function Ge(e3) {
  if ("string" == typeof e3) {
    var t3 = "undefined" != typeof window ? window : globalThis;
    return t3.__localeData__ ? t3.__localeData__[e3] : null;
  }
  return e3;
}
function Je(e3, t3) {
  return xe(setMonth(Pe(), e3), "LLLL", t3);
}
function Xe(e3, t3) {
  return xe(setMonth(Pe(), e3), "LLL", t3);
}
function Ze(e3, t3) {
  return xe(setQuarter(Pe(), e3), "QQQ", t3);
}
function et(e3) {
  var t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, r2 = t3.minDate, n2 = t3.maxDate, o2 = t3.excludeDates, a4 = t3.excludeDateIntervals, s4 = t3.includeDates, i3 = t3.includeDateIntervals, p2 = t3.filterDate;
  return it(e3, { minDate: r2, maxDate: n2 }) || o2 && o2.some(function(t4) {
    return He(e3, t4);
  }) || a4 && a4.some(function(t4) {
    var r3 = t4.start, n3 = t4.end;
    return isWithinInterval(e3, { start: r3, end: n3 });
  }) || s4 && !s4.some(function(t4) {
    return He(e3, t4);
  }) || i3 && !i3.some(function(t4) {
    var r3 = t4.start, n3 = t4.end;
    return isWithinInterval(e3, { start: r3, end: n3 });
  }) || p2 && !p2(Pe(e3)) || false;
}
function tt2(e3) {
  var t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, r2 = t3.excludeDates, n2 = t3.excludeDateIntervals;
  return n2 && n2.length > 0 ? n2.some(function(t4) {
    var r3 = t4.start, n3 = t4.end;
    return isWithinInterval(e3, { start: r3, end: n3 });
  }) : r2 && r2.some(function(t4) {
    return He(e3, t4);
  }) || false;
}
function rt(e3) {
  var t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, r2 = t3.minDate, n2 = t3.maxDate, o2 = t3.excludeDates, a4 = t3.includeDates, s4 = t3.filterDate;
  return it(e3, { minDate: startOfMonth(r2), maxDate: endOfMonth(n2) }) || o2 && o2.some(function(t4) {
    return je(e3, t4);
  }) || a4 && !a4.some(function(t4) {
    return je(e3, t4);
  }) || s4 && !s4(Pe(e3)) || false;
}
function nt(e3, t3, r2, n2) {
  var o2 = getYear(e3), a4 = getMonth(e3), s4 = getYear(t3), i3 = getMonth(t3), p2 = getYear(n2);
  return o2 === s4 && o2 === p2 ? a4 <= r2 && r2 <= i3 : o2 < s4 ? p2 === o2 && a4 <= r2 || p2 === s4 && i3 >= r2 || p2 < s4 && p2 > o2 : void 0;
}
function ot(e3) {
  var t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, r2 = t3.minDate, n2 = t3.maxDate, o2 = t3.excludeDates, a4 = t3.includeDates, s4 = t3.filterDate;
  return it(e3, { minDate: r2, maxDate: n2 }) || o2 && o2.some(function(t4) {
    return Qe(e3, t4);
  }) || a4 && !a4.some(function(t4) {
    return Qe(e3, t4);
  }) || s4 && !s4(Pe(e3)) || false;
}
function at(e3) {
  var t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, r2 = t3.minDate, n2 = t3.maxDate, o2 = t3.excludeDates, a4 = t3.includeDates, s4 = t3.filterDate, i3 = new Date(e3, 0, 1);
  return it(i3, { minDate: startOfYear(r2), maxDate: endOfYear(n2) }) || o2 && o2.some(function(e4) {
    return We(i3, e4);
  }) || a4 && !a4.some(function(e4) {
    return We(i3, e4);
  }) || s4 && !s4(Pe(i3)) || false;
}
function st(e3, t3, r2, n2) {
  var o2 = getYear(e3), a4 = getQuarter(e3), s4 = getYear(t3), i3 = getQuarter(t3), p2 = getYear(n2);
  return o2 === s4 && o2 === p2 ? a4 <= r2 && r2 <= i3 : o2 < s4 ? p2 === o2 && a4 <= r2 || p2 === s4 && i3 >= r2 || p2 < s4 && p2 > o2 : void 0;
}
function it(e3) {
  var t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, r2 = t3.minDate, n2 = t3.maxDate;
  return r2 && differenceInCalendarDays(e3, r2) < 0 || n2 && differenceInCalendarDays(e3, n2) > 0;
}
function pt(e3, t3) {
  return t3.some(function(t4) {
    return getHours(t4) === getHours(e3) && getMinutes(t4) === getMinutes(e3);
  });
}
function ct(e3) {
  var t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, r2 = t3.excludeTimes, n2 = t3.includeTimes, o2 = t3.filterTime;
  return r2 && pt(e3, r2) || n2 && !pt(e3, n2) || o2 && !o2(e3) || false;
}
function lt(e3, t3) {
  var r2 = t3.minTime, n2 = t3.maxTime;
  if (!r2 || !n2)
    throw new Error("Both minTime and maxTime props required");
  var o2, a4 = Pe(), s4 = setHours(setMinutes(a4, getMinutes(e3)), getHours(e3)), i3 = setHours(setMinutes(a4, getMinutes(r2)), getHours(r2)), p2 = setHours(setMinutes(a4, getMinutes(n2)), getHours(n2));
  try {
    o2 = !isWithinInterval(s4, { start: i3, end: p2 });
  } catch (e4) {
    o2 = false;
  }
  return o2;
}
function dt(e3) {
  var t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, r2 = t3.minDate, n2 = t3.includeDates, o2 = subMonths(e3, 1);
  return r2 && differenceInCalendarMonths(r2, o2) > 0 || n2 && n2.every(function(e4) {
    return differenceInCalendarMonths(e4, o2) > 0;
  }) || false;
}
function ut(e3) {
  var t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, r2 = t3.maxDate, n2 = t3.includeDates, o2 = addMonths(e3, 1);
  return r2 && differenceInCalendarMonths(o2, r2) > 0 || n2 && n2.every(function(e4) {
    return differenceInCalendarMonths(o2, e4) > 0;
  }) || false;
}
function ht(e3) {
  var t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, r2 = t3.minDate, n2 = t3.includeDates, o2 = subYears(e3, 1);
  return r2 && differenceInCalendarYears(r2, o2) > 0 || n2 && n2.every(function(e4) {
    return differenceInCalendarYears(e4, o2) > 0;
  }) || false;
}
function mt(e3) {
  var t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, r2 = t3.maxDate, n2 = t3.includeDates, o2 = addYears(e3, 1);
  return r2 && differenceInCalendarYears(o2, r2) > 0 || n2 && n2.every(function(e4) {
    return differenceInCalendarYears(o2, e4) > 0;
  }) || false;
}
function ft(e3) {
  var t3 = e3.minDate, r2 = e3.includeDates;
  if (r2 && t3) {
    var n2 = r2.filter(function(e4) {
      return differenceInCalendarDays(e4, t3) >= 0;
    });
    return min(n2);
  }
  return r2 ? min(r2) : t3;
}
function yt(e3) {
  var t3 = e3.maxDate, r2 = e3.includeDates;
  if (r2 && t3) {
    var n2 = r2.filter(function(e4) {
      return differenceInCalendarDays(e4, t3) <= 0;
    });
    return max(n2);
  }
  return r2 ? max(r2) : t3;
}
function vt() {
  for (var e3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [], t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "react-datepicker__day--highlighted", r2 = /* @__PURE__ */ new Map(), o2 = 0, a4 = e3.length; o2 < a4; o2++) {
    var s4 = e3[o2];
    if (isDate(s4)) {
      var i3 = xe(s4, "MM.dd.yyyy"), p2 = r2.get(i3) || [];
      p2.includes(t3) || (p2.push(t3), r2.set(i3, p2));
    } else if ("object" === ue(s4)) {
      var c3 = Object.keys(s4), l2 = c3[0], d4 = s4[c3[0]];
      if ("string" == typeof l2 && d4.constructor === Array)
        for (var u3 = 0, h4 = d4.length; u3 < h4; u3++) {
          var m4 = xe(d4[u3], "MM.dd.yyyy"), f2 = r2.get(m4) || [];
          f2.includes(l2) || (f2.push(l2), r2.set(m4, f2));
        }
    }
  }
  return r2;
}
function Dt(e3, t3, r2, n2, o2) {
  for (var a4 = o2.length, p2 = [], c3 = 0; c3 < a4; c3++) {
    var l2 = addMinutes(addHours(e3, getHours(o2[c3])), getMinutes(o2[c3])), d4 = addMinutes(e3, (r2 + 1) * n2);
    isAfter(l2, t3) && isBefore(l2, d4) && p2.push(o2[c3]);
  }
  return p2;
}
function wt(e3) {
  return e3 < 10 ? "0".concat(e3) : "".concat(e3);
}
function gt(e3) {
  var t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 12, r2 = Math.ceil(getYear(e3) / t3) * t3, n2 = r2 - (t3 - 1);
  return { startPeriod: n2, endPeriod: r2 };
}
function kt(e3, t3, r2, n2) {
  for (var o2 = [], a4 = 0; a4 < 2 * t3 + 1; a4++) {
    var s4 = e3 + t3 - a4, i3 = true;
    r2 && (i3 = getYear(r2) <= s4), n2 && i3 && (i3 = getYear(n2) >= s4), i3 && o2.push(s4);
  }
  return o2;
}
var bt = onClickOutsideHOC(function(n2) {
  De(a4, e$3.Component);
  var o2 = Se(a4);
  function a4(r2) {
    var n3;
    he(this, a4), ye(ke(n3 = o2.call(this, r2)), "renderOptions", function() {
      var t3 = n3.props.year, r3 = n3.state.yearsList.map(function(r4) {
        return e$3.createElement("div", { className: t3 === r4 ? "react-datepicker__year-option react-datepicker__year-option--selected_year" : "react-datepicker__year-option", key: r4, onClick: n3.onChange.bind(ke(n3), r4), "aria-selected": t3 === r4 ? "true" : void 0 }, t3 === r4 ? e$3.createElement("span", { className: "react-datepicker__year-option--selected" }, "\u2713") : "", r4);
      }), o3 = n3.props.minDate ? getYear(n3.props.minDate) : null, a5 = n3.props.maxDate ? getYear(n3.props.maxDate) : null;
      return a5 && n3.state.yearsList.find(function(e3) {
        return e3 === a5;
      }) || r3.unshift(e$3.createElement("div", { className: "react-datepicker__year-option", key: "upcoming", onClick: n3.incrementYears }, e$3.createElement("a", { className: "react-datepicker__navigation react-datepicker__navigation--years react-datepicker__navigation--years-upcoming" }))), o3 && n3.state.yearsList.find(function(e3) {
        return e3 === o3;
      }) || r3.push(e$3.createElement("div", { className: "react-datepicker__year-option", key: "previous", onClick: n3.decrementYears }, e$3.createElement("a", { className: "react-datepicker__navigation react-datepicker__navigation--years react-datepicker__navigation--years-previous" }))), r3;
    }), ye(ke(n3), "onChange", function(e3) {
      n3.props.onChange(e3);
    }), ye(ke(n3), "handleClickOutside", function() {
      n3.props.onCancel();
    }), ye(ke(n3), "shiftYears", function(e3) {
      var t3 = n3.state.yearsList.map(function(t4) {
        return t4 + e3;
      });
      n3.setState({ yearsList: t3 });
    }), ye(ke(n3), "incrementYears", function() {
      return n3.shiftYears(1);
    }), ye(ke(n3), "decrementYears", function() {
      return n3.shiftYears(-1);
    });
    var s4 = r2.yearDropdownItemNumber, i3 = r2.scrollableYearDropdown, p2 = s4 || (i3 ? 10 : 5);
    return n3.state = { yearsList: kt(n3.props.year, p2, n3.props.minDate, n3.props.maxDate) }, n3.dropdownRef = react.exports.createRef(), n3;
  }
  return fe(a4, [{ key: "componentDidMount", value: function() {
    var e3 = this.dropdownRef.current;
    if (e3) {
      var t3 = e3.children ? Array.from(e3.children) : null, r2 = t3 ? t3.find(function(e4) {
        return e4.ariaSelected;
      }) : null;
      e3.scrollTop = r2 ? r2.offsetTop + (r2.clientHeight - e3.clientHeight) / 2 : (e3.scrollHeight - e3.clientHeight) / 2;
    }
  } }, { key: "render", value: function() {
    var t3 = r({ "react-datepicker__year-dropdown": true, "react-datepicker__year-dropdown--scrollable": this.props.scrollableYearDropdown });
    return e$3.createElement("div", { className: t3, ref: this.dropdownRef }, this.renderOptions());
  } }]), a4;
}()), St = function(t3) {
  De(n2, e$3.Component);
  var r2 = Se(n2);
  function n2() {
    var t4;
    he(this, n2);
    for (var o2 = arguments.length, a4 = new Array(o2), s4 = 0; s4 < o2; s4++)
      a4[s4] = arguments[s4];
    return ye(ke(t4 = r2.call.apply(r2, [this].concat(a4))), "state", { dropdownVisible: false }), ye(ke(t4), "renderSelectOptions", function() {
      for (var r3 = t4.props.minDate ? getYear(t4.props.minDate) : 1900, n3 = t4.props.maxDate ? getYear(t4.props.maxDate) : 2100, o3 = [], a5 = r3; a5 <= n3; a5++)
        o3.push(e$3.createElement("option", { key: a5, value: a5 }, a5));
      return o3;
    }), ye(ke(t4), "onSelectChange", function(e3) {
      t4.onChange(e3.target.value);
    }), ye(ke(t4), "renderSelectMode", function() {
      return e$3.createElement("select", { value: t4.props.year, className: "react-datepicker__year-select", onChange: t4.onSelectChange }, t4.renderSelectOptions());
    }), ye(ke(t4), "renderReadView", function(r3) {
      return e$3.createElement("div", { key: "read", style: { visibility: r3 ? "visible" : "hidden" }, className: "react-datepicker__year-read-view", onClick: function(e3) {
        return t4.toggleDropdown(e3);
      } }, e$3.createElement("span", { className: "react-datepicker__year-read-view--down-arrow" }), e$3.createElement("span", { className: "react-datepicker__year-read-view--selected-year" }, t4.props.year));
    }), ye(ke(t4), "renderDropdown", function() {
      return e$3.createElement(bt, { key: "dropdown", year: t4.props.year, onChange: t4.onChange, onCancel: t4.toggleDropdown, minDate: t4.props.minDate, maxDate: t4.props.maxDate, scrollableYearDropdown: t4.props.scrollableYearDropdown, yearDropdownItemNumber: t4.props.yearDropdownItemNumber });
    }), ye(ke(t4), "renderScrollMode", function() {
      var e3 = t4.state.dropdownVisible, r3 = [t4.renderReadView(!e3)];
      return e3 && r3.unshift(t4.renderDropdown()), r3;
    }), ye(ke(t4), "onChange", function(e3) {
      t4.toggleDropdown(), e3 !== t4.props.year && t4.props.onChange(e3);
    }), ye(ke(t4), "toggleDropdown", function(e3) {
      t4.setState({ dropdownVisible: !t4.state.dropdownVisible }, function() {
        t4.props.adjustDateOnChange && t4.handleYearChange(t4.props.date, e3);
      });
    }), ye(ke(t4), "handleYearChange", function(e3, r3) {
      t4.onSelect(e3, r3), t4.setOpen();
    }), ye(ke(t4), "onSelect", function(e3, r3) {
      t4.props.onSelect && t4.props.onSelect(e3, r3);
    }), ye(ke(t4), "setOpen", function() {
      t4.props.setOpen && t4.props.setOpen(true);
    }), t4;
  }
  return fe(n2, [{ key: "render", value: function() {
    var t4;
    switch (this.props.dropdownMode) {
      case "scroll":
        t4 = this.renderScrollMode();
        break;
      case "select":
        t4 = this.renderSelectMode();
    }
    return e$3.createElement("div", { className: "react-datepicker__year-dropdown-container react-datepicker__year-dropdown-container--".concat(this.props.dropdownMode) }, t4);
  } }]), n2;
}(), Ct = onClickOutsideHOC(function(t3) {
  De(n2, e$3.Component);
  var r2 = Se(n2);
  function n2() {
    var t4;
    he(this, n2);
    for (var o2 = arguments.length, a4 = new Array(o2), s4 = 0; s4 < o2; s4++)
      a4[s4] = arguments[s4];
    return ye(ke(t4 = r2.call.apply(r2, [this].concat(a4))), "isSelectedMonth", function(e3) {
      return t4.props.month === e3;
    }), ye(ke(t4), "renderOptions", function() {
      return t4.props.monthNames.map(function(r3, n3) {
        return e$3.createElement("div", { className: t4.isSelectedMonth(n3) ? "react-datepicker__month-option react-datepicker__month-option--selected_month" : "react-datepicker__month-option", key: r3, onClick: t4.onChange.bind(ke(t4), n3), "aria-selected": t4.isSelectedMonth(n3) ? "true" : void 0 }, t4.isSelectedMonth(n3) ? e$3.createElement("span", { className: "react-datepicker__month-option--selected" }, "\u2713") : "", r3);
      });
    }), ye(ke(t4), "onChange", function(e3) {
      return t4.props.onChange(e3);
    }), ye(ke(t4), "handleClickOutside", function() {
      return t4.props.onCancel();
    }), t4;
  }
  return fe(n2, [{ key: "render", value: function() {
    return e$3.createElement("div", { className: "react-datepicker__month-dropdown" }, this.renderOptions());
  } }]), n2;
}()), _t = function(t3) {
  De(n2, e$3.Component);
  var r2 = Se(n2);
  function n2() {
    var t4;
    he(this, n2);
    for (var o2 = arguments.length, a4 = new Array(o2), s4 = 0; s4 < o2; s4++)
      a4[s4] = arguments[s4];
    return ye(ke(t4 = r2.call.apply(r2, [this].concat(a4))), "state", { dropdownVisible: false }), ye(ke(t4), "renderSelectOptions", function(t5) {
      return t5.map(function(t6, r3) {
        return e$3.createElement("option", { key: r3, value: r3 }, t6);
      });
    }), ye(ke(t4), "renderSelectMode", function(r3) {
      return e$3.createElement("select", { value: t4.props.month, className: "react-datepicker__month-select", onChange: function(e3) {
        return t4.onChange(e3.target.value);
      } }, t4.renderSelectOptions(r3));
    }), ye(ke(t4), "renderReadView", function(r3, n3) {
      return e$3.createElement("div", { key: "read", style: { visibility: r3 ? "visible" : "hidden" }, className: "react-datepicker__month-read-view", onClick: t4.toggleDropdown }, e$3.createElement("span", { className: "react-datepicker__month-read-view--down-arrow" }), e$3.createElement("span", { className: "react-datepicker__month-read-view--selected-month" }, n3[t4.props.month]));
    }), ye(ke(t4), "renderDropdown", function(r3) {
      return e$3.createElement(Ct, { key: "dropdown", month: t4.props.month, monthNames: r3, onChange: t4.onChange, onCancel: t4.toggleDropdown });
    }), ye(ke(t4), "renderScrollMode", function(e3) {
      var r3 = t4.state.dropdownVisible, n3 = [t4.renderReadView(!r3, e3)];
      return r3 && n3.unshift(t4.renderDropdown(e3)), n3;
    }), ye(ke(t4), "onChange", function(e3) {
      t4.toggleDropdown(), e3 !== t4.props.month && t4.props.onChange(e3);
    }), ye(ke(t4), "toggleDropdown", function() {
      return t4.setState({ dropdownVisible: !t4.state.dropdownVisible });
    }), t4;
  }
  return fe(n2, [{ key: "render", value: function() {
    var t4, r3 = this, n3 = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11].map(this.props.useShortMonthInDropdown ? function(e3) {
      return Xe(e3, r3.props.locale);
    } : function(e3) {
      return Je(e3, r3.props.locale);
    });
    switch (this.props.dropdownMode) {
      case "scroll":
        t4 = this.renderScrollMode(n3);
        break;
      case "select":
        t4 = this.renderSelectMode(n3);
    }
    return e$3.createElement("div", { className: "react-datepicker__month-dropdown-container react-datepicker__month-dropdown-container--".concat(this.props.dropdownMode) }, t4);
  } }]), n2;
}();
function Mt(e3, t3) {
  for (var r2 = [], n2 = Fe(e3), o2 = Fe(t3); !isAfter(n2, o2); )
    r2.push(Pe(n2)), n2 = addMonths(n2, 1);
  return r2;
}
var Pt = onClickOutsideHOC(function(t3) {
  De(o2, e$3.Component);
  var n2 = Se(o2);
  function o2(t4) {
    var r2;
    return he(this, o2), ye(ke(r2 = n2.call(this, t4)), "renderOptions", function() {
      return r2.state.monthYearsList.map(function(t5) {
        var n3 = getTime(t5), o3 = We(r2.props.date, t5) && je(r2.props.date, t5);
        return e$3.createElement("div", { className: o3 ? "react-datepicker__month-year-option--selected_month-year" : "react-datepicker__month-year-option", key: n3, onClick: r2.onChange.bind(ke(r2), n3), "aria-selected": o3 ? "true" : void 0 }, o3 ? e$3.createElement("span", { className: "react-datepicker__month-year-option--selected" }, "\u2713") : "", xe(t5, r2.props.dateFormat, r2.props.locale));
      });
    }), ye(ke(r2), "onChange", function(e3) {
      return r2.props.onChange(e3);
    }), ye(ke(r2), "handleClickOutside", function() {
      r2.props.onCancel();
    }), r2.state = { monthYearsList: Mt(r2.props.minDate, r2.props.maxDate) }, r2;
  }
  return fe(o2, [{ key: "render", value: function() {
    var t4 = r({ "react-datepicker__month-year-dropdown": true, "react-datepicker__month-year-dropdown--scrollable": this.props.scrollableMonthYearDropdown });
    return e$3.createElement("div", { className: t4 }, this.renderOptions());
  } }]), o2;
}()), Et = function(t3) {
  De(n2, e$3.Component);
  var r2 = Se(n2);
  function n2() {
    var t4;
    he(this, n2);
    for (var o2 = arguments.length, a4 = new Array(o2), s4 = 0; s4 < o2; s4++)
      a4[s4] = arguments[s4];
    return ye(ke(t4 = r2.call.apply(r2, [this].concat(a4))), "state", { dropdownVisible: false }), ye(ke(t4), "renderSelectOptions", function() {
      for (var r3 = Fe(t4.props.minDate), n3 = Fe(t4.props.maxDate), o3 = []; !isAfter(r3, n3); ) {
        var a5 = getTime(r3);
        o3.push(e$3.createElement("option", { key: a5, value: a5 }, xe(r3, t4.props.dateFormat, t4.props.locale))), r3 = addMonths(r3, 1);
      }
      return o3;
    }), ye(ke(t4), "onSelectChange", function(e3) {
      t4.onChange(e3.target.value);
    }), ye(ke(t4), "renderSelectMode", function() {
      return e$3.createElement("select", { value: getTime(Fe(t4.props.date)), className: "react-datepicker__month-year-select", onChange: t4.onSelectChange }, t4.renderSelectOptions());
    }), ye(ke(t4), "renderReadView", function(r3) {
      var n3 = xe(t4.props.date, t4.props.dateFormat, t4.props.locale);
      return e$3.createElement("div", { key: "read", style: { visibility: r3 ? "visible" : "hidden" }, className: "react-datepicker__month-year-read-view", onClick: function(e3) {
        return t4.toggleDropdown(e3);
      } }, e$3.createElement("span", { className: "react-datepicker__month-year-read-view--down-arrow" }), e$3.createElement("span", { className: "react-datepicker__month-year-read-view--selected-month-year" }, n3));
    }), ye(ke(t4), "renderDropdown", function() {
      return e$3.createElement(Pt, { key: "dropdown", date: t4.props.date, dateFormat: t4.props.dateFormat, onChange: t4.onChange, onCancel: t4.toggleDropdown, minDate: t4.props.minDate, maxDate: t4.props.maxDate, scrollableMonthYearDropdown: t4.props.scrollableMonthYearDropdown, locale: t4.props.locale });
    }), ye(ke(t4), "renderScrollMode", function() {
      var e3 = t4.state.dropdownVisible, r3 = [t4.renderReadView(!e3)];
      return e3 && r3.unshift(t4.renderDropdown()), r3;
    }), ye(ke(t4), "onChange", function(e3) {
      t4.toggleDropdown();
      var r3 = Pe(parseInt(e3));
      We(t4.props.date, r3) && je(t4.props.date, r3) || t4.props.onChange(r3);
    }), ye(ke(t4), "toggleDropdown", function() {
      return t4.setState({ dropdownVisible: !t4.state.dropdownVisible });
    }), t4;
  }
  return fe(n2, [{ key: "render", value: function() {
    var t4;
    switch (this.props.dropdownMode) {
      case "scroll":
        t4 = this.renderScrollMode();
        break;
      case "select":
        t4 = this.renderSelectMode();
    }
    return e$3.createElement("div", { className: "react-datepicker__month-year-dropdown-container react-datepicker__month-year-dropdown-container--".concat(this.props.dropdownMode) }, t4);
  } }]), n2;
}(), Nt = function(t3) {
  De(o2, e$3.Component);
  var n2 = Se(o2);
  function o2() {
    var t4;
    he(this, o2);
    for (var a4 = arguments.length, s4 = new Array(a4), i3 = 0; i3 < a4; i3++)
      s4[i3] = arguments[i3];
    return ye(ke(t4 = n2.call.apply(n2, [this].concat(s4))), "dayEl", e$3.createRef()), ye(ke(t4), "handleClick", function(e3) {
      !t4.isDisabled() && t4.props.onClick && t4.props.onClick(e3);
    }), ye(ke(t4), "handleMouseEnter", function(e3) {
      !t4.isDisabled() && t4.props.onMouseEnter && t4.props.onMouseEnter(e3);
    }), ye(ke(t4), "handleOnKeyDown", function(e3) {
      " " === e3.key && (e3.preventDefault(), e3.key = "Enter"), t4.props.handleOnKeyDown(e3);
    }), ye(ke(t4), "isSameDay", function(e3) {
      return He(t4.props.day, e3);
    }), ye(ke(t4), "isKeyboardSelected", function() {
      return !t4.props.disabledKeyboardNavigation && !t4.isSameDay(t4.props.selected) && t4.isSameDay(t4.props.preSelection);
    }), ye(ke(t4), "isDisabled", function() {
      return et(t4.props.day, t4.props);
    }), ye(ke(t4), "isExcluded", function() {
      return tt2(t4.props.day, t4.props);
    }), ye(ke(t4), "getHighLightedClass", function(e3) {
      var r2 = t4.props, n3 = r2.day, o3 = r2.highlightDates;
      if (!o3)
        return false;
      var a5 = xe(n3, "MM.dd.yyyy");
      return o3.get(a5);
    }), ye(ke(t4), "isInRange", function() {
      var e3 = t4.props, r2 = e3.day, n3 = e3.startDate, o3 = e3.endDate;
      return !(!n3 || !o3) && qe(r2, n3, o3);
    }), ye(ke(t4), "isInSelectingRange", function() {
      var e3, r2 = t4.props, n3 = r2.day, o3 = r2.selectsStart, a5 = r2.selectsEnd, s5 = r2.selectsRange, i4 = r2.selectsDisabledDaysInRange, p2 = r2.startDate, c3 = r2.endDate, l2 = null !== (e3 = t4.props.selectingDate) && void 0 !== e3 ? e3 : t4.props.preSelection;
      return !(!(o3 || a5 || s5) || !l2 || !i4 && t4.isDisabled()) && (o3 && c3 && (isBefore(l2, c3) || Ve(l2, c3)) ? qe(n3, l2, c3) : (a5 && p2 && (isAfter(l2, p2) || Ve(l2, p2)) || !(!s5 || !p2 || c3 || !isAfter(l2, p2) && !Ve(l2, p2))) && qe(n3, p2, l2));
    }), ye(ke(t4), "isSelectingRangeStart", function() {
      var e3;
      if (!t4.isInSelectingRange())
        return false;
      var r2 = t4.props, n3 = r2.day, o3 = r2.startDate, a5 = r2.selectsStart, s5 = null !== (e3 = t4.props.selectingDate) && void 0 !== e3 ? e3 : t4.props.preSelection;
      return He(n3, a5 ? s5 : o3);
    }), ye(ke(t4), "isSelectingRangeEnd", function() {
      var e3;
      if (!t4.isInSelectingRange())
        return false;
      var r2 = t4.props, n3 = r2.day, o3 = r2.endDate, a5 = r2.selectsEnd, s5 = r2.selectsRange, i4 = null !== (e3 = t4.props.selectingDate) && void 0 !== e3 ? e3 : t4.props.preSelection;
      return He(n3, a5 || s5 ? i4 : o3);
    }), ye(ke(t4), "isRangeStart", function() {
      var e3 = t4.props, r2 = e3.day, n3 = e3.startDate, o3 = e3.endDate;
      return !(!n3 || !o3) && He(n3, r2);
    }), ye(ke(t4), "isRangeEnd", function() {
      var e3 = t4.props, r2 = e3.day, n3 = e3.startDate, o3 = e3.endDate;
      return !(!n3 || !o3) && He(o3, r2);
    }), ye(ke(t4), "isWeekend", function() {
      var e3 = getDay(t4.props.day);
      return 0 === e3 || 6 === e3;
    }), ye(ke(t4), "isAfterMonth", function() {
      return void 0 !== t4.props.month && (t4.props.month + 1) % 12 === getMonth(t4.props.day);
    }), ye(ke(t4), "isBeforeMonth", function() {
      return void 0 !== t4.props.month && (getMonth(t4.props.day) + 1) % 12 === t4.props.month;
    }), ye(ke(t4), "isCurrentDay", function() {
      return t4.isSameDay(Pe());
    }), ye(ke(t4), "isSelected", function() {
      return t4.isSameDay(t4.props.selected);
    }), ye(ke(t4), "getClassNames", function(e3) {
      var n3 = t4.props.dayClassName ? t4.props.dayClassName(e3) : void 0;
      return r("react-datepicker__day", n3, "react-datepicker__day--" + Te(t4.props.day), { "react-datepicker__day--disabled": t4.isDisabled(), "react-datepicker__day--excluded": t4.isExcluded(), "react-datepicker__day--selected": t4.isSelected(), "react-datepicker__day--keyboard-selected": t4.isKeyboardSelected(), "react-datepicker__day--range-start": t4.isRangeStart(), "react-datepicker__day--range-end": t4.isRangeEnd(), "react-datepicker__day--in-range": t4.isInRange(), "react-datepicker__day--in-selecting-range": t4.isInSelectingRange(), "react-datepicker__day--selecting-range-start": t4.isSelectingRangeStart(), "react-datepicker__day--selecting-range-end": t4.isSelectingRangeEnd(), "react-datepicker__day--today": t4.isCurrentDay(), "react-datepicker__day--weekend": t4.isWeekend(), "react-datepicker__day--outside-month": t4.isAfterMonth() || t4.isBeforeMonth() }, t4.getHighLightedClass("react-datepicker__day--highlighted"));
    }), ye(ke(t4), "getAriaLabel", function() {
      var e3 = t4.props, r2 = e3.day, n3 = e3.ariaLabelPrefixWhenEnabled, o3 = void 0 === n3 ? "Choose" : n3, a5 = e3.ariaLabelPrefixWhenDisabled, s5 = void 0 === a5 ? "Not available" : a5, i4 = t4.isDisabled() || t4.isExcluded() ? s5 : o3;
      return "".concat(i4, " ").concat(xe(r2, "PPPP", t4.props.locale));
    }), ye(ke(t4), "getTabIndex", function(e3, r2) {
      var n3 = e3 || t4.props.selected, o3 = r2 || t4.props.preSelection;
      return t4.isKeyboardSelected() || t4.isSameDay(n3) && He(o3, n3) ? 0 : -1;
    }), ye(ke(t4), "handleFocusDay", function() {
      var e3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, r2 = false;
      0 === t4.getTabIndex() && !e3.isInputFocused && t4.isSameDay(t4.props.preSelection) && (document.activeElement && document.activeElement !== document.body || (r2 = true), t4.props.inline && !t4.props.shouldFocusDayInline && (r2 = false), t4.props.containerRef && t4.props.containerRef.current && t4.props.containerRef.current.contains(document.activeElement) && document.activeElement.classList.contains("react-datepicker__day") && (r2 = true)), r2 && t4.dayEl.current.focus({ preventScroll: true });
    }), ye(ke(t4), "renderDayContents", function() {
      return t4.props.monthShowsDuplicateDaysEnd && t4.isAfterMonth() || t4.props.monthShowsDuplicateDaysStart && t4.isBeforeMonth() ? null : t4.props.renderDayContents ? t4.props.renderDayContents(getDate(t4.props.day), t4.props.day) : getDate(t4.props.day);
    }), ye(ke(t4), "render", function() {
      return e$3.createElement("div", { ref: t4.dayEl, className: t4.getClassNames(t4.props.day), onKeyDown: t4.handleOnKeyDown, onClick: t4.handleClick, onMouseEnter: t4.handleMouseEnter, tabIndex: t4.getTabIndex(), "aria-label": t4.getAriaLabel(), role: "option", "aria-disabled": t4.isDisabled(), "aria-current": t4.isCurrentDay() ? "date" : void 0, "aria-selected": t4.isSelected() }, t4.renderDayContents());
    }), t4;
  }
  return fe(o2, [{ key: "componentDidMount", value: function() {
    this.handleFocusDay();
  } }, { key: "componentDidUpdate", value: function(e3) {
    this.handleFocusDay(e3);
  } }]), o2;
}(), xt = function(t3) {
  De(o2, e$3.Component);
  var n2 = Se(o2);
  function o2() {
    var e3;
    he(this, o2);
    for (var t4 = arguments.length, r2 = new Array(t4), a4 = 0; a4 < t4; a4++)
      r2[a4] = arguments[a4];
    return ye(ke(e3 = n2.call.apply(n2, [this].concat(r2))), "handleClick", function(t5) {
      e3.props.onClick && e3.props.onClick(t5);
    }), e3;
  }
  return fe(o2, [{ key: "render", value: function() {
    var t4 = this.props, n3 = t4.weekNumber, o3 = t4.ariaLabelPrefix, a4 = void 0 === o3 ? "week " : o3, s4 = { "react-datepicker__week-number": true, "react-datepicker__week-number--clickable": !!t4.onClick };
    return e$3.createElement("div", { className: r(s4), "aria-label": "".concat(a4, " ").concat(this.props.weekNumber), onClick: this.handleClick }, n3);
  } }]), o2;
}(), Yt = function(t3) {
  De(n2, e$3.Component);
  var r2 = Se(n2);
  function n2() {
    var t4;
    he(this, n2);
    for (var o2 = arguments.length, a4 = new Array(o2), s4 = 0; s4 < o2; s4++)
      a4[s4] = arguments[s4];
    return ye(ke(t4 = r2.call.apply(r2, [this].concat(a4))), "handleDayClick", function(e3, r3) {
      t4.props.onDayClick && t4.props.onDayClick(e3, r3);
    }), ye(ke(t4), "handleDayMouseEnter", function(e3) {
      t4.props.onDayMouseEnter && t4.props.onDayMouseEnter(e3);
    }), ye(ke(t4), "handleWeekClick", function(e3, r3, n3) {
      "function" == typeof t4.props.onWeekSelect && t4.props.onWeekSelect(e3, r3, n3), t4.props.shouldCloseOnSelect && t4.props.setOpen(false);
    }), ye(ke(t4), "formatWeekNumber", function(e3) {
      return t4.props.formatWeekNumber ? t4.props.formatWeekNumber(e3) : Ie(e3);
    }), ye(ke(t4), "renderDays", function() {
      var r3 = Re(t4.props.day, t4.props.locale, t4.props.calendarStartDay), n3 = [], o3 = t4.formatWeekNumber(r3);
      if (t4.props.showWeekNumber) {
        var a5 = t4.props.onWeekSelect ? t4.handleWeekClick.bind(ke(t4), r3, o3) : void 0;
        n3.push(e$3.createElement(xt, { key: "W", weekNumber: o3, onClick: a5, ariaLabelPrefix: t4.props.ariaLabelPrefix }));
      }
      return n3.concat([0, 1, 2, 3, 4, 5, 6].map(function(n4) {
        var o4 = addDays(r3, n4);
        return e$3.createElement(Nt, { ariaLabelPrefixWhenEnabled: t4.props.chooseDayAriaLabelPrefix, ariaLabelPrefixWhenDisabled: t4.props.disabledDayAriaLabelPrefix, key: o4.valueOf(), day: o4, month: t4.props.month, onClick: t4.handleDayClick.bind(ke(t4), o4), onMouseEnter: t4.handleDayMouseEnter.bind(ke(t4), o4), minDate: t4.props.minDate, maxDate: t4.props.maxDate, excludeDates: t4.props.excludeDates, excludeDateIntervals: t4.props.excludeDateIntervals, includeDates: t4.props.includeDates, includeDateIntervals: t4.props.includeDateIntervals, highlightDates: t4.props.highlightDates, selectingDate: t4.props.selectingDate, filterDate: t4.props.filterDate, preSelection: t4.props.preSelection, selected: t4.props.selected, selectsStart: t4.props.selectsStart, selectsEnd: t4.props.selectsEnd, selectsRange: t4.props.selectsRange, selectsDisabledDaysInRange: t4.props.selectsDisabledDaysInRange, startDate: t4.props.startDate, endDate: t4.props.endDate, dayClassName: t4.props.dayClassName, renderDayContents: t4.props.renderDayContents, disabledKeyboardNavigation: t4.props.disabledKeyboardNavigation, handleOnKeyDown: t4.props.handleOnKeyDown, isInputFocused: t4.props.isInputFocused, containerRef: t4.props.containerRef, inline: t4.props.inline, shouldFocusDayInline: t4.props.shouldFocusDayInline, monthShowsDuplicateDaysEnd: t4.props.monthShowsDuplicateDaysEnd, monthShowsDuplicateDaysStart: t4.props.monthShowsDuplicateDaysStart, locale: t4.props.locale });
      }));
    }), t4;
  }
  return fe(n2, [{ key: "render", value: function() {
    return e$3.createElement("div", { className: "react-datepicker__week" }, this.renderDays());
  } }], [{ key: "defaultProps", get: function() {
    return { shouldCloseOnSelect: true };
  } }]), n2;
}(), Ot = function(t3) {
  De(o2, e$3.Component);
  var n2 = Se(o2);
  function o2() {
    var t4;
    he(this, o2);
    for (var a4 = arguments.length, s4 = new Array(a4), i3 = 0; i3 < a4; i3++)
      s4[i3] = arguments[i3];
    return ye(ke(t4 = n2.call.apply(n2, [this].concat(s4))), "MONTH_REFS", Ce(Array(12)).map(function() {
      return e$3.createRef();
    })), ye(ke(t4), "QUARTER_REFS", Ce(Array(4)).map(function() {
      return e$3.createRef();
    })), ye(ke(t4), "isDisabled", function(e3) {
      return et(e3, t4.props);
    }), ye(ke(t4), "isExcluded", function(e3) {
      return tt2(e3, t4.props);
    }), ye(ke(t4), "handleDayClick", function(e3, r2) {
      t4.props.onDayClick && t4.props.onDayClick(e3, r2, t4.props.orderInDisplay);
    }), ye(ke(t4), "handleDayMouseEnter", function(e3) {
      t4.props.onDayMouseEnter && t4.props.onDayMouseEnter(e3);
    }), ye(ke(t4), "handleMouseLeave", function() {
      t4.props.onMouseLeave && t4.props.onMouseLeave();
    }), ye(ke(t4), "isRangeStartMonth", function(e3) {
      var r2 = t4.props, n3 = r2.day, o3 = r2.startDate, a5 = r2.endDate;
      return !(!o3 || !a5) && je(setMonth(n3, e3), o3);
    }), ye(ke(t4), "isRangeStartQuarter", function(e3) {
      var r2 = t4.props, n3 = r2.day, o3 = r2.startDate, a5 = r2.endDate;
      return !(!o3 || !a5) && Qe(setQuarter(n3, e3), o3);
    }), ye(ke(t4), "isRangeEndMonth", function(e3) {
      var r2 = t4.props, n3 = r2.day, o3 = r2.startDate, a5 = r2.endDate;
      return !(!o3 || !a5) && je(setMonth(n3, e3), a5);
    }), ye(ke(t4), "isRangeEndQuarter", function(e3) {
      var r2 = t4.props, n3 = r2.day, o3 = r2.startDate, a5 = r2.endDate;
      return !(!o3 || !a5) && Qe(setQuarter(n3, e3), a5);
    }), ye(ke(t4), "isWeekInMonth", function(e3) {
      var r2 = t4.props.day, n3 = addDays(e3, 6);
      return je(e3, r2) || je(n3, r2);
    }), ye(ke(t4), "isCurrentMonth", function(e3, t5) {
      return getYear(e3) === getYear(Pe()) && t5 === getMonth(Pe());
    }), ye(ke(t4), "isCurrentQuarter", function(e3, t5) {
      return getYear(e3) === getYear(Pe()) && t5 === getQuarter(Pe());
    }), ye(ke(t4), "isSelectedMonth", function(e3, t5, r2) {
      return getMonth(e3) === t5 && getYear(e3) === getYear(r2);
    }), ye(ke(t4), "isSelectedQuarter", function(e3, t5, r2) {
      return getQuarter(e3) === t5 && getYear(e3) === getYear(r2);
    }), ye(ke(t4), "renderWeeks", function() {
      for (var r2 = [], n3 = t4.props.fixedHeight, o3 = 0, a5 = false, s5 = Re(Fe(t4.props.day), t4.props.locale, t4.props.calendarStartDay); r2.push(e$3.createElement(Yt, { ariaLabelPrefix: t4.props.weekAriaLabelPrefix, chooseDayAriaLabelPrefix: t4.props.chooseDayAriaLabelPrefix, disabledDayAriaLabelPrefix: t4.props.disabledDayAriaLabelPrefix, key: o3, day: s5, month: getMonth(t4.props.day), onDayClick: t4.handleDayClick, onDayMouseEnter: t4.handleDayMouseEnter, onWeekSelect: t4.props.onWeekSelect, formatWeekNumber: t4.props.formatWeekNumber, locale: t4.props.locale, minDate: t4.props.minDate, maxDate: t4.props.maxDate, excludeDates: t4.props.excludeDates, excludeDateIntervals: t4.props.excludeDateIntervals, includeDates: t4.props.includeDates, includeDateIntervals: t4.props.includeDateIntervals, inline: t4.props.inline, shouldFocusDayInline: t4.props.shouldFocusDayInline, highlightDates: t4.props.highlightDates, selectingDate: t4.props.selectingDate, filterDate: t4.props.filterDate, preSelection: t4.props.preSelection, selected: t4.props.selected, selectsStart: t4.props.selectsStart, selectsEnd: t4.props.selectsEnd, selectsRange: t4.props.selectsRange, selectsDisabledDaysInRange: t4.props.selectsDisabledDaysInRange, showWeekNumber: t4.props.showWeekNumbers, startDate: t4.props.startDate, endDate: t4.props.endDate, dayClassName: t4.props.dayClassName, setOpen: t4.props.setOpen, shouldCloseOnSelect: t4.props.shouldCloseOnSelect, disabledKeyboardNavigation: t4.props.disabledKeyboardNavigation, renderDayContents: t4.props.renderDayContents, handleOnKeyDown: t4.props.handleOnKeyDown, isInputFocused: t4.props.isInputFocused, containerRef: t4.props.containerRef, calendarStartDay: t4.props.calendarStartDay, monthShowsDuplicateDaysEnd: t4.props.monthShowsDuplicateDaysEnd, monthShowsDuplicateDaysStart: t4.props.monthShowsDuplicateDaysStart })), !a5; ) {
        o3++, s5 = addWeeks(s5, 1);
        var i4 = n3 && o3 >= 6, p2 = !n3 && !t4.isWeekInMonth(s5);
        if (i4 || p2) {
          if (!t4.props.peekNextMonth)
            break;
          a5 = true;
        }
      }
      return r2;
    }), ye(ke(t4), "onMonthClick", function(e3, r2) {
      t4.handleDayClick(Fe(setMonth(t4.props.day, r2)), e3);
    }), ye(ke(t4), "handleMonthNavigation", function(e3, r2) {
      t4.isDisabled(r2) || t4.isExcluded(r2) || (t4.props.setPreSelection(r2), t4.MONTH_REFS[e3].current && t4.MONTH_REFS[e3].current.focus());
    }), ye(ke(t4), "onMonthKeyDown", function(e3, r2) {
      e3.preventDefault();
      var n3 = e3.key;
      if (!t4.props.disabledKeyboardNavigation)
        switch (n3) {
          case "Enter":
            t4.onMonthClick(e3, r2), t4.props.setPreSelection(t4.props.selected);
            break;
          case "ArrowRight":
            t4.handleMonthNavigation(11 === r2 ? 0 : r2 + 1, addMonths(t4.props.preSelection, 1));
            break;
          case "ArrowLeft":
            t4.handleMonthNavigation(0 === r2 ? 11 : r2 - 1, subMonths(t4.props.preSelection, 1));
            break;
          case "ArrowUp":
            t4.handleMonthNavigation(r2 >= 0 && r2 <= 2 ? r2 + 9 : r2 - 3, subMonths(t4.props.preSelection, 3));
            break;
          case "ArrowDown":
            t4.handleMonthNavigation(r2 >= 9 && r2 <= 11 ? r2 - 9 : r2 + 3, addMonths(t4.props.preSelection, 3));
        }
    }), ye(ke(t4), "onQuarterClick", function(e3, r2) {
      t4.handleDayClick(Ke(setQuarter(t4.props.day, r2)), e3);
    }), ye(ke(t4), "handleQuarterNavigation", function(e3, r2) {
      t4.isDisabled(r2) || t4.isExcluded(r2) || (t4.props.setPreSelection(r2), t4.QUARTER_REFS[e3 - 1].current && t4.QUARTER_REFS[e3 - 1].current.focus());
    }), ye(ke(t4), "onQuarterKeyDown", function(e3, r2) {
      var n3 = e3.key;
      if (!t4.props.disabledKeyboardNavigation)
        switch (n3) {
          case "Enter":
            t4.onQuarterClick(e3, r2), t4.props.setPreSelection(t4.props.selected);
            break;
          case "ArrowRight":
            t4.handleQuarterNavigation(4 === r2 ? 1 : r2 + 1, addQuarters(t4.props.preSelection, 1));
            break;
          case "ArrowLeft":
            t4.handleQuarterNavigation(1 === r2 ? 4 : r2 - 1, subQuarters(t4.props.preSelection, 1));
        }
    }), ye(ke(t4), "getMonthClassNames", function(e3) {
      var n3 = t4.props, o3 = n3.day, a5 = n3.startDate, s5 = n3.endDate, i4 = n3.selected, p2 = n3.minDate, c3 = n3.maxDate, l2 = n3.preSelection, d4 = n3.monthClassName, u3 = n3.excludeDates, h4 = n3.includeDates, m4 = d4 ? d4(setMonth(o3, e3)) : void 0, f2 = setMonth(o3, e3);
      return r("react-datepicker__month-text", "react-datepicker__month-".concat(e3), m4, { "react-datepicker__month--disabled": (p2 || c3 || u3 || h4) && rt(f2, t4.props), "react-datepicker__month--selected": t4.isSelectedMonth(o3, e3, i4), "react-datepicker__month-text--keyboard-selected": !t4.props.disabledKeyboardNavigation && getMonth(l2) === e3, "react-datepicker__month--in-range": nt(a5, s5, e3, o3), "react-datepicker__month--range-start": t4.isRangeStartMonth(e3), "react-datepicker__month--range-end": t4.isRangeEndMonth(e3), "react-datepicker__month-text--today": t4.isCurrentMonth(o3, e3) });
    }), ye(ke(t4), "getTabIndex", function(e3) {
      var r2 = getMonth(t4.props.preSelection);
      return t4.props.disabledKeyboardNavigation || e3 !== r2 ? "-1" : "0";
    }), ye(ke(t4), "getQuarterTabIndex", function(e3) {
      var r2 = getQuarter(t4.props.preSelection);
      return t4.props.disabledKeyboardNavigation || e3 !== r2 ? "-1" : "0";
    }), ye(ke(t4), "getAriaLabel", function(e3) {
      var r2 = t4.props, n3 = r2.chooseDayAriaLabelPrefix, o3 = void 0 === n3 ? "Choose" : n3, a5 = r2.disabledDayAriaLabelPrefix, s5 = void 0 === a5 ? "Not available" : a5, i4 = r2.day, p2 = setMonth(i4, e3), c3 = t4.isDisabled(p2) || t4.isExcluded(p2) ? s5 : o3;
      return "".concat(c3, " ").concat(xe(p2, "MMMM yyyy"));
    }), ye(ke(t4), "getQuarterClassNames", function(e3) {
      var n3 = t4.props, o3 = n3.day, a5 = n3.startDate, s5 = n3.endDate, i4 = n3.selected, p2 = n3.minDate, c3 = n3.maxDate, l2 = n3.preSelection;
      return r("react-datepicker__quarter-text", "react-datepicker__quarter-".concat(e3), { "react-datepicker__quarter--disabled": (p2 || c3) && ot(setQuarter(o3, e3), t4.props), "react-datepicker__quarter--selected": t4.isSelectedQuarter(o3, e3, i4), "react-datepicker__quarter-text--keyboard-selected": getQuarter(l2) === e3, "react-datepicker__quarter--in-range": st(a5, s5, e3, o3), "react-datepicker__quarter--range-start": t4.isRangeStartQuarter(e3), "react-datepicker__quarter--range-end": t4.isRangeEndQuarter(e3) });
    }), ye(ke(t4), "renderMonths", function() {
      var r2 = t4.props, n3 = r2.showFullMonthYearPicker, o3 = r2.showTwoColumnMonthYearPicker, a5 = r2.showFourColumnMonthYearPicker, s5 = r2.locale, i4 = r2.day, p2 = r2.selected;
      return (a5 ? [[0, 1, 2, 3], [4, 5, 6, 7], [8, 9, 10, 11]] : o3 ? [[0, 1], [2, 3], [4, 5], [6, 7], [8, 9], [10, 11]] : [[0, 1, 2], [3, 4, 5], [6, 7, 8], [9, 10, 11]]).map(function(r3, o4) {
        return e$3.createElement("div", { className: "react-datepicker__month-wrapper", key: o4 }, r3.map(function(r4, o5) {
          return e$3.createElement("div", { ref: t4.MONTH_REFS[r4], key: o5, onClick: function(e3) {
            t4.onMonthClick(e3, r4);
          }, onKeyDown: function(e3) {
            t4.onMonthKeyDown(e3, r4);
          }, tabIndex: t4.getTabIndex(r4), className: t4.getMonthClassNames(r4), role: "option", "aria-label": t4.getAriaLabel(r4), "aria-current": t4.isCurrentMonth(i4, r4) ? "date" : void 0, "aria-selected": t4.isSelectedMonth(i4, r4, p2) }, n3 ? Je(r4, s5) : Xe(r4, s5));
        }));
      });
    }), ye(ke(t4), "renderQuarters", function() {
      var r2 = t4.props, n3 = r2.day, o3 = r2.selected;
      return e$3.createElement("div", { className: "react-datepicker__quarter-wrapper" }, [1, 2, 3, 4].map(function(r3, a5) {
        return e$3.createElement("div", { key: a5, ref: t4.QUARTER_REFS[a5], role: "option", onClick: function(e3) {
          t4.onQuarterClick(e3, r3);
        }, onKeyDown: function(e3) {
          t4.onQuarterKeyDown(e3, r3);
        }, className: t4.getQuarterClassNames(r3), "aria-selected": t4.isSelectedQuarter(n3, r3, o3), tabIndex: t4.getQuarterTabIndex(r3), "aria-current": t4.isCurrentQuarter(n3, r3) ? "date" : void 0 }, Ze(r3, t4.props.locale));
      }));
    }), ye(ke(t4), "getClassNames", function() {
      var e3 = t4.props;
      e3.day;
      var n3 = e3.selectingDate, o3 = e3.selectsStart, a5 = e3.selectsEnd, s5 = e3.showMonthYearPicker, i4 = e3.showQuarterYearPicker;
      return r("react-datepicker__month", { "react-datepicker__month--selecting-range": n3 && (o3 || a5) }, { "react-datepicker__monthPicker": s5 }, { "react-datepicker__quarterPicker": i4 });
    }), t4;
  }
  return fe(o2, [{ key: "render", value: function() {
    var t4 = this.props, r2 = t4.showMonthYearPicker, n3 = t4.showQuarterYearPicker, o3 = t4.day, a4 = t4.ariaLabelPrefix, s4 = void 0 === a4 ? "month " : a4;
    return e$3.createElement("div", { className: this.getClassNames(), onMouseLeave: this.handleMouseLeave, "aria-label": "".concat(s4, " ").concat(xe(o3, "yyyy-MM")), role: "listbox" }, r2 ? this.renderMonths() : n3 ? this.renderQuarters() : this.renderWeeks());
  } }]), o2;
}(), It = function(t3) {
  De(n2, e$3.Component);
  var r2 = Se(n2);
  function n2() {
    var t4;
    he(this, n2);
    for (var o2 = arguments.length, a4 = new Array(o2), i3 = 0; i3 < o2; i3++)
      a4[i3] = arguments[i3];
    return ye(ke(t4 = r2.call.apply(r2, [this].concat(a4))), "state", { height: null }), ye(ke(t4), "handleClick", function(e3) {
      (t4.props.minTime || t4.props.maxTime) && lt(e3, t4.props) || (t4.props.excludeTimes || t4.props.includeTimes || t4.props.filterTime) && ct(e3, t4.props) || t4.props.onChange(e3);
    }), ye(ke(t4), "isSelectedTime", function(e3, r3, n3) {
      return t4.props.selected && r3 === getHours(e3) && n3 === getMinutes(e3);
    }), ye(ke(t4), "liClasses", function(e3, r3, n3) {
      var o3 = ["react-datepicker__time-list-item", t4.props.timeClassName ? t4.props.timeClassName(e3, r3, n3) : void 0];
      return t4.isSelectedTime(e3, r3, n3) && o3.push("react-datepicker__time-list-item--selected"), ((t4.props.minTime || t4.props.maxTime) && lt(e3, t4.props) || (t4.props.excludeTimes || t4.props.includeTimes || t4.props.filterTime) && ct(e3, t4.props)) && o3.push("react-datepicker__time-list-item--disabled"), t4.props.injectTimes && (60 * getHours(e3) + getMinutes(e3)) % t4.props.intervals != 0 && o3.push("react-datepicker__time-list-item--injected"), o3.join(" ");
    }), ye(ke(t4), "handleOnKeyDown", function(e3, r3) {
      " " === e3.key && (e3.preventDefault(), e3.key = "Enter"), "Enter" === e3.key && t4.handleClick(r3), t4.props.handleOnKeyDown(e3);
    }), ye(ke(t4), "renderTimes", function() {
      for (var r3 = [], n3 = t4.props.format ? t4.props.format : "p", o3 = t4.props.intervals, a5 = Le(Pe(t4.props.selected)), i4 = 1440 / o3, p2 = t4.props.injectTimes && t4.props.injectTimes.sort(function(e3, t5) {
        return e3 - t5;
      }), c3 = t4.props.selected || t4.props.openToDate || Pe(), l2 = getHours(c3), d4 = getMinutes(c3), u3 = setHours(setMinutes(a5, d4), l2), h4 = 0; h4 < i4; h4++) {
        var m4 = addMinutes(a5, h4 * o3);
        if (r3.push(m4), p2) {
          var f2 = Dt(a5, m4, h4, o3, p2);
          r3 = r3.concat(f2);
        }
      }
      return r3.map(function(r4, o4) {
        return e$3.createElement("li", { key: o4, onClick: t4.handleClick.bind(ke(t4), r4), className: t4.liClasses(r4, l2, d4), ref: function(e3) {
          (isBefore(r4, u3) || Ve(r4, u3)) && (t4.centerLi = e3);
        }, onKeyDown: function(e3) {
          t4.handleOnKeyDown(e3, r4);
        }, tabIndex: "0", "aria-selected": t4.isSelectedTime(r4, l2, d4) ? "true" : void 0 }, xe(r4, n3, t4.props.locale));
      });
    }), t4;
  }
  return fe(n2, [{ key: "componentDidMount", value: function() {
    this.list.scrollTop = this.centerLi && n2.calcCenterPosition(this.props.monthRef ? this.props.monthRef.clientHeight - this.header.clientHeight : this.list.clientHeight, this.centerLi), this.props.monthRef && this.header && this.setState({ height: this.props.monthRef.clientHeight - this.header.clientHeight });
  } }, { key: "render", value: function() {
    var t4 = this, r3 = this.state.height;
    return e$3.createElement("div", { className: "react-datepicker__time-container ".concat(this.props.todayButton ? "react-datepicker__time-container--with-today-button" : "") }, e$3.createElement("div", { className: "react-datepicker__header react-datepicker__header--time ".concat(this.props.showTimeSelectOnly ? "react-datepicker__header--time--only" : ""), ref: function(e3) {
      t4.header = e3;
    } }, e$3.createElement("div", { className: "react-datepicker-time__header" }, this.props.timeCaption)), e$3.createElement("div", { className: "react-datepicker__time" }, e$3.createElement("div", { className: "react-datepicker__time-box" }, e$3.createElement("ul", { className: "react-datepicker__time-list", ref: function(e3) {
      t4.list = e3;
    }, style: r3 ? { height: r3 } : {}, tabIndex: "0" }, this.renderTimes()))));
  } }], [{ key: "defaultProps", get: function() {
    return { intervals: 30, onTimeChange: function() {
    }, todayButton: null, timeCaption: "Time" };
  } }]), n2;
}();
ye(It, "calcCenterPosition", function(e3, t3) {
  return t3.offsetTop - (e3 / 2 - t3.clientHeight / 2);
});
var Tt = function(t3) {
  De(o2, e$3.Component);
  var n2 = Se(o2);
  function o2(t4) {
    var a4;
    return he(this, o2), ye(ke(a4 = n2.call(this, t4)), "YEAR_REFS", Ce(Array(a4.props.yearItemNumber)).map(function() {
      return e$3.createRef();
    })), ye(ke(a4), "isDisabled", function(e3) {
      return et(e3, a4.props);
    }), ye(ke(a4), "isExcluded", function(e3) {
      return tt2(e3, a4.props);
    }), ye(ke(a4), "updateFocusOnPaginate", function(e3) {
      var t5 = function() {
        this.YEAR_REFS[e3].current.focus();
      }.bind(ke(a4));
      window.requestAnimationFrame(t5);
    }), ye(ke(a4), "handleYearClick", function(e3, t5) {
      a4.props.onDayClick && a4.props.onDayClick(e3, t5);
    }), ye(ke(a4), "handleYearNavigation", function(e3, t5) {
      var r2 = a4.props, n3 = r2.date, o3 = r2.yearItemNumber, s4 = gt(n3, o3).startPeriod;
      a4.isDisabled(t5) || a4.isExcluded(t5) || (a4.props.setPreSelection(t5), e3 - s4 == -1 ? a4.updateFocusOnPaginate(o3 - 1) : e3 - s4 === o3 ? a4.updateFocusOnPaginate(0) : a4.YEAR_REFS[e3 - s4].current.focus());
    }), ye(ke(a4), "isSameDay", function(e3, t5) {
      return He(e3, t5);
    }), ye(ke(a4), "isCurrentYear", function(e3) {
      return e3 === getYear(Pe());
    }), ye(ke(a4), "isKeyboardSelected", function(e3) {
      var t5 = Ae(setYear(a4.props.date, e3));
      return !a4.props.disabledKeyboardNavigation && !a4.props.inline && !He(t5, Ae(a4.props.selected)) && He(t5, Ae(a4.props.preSelection));
    }), ye(ke(a4), "onYearClick", function(e3, t5) {
      var r2 = a4.props.date;
      a4.handleYearClick(Ae(setYear(r2, t5)), e3);
    }), ye(ke(a4), "onYearKeyDown", function(e3, t5) {
      var r2 = e3.key;
      if (!a4.props.disabledKeyboardNavigation)
        switch (r2) {
          case "Enter":
            a4.onYearClick(e3, t5), a4.props.setPreSelection(a4.props.selected);
            break;
          case "ArrowRight":
            a4.handleYearNavigation(t5 + 1, addYears(a4.props.preSelection, 1));
            break;
          case "ArrowLeft":
            a4.handleYearNavigation(t5 - 1, subYears(a4.props.preSelection, 1));
        }
    }), ye(ke(a4), "getYearClassNames", function(e3) {
      var t5 = a4.props, n3 = t5.minDate, o3 = t5.maxDate, s4 = t5.selected, i3 = t5.excludeDates, p2 = t5.includeDates, c3 = t5.filterDate;
      return r("react-datepicker__year-text", { "react-datepicker__year-text--selected": e3 === getYear(s4), "react-datepicker__year-text--disabled": (n3 || o3 || i3 || p2 || c3) && at(e3, a4.props), "react-datepicker__year-text--keyboard-selected": a4.isKeyboardSelected(e3), "react-datepicker__year-text--today": a4.isCurrentYear(e3) });
    }), ye(ke(a4), "getYearTabIndex", function(e3) {
      return a4.props.disabledKeyboardNavigation ? "-1" : e3 === getYear(a4.props.preSelection) ? "0" : "-1";
    }), a4;
  }
  return fe(o2, [{ key: "render", value: function() {
    for (var t4 = this, r2 = [], n3 = this.props, o3 = gt(n3.date, n3.yearItemNumber), a4 = o3.startPeriod, s4 = o3.endPeriod, i3 = function(n4) {
      r2.push(e$3.createElement("div", { ref: t4.YEAR_REFS[n4 - a4], onClick: function(e3) {
        t4.onYearClick(e3, n4);
      }, onKeyDown: function(e3) {
        t4.onYearKeyDown(e3, n4);
      }, tabIndex: t4.getYearTabIndex(n4), className: t4.getYearClassNames(n4), key: n4, "aria-current": t4.isCurrentYear(n4) ? "date" : void 0 }, n4));
    }, p2 = a4; p2 <= s4; p2++)
      i3(p2);
    return e$3.createElement("div", { className: "react-datepicker__year" }, e$3.createElement("div", { className: "react-datepicker__year-wrapper" }, r2));
  } }]), o2;
}(), Lt = function(t3) {
  De(n2, e$3.Component);
  var r2 = Se(n2);
  function n2(t4) {
    var o2;
    return he(this, n2), ye(ke(o2 = r2.call(this, t4)), "onTimeChange", function(e3) {
      o2.setState({ time: e3 });
      var t5 = new Date();
      t5.setHours(e3.split(":")[0]), t5.setMinutes(e3.split(":")[1]), o2.props.onChange(t5);
    }), ye(ke(o2), "renderTimeInput", function() {
      var t5 = o2.state.time, r3 = o2.props, n3 = r3.date, a4 = r3.timeString, s4 = r3.customTimeInput;
      return s4 ? e$3.cloneElement(s4, { date: n3, value: t5, onChange: o2.onTimeChange }) : e$3.createElement("input", { type: "time", className: "react-datepicker-time__input", placeholder: "Time", name: "time-input", required: true, value: t5, onChange: function(e3) {
        o2.onTimeChange(e3.target.value || a4);
      } });
    }), o2.state = { time: o2.props.timeString }, o2;
  }
  return fe(n2, [{ key: "render", value: function() {
    return e$3.createElement("div", { className: "react-datepicker__input-time-container" }, e$3.createElement("div", { className: "react-datepicker-time__caption" }, this.props.timeInputLabel), e$3.createElement("div", { className: "react-datepicker-time__input-container" }, e$3.createElement("div", { className: "react-datepicker-time__input" }, this.renderTimeInput())));
  } }], [{ key: "getDerivedStateFromProps", value: function(e3, t4) {
    return e3.timeString !== t4.time ? { time: e3.timeString } : null;
  } }]), n2;
}();
function Rt(t3) {
  var r2 = t3.className, n2 = t3.children, o2 = t3.showPopperArrow, a4 = t3.arrowProps, s4 = void 0 === a4 ? {} : a4;
  return e$3.createElement("div", { className: r2 }, o2 && e$3.createElement("div", ve({ className: "react-datepicker__triangle" }, s4)), n2);
}
var Ft = ["react-datepicker__year-select", "react-datepicker__month-select", "react-datepicker__month-year-select"], At = function(t3) {
  De(o2, e$3.Component);
  var n2 = Se(o2);
  function o2(t4) {
    var a4;
    return he(this, o2), ye(ke(a4 = n2.call(this, t4)), "handleClickOutside", function(e3) {
      a4.props.onClickOutside(e3);
    }), ye(ke(a4), "setClickOutsideRef", function() {
      return a4.containerRef.current;
    }), ye(ke(a4), "handleDropdownFocus", function(e3) {
      (function() {
        var e4 = ((arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}).className || "").split(/\s+/);
        return Ft.some(function(t5) {
          return e4.indexOf(t5) >= 0;
        });
      })(e3.target) && a4.props.onDropdownFocus();
    }), ye(ke(a4), "getDateInView", function() {
      var e3 = a4.props, t5 = e3.preSelection, r2 = e3.selected, n3 = e3.openToDate, o3 = ft(a4.props), s4 = yt(a4.props), i3 = Pe(), p2 = n3 || r2 || t5;
      return p2 || (o3 && isBefore(i3, o3) ? o3 : s4 && isAfter(i3, s4) ? s4 : i3);
    }), ye(ke(a4), "increaseMonth", function() {
      a4.setState(function(e3) {
        var t5 = e3.date;
        return { date: addMonths(t5, 1) };
      }, function() {
        return a4.handleMonthChange(a4.state.date);
      });
    }), ye(ke(a4), "decreaseMonth", function() {
      a4.setState(function(e3) {
        var t5 = e3.date;
        return { date: subMonths(t5, 1) };
      }, function() {
        return a4.handleMonthChange(a4.state.date);
      });
    }), ye(ke(a4), "handleDayClick", function(e3, t5, r2) {
      a4.props.onSelect(e3, t5, r2), a4.props.setPreSelection && a4.props.setPreSelection(e3);
    }), ye(ke(a4), "handleDayMouseEnter", function(e3) {
      a4.setState({ selectingDate: e3 }), a4.props.onDayMouseEnter && a4.props.onDayMouseEnter(e3);
    }), ye(ke(a4), "handleMonthMouseLeave", function() {
      a4.setState({ selectingDate: null }), a4.props.onMonthMouseLeave && a4.props.onMonthMouseLeave();
    }), ye(ke(a4), "handleYearChange", function(e3) {
      a4.props.onYearChange && (a4.props.onYearChange(e3), a4.setState({ isRenderAriaLiveMessage: true })), a4.props.adjustDateOnChange && (a4.props.onSelect && a4.props.onSelect(e3), a4.props.setOpen && a4.props.setOpen(true)), a4.props.setPreSelection && a4.props.setPreSelection(e3);
    }), ye(ke(a4), "handleMonthChange", function(e3) {
      a4.props.onMonthChange && (a4.props.onMonthChange(e3), a4.setState({ isRenderAriaLiveMessage: true })), a4.props.adjustDateOnChange && (a4.props.onSelect && a4.props.onSelect(e3), a4.props.setOpen && a4.props.setOpen(true)), a4.props.setPreSelection && a4.props.setPreSelection(e3);
    }), ye(ke(a4), "handleMonthYearChange", function(e3) {
      a4.handleYearChange(e3), a4.handleMonthChange(e3);
    }), ye(ke(a4), "changeYear", function(e3) {
      a4.setState(function(t5) {
        var r2 = t5.date;
        return { date: setYear(r2, e3) };
      }, function() {
        return a4.handleYearChange(a4.state.date);
      });
    }), ye(ke(a4), "changeMonth", function(e3) {
      a4.setState(function(t5) {
        var r2 = t5.date;
        return { date: setMonth(r2, e3) };
      }, function() {
        return a4.handleMonthChange(a4.state.date);
      });
    }), ye(ke(a4), "changeMonthYear", function(e3) {
      a4.setState(function(t5) {
        var r2 = t5.date;
        return { date: setYear(setMonth(r2, getMonth(e3)), getYear(e3)) };
      }, function() {
        return a4.handleMonthYearChange(a4.state.date);
      });
    }), ye(ke(a4), "header", function() {
      var t5 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : a4.state.date, n3 = Re(t5, a4.props.locale, a4.props.calendarStartDay), o3 = [];
      return a4.props.showWeekNumbers && o3.push(e$3.createElement("div", { key: "W", className: "react-datepicker__day-name" }, a4.props.weekLabel || "#")), o3.concat([0, 1, 2, 3, 4, 5, 6].map(function(t6) {
        var o4 = addDays(n3, t6), s4 = a4.formatWeekday(o4, a4.props.locale), i3 = a4.props.weekDayClassName ? a4.props.weekDayClassName(o4) : void 0;
        return e$3.createElement("div", { key: t6, className: r("react-datepicker__day-name", i3) }, s4);
      }));
    }), ye(ke(a4), "formatWeekday", function(e3, t5) {
      return a4.props.formatWeekDay ? function(e4, t6, r2) {
        return "function" == typeof t6 ? t6(e4, r2) : xe(e4, "EEEE", r2);
      }(e3, a4.props.formatWeekDay, t5) : a4.props.useWeekdaysShort ? function(e4, t6) {
        return xe(e4, "EEE", t6);
      }(e3, t5) : function(e4, t6) {
        return xe(e4, "EEEEEE", t6);
      }(e3, t5);
    }), ye(ke(a4), "decreaseYear", function() {
      a4.setState(function(e3) {
        var t5 = e3.date;
        return { date: subYears(t5, a4.props.showYearPicker ? a4.props.yearItemNumber : 1) };
      }, function() {
        return a4.handleYearChange(a4.state.date);
      });
    }), ye(ke(a4), "renderPreviousButton", function() {
      if (!a4.props.renderCustomHeader) {
        var t5;
        switch (true) {
          case a4.props.showMonthYearPicker:
            t5 = ht(a4.state.date, a4.props);
            break;
          case a4.props.showYearPicker:
            t5 = function(e3) {
              var t6 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, r3 = t6.minDate, n4 = t6.yearItemNumber, o4 = void 0 === n4 ? 12 : n4, a5 = gt(Ae(subYears(e3, o4)), o4).endPeriod, s5 = r3 && getYear(r3);
              return s5 && s5 > a5 || false;
            }(a4.state.date, a4.props);
            break;
          default:
            t5 = dt(a4.state.date, a4.props);
        }
        if ((a4.props.forceShowMonthNavigation || a4.props.showDisabledMonthNavigation || !t5) && !a4.props.showTimeSelectOnly) {
          var r2 = ["react-datepicker__navigation", "react-datepicker__navigation--previous"], n3 = a4.decreaseMonth;
          (a4.props.showMonthYearPicker || a4.props.showQuarterYearPicker || a4.props.showYearPicker) && (n3 = a4.decreaseYear), t5 && a4.props.showDisabledMonthNavigation && (r2.push("react-datepicker__navigation--previous--disabled"), n3 = null);
          var o3 = a4.props.showMonthYearPicker || a4.props.showQuarterYearPicker || a4.props.showYearPicker, s4 = a4.props, i3 = s4.previousMonthButtonLabel, p2 = s4.previousYearButtonLabel, c3 = a4.props, l2 = c3.previousMonthAriaLabel, d4 = void 0 === l2 ? "string" == typeof i3 ? i3 : "Previous Month" : l2, u3 = c3.previousYearAriaLabel, h4 = void 0 === u3 ? "string" == typeof p2 ? p2 : "Previous Year" : u3;
          return e$3.createElement("button", { type: "button", className: r2.join(" "), onClick: n3, onKeyDown: a4.props.handleOnKeyDown, "aria-label": o3 ? h4 : d4 }, e$3.createElement("span", { className: ["react-datepicker__navigation-icon", "react-datepicker__navigation-icon--previous"].join(" ") }, o3 ? a4.props.previousYearButtonLabel : a4.props.previousMonthButtonLabel));
        }
      }
    }), ye(ke(a4), "increaseYear", function() {
      a4.setState(function(e3) {
        var t5 = e3.date;
        return { date: addYears(t5, a4.props.showYearPicker ? a4.props.yearItemNumber : 1) };
      }, function() {
        return a4.handleYearChange(a4.state.date);
      });
    }), ye(ke(a4), "renderNextButton", function() {
      if (!a4.props.renderCustomHeader) {
        var t5;
        switch (true) {
          case a4.props.showMonthYearPicker:
            t5 = mt(a4.state.date, a4.props);
            break;
          case a4.props.showYearPicker:
            t5 = function(e3) {
              var t6 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, r3 = t6.maxDate, n4 = t6.yearItemNumber, o4 = void 0 === n4 ? 12 : n4, a5 = gt(addYears(e3, o4), o4).startPeriod, s5 = r3 && getYear(r3);
              return s5 && s5 < a5 || false;
            }(a4.state.date, a4.props);
            break;
          default:
            t5 = ut(a4.state.date, a4.props);
        }
        if ((a4.props.forceShowMonthNavigation || a4.props.showDisabledMonthNavigation || !t5) && !a4.props.showTimeSelectOnly) {
          var r2 = ["react-datepicker__navigation", "react-datepicker__navigation--next"];
          a4.props.showTimeSelect && r2.push("react-datepicker__navigation--next--with-time"), a4.props.todayButton && r2.push("react-datepicker__navigation--next--with-today-button");
          var n3 = a4.increaseMonth;
          (a4.props.showMonthYearPicker || a4.props.showQuarterYearPicker || a4.props.showYearPicker) && (n3 = a4.increaseYear), t5 && a4.props.showDisabledMonthNavigation && (r2.push("react-datepicker__navigation--next--disabled"), n3 = null);
          var o3 = a4.props.showMonthYearPicker || a4.props.showQuarterYearPicker || a4.props.showYearPicker, s4 = a4.props, i3 = s4.nextMonthButtonLabel, p2 = s4.nextYearButtonLabel, c3 = a4.props, l2 = c3.nextMonthAriaLabel, d4 = void 0 === l2 ? "string" == typeof i3 ? i3 : "Next Month" : l2, h4 = c3.nextYearAriaLabel, m4 = void 0 === h4 ? "string" == typeof p2 ? p2 : "Next Year" : h4;
          return e$3.createElement("button", { type: "button", className: r2.join(" "), onClick: n3, onKeyDown: a4.props.handleOnKeyDown, "aria-label": o3 ? m4 : d4 }, e$3.createElement("span", { className: ["react-datepicker__navigation-icon", "react-datepicker__navigation-icon--next"].join(" ") }, o3 ? a4.props.nextYearButtonLabel : a4.props.nextMonthButtonLabel));
        }
      }
    }), ye(ke(a4), "renderCurrentMonth", function() {
      var t5 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : a4.state.date, r2 = ["react-datepicker__current-month"];
      return a4.props.showYearDropdown && r2.push("react-datepicker__current-month--hasYearDropdown"), a4.props.showMonthDropdown && r2.push("react-datepicker__current-month--hasMonthDropdown"), a4.props.showMonthYearDropdown && r2.push("react-datepicker__current-month--hasMonthYearDropdown"), e$3.createElement("div", { className: r2.join(" ") }, xe(t5, a4.props.dateFormat, a4.props.locale));
    }), ye(ke(a4), "renderYearDropdown", function() {
      var t5 = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
      if (a4.props.showYearDropdown && !t5)
        return e$3.createElement(St, { adjustDateOnChange: a4.props.adjustDateOnChange, date: a4.state.date, onSelect: a4.props.onSelect, setOpen: a4.props.setOpen, dropdownMode: a4.props.dropdownMode, onChange: a4.changeYear, minDate: a4.props.minDate, maxDate: a4.props.maxDate, year: getYear(a4.state.date), scrollableYearDropdown: a4.props.scrollableYearDropdown, yearDropdownItemNumber: a4.props.yearDropdownItemNumber });
    }), ye(ke(a4), "renderMonthDropdown", function() {
      var t5 = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
      if (a4.props.showMonthDropdown && !t5)
        return e$3.createElement(_t, { dropdownMode: a4.props.dropdownMode, locale: a4.props.locale, onChange: a4.changeMonth, month: getMonth(a4.state.date), useShortMonthInDropdown: a4.props.useShortMonthInDropdown });
    }), ye(ke(a4), "renderMonthYearDropdown", function() {
      var t5 = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
      if (a4.props.showMonthYearDropdown && !t5)
        return e$3.createElement(Et, { dropdownMode: a4.props.dropdownMode, locale: a4.props.locale, dateFormat: a4.props.dateFormat, onChange: a4.changeMonthYear, minDate: a4.props.minDate, maxDate: a4.props.maxDate, date: a4.state.date, scrollableMonthYearDropdown: a4.props.scrollableMonthYearDropdown });
    }), ye(ke(a4), "handleTodayButtonClick", function(e3) {
      a4.props.onSelect(Be(), e3), a4.props.setPreSelection && a4.props.setPreSelection(Be());
    }), ye(ke(a4), "renderTodayButton", function() {
      if (a4.props.todayButton && !a4.props.showTimeSelectOnly)
        return e$3.createElement("div", { className: "react-datepicker__today-button", onClick: function(e3) {
          return a4.handleTodayButtonClick(e3);
        } }, a4.props.todayButton);
    }), ye(ke(a4), "renderDefaultHeader", function(t5) {
      var r2 = t5.monthDate, n3 = t5.i;
      return e$3.createElement("div", { className: "react-datepicker__header ".concat(a4.props.showTimeSelect ? "react-datepicker__header--has-time-select" : "") }, a4.renderCurrentMonth(r2), e$3.createElement("div", { className: "react-datepicker__header__dropdown react-datepicker__header__dropdown--".concat(a4.props.dropdownMode), onFocus: a4.handleDropdownFocus }, a4.renderMonthDropdown(0 !== n3), a4.renderMonthYearDropdown(0 !== n3), a4.renderYearDropdown(0 !== n3)), e$3.createElement("div", { className: "react-datepicker__day-names" }, a4.header(r2)));
    }), ye(ke(a4), "renderCustomHeader", function() {
      var t5 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, r2 = t5.monthDate, n3 = t5.i;
      if (a4.props.showTimeSelect && !a4.state.monthContainer || a4.props.showTimeSelectOnly)
        return null;
      var o3 = dt(a4.state.date, a4.props), s4 = ut(a4.state.date, a4.props), i3 = ht(a4.state.date, a4.props), p2 = mt(a4.state.date, a4.props), c3 = !a4.props.showMonthYearPicker && !a4.props.showQuarterYearPicker && !a4.props.showYearPicker;
      return e$3.createElement("div", { className: "react-datepicker__header react-datepicker__header--custom", onFocus: a4.props.onDropdownFocus }, a4.props.renderCustomHeader(de(de({}, a4.state), {}, { customHeaderCount: n3, monthDate: r2, changeMonth: a4.changeMonth, changeYear: a4.changeYear, decreaseMonth: a4.decreaseMonth, increaseMonth: a4.increaseMonth, decreaseYear: a4.decreaseYear, increaseYear: a4.increaseYear, prevMonthButtonDisabled: o3, nextMonthButtonDisabled: s4, prevYearButtonDisabled: i3, nextYearButtonDisabled: p2 })), c3 && e$3.createElement("div", { className: "react-datepicker__day-names" }, a4.header(r2)));
    }), ye(ke(a4), "renderYearHeader", function() {
      var t5 = a4.state.date, r2 = a4.props, n3 = r2.showYearPicker, o3 = gt(t5, r2.yearItemNumber), s4 = o3.startPeriod, i3 = o3.endPeriod;
      return e$3.createElement("div", { className: "react-datepicker__header react-datepicker-year-header" }, n3 ? "".concat(s4, " - ").concat(i3) : getYear(t5));
    }), ye(ke(a4), "renderHeader", function(e3) {
      switch (true) {
        case void 0 !== a4.props.renderCustomHeader:
          return a4.renderCustomHeader(e3);
        case (a4.props.showMonthYearPicker || a4.props.showQuarterYearPicker || a4.props.showYearPicker):
          return a4.renderYearHeader(e3);
        default:
          return a4.renderDefaultHeader(e3);
      }
    }), ye(ke(a4), "renderMonths", function() {
      if (!a4.props.showTimeSelectOnly && !a4.props.showYearPicker) {
        for (var t5 = [], r2 = a4.props.showPreviousMonths ? a4.props.monthsShown - 1 : 0, n3 = subMonths(a4.state.date, r2), o3 = 0; o3 < a4.props.monthsShown; ++o3) {
          var s4 = o3 - a4.props.monthSelectedIn, i3 = addMonths(n3, s4), p2 = "month-".concat(o3), c3 = o3 < a4.props.monthsShown - 1, d4 = o3 > 0;
          t5.push(e$3.createElement("div", { key: p2, ref: function(e3) {
            a4.monthContainer = e3;
          }, className: "react-datepicker__month-container" }, a4.renderHeader({ monthDate: i3, i: o3 }), e$3.createElement(Ot, { chooseDayAriaLabelPrefix: a4.props.chooseDayAriaLabelPrefix, disabledDayAriaLabelPrefix: a4.props.disabledDayAriaLabelPrefix, weekAriaLabelPrefix: a4.props.weekAriaLabelPrefix, ariaLabelPrefix: a4.props.monthAriaLabelPrefix, onChange: a4.changeMonthYear, day: i3, dayClassName: a4.props.dayClassName, calendarStartDay: a4.props.calendarStartDay, monthClassName: a4.props.monthClassName, onDayClick: a4.handleDayClick, handleOnKeyDown: a4.props.handleOnDayKeyDown, onDayMouseEnter: a4.handleDayMouseEnter, onMouseLeave: a4.handleMonthMouseLeave, onWeekSelect: a4.props.onWeekSelect, orderInDisplay: o3, formatWeekNumber: a4.props.formatWeekNumber, locale: a4.props.locale, minDate: a4.props.minDate, maxDate: a4.props.maxDate, excludeDates: a4.props.excludeDates, excludeDateIntervals: a4.props.excludeDateIntervals, highlightDates: a4.props.highlightDates, selectingDate: a4.state.selectingDate, includeDates: a4.props.includeDates, includeDateIntervals: a4.props.includeDateIntervals, inline: a4.props.inline, shouldFocusDayInline: a4.props.shouldFocusDayInline, fixedHeight: a4.props.fixedHeight, filterDate: a4.props.filterDate, preSelection: a4.props.preSelection, setPreSelection: a4.props.setPreSelection, selected: a4.props.selected, selectsStart: a4.props.selectsStart, selectsEnd: a4.props.selectsEnd, selectsRange: a4.props.selectsRange, selectsDisabledDaysInRange: a4.props.selectsDisabledDaysInRange, showWeekNumbers: a4.props.showWeekNumbers, startDate: a4.props.startDate, endDate: a4.props.endDate, peekNextMonth: a4.props.peekNextMonth, setOpen: a4.props.setOpen, shouldCloseOnSelect: a4.props.shouldCloseOnSelect, renderDayContents: a4.props.renderDayContents, disabledKeyboardNavigation: a4.props.disabledKeyboardNavigation, showMonthYearPicker: a4.props.showMonthYearPicker, showFullMonthYearPicker: a4.props.showFullMonthYearPicker, showTwoColumnMonthYearPicker: a4.props.showTwoColumnMonthYearPicker, showFourColumnMonthYearPicker: a4.props.showFourColumnMonthYearPicker, showYearPicker: a4.props.showYearPicker, showQuarterYearPicker: a4.props.showQuarterYearPicker, isInputFocused: a4.props.isInputFocused, containerRef: a4.containerRef, monthShowsDuplicateDaysEnd: c3, monthShowsDuplicateDaysStart: d4 })));
        }
        return t5;
      }
    }), ye(ke(a4), "renderYears", function() {
      if (!a4.props.showTimeSelectOnly)
        return a4.props.showYearPicker ? e$3.createElement("div", { className: "react-datepicker__year--container" }, a4.renderHeader(), e$3.createElement(Tt, ve({ onDayClick: a4.handleDayClick, date: a4.state.date }, a4.props))) : void 0;
    }), ye(ke(a4), "renderTimeSection", function() {
      if (a4.props.showTimeSelect && (a4.state.monthContainer || a4.props.showTimeSelectOnly))
        return e$3.createElement(It, { selected: a4.props.selected, openToDate: a4.props.openToDate, onChange: a4.props.onTimeChange, timeClassName: a4.props.timeClassName, format: a4.props.timeFormat, includeTimes: a4.props.includeTimes, intervals: a4.props.timeIntervals, minTime: a4.props.minTime, maxTime: a4.props.maxTime, excludeTimes: a4.props.excludeTimes, filterTime: a4.props.filterTime, timeCaption: a4.props.timeCaption, todayButton: a4.props.todayButton, showMonthDropdown: a4.props.showMonthDropdown, showMonthYearDropdown: a4.props.showMonthYearDropdown, showYearDropdown: a4.props.showYearDropdown, withPortal: a4.props.withPortal, monthRef: a4.state.monthContainer, injectTimes: a4.props.injectTimes, locale: a4.props.locale, handleOnKeyDown: a4.props.handleOnKeyDown, showTimeSelectOnly: a4.props.showTimeSelectOnly });
    }), ye(ke(a4), "renderInputTimeSection", function() {
      var t5 = new Date(a4.props.selected), r2 = Ne(t5) && Boolean(a4.props.selected) ? "".concat(wt(t5.getHours()), ":").concat(wt(t5.getMinutes())) : "";
      if (a4.props.showTimeInput)
        return e$3.createElement(Lt, { date: t5, timeString: r2, timeInputLabel: a4.props.timeInputLabel, onChange: a4.props.onTimeChange, customTimeInput: a4.props.customTimeInput });
    }), ye(ke(a4), "renderAriaLiveRegion", function() {
      var t5, r2 = gt(a4.state.date, a4.props.yearItemNumber), n3 = r2.startPeriod, o3 = r2.endPeriod;
      return t5 = a4.props.showYearPicker ? "".concat(n3, " - ").concat(o3) : a4.props.showMonthYearPicker || a4.props.showQuarterYearPicker ? getYear(a4.state.date) : "".concat(Je(getMonth(a4.state.date), a4.props.locale), " ").concat(getYear(a4.state.date)), e$3.createElement("span", { role: "alert", "aria-live": "polite", className: "react-datepicker__aria-live" }, a4.state.isRenderAriaLiveMessage && t5);
    }), ye(ke(a4), "renderChildren", function() {
      if (a4.props.children)
        return e$3.createElement("div", { className: "react-datepicker__children-container" }, a4.props.children);
    }), a4.containerRef = e$3.createRef(), a4.state = { date: a4.getDateInView(), selectingDate: null, monthContainer: null, isRenderAriaLiveMessage: false }, a4;
  }
  return fe(o2, [{ key: "componentDidMount", value: function() {
    var e3 = this;
    this.props.showTimeSelect && (this.assignMonthContainer = void e3.setState({ monthContainer: e3.monthContainer }));
  } }, { key: "componentDidUpdate", value: function(e3) {
    !this.props.preSelection || He(this.props.preSelection, e3.preSelection) && this.props.monthSelectedIn === e3.monthSelectedIn ? this.props.openToDate && !He(this.props.openToDate, e3.openToDate) && this.setState({ date: this.props.openToDate }) : this.setState({ date: this.props.preSelection });
  } }, { key: "render", value: function() {
    var t4 = this.props.container || Rt;
    return e$3.createElement("div", { ref: this.containerRef }, e$3.createElement(t4, { className: r("react-datepicker", this.props.className, { "react-datepicker--time-only": this.props.showTimeSelectOnly }), showPopperArrow: this.props.showPopperArrow, arrowProps: this.props.arrowProps }, this.renderAriaLiveRegion(), this.renderPreviousButton(), this.renderNextButton(), this.renderMonths(), this.renderYears(), this.renderTodayButton(), this.renderTimeSection(), this.renderInputTimeSection(), this.renderChildren()));
  } }], [{ key: "defaultProps", get: function() {
    return { onDropdownFocus: function() {
    }, monthsShown: 1, monthSelectedIn: 0, forceShowMonthNavigation: false, timeCaption: "Time", previousYearButtonLabel: "Previous Year", nextYearButtonLabel: "Next Year", previousMonthButtonLabel: "Previous Month", nextMonthButtonLabel: "Next Month", customTimeInput: null, yearItemNumber: 12 };
  } }]), o2;
}(), Kt = function(t3) {
  De(n2, e$3.Component);
  var r2 = Se(n2);
  function n2(e3) {
    var t4;
    return he(this, n2), (t4 = r2.call(this, e3)).el = document.createElement("div"), t4;
  }
  return fe(n2, [{ key: "componentDidMount", value: function() {
    this.portalRoot = (this.props.portalHost || document).getElementById(this.props.portalId), this.portalRoot || (this.portalRoot = document.createElement("div"), this.portalRoot.setAttribute("id", this.props.portalId), (this.props.portalHost || document.body).appendChild(this.portalRoot)), this.portalRoot.appendChild(this.el);
  } }, { key: "componentWillUnmount", value: function() {
    this.portalRoot.removeChild(this.el);
  } }, { key: "render", value: function() {
    return ae.createPortal(this.props.children, this.el);
  } }]), n2;
}(), Bt = function(e3) {
  return !e3.disabled && -1 !== e3.tabIndex;
}, Wt = function(t3) {
  De(n2, e$3.Component);
  var r2 = Se(n2);
  function n2(t4) {
    var o2;
    return he(this, n2), ye(ke(o2 = r2.call(this, t4)), "getTabChildren", function() {
      return Array.prototype.slice.call(o2.tabLoopRef.current.querySelectorAll("[tabindex], a, button, input, select, textarea"), 1, -1).filter(Bt);
    }), ye(ke(o2), "handleFocusStart", function(e3) {
      var t5 = o2.getTabChildren();
      t5 && t5.length > 1 && t5[t5.length - 1].focus();
    }), ye(ke(o2), "handleFocusEnd", function(e3) {
      var t5 = o2.getTabChildren();
      t5 && t5.length > 1 && t5[0].focus();
    }), o2.tabLoopRef = e$3.createRef(), o2;
  }
  return fe(n2, [{ key: "render", value: function() {
    return this.props.enableTabLoop ? e$3.createElement("div", { className: "react-datepicker__tab-loop", ref: this.tabLoopRef }, e$3.createElement("div", { className: "react-datepicker__tab-loop__start", tabIndex: "0", onFocus: this.handleFocusStart }), this.props.children, e$3.createElement("div", { className: "react-datepicker__tab-loop__end", tabIndex: "0", onFocus: this.handleFocusEnd })) : this.props.children;
  } }], [{ key: "defaultProps", get: function() {
    return { enableTabLoop: true };
  } }]), n2;
}(), jt = function(t3) {
  De(o2, e$3.Component);
  var n2 = Se(o2);
  function o2() {
    return he(this, o2), n2.apply(this, arguments);
  }
  return fe(o2, [{ key: "render", value: function() {
    var t4, n3 = this.props, o3 = n3.className, a4 = n3.wrapperClassName, s4 = n3.hidePopper, i3 = n3.popperComponent, p2 = n3.popperModifiers, c3 = n3.popperPlacement, l2 = n3.popperProps, d4 = n3.targetComponent, u3 = n3.enableTabLoop, h4 = n3.popperOnKeyDown, m4 = n3.portalId, f2 = n3.portalHost;
    if (!s4) {
      var y4 = r("react-datepicker-popper", o3);
      t4 = e$3.createElement(Popper, ve({ modifiers: p2, placement: c3 }, l2), function(t5) {
        var r2 = t5.ref, n4 = t5.style, o4 = t5.placement, a5 = t5.arrowProps;
        return e$3.createElement(Wt, { enableTabLoop: u3 }, e$3.createElement("div", { ref: r2, style: n4, className: y4, "data-placement": o4, onKeyDown: h4 }, e$3.cloneElement(i3, { arrowProps: a5 })));
      });
    }
    this.props.popperContainer && (t4 = e$3.createElement(this.props.popperContainer, {}, t4)), m4 && !s4 && (t4 = e$3.createElement(Kt, { portalId: m4, portalHost: f2 }, t4));
    var v2 = r("react-datepicker-wrapper", a4);
    return e$3.createElement(Manager, { className: "react-datepicker-manager" }, e$3.createElement(Reference, null, function(t5) {
      var r2 = t5.ref;
      return e$3.createElement("div", { ref: r2, className: v2 }, d4);
    }), t4);
  } }], [{ key: "defaultProps", get: function() {
    return { hidePopper: true, popperModifiers: [], popperProps: {}, popperPlacement: "bottom-start" };
  } }]), o2;
}(), Qt = onClickOutsideHOC(At);
var Ht = function(t3) {
  De(a4, e$3.Component);
  var o2 = Se(a4);
  function a4(t4) {
    var s4;
    return he(this, a4), ye(ke(s4 = o2.call(this, t4)), "getPreSelection", function() {
      return s4.props.openToDate ? s4.props.openToDate : s4.props.selectsEnd && s4.props.startDate ? s4.props.startDate : s4.props.selectsStart && s4.props.endDate ? s4.props.endDate : Pe();
    }), ye(ke(s4), "calcInitialState", function() {
      var e3, t5 = s4.getPreSelection(), r2 = ft(s4.props), n2 = yt(s4.props), o3 = r2 && isBefore(t5, startOfDay(r2)) ? r2 : n2 && isAfter(t5, endOfDay(n2)) ? n2 : t5;
      return { open: s4.props.startOpen || false, preventFocus: false, preSelection: null !== (e3 = s4.props.selectsRange ? s4.props.startDate : s4.props.selected) && void 0 !== e3 ? e3 : o3, highlightDates: vt(s4.props.highlightDates), focused: false, shouldFocusDayInline: false, isRenderAriaLiveMessage: false };
    }), ye(ke(s4), "clearPreventFocusTimeout", function() {
      s4.preventFocusTimeout && clearTimeout(s4.preventFocusTimeout);
    }), ye(ke(s4), "setFocus", function() {
      s4.input && s4.input.focus && s4.input.focus({ preventScroll: true });
    }), ye(ke(s4), "setBlur", function() {
      s4.input && s4.input.blur && s4.input.blur(), s4.cancelFocusInput();
    }), ye(ke(s4), "setOpen", function(e3) {
      var t5 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
      s4.setState({ open: e3, preSelection: e3 && s4.state.open ? s4.state.preSelection : s4.calcInitialState().preSelection, lastPreSelectChange: qt }, function() {
        e3 || s4.setState(function(e4) {
          return { focused: !!t5 && e4.focused };
        }, function() {
          !t5 && s4.setBlur(), s4.setState({ inputValue: null });
        });
      });
    }), ye(ke(s4), "inputOk", function() {
      return isDate(s4.state.preSelection);
    }), ye(ke(s4), "isCalendarOpen", function() {
      return void 0 === s4.props.open ? s4.state.open && !s4.props.disabled && !s4.props.readOnly : s4.props.open;
    }), ye(ke(s4), "handleFocus", function(e3) {
      s4.state.preventFocus || (s4.props.onFocus(e3), s4.props.preventOpenOnFocus || s4.props.readOnly || s4.setOpen(true)), s4.setState({ focused: true });
    }), ye(ke(s4), "cancelFocusInput", function() {
      clearTimeout(s4.inputFocusTimeout), s4.inputFocusTimeout = null;
    }), ye(ke(s4), "deferFocusInput", function() {
      s4.cancelFocusInput(), s4.inputFocusTimeout = setTimeout(function() {
        return s4.setFocus();
      }, 1);
    }), ye(ke(s4), "handleDropdownFocus", function() {
      s4.cancelFocusInput();
    }), ye(ke(s4), "handleBlur", function(e3) {
      (!s4.state.open || s4.props.withPortal || s4.props.showTimeInput) && s4.props.onBlur(e3), s4.setState({ focused: false });
    }), ye(ke(s4), "handleCalendarClickOutside", function(e3) {
      s4.props.inline || s4.setOpen(false), s4.props.onClickOutside(e3), s4.props.withPortal && e3.preventDefault();
    }), ye(ke(s4), "handleChange", function() {
      for (var e3 = arguments.length, t5 = new Array(e3), r2 = 0; r2 < e3; r2++)
        t5[r2] = arguments[r2];
      var n2 = t5[0];
      if (!s4.props.onChangeRaw || (s4.props.onChangeRaw.apply(ke(s4), t5), "function" == typeof n2.isDefaultPrevented && !n2.isDefaultPrevented())) {
        s4.setState({ inputValue: n2.target.value, lastPreSelectChange: Vt });
        var o3 = Ee(n2.target.value, s4.props.dateFormat, s4.props.locale, s4.props.strictParsing, s4.props.selected, s4.props.minDate);
        s4.props.showTimeSelectOnly && !He(o3, s4.props.selected) && (o3 = set(s4.props.selected, null == o3 ? { hours: getHours(s4.props.selected), minutes: getMinutes(s4.props.selected), seconds: getSeconds(s4.props.selected) } : { hours: getHours(o3), minutes: getMinutes(o3), seconds: getSeconds(o3) })), !o3 && n2.target.value || s4.setSelected(o3, n2, true);
      }
    }), ye(ke(s4), "handleSelect", function(e3, t5, r2) {
      if (s4.setState({ preventFocus: true }, function() {
        return s4.preventFocusTimeout = setTimeout(function() {
          return s4.setState({ preventFocus: false });
        }, 50), s4.preventFocusTimeout;
      }), s4.props.onChangeRaw && s4.props.onChangeRaw(t5), s4.setSelected(e3, t5, false, r2), s4.setState({ isRenderAriaLiveMessage: true }), !s4.props.shouldCloseOnSelect || s4.props.showTimeSelect)
        s4.setPreSelection(e3);
      else if (!s4.props.inline) {
        s4.props.selectsRange || s4.setOpen(false);
        var n2 = s4.props, o3 = n2.startDate, a5 = n2.endDate;
        !o3 || a5 || isBefore(e3, o3) || s4.setOpen(false);
      }
    }), ye(ke(s4), "setSelected", function(e3, t5, r2, n2) {
      var o3 = e3;
      if (s4.props.showYearPicker) {
        if (null !== o3 && at(getYear(o3), s4.props))
          return;
      } else if (s4.props.showMonthYearPicker) {
        if (null !== o3 && rt(o3, s4.props))
          return;
      } else if (null !== o3 && et(o3, s4.props))
        return;
      var a5 = s4.props, i3 = a5.onChange, p2 = a5.selectsRange, c3 = a5.startDate, l2 = a5.endDate;
      if (!Ve(s4.props.selected, o3) || s4.props.allowSameDay || p2)
        if (null !== o3 && (!s4.props.selected || r2 && (s4.props.showTimeSelect || s4.props.showTimeSelectOnly || s4.props.showTimeInput) || (o3 = Oe(o3, { hour: getHours(s4.props.selected), minute: getMinutes(s4.props.selected), second: getSeconds(s4.props.selected) })), s4.props.inline || s4.setState({ preSelection: o3 }), s4.props.focusSelectedMonth || s4.setState({ monthSelectedIn: n2 })), p2) {
          var d4 = c3 && !l2, u3 = c3 && l2;
          !c3 && !l2 ? i3([o3, null], t5) : d4 && (isBefore(o3, c3) ? i3([o3, null], t5) : i3([c3, o3], t5)), u3 && i3([o3, null], t5);
        } else
          i3(o3, t5);
      r2 || (s4.props.onSelect(o3, t5), s4.setState({ inputValue: null }));
    }), ye(ke(s4), "setPreSelection", function(e3) {
      var t5 = void 0 !== s4.props.minDate, r2 = void 0 !== s4.props.maxDate, n2 = true;
      if (e3) {
        var o3 = startOfDay(e3);
        if (t5 && r2)
          n2 = qe(e3, s4.props.minDate, s4.props.maxDate);
        else if (t5) {
          var a5 = startOfDay(s4.props.minDate);
          n2 = isAfter(e3, a5) || Ve(o3, a5);
        } else if (r2) {
          var i3 = endOfDay(s4.props.maxDate);
          n2 = isBefore(e3, i3) || Ve(o3, i3);
        }
      }
      n2 && s4.setState({ preSelection: e3 });
    }), ye(ke(s4), "handleTimeChange", function(e3) {
      var t5 = Oe(s4.props.selected ? s4.props.selected : s4.getPreSelection(), { hour: getHours(e3), minute: getMinutes(e3) });
      s4.setState({ preSelection: t5 }), s4.props.onChange(t5), s4.props.shouldCloseOnSelect && s4.setOpen(false), s4.props.showTimeInput && s4.setOpen(true), (s4.props.showTimeSelectOnly || s4.props.showTimeSelect) && s4.setState({ isRenderAriaLiveMessage: true }), s4.setState({ inputValue: null });
    }), ye(ke(s4), "onInputClick", function() {
      s4.props.disabled || s4.props.readOnly || s4.setOpen(true), s4.props.onInputClick();
    }), ye(ke(s4), "onInputKeyDown", function(e3) {
      s4.props.onKeyDown(e3);
      var t5 = e3.key;
      if (s4.state.open || s4.props.inline || s4.props.preventOpenOnFocus) {
        if (s4.state.open) {
          if ("ArrowDown" === t5 || "ArrowUp" === t5) {
            e3.preventDefault();
            var r2 = s4.calendar.componentNode && s4.calendar.componentNode.querySelector('.react-datepicker__day[tabindex="0"]');
            return void (r2 && r2.focus({ preventScroll: true }));
          }
          var n2 = Pe(s4.state.preSelection);
          "Enter" === t5 ? (e3.preventDefault(), s4.inputOk() && s4.state.lastPreSelectChange === qt ? (s4.handleSelect(n2, e3), !s4.props.shouldCloseOnSelect && s4.setPreSelection(n2)) : s4.setOpen(false)) : "Escape" === t5 && (e3.preventDefault(), s4.setOpen(false)), s4.inputOk() || s4.props.onInputError({ code: 1, msg: "Date input not valid." });
        }
      } else
        "ArrowDown" !== t5 && "ArrowUp" !== t5 && "Enter" !== t5 || s4.onInputClick();
    }), ye(ke(s4), "onPortalKeyDown", function(e3) {
      "Escape" === e3.key && (e3.preventDefault(), s4.setState({ preventFocus: true }, function() {
        s4.setOpen(false), setTimeout(function() {
          s4.setFocus(), s4.setState({ preventFocus: false });
        });
      }));
    }), ye(ke(s4), "onDayKeyDown", function(e3) {
      s4.props.onKeyDown(e3);
      var t5 = e3.key, r2 = Pe(s4.state.preSelection);
      if ("Enter" === t5)
        e3.preventDefault(), s4.handleSelect(r2, e3), !s4.props.shouldCloseOnSelect && s4.setPreSelection(r2);
      else if ("Escape" === t5)
        e3.preventDefault(), s4.setOpen(false), s4.inputOk() || s4.props.onInputError({ code: 1, msg: "Date input not valid." });
      else if (!s4.props.disabledKeyboardNavigation) {
        var n2;
        switch (t5) {
          case "ArrowLeft":
            n2 = subDays(r2, 1);
            break;
          case "ArrowRight":
            n2 = addDays(r2, 1);
            break;
          case "ArrowUp":
            n2 = subWeeks(r2, 1);
            break;
          case "ArrowDown":
            n2 = addWeeks(r2, 1);
            break;
          case "PageUp":
            n2 = subMonths(r2, 1);
            break;
          case "PageDown":
            n2 = addMonths(r2, 1);
            break;
          case "Home":
            n2 = subYears(r2, 1);
            break;
          case "End":
            n2 = addYears(r2, 1);
        }
        if (!n2)
          return void (s4.props.onInputError && s4.props.onInputError({ code: 1, msg: "Date input not valid." }));
        if (e3.preventDefault(), s4.setState({ lastPreSelectChange: qt }), s4.props.adjustDateOnChange && s4.setSelected(n2), s4.setPreSelection(n2), s4.props.inline) {
          var o3 = getMonth(r2), a5 = getMonth(n2), i3 = getYear(r2), d4 = getYear(n2);
          o3 !== a5 || i3 !== d4 ? s4.setState({ shouldFocusDayInline: true }) : s4.setState({ shouldFocusDayInline: false });
        }
      }
    }), ye(ke(s4), "onPopperKeyDown", function(e3) {
      "Escape" === e3.key && (e3.preventDefault(), s4.setState({ preventFocus: true }, function() {
        s4.setOpen(false), setTimeout(function() {
          s4.setFocus(), s4.setState({ preventFocus: false });
        });
      }));
    }), ye(ke(s4), "onClearClick", function(e3) {
      e3 && e3.preventDefault && e3.preventDefault(), s4.props.selectsRange ? s4.props.onChange([null, null], e3) : s4.props.onChange(null, e3), s4.setState({ inputValue: null });
    }), ye(ke(s4), "clear", function() {
      s4.onClearClick();
    }), ye(ke(s4), "onScroll", function(e3) {
      "boolean" == typeof s4.props.closeOnScroll && s4.props.closeOnScroll ? e3.target !== document && e3.target !== document.documentElement && e3.target !== document.body || s4.setOpen(false) : "function" == typeof s4.props.closeOnScroll && s4.props.closeOnScroll(e3) && s4.setOpen(false);
    }), ye(ke(s4), "renderCalendar", function() {
      return s4.props.inline || s4.isCalendarOpen() ? e$3.createElement(Qt, { ref: function(e3) {
        s4.calendar = e3;
      }, locale: s4.props.locale, calendarStartDay: s4.props.calendarStartDay, chooseDayAriaLabelPrefix: s4.props.chooseDayAriaLabelPrefix, disabledDayAriaLabelPrefix: s4.props.disabledDayAriaLabelPrefix, weekAriaLabelPrefix: s4.props.weekAriaLabelPrefix, monthAriaLabelPrefix: s4.props.monthAriaLabelPrefix, adjustDateOnChange: s4.props.adjustDateOnChange, setOpen: s4.setOpen, shouldCloseOnSelect: s4.props.shouldCloseOnSelect, dateFormat: s4.props.dateFormatCalendar, useWeekdaysShort: s4.props.useWeekdaysShort, formatWeekDay: s4.props.formatWeekDay, dropdownMode: s4.props.dropdownMode, selected: s4.props.selected, preSelection: s4.state.preSelection, onSelect: s4.handleSelect, onWeekSelect: s4.props.onWeekSelect, openToDate: s4.props.openToDate, minDate: s4.props.minDate, maxDate: s4.props.maxDate, selectsStart: s4.props.selectsStart, selectsEnd: s4.props.selectsEnd, selectsRange: s4.props.selectsRange, startDate: s4.props.startDate, endDate: s4.props.endDate, excludeDates: s4.props.excludeDates, excludeDateIntervals: s4.props.excludeDateIntervals, filterDate: s4.props.filterDate, onClickOutside: s4.handleCalendarClickOutside, formatWeekNumber: s4.props.formatWeekNumber, highlightDates: s4.state.highlightDates, includeDates: s4.props.includeDates, includeDateIntervals: s4.props.includeDateIntervals, includeTimes: s4.props.includeTimes, injectTimes: s4.props.injectTimes, inline: s4.props.inline, shouldFocusDayInline: s4.state.shouldFocusDayInline, peekNextMonth: s4.props.peekNextMonth, showMonthDropdown: s4.props.showMonthDropdown, showPreviousMonths: s4.props.showPreviousMonths, useShortMonthInDropdown: s4.props.useShortMonthInDropdown, showMonthYearDropdown: s4.props.showMonthYearDropdown, showWeekNumbers: s4.props.showWeekNumbers, showYearDropdown: s4.props.showYearDropdown, withPortal: s4.props.withPortal, forceShowMonthNavigation: s4.props.forceShowMonthNavigation, showDisabledMonthNavigation: s4.props.showDisabledMonthNavigation, scrollableYearDropdown: s4.props.scrollableYearDropdown, scrollableMonthYearDropdown: s4.props.scrollableMonthYearDropdown, todayButton: s4.props.todayButton, weekLabel: s4.props.weekLabel, outsideClickIgnoreClass: "react-datepicker-ignore-onclickoutside", fixedHeight: s4.props.fixedHeight, monthsShown: s4.props.monthsShown, monthSelectedIn: s4.state.monthSelectedIn, onDropdownFocus: s4.handleDropdownFocus, onMonthChange: s4.props.onMonthChange, onYearChange: s4.props.onYearChange, dayClassName: s4.props.dayClassName, weekDayClassName: s4.props.weekDayClassName, monthClassName: s4.props.monthClassName, timeClassName: s4.props.timeClassName, showTimeSelect: s4.props.showTimeSelect, showTimeSelectOnly: s4.props.showTimeSelectOnly, onTimeChange: s4.handleTimeChange, timeFormat: s4.props.timeFormat, timeIntervals: s4.props.timeIntervals, minTime: s4.props.minTime, maxTime: s4.props.maxTime, excludeTimes: s4.props.excludeTimes, filterTime: s4.props.filterTime, timeCaption: s4.props.timeCaption, className: s4.props.calendarClassName, container: s4.props.calendarContainer, yearItemNumber: s4.props.yearItemNumber, yearDropdownItemNumber: s4.props.yearDropdownItemNumber, previousMonthAriaLabel: s4.props.previousMonthAriaLabel, previousMonthButtonLabel: s4.props.previousMonthButtonLabel, nextMonthAriaLabel: s4.props.nextMonthAriaLabel, nextMonthButtonLabel: s4.props.nextMonthButtonLabel, previousYearAriaLabel: s4.props.previousYearAriaLabel, previousYearButtonLabel: s4.props.previousYearButtonLabel, nextYearAriaLabel: s4.props.nextYearAriaLabel, nextYearButtonLabel: s4.props.nextYearButtonLabel, timeInputLabel: s4.props.timeInputLabel, disabledKeyboardNavigation: s4.props.disabledKeyboardNavigation, renderCustomHeader: s4.props.renderCustomHeader, popperProps: s4.props.popperProps, renderDayContents: s4.props.renderDayContents, onDayMouseEnter: s4.props.onDayMouseEnter, onMonthMouseLeave: s4.props.onMonthMouseLeave, selectsDisabledDaysInRange: s4.props.selectsDisabledDaysInRange, showTimeInput: s4.props.showTimeInput, showMonthYearPicker: s4.props.showMonthYearPicker, showFullMonthYearPicker: s4.props.showFullMonthYearPicker, showTwoColumnMonthYearPicker: s4.props.showTwoColumnMonthYearPicker, showFourColumnMonthYearPicker: s4.props.showFourColumnMonthYearPicker, showYearPicker: s4.props.showYearPicker, showQuarterYearPicker: s4.props.showQuarterYearPicker, showPopperArrow: s4.props.showPopperArrow, excludeScrollbar: s4.props.excludeScrollbar, handleOnKeyDown: s4.props.onKeyDown, handleOnDayKeyDown: s4.onDayKeyDown, isInputFocused: s4.state.focused, customTimeInput: s4.props.customTimeInput, setPreSelection: s4.setPreSelection }, s4.props.children) : null;
    }), ye(ke(s4), "renderAriaLiveRegion", function() {
      var t5, r2 = s4.props, n2 = r2.dateFormat, o3 = r2.locale, a5 = s4.props.showTimeInput || s4.props.showTimeSelect ? "PPPPp" : "PPPP";
      return t5 = s4.props.selectsRange ? "Selected start date: ".concat(Ye(s4.props.startDate, { dateFormat: a5, locale: o3 }), ". ").concat(s4.props.endDate ? "End date: " + Ye(s4.props.endDate, { dateFormat: a5, locale: o3 }) : "") : s4.props.showTimeSelectOnly ? "Selected time: ".concat(Ye(s4.props.selected, { dateFormat: n2, locale: o3 })) : s4.props.showYearPicker ? "Selected year: ".concat(Ye(s4.props.selected, { dateFormat: "yyyy", locale: o3 })) : s4.props.showMonthYearPicker ? "Selected month: ".concat(Ye(s4.props.selected, { dateFormat: "MMMM yyyy", locale: o3 })) : s4.props.showQuarterYearPicker ? "Selected quarter: ".concat(Ye(s4.props.selected, { dateFormat: "yyyy, QQQ", locale: o3 })) : "Selected date: ".concat(Ye(s4.props.selected, { dateFormat: a5, locale: o3 })), e$3.createElement("span", { role: "alert", "aria-live": "polite", className: "react-datepicker__aria-live" }, s4.state.isRenderAriaLiveMessage && t5);
    }), ye(ke(s4), "renderDateInput", function() {
      var t5, n2 = r(s4.props.className, ye({}, "react-datepicker-ignore-onclickoutside", s4.state.open)), o3 = s4.props.customInput || e$3.createElement("input", { type: "text" }), a5 = s4.props.customInputRef || "ref", i3 = "string" == typeof s4.props.value ? s4.props.value : "string" == typeof s4.state.inputValue ? s4.state.inputValue : s4.props.selectsRange ? function(e3, t6, r2) {
        if (!e3)
          return "";
        var n3 = Ye(e3, r2), o4 = t6 ? Ye(t6, r2) : "";
        return "".concat(n3, " - ").concat(o4);
      }(s4.props.startDate, s4.props.endDate, s4.props) : Ye(s4.props.selected, s4.props);
      return e$3.cloneElement(o3, (ye(t5 = {}, a5, function(e3) {
        s4.input = e3;
      }), ye(t5, "value", i3), ye(t5, "onBlur", s4.handleBlur), ye(t5, "onChange", s4.handleChange), ye(t5, "onClick", s4.onInputClick), ye(t5, "onFocus", s4.handleFocus), ye(t5, "onKeyDown", s4.onInputKeyDown), ye(t5, "id", s4.props.id), ye(t5, "name", s4.props.name), ye(t5, "form", s4.props.form), ye(t5, "autoFocus", s4.props.autoFocus), ye(t5, "placeholder", s4.props.placeholderText), ye(t5, "disabled", s4.props.disabled), ye(t5, "autoComplete", s4.props.autoComplete), ye(t5, "className", r(o3.props.className, n2)), ye(t5, "title", s4.props.title), ye(t5, "readOnly", s4.props.readOnly), ye(t5, "required", s4.props.required), ye(t5, "tabIndex", s4.props.tabIndex), ye(t5, "aria-describedby", s4.props.ariaDescribedBy), ye(t5, "aria-invalid", s4.props.ariaInvalid), ye(t5, "aria-labelledby", s4.props.ariaLabelledBy), ye(t5, "aria-required", s4.props.ariaRequired), t5));
    }), ye(ke(s4), "renderClearButton", function() {
      var t5 = s4.props, r2 = t5.isClearable, n2 = t5.selected, o3 = t5.startDate, a5 = t5.endDate, i3 = t5.clearButtonTitle, p2 = t5.clearButtonClassName, c3 = void 0 === p2 ? "" : p2, l2 = t5.ariaLabelClose, d4 = void 0 === l2 ? "Close" : l2;
      return !r2 || null == n2 && null == o3 && null == a5 ? null : e$3.createElement("button", { type: "button", className: "react-datepicker__close-icon ".concat(c3).trim(), "aria-label": d4, onClick: s4.onClearClick, title: i3, tabIndex: -1 });
    }), s4.state = s4.calcInitialState(), s4;
  }
  return fe(a4, [{ key: "componentDidMount", value: function() {
    window.addEventListener("scroll", this.onScroll, true);
  } }, { key: "componentDidUpdate", value: function(e3, t4) {
    var r2, n2;
    e3.inline && (r2 = e3.selected, n2 = this.props.selected, r2 && n2 ? getMonth(r2) !== getMonth(n2) || getYear(r2) !== getYear(n2) : r2 !== n2) && this.setPreSelection(this.props.selected), void 0 !== this.state.monthSelectedIn && e3.monthsShown !== this.props.monthsShown && this.setState({ monthSelectedIn: 0 }), e3.highlightDates !== this.props.highlightDates && this.setState({ highlightDates: vt(this.props.highlightDates) }), t4.focused || Ve(e3.selected, this.props.selected) || this.setState({ inputValue: null }), t4.open !== this.state.open && (false === t4.open && true === this.state.open && this.props.onCalendarOpen(), true === t4.open && false === this.state.open && this.props.onCalendarClose());
  } }, { key: "componentWillUnmount", value: function() {
    this.clearPreventFocusTimeout(), window.removeEventListener("scroll", this.onScroll, true);
  } }, { key: "renderInputContainer", value: function() {
    return e$3.createElement("div", { className: "react-datepicker__input-container" }, this.renderAriaLiveRegion(), this.renderDateInput(), this.renderClearButton());
  } }, { key: "render", value: function() {
    var t4 = this.renderCalendar();
    if (this.props.inline)
      return t4;
    if (this.props.withPortal) {
      var r2 = this.state.open ? e$3.createElement(Wt, { enableTabLoop: this.props.enableTabLoop }, e$3.createElement("div", { className: "react-datepicker__portal", tabIndex: -1, onKeyDown: this.onPortalKeyDown }, t4)) : null;
      return this.state.open && this.props.portalId && (r2 = e$3.createElement(Kt, { portalId: this.props.portalId, portalHost: this.props.portalHost }, r2)), e$3.createElement("div", null, this.renderInputContainer(), r2);
    }
    return e$3.createElement(jt, { className: this.props.popperClassName, wrapperClassName: this.props.wrapperClassName, hidePopper: !this.isCalendarOpen(), portalId: this.props.portalId, portalHost: this.props.portalHost, popperModifiers: this.props.popperModifiers, targetComponent: this.renderInputContainer(), popperContainer: this.props.popperContainer, popperComponent: t4, popperPlacement: this.props.popperPlacement, popperProps: this.props.popperProps, popperOnKeyDown: this.onPopperKeyDown, enableTabLoop: this.props.enableTabLoop });
  } }], [{ key: "defaultProps", get: function() {
    return { allowSameDay: false, dateFormat: "MM/dd/yyyy", dateFormatCalendar: "LLLL yyyy", onChange: function() {
    }, disabled: false, disabledKeyboardNavigation: false, dropdownMode: "scroll", onFocus: function() {
    }, onBlur: function() {
    }, onKeyDown: function() {
    }, onInputClick: function() {
    }, onSelect: function() {
    }, onClickOutside: function() {
    }, onMonthChange: function() {
    }, onCalendarOpen: function() {
    }, onCalendarClose: function() {
    }, preventOpenOnFocus: false, onYearChange: function() {
    }, onInputError: function() {
    }, monthsShown: 1, readOnly: false, withPortal: false, selectsDisabledDaysInRange: false, shouldCloseOnSelect: true, showTimeSelect: false, showTimeInput: false, showPreviousMonths: false, showMonthYearPicker: false, showFullMonthYearPicker: false, showTwoColumnMonthYearPicker: false, showFourColumnMonthYearPicker: false, showYearPicker: false, showQuarterYearPicker: false, strictParsing: false, timeIntervals: 30, timeCaption: "Time", previousMonthAriaLabel: "Previous Month", previousMonthButtonLabel: "Previous Month", nextMonthAriaLabel: "Next Month", nextMonthButtonLabel: "Next Month", previousYearAriaLabel: "Previous Year", previousYearButtonLabel: "Previous Year", nextYearAriaLabel: "Next Year", nextYearButtonLabel: "Next Year", timeInputLabel: "Time", enableTabLoop: true, yearItemNumber: 12, renderDayContents: function(e3) {
      return e3;
    }, focusSelectedMonth: false, showPopperArrow: true, excludeScrollbar: true, customTimeInput: null, calendarStartDay: void 0 };
  } }]), a4;
}(), Vt = "input", qt = "navigate";
const datePicker = "_datePicker_1dmxa_2";
var Style = {
  datePicker
};
const Component$1 = ({
  value,
  onChange,
  options
}) => {
  const date = value ? new Date(value * 1e3) : null;
  const [open, setOpen] = react.exports.useState(false);
  const formattedDate = date ? new Intl.DateTimeFormat(void 0, {
    dateStyle: "long",
    timeStyle: options.time ? "short" : void 0
  }).format(date) : "";
  const handleChange = (date2) => {
    onChange(date2.getTime() / 1e3);
    if (!options.time) {
      setOpen(false);
    }
  };
  const ReactDatePickerComponent = typeof Ht === "function" ? Ht : Ht.default;
  const id2 = useUniqId("datepickerinput");
  return /* @__PURE__ */ jsx(Field$1, {
    id: id2,
    help: options.help,
    icon: /* @__PURE__ */ jsx(ButtonIcon, {
      additionalStyle: {
        width: "32px",
        height: "32px"
      },
      onClick: prevent(() => setOpen(true)),
      children: /* @__PURE__ */ jsx(IconCalendar, {
        size: 16
      })
    }),
    children: /* @__PURE__ */ jsxs("div", {
      className: Style.datePicker,
      children: [/* @__PURE__ */ jsx(
        Field$2,
        {
          id: id2,
          children: options.label,
          onFocus: () => setOpen(true),
          value: formattedDate,
          readOnly: true
        }
      ), open && /* @__PURE__ */ jsx("div", {
        style: {
          position: "absolute",
          zIndex: 4
        },
        children: /* @__PURE__ */ jsx(ReactDatePickerComponent, {
          selected: date,
          showTimeInput: options.time,
          inline: true,
          onChange: handleChange,
          onClickOutside: () => setOpen(false)
        })
      })]
    })
  });
};
const DatePicker = defineField({
  defaultOptions: {
    default: "",
    time: false
  },
  render: Component$1
});
const AlignmentIcons = {
  left: IconTextLeft,
  center: IconTextCenter,
  right: IconTextRight
};
const Component = ({
  value,
  onChange,
  options
}) => {
  const alignements = Object.keys(AlignmentIcons);
  const id2 = useUniqId();
  return /* @__PURE__ */ jsx(Field$1, {
    label: options.label,
    children: /* @__PURE__ */ jsx(AlignmentButtons, {
      children: alignements.map((alignment) => /* @__PURE__ */ jsx(AlignmentButton, {
        name: id2,
        value: alignment,
        checked: value === alignment,
        onChange,
        icon: AlignmentIcons[alignment]
      }, alignment))
    })
  });
};
const TextAlign = defineField({
  defaultOptions: {
    default: "left"
  },
  render: Component
});
const Translations = {
  copyPage: "Copier le code de la page",
  deleteComponent: "Supprimer le bloc",
  copyComponent: "Copier le  bloc",
  searchComponent: "Rechercher un bloc",
  copySuccess: "Le code a bi\xE9n \xE9t\xE9 copi\xE9",
  copyInstructions: "vous pouvez le coller sur une autre page (CTRL + V)",
  addComponent: "Ajouter un bloc",
  responsiveView: "Vue responsive",
  addItem: "Ajouter un \xE9l\xE9ment",
  deleteItem: "Supprimer l'\xE9l\xE9ment",
  rollback: "R\xE9tablir",
  deleteItemConfirm: "Le bloc a bien \xE9t\xE9 supprim\xE9",
  unknownComponent: "Bloc inconnu",
  save: "Sauvegarder",
  close: "Fermer",
  noContent: `Vous n'avez pas encore de contenu`,
  useTemplate: "Utilisez un template"
};
const components = {};
const templates = [];
const _Editor = class {
  constructor(options = {}) {
    _Editor.i18n = options.lang || Translations$1;
  }
  registerComponent(name, definition) {
    components[name] = {
      label: "title",
      ...definition
    };
  }
  registerTemplate(template) {
    templates.push(template);
  }
  defineElement(elementName = "editor-builder") {
    class EditorElement extends HTMLElement {
      constructor() {
        super(...arguments);
        __publicField(this, "_mounted", false);
        __publicField(this, "_data", null);
        __publicField(this, "_value", "");
      }
      static get observedAttributes() {
        return ["hidden", "value"];
      }
      get value() {
        return this._value;
      }
      set value(v2) {
        if (v2 === this._value) {
          return;
        }
        this._value = v2;
        this._data = null;
        this.render();
      }
      connectedCallback() {
        this._value = this.getAttribute("value") || "[]";
        this.render();
        this._mounted = true;
      }
      attributeChangedCallback(name, oldValue, newValue) {
        if (!this._mounted) {
          return false;
        }
        if (name === "value") {
          if (newValue === this._value) {
            return;
          }
          this._value = newValue;
        }
        this.render();
      }
      disconnectedCallback() {
        this._mounted = false;
      }
      parseValue(value) {
        if (this._data === null) {
          try {
            const json = JSON.parse(value);
            this._data = indexify(json).map((value2) => {
              var _a, _b;
              return fillDefaults(value2, (_b = (_a = components[value2._name]) == null ? void 0 : _a.fields) != null ? _b : []);
            });
          } catch (e3) {
            console.error("Impossible de parser les donn\xE9es", value, e3);
            alert("Impossible de parser les donn\xE9es de l'\xE9diteur visuel");
            this._data = [];
          }
        }
        return this._data;
      }
      render() {
        var _a, _b, _c, _d, _e2, _f;
        const data = this.parseValue(this._value);
        const hiddenCategories = (_b = (_a = this.getAttribute("hidden-categories")) == null ? void 0 : _a.split(";")) != null ? _b : [];
        createRoot(this).render(/* @__PURE__ */ jsx(StoreProvider, {
          data,
          definitions: components,
          templates,
          hiddenCategories,
          rootElement: this,
          insertPosition: (_c = this.getAttribute("insertPosition")) != null ? _c : InsertPosition.Start,
          children: /* @__PURE__ */ jsx(EditorComponent, {
            element: this,
            value: data,
            previewUrl: (_d = this.getAttribute("preview")) != null ? _d : "",
            iconsUrl: (_e2 = this.getAttribute("iconsUrl")) != null ? _e2 : "/",
            name: (_f = this.getAttribute("name")) != null ? _f : "",
            visible: this.getAttribute("hidden") === null,
            onChange: (value) => {
              if (this._value === value) {
                return;
              }
              this._value = value;
              this.dispatchEvent(new CustomEvent("change", {
                detail: value
              }));
            }
          })
        }));
      }
    }
    __publicField(EditorElement, "changeEventName", "change");
    customElements.define(elementName, EditorElement);
  }
};
let Editor = _Editor;
__publicField(Editor, "i18n", Translations$1);
function EditorComponent({
  value,
  previewUrl,
  name,
  element,
  iconsUrl,
  visible: visibleProps,
  onChange
}) {
  const skipNextChange = react.exports.useRef(true);
  const updateData = useUpdateData();
  const data = useData();
  const visible = useStateDelayed(visibleProps);
  const handleClose = () => {
    element.dispatchEvent(new Event("close"));
  };
  const doNothing2 = () => null;
  const cleanedData = react.exports.useMemo(() => stringifyFields(data), [data]);
  useUpdateEffect(() => {
    skipNextChange.current = true;
    updateData(value);
  }, [value]);
  useClipboardPaste(visible);
  react.exports.useEffect(() => {
    if (skipNextChange.current) {
      skipNextChange.current = false;
    } else {
      onChange(cleanedData);
    }
  }, [cleanedData]);
  const div2 = react.exports.useRef(null);
  useStopPropagation(div2, ["change", "close"]);
  if (!visible) {
    return /* @__PURE__ */ jsx("textarea", {
      hidden: true,
      name,
      value: cleanedData,
      onChange: doNothing2
    });
  }
  return /* @__PURE__ */ jsxs("div", {
    ref: div2,
    children: [/* @__PURE__ */ jsx(BaseStyles, {
      children: /* @__PURE__ */ jsx(Layout, {
        data,
        onClose: handleClose,
        previewUrl,
        iconsUrl
      })
    }), /* @__PURE__ */ jsx("textarea", {
      hidden: true,
      name,
      value: cleanedData,
      onChange: doNothing2
    })]
  });
}
export { Alignment, BaseStyles, Checkbox, Color, DatePicker, Translations$1 as EN, Editor, EditorComponent, Translations as FR, Field$1 as Field, FieldsRenderer, HTMLText, ImageUrl, Number$1 as Number, Range, e$3 as React, Repeater, Row, Select, Tabs, Text$2 as Text, TextAlign, defineField, defineFieldGroup };
